Paper Info

Title: Conflict Optimization for Binary CSP Applied to Minimum Partition into Plane Subgraphs and Graph Coloring
Publish Date: 25 Mar 2023
Author List: Loïc Crombez (from LIMOS, Université Clermont Auvergne), Guilherme Da Fonseca (from LIS, Aix-Marseille Université), Florian Fontan (from Independent Researcher), Yan Gerard (from LIMOS, Université Clermont Auvergne), Aldo Gonzalez-Lorenzo (from LIS, Aix-Marseille Université), Pascal Lafourcade (from LIMOS, Université Clermont Auvergne), Luc Libralesso (from LIMOS, Université Clermont Auvergne), Benjamin Momège (from Independent Researcher), Jack Spalding-Jamieson (from David R. Cheriton School of Computer Science, University of Waterloo), Brandon Zhang (from Independent Researcher), Da Zheng (from Department of Computer Science, University of Illinois at Urbana-Champaign)

Figure

Figure 1: A partition of the input graph of the CG:SHOP2022 instance vispecn2518 into 57 plane graphs.It is the smallest instance of the challenge with 2518 segments.On top left, you see all 57 colors together.On top right, you see a clique of size 57, hence the solution is optimal.Each of the 57 colors is then presented in small figures.
Figure 2: Number of colors over time for the instance vispecn13806 using different values p.The algorithm uses σ = 0.15, easy vertices, q max = 59022, but does not use the BDFS nor any clique.
Figure 3: Number of colors over time with different values of q max obtained on the instance vispecn13806.Parameters are σ = 0.15, p = 1.2, no clique knowledge, and no BDFS.
Figure 4: Number of colors over time with and without clique knowledge and BDFS obtained on the instance vispecn13806.Parameters are σ = 0.15, p = 1.2, and q max = 1500000.
Figure 5: Number of colors over time for the instance vispecn13806 for different values of σ.In both figures the algorithm uses p = 1.2, easy vertices, q max = 59022, but does not use the BDFS nor any clique.For σ ≥ 0.25, no solution better than 248 colors is found.
Figure 6: Number of colors over time (in hours) for the instance vispecn13806.
Several CG:SHOP 2022 results.We compare the size of the largest known clique to the smallest coloring found by each team on a selection of 14 CG:SHOP 2022 instances.
[20][21][22][23][24][25] with state-of-the-art graph coloring algorithms.The conflict optimizer underperforms except on the geometric graphs r* and dsjr*.CE39-0007), SEVERITAS (ANR-20-CE39-0005) and by the French government IDEX-ISITE initiative 16-IDEX-0001 (CAP[20][21][22][23][24][25].The work of Luc Libralesso is supported by the French ANR PRC grant DECRYPT (ANR-18-CE39-0007).

abstract

CG:SHOP is an annual geometric optimization challenge and the 2022 edition proposed the problem of coloring a certain geometric graph defined by line segments. Surprisingly, the top three teams used the same technique, called conflict optimization. This technique has been introduced in the 2021 edition of the challenge, to solve a coordinated motion planning problem.
In this paper, we present the technique in the more general framework of binary constraint satisfaction problems (binary CSP). Then, the top three teams describe their different implementations of the same underlying strategy. We evaluate the performance of those implementations to vertex color not only geometric graphs, but also other types of graphs.

Introduction

The CG:SHOP challenge (Computational Geometry: Solving Hard Optimization Problems) is an annual geometric optimization competition, whose first edition took place in 2019. The 2022 edition proposed a problem called minimum partition into plane subgraphs. The input is a graph G embedded in the plane with edges drawn as straight line segments, and the goal is to partition the set of edges into a small number of plane graphs (Fig. ) .
This goal can be formulated as a vertex coloring problem on a graph G defined as follows. The vertices of G are the segments defining the edges of G, and the edges of G correspond to pairs of crossing segments (segments that intersect only at a common endpoint are not considered crossing). The three top-ranking teams (Lasa, Gitastrophe, and Shadoks) on the CG:SHOP 2022 challenge all used a common approach called conflict optimization while the fourth team used a SAT-Boosted Tabu Search .
Conflict optimization is a technique used by Shadoks to obtain the first place in the CG:SHOP 2021 challenge for low-makespan coordinated motion planning , and the main ideas of the technique lent themselves well to the 2022 challenge. Next, we describe the conflict optimizer as a metaheuristic to solve constraint satisfaction problems (CSP) .
We start by describing a CSP. A CSP is a triple of • variables X = (x 1 , . . . , x n ), Each of the 57 colors is then presented in small figures. • domains D = (D 1 , . . . , D n ), and • constraints R. Each variable x i must be assigned a value in the corresponding domain D i such that all constraints are satisfied.
In general, the constraints may forbid arbitrary subsets of values. We restrict our attention to a particular type of constraints (binary CSP ), which only involve pairs of assignments. A partial evaluation is an assignment of a subset of the variables, called evaluated, with the remaining variables called non-evaluated.
All constraints involving a non-evaluated variable are satisfied by default. We only consider assignments and partial assignments that satisfy all constraints. The conflict optimizer iteratively modifies a partial evaluation with the goal of emptying the set S of non-evaluated variables, at which point it stops.
At each step, a variable x i is removed from S. If there exists a value x ∈ D i that satisfies all constraints, then we assign the value x to the variable x i . Otherwise, we proceed as follows. For each possible value x ∈ D i , we consider the set K(i, x) of variables (other than x i ) that are part of constraints violated by the assignment x i = x.
We assign to x i the value x that minimizes where w(j) is a weight function to be described later. The variables x j ∈ K(i, x) become non-evaluated and added to S. The weight function should be such that w(j) increases each time x j is added to S, in order to avoid loops that keep moving the same variables back and forth from S. Let q(j) be the number of times x j became non-evaluated.
A possible weight function is w(j) = q(j). More generally, we can have w(j) = q(j) p for some exponent p (typically between 1 and 2). Of course, several details of the conflict optimizer are left open. For example, which element to choose from S, whether some random noise should be added to w, and the decision to restart the procedure from scratch after a certain time.
The CSP as is, does not apply to optimization problems. However, we can, impose a maximum value k of the objective function in order to obtain a CSP. The conflict optimizer was introduced in a low makespan coordinated motion planning setting. In that setting, the variables are the robots, the domains are their paths (of length at most k) and the constraints forbid collisions between two paths.
In the graph coloring setting, the domains are the k colors of the vertices and the constraints forbid adjacent vertices from having the same color. The conflict optimizer can be adapted to non-binary CSP, but in that case multiple variables may be unassigned for a single violated constraint. The strategy has some resemblance to the similarly named min-conflicts algorithm , but notable differences are that a partial evaluation is kept instead of an invalid evaluation and the weight function that changes over time.
While the conflict optimization strategy is simple, there are different ways to apply it to the graph coloring problem. The goal of the paper is to present how the top three teams applied it or complemented it with additional strategies. We compare the relative benefits of each variant on the instances given in the CG:SHOP 2022 challenge.
We also compare them to baselines on some instances issued from graph coloring benchmarks. The paper is organized as follows. Section 2 presents the details of the conflict optimization strategy applied to graph coloring. In the three sections that follow, the three teams Lasa, Gitastrophe, and Shadoks present the different parameters and modified strategies that they used to make the algorithm more efficient for the CG:SHOP 2022 challenge.
The last section is devoted to the experimental results.

Literature Review

The study of graph coloring goes back to the 4-color problem (1852) and it has been intensively studied since the 1970s (see for surveys). Many heuristics have been proposed , as well as exact algorithms . We briefly present two classes of algorithms: greedy algorithms and exact algorithms. Greedy algorithms.
These algorithms are used to find good quality initial solutions in a short amount of time. The classic greedy heuristic considers the vertices in arbitrary order and colors each vertex with the smallest non-conflicting color. The two most famous modern greedy heuristics are DSATUR and Recursive Largest First (RLF ) .
At each step (until all vertices are colored), DSATUR selects the vertex v that has the largest number of different colors in its neighbourhood. Ties are broken by selecting a vertex with maximum degree. The vertex v is colored with the smallest non-conflicting color. RLF searches for a large independent set I, assigns the vertices I the same color, removes I from G , and repeats until all vertices are colored.
Exact algorithms. Some exact methods use a branch-and-bound strategy, for example extending the DSATUR heuristic by allowing it to backtrack . Another type of exact method (branch-and-cut-and-price) decomposes the vertex coloring problem into an iterative resolution of two sub-problems . The "master problem" maintains a small set of valid colors using a set-covering formulation.
The "pricing problem" finds a new valid coloring that is promising by solving a maximum weight independent set problem. Exact algorithms are usually able to find the optimal coloring for graphs with a few hundred vertices. However, even the smallest CG:SHOP 2022 competition instances involve at least a few thousands vertices.

Conflict Optimization for Graph Coloring

Henceforth, we will only refer to the intersection conflict graph G induced by the instance. Vertices will refer to the vertices V (G ), and edges will refer to the edges E(G ). Our goal is to partition the vertices using a minimum set of k color classes C = {C 1 , . . . , C k }, where no two vertices in the same color class C i are incident to a common edge.

Conflict Optimization

TABUCOL inspired neighbourhood One classical approach for the vertex coloring involves allowing solutions with conflicting vertices (two adjacent vertices with the same color). It was introduced in 1987 and called TABUCOL. It starts with an initial solution, removes a color (usually the one with the least number of vertices), and assigns uncolored vertices with a new color among the remaining ones.
This is likely to lead to some conflicts (i.e. two adjacent vertices sharing a same color). The local search scheme selects a conflicting vertex, and tries to swap its color, choosing the new coloring that minimises the number of conflicts. If it reaches a state with no conflict, it provides a solution with one color less than the initial solution.
The process is repeated until the stopping criterion is met. While the original TABUCOL algorithm includes a "tabu-list" mechanism to avoid cycling, it is not always sufficient, and requires some hyper-parameter tuning in order to obtain a good performance on a large variety of instances. To overcome this issue, we use a neighbourhood, but replace the "tabu-list" by the conflict optimizer scheme presented above.
PARTIALCOL inspired neighbourhood PARTIALCOL another local search algorithm solving the vertex coloring problem was introduced in 2008. This algorithm proposes a new local search scheme that allows partial coloring (thus allowing uncolored vertices). The goal is to minimize the number of uncolored vertices.
Similarly to TABUCOL, PARTIALCOL starts with an initial solution, removes one color (unassigning its vertices), and performs local search iterations until no vertex is left uncolored. When coloring a vertex, the adjacent conflicting vertices are uncolored. Then, the algorithm repeats the process until all vertices are colored, or the stopping criterion is met.
This neighbourhood was also introduced alongside a tabu-search procedure. The tabu-search scheme is also replaced by a conflict-optimization scheme. Note that this neighbourhood was predominantly used by the other teams.

Finding Initial Solutions

Lasa team used two approaches to find initial solutions: 1. DSATUR is the classical graph coloring algorithm presented in Section 1. 2. Orientation greedy is almost the only algorithm where the geometry of the segments is used. If segments are almost parallel, it is likely that they do not intersect (thus forming an independent set).
This greedy algorithm first sorts the segments by orientation, ranging from − π 2 to π 2 . For each segment in this order, the algorithm tries to color it using the first available color. If no color has been found, a new color is created for coloring the considered segment. This algorithm is efficient, produces interesting initial solutions and takes into account the specificities of the competition.

Solution Initialization

The gitastrophe team uses the traditional greedy algorithm of Welsh and Powell to obtain initial solutions: order the vertices in decreasing order of degree, and assign each vertex the minimum-label color not used by its neighbors. During the challenge Gitastrophe attempted to use different orderings for the greedy algorithm, such as sorting by the slope of the line segment associated with each vertex (as the orientation greedy initialization presented in Section 3), and also tried numerous other strategies.
Ultimately, after running the solution optimizer for approximately the same amount of time, all initializations resulted in an equal number of colors.

Modifications to the Conflict Optimizer

Taking inspiration from memetic algorithms, which alternate between an intensification and a diversification stage, the algorithm continually switched between a phase using the above conflict score, and one minimizing only the number of conflicts. Thus during the conflict-minimization phase, the random variables f (C j ) and w(u) are both fixed equal to 1 leading to a conflict score
Each phase lasted for 10 5 iterations. Adding the conflict-minimization phase gave minor improvements to some of the challenge instances.

Shadoks

In this section, we describe the choices used by the Shadoks team for the options described in Section 2.1. The Shadoks generally chose to eliminate the color with the smallest number of elements. However, if the multistart option is toggled on, then a random color is used each time. The conflict set S is stored in a queue.
The Shadoks tried other strategies, but found that the queue gives the best results. The weight function used is w(u) = 1 + q(u) p , mostly with p = 1.2. The effect of the parameter p is shown in Fig. . Notice that in all figures, the number of colors shown is the average of ten executions of the code using different random seeds.
The algorithm uses σ = 0.15, easy vertices, q max = 59022, but does not use the BDFS nor any clique. If q(u) is larger than a threshold q max , the Shadoks set w(u) = ∞ so that the vertex u never reenters S. If at some point an uncolored vertex v is adjacent to some vertex u of infinite weight in every color class, then the conflict optimizer is restarted.
When restarting, the initial coloring is shuffled by moving some vertices from their initial color class to a new one. Looking at Fig. , the value of q max does not seem to have much influence as long as it is not too small. Throughout the challenge the Shadoks almost exclusively used q max = 2000 • (75000/m) 2 , where m is the number of vertices.
This value roughly ensures a restart every few hours. q max =0.5k q max =5k q max =50k q max =100k q max =250k The Shadoks use the function f as a Gaussian random variable of mean 1 and variance σ. A good default value is σ = 0.15. The effect of the variance is shown in Fig. . Notice that setting σ = 0 gives much worse results.
Option (e) The goal of BDFS is to further optimize very good solutions that the conflict optimizer is not able to improve otherwise. Fig. shows the influence of BDFS. While on this figure, the advantages of BDFS cannot be noticed, its use near the end of the challenge improved about 30 solutions. The bounded depth-first search (BDFS) algorithm tries to improve the dequeuing process.
The goal is to prevent a vertex in conflict with some adjacent colored vertices from entering in the conflict set. At the first level, the algorithm searches for a recoloring of some adjacent vertices which allows us to directly recolor the conflict vertex. If no solution is found, the algorithm  In both figures the algorithm uses p = 1.2, easy vertices, q max = 59022, but does not use the BDFS nor any clique.
For σ ≥ 0.25, no solution better than 248 colors is found. could recolor some vertices at larger distances from the conflict vertex. To do so, a local search is performed by trying to recolor vertices at a bounded distance from the conflict vertex in the current partial solution. The BDFS algorithm has two parameters: adjacency bound a max and depth d.
In order to recolor a vertex v, BDFS gets the set C of color classes with at most a max neighbors of v. If a class in C has no neighbor of v, v is assigned to C. Otherwise, for each class C ∈ C, BDFS tries to recolor the vertices in C which are adjacent to v by recursively calling itself with depth d − 1.
At depth d = 0 the algorithm stops trying to color the vertices. During the challenge the Shadoks used BDFS with parameters a max = 3 and d = 3. The depth was increased to 5 (resp. 7) when the number of vertices in the queue was 2 (resp. 1). Degeneracy order Given a target number of colors k, we call easy vertices a set of vertices Y such that, if the remainder of the vertices of G are colored using k colors, then we are guaranteed to be able to color all vertices of G with k colors.
This is obtained using the degeneracy order Y . To obtain Y we iteratively remove from the graph a vertex v that has at most k − 1 neighbors, appending v to the end of Y . We repeat until no other vertex can be added to Y . Notice that, once we color the remainder of the graph with at least k colors, we can use a greedy coloring for Y in order from last to first without increasing the number of colors used.
Removing the easy vertices reduces the total number of vertices, making the conflict optimizer more effective. The Shadoks always toggle this option on (the challenge instances contain from 0 to 23% easy vertices).

Results

We provide the results of the experiments performed with the code from the three teams on two classes of instances. First, we present the results on some selected CG:SHOP 2022 instances. These instances are intersection graphs of line segments. Second, we execute the code on graphs that are not intersection graphs, namely the classic DIMACS graphs , comparing the results of our conflict optimizer implementations to previous solutions.
The source code for the three teams is available at: • Lasa: https://github.com/librallu/dogs-color • Gitastrophe: https://github.com/jacketsj/cgshop2022-gitastrophe • Shadoks: https://github.com/gfonsecabr/shadoks-CGSHOP2022

CG:SHOP 2022 Instances

We selected 14 instances (out of 225) covering the different types of instances given in the CG:SHOP 2022 challenge. The results are presented in Table . For comparison, we executed the HEAD code on some instances using the default parameters. The table shows the smallest number of colors for which HEAD found a solution.
We ran HEAD for 1 hour of repetitions for each target number of colors on a single CPU core (the HEAD solver takes the target number of colors as a parameter and we increased this parameter one by one). At the end of the challenge, 8 colorings computed by Lasa, 11 colorings computed by Gitastrophe, and 23 colorings computed by Shadoks over 225 instances have been proved optimal (their number of colors is equal to the size of a clique).
In order to compare the efficiency of the algorithms, we executed the different implementations on the CG:SHOP instance vispecn13806. The edge density of this graph is 19%, the largest clique that we found has 177 vertices and the best coloring found during the challenge uses 218 colors. Notice that vispecn13806 is the same instance used in other Shadoks experiments in Section 5. Notice also that HEAD algorithm provides 283 colors after one hour compared to less than 240 colors for the conflict optimizers.
We ran the three implementations on three different servers and compared the results shown in Figure . For each implementation, the x coordinate is the running time in hours, while the y coordinate is the smallest number of colors found at that time.

Results on DIMACS Graphs

We tested the implementation of each team on the DIMACS instances to gauge the performance of the conflict optimizer on other classes of graphs. We compared our results to the best known bounds and to the state of the art coloring algorithms HEAD and QACOL . The time limit for Lasa's algorithms is 1 hour.
CWLS is Lasa's conflict optimizer with the neighbourhood presented in TABUCOL , while PWLS is the optimizer with the neighbourhood presented in PARTIALCOL . Gitastrophe algorithm ran 10 minutes after which the number of colors no longer decreases. Shadoks algorithm ran for 1 hour without the BDFS option (results with BDFS are worse).
Results are presented in Table . We only kept the difficult DIMACS instances. For the other instances, all the results match the best known bounds. The DIMACS instances had comparatively few edges (on the order of thousands or millions); the largest intersection graphs considered in the CG:SHOP challenge had over 1.5 billion edges.
We notice that the conflict optimizer works extremely poorly on random graphs, but it is fast and appears to perform well on geometric graphs (r250.5, r1000.1c, r1000.5, dsjr500.1c and dsjr500.5), matching the best-known results . Interestingly, these geometric graphs are not intersection graphs as in the CG:SHOP challenge, but are generated based on a distance threshold.
On the DIMACS graphs, Lasa implementation shows better performance than the other implementations.