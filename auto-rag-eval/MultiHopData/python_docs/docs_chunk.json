[
  {
    "doc_id": "python_docs_data_structures",
    "original_uuid": "7a8c",
    "content": "5. Data StructuresÂ¶\nThis chapter describes some things youâve learned about already in more detail,\nand adds some new things as well.\n5.1. More on ListsÂ¶\nThe list data type has some more methods.  Here are all of the methods of list\nobjects:\nlist.append(x)\nAdd an item to the end of the list.  Similar to a[len(a):] = [x].\nlist.extend(iterable)\nExtend the list by appending all the items from the iterable.  Similar to\na[len(a):] = iterable.\nlist.insert(i, x)\nInsert an item at a given position.  The first argument is the index of the\nelement before which to insert, so a.insert(0, x) inserts at the front of\nthe list, and a.insert(len(a), x) is equivalent to a.append(x).\nlist.remove(x)\nRemove the first item from the list whose value is equal to x.  It raises a\nValueError if there is no such item.\nlist.pop([i])\nRemove the item at the given position in the list, and return it.  If no index\nis specified, a.pop() removes and returns the last item in the list.\nIt raises an IndexError if the list is empty or the index is\noutside the list range.\nlist.clear()\nRemove all items from the list.  Similar to del a[:].\nlist.index(x[, start[, end]])\nReturn zero-based index in the list of the first item whose value is equal to x.\nRaises a ValueError if there is no such item.\nThe optional arguments start and end are interpreted as in the slice\nnotation and are used to limit the search to a particular subsequence of\nthe list.  The returned index is computed relative to the beginning of the full\nsequence rather than the start argument.\nlist.count(x)\nReturn the number of times x appears in the list.\nlist.sort(*, key=None, reverse=False)\nSort the items of the list in place (the arguments can be used for sort\ncustomization, see sorted() for their explanation).\nlist.reverse()\nReverse the elements of the list in place.\nlist.copy()\nReturn a shallow copy of the list.  Similar to a[:].\nAn example that uses most of the list methods:\n>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']\n>>> fruits.count('apple')\n2\n>>> fruits.count('tangerine')\n0\n>>> fruits.index('banana')\n3\n>>> fruits.index('banana', 4)  # Find next banana starting at position 4\n6\n>>> fruits.reverse()\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n>>> fruits.append('grape')\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n>>> fruits.sort()\n>>> fruits\n['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n>>> fruits.pop()\n'pear'\nYou might have noticed that methods like insert, remove or sort that\nonly modify the list have no return value printed â they return the default\nNone. [1]  This is a design principle for all mutable data structures in\nPython.\nAnother thing you might notice is that not all data can be sorted or\ncompared.  For instance, [None, 'hello', 10] doesnât sort because\nintegers canât be compared to strings and None canât be compared to\nother types.  Also, there are some types that donât have a defined\nordering relation.  For example, 3+4j < 5+7j isnât a valid\ncomparison.\n5.1.1. Using Lists as StacksÂ¶\nThe list methods make it very easy to use a list as a stack, where the last\nelement added is the first element retrieved (âlast-in, first-outâ).  To add an\nitem to the top of the stack, use append().  To retrieve an item from the\ntop of the stack, use pop() without an explicit index.  For example:\n>>> stack = [3, 4, 5]\n>>> stack.append(6)\n>>> stack.append(7)\n>>> stack\n[3, 4, 5, 6, 7]\n>>> stack.pop()\n7\n>>> stack\n[3, 4, 5, 6]\n>>> stack.pop()\n6\n>>> stack.pop()\n5\n>>> stack\n[3, 4]\n5.1.2. Using Lists as QueuesÂ¶\nIt is also possible to use a list as a queue, where the first element added is\nthe first element retrieved (âfirst-in, first-outâ); however, lists are not\nefficient for this purpose.  While appends and pops from the end of list are\nfast, doing inserts or pops from the beginning of a list is slow (because all\nof the other elements have to be shifted by one).\nTo implement a queue, use collections.deque which was designed to\nhave fast appends and pops from both ends.  For example:\n>>> from collections import deque\n>>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n>>> queue.append(\"Terry\")           # Terry arrives\n>>> queue.append(\"Graham\")          # Graham arrives\n>>> queue.popleft()                 # The first to arrive now leaves\n'Eric'\n>>> queue.popleft()                 # The second to arrive now leaves\n'John'\n>>> queue                           # Remaining queue in order of arrival\ndeque(['Michael', 'Terry', 'Graham'])\n5.1.3. List ComprehensionsÂ¶\nList comprehensions provide a concise way to create lists.\nCommon applications are to make new lists where each element is the result of\nsome operations applied to each member of another sequence or iterable, or to\ncreate a subsequence of those elements that satisfy a certain condition.\nFor example, assume we want to create a list of squares, like:\n>>> squares = []\n>>> for x in range(10):\n...     squares.append(x**2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nNote that this creates (or overwrites) a variable named x that still exists\nafter the loop completes.  We can calculate the list of squares without any\nside effects using:\nsquares = list(map(lambda x: x**2, range(10)))\nor, equivalently:\nsquares = [x**2 for x in range(10)]\nwhich is more concise and readable.\nA list comprehension consists of brackets containing an expression followed\nby a for clause, then zero or more for or if\nclauses.  The result will be a new list resulting from evaluating the expression\nin the context of the for and if clauses which follow it.\nFor example, this listcomp combines the elements of two lists if they are not\nequal:\n>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\nand itâs equivalent to:\n>>> combs = []\n>>> for x in [1,2,3]:\n...     for y in [3,1,4]:\n...         if x != y:\n...             combs.append((x, y))\n...\n>>> combs\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\nNote how the order of the for and if statements is the\nsame in both these snippets.\nIf the expression is a tuple (e.g. the (x, y) in the previous example),\nit must be parenthesized.\n>>> vec = [-4, -2, 0, 2, 4]\n>>> # create a new list with the values doubled\n>>> [x*2 for x in vec]\n[-8, -4, 0, 4, 8]\n>>> # filter the list to exclude negative numbers\n>>> [x for x in vec if x >= 0]\n[0, 2, 4]\n>>> # apply a function to all the elements\n>>> [abs(x) for x in vec]\n[4, 2, 0, 2, 4]\n>>> # call a method on each element\n>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n>>> [weapon.strip() for weapon in freshfruit]\n['banana', 'loganberry', 'passion fruit']\n>>> # create a list of 2-tuples like (number, square)\n>>> [(x, x**2) for x in range(6)]\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n>>> # the tuple must be parenthesized, otherwise an error is raised\n>>> [x, x**2 for x in range(6)]\nFile \"<stdin>\", line 1\n[x, x**2 for x in range(6)]\n^^^^^^^\nSyntaxError: did you forget parentheses around the comprehension target?\n>>> # flatten a list using a listcomp with two 'for'\n>>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n>>> [num for elem in vec for num in elem]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\nList comprehensions can contain complex expressions and nested functions:\n>>> from math import pi\n>>> [str(round(pi, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n5.1.4. Nested List ComprehensionsÂ¶\nThe initial expression in a list comprehension can be any arbitrary expression,\nincluding another list comprehension.\nConsider the following example of a 3x4 matrix implemented as a list of\n3 lists of length 4:\n>>> matrix = [\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12],\n... ]\nThe following list comprehension will transpose rows and columns:\n>>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nAs we saw in the previous section, the inner list comprehension is evaluated in\nthe context of the for that follows it, so this example is\nequivalent to:\n>>> transposed = []\n>>> for i in range(4):\n...     transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nwhich, in turn, is the same as:\n>>> transposed = []\n>>> for i in range(4):\n...     # the following 3 lines implement the nested listcomp\n...     transposed_row = []\n...     for row in matrix:\n...         transposed_row.append(row[i])\n...     transposed.append(transposed_row)\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nIn the real world, you should prefer built-in functions to complex flow statements.\nThe zip() function would do a great job for this use case:\n>>> list(zip(*matrix))\n[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]\nSee Unpacking Argument Lists for details on the asterisk in this line.\n5.2. The del statementÂ¶\nThere is a way to remove an item from a list given its index instead of its\nvalue: the del statement.  This differs from the pop() method\nwhich returns a value.  The del statement can also be used to remove\nslices from a list or clear the entire list (which we did earlier by assignment\nof an empty list to the slice).  For example:\n>>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a\n[1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[]\ndel can also be used to delete entire variables:\n>>> del a\nReferencing the name a hereafter is an error (at least until another value\nis assigned to it).  Weâll find other uses for del later.\n5.3. Tuples and SequencesÂ¶\nWe saw that lists and strings have many common properties, such as indexing and\nslicing operations.  They are two examples of sequence data types (see\nSequence Types â list, tuple, range).  Since Python is an evolving language, other sequence data\ntypes may be added.  There is also another standard sequence data type: the\ntuple.\nA tuple consists of a number of values separated by commas, for instance:\n>>> t = 12345, 54321, 'hello!'\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')\n>>> # Tuples may be nested:\n>>> u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n>>> # Tuples are immutable:\n>>> t[0] = 88888\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> # but they can contain mutable objects:\n>>> v = ([1, 2, 3], [3, 2, 1])\n>>> v\n([1, 2, 3], [3, 2, 1])\nAs you see, on output tuples are always enclosed in parentheses, so that nested\ntuples are interpreted correctly; they may be input with or without surrounding\nparentheses, although often parentheses are necessary anyway (if the tuple is\npart of a larger expression).  It is not possible to assign to the individual\nitems of a tuple, however it is possible to create tuples which contain mutable\nobjects, such as lists.\nThough tuples may seem similar to lists, they are often used in different\nsituations and for different purposes.\nTuples are immutable, and usually contain a heterogeneous sequence of\nelements that are accessed via unpacking (see later in this section) or indexing\n(or even by attribute in the case of namedtuples).\nLists are mutable, and their elements are usually homogeneous and are\naccessed by iterating over the list.\nA special problem is the construction of tuples containing 0 or 1 items: the\nsyntax has some extra quirks to accommodate these.  Empty tuples are constructed\nby an empty pair of parentheses; a tuple with one item is constructed by\nfollowing a value with a comma (it is not sufficient to enclose a single value\nin parentheses). Ugly, but effective.  For example:\n>>> empty = ()\n>>> singleton = 'hello',    # <-- note trailing comma\n>>> len(empty)\n0\n>>> len(singleton)\n1\n>>> singleton\n('hello',)\nThe statement t = 12345, 54321, 'hello!' is an example of tuple packing:\nthe values 12345, 54321 and 'hello!' are packed together in a tuple.\nThe reverse operation is also possible:\n>>> x, y, z = t\nThis is called, appropriately enough, sequence unpacking and works for any\nsequence on the right-hand side.  Sequence unpacking requires that there are as\nmany variables on the left side of the equals sign as there are elements in the\nsequence.  Note that multiple assignment is really just a combination of tuple\npacking and sequence unpacking.\n5.4. SetsÂ¶\nPython also includes a data type for sets.  A set is an unordered collection\nwith no duplicate elements.  Basic uses include membership testing and\neliminating duplicate entries.  Set objects also support mathematical operations\nlike union, intersection, difference, and symmetric difference.\nCurly braces or the set() function can be used to create sets.  Note: to\ncreate an empty set you have to use set(), not {}; the latter creates an\nempty dictionary, a data structure that we discuss in the next section.\nHere is a brief demonstration:\n>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n>>> print(basket)                      # show that duplicates have been removed\n{'orange', 'banana', 'pear', 'apple'}\n>>> 'orange' in basket                 # fast membership testing\nTrue\n>>> 'crabgrass' in basket\nFalse\n>>> # Demonstrate set operations on unique letters from two words\n>>>\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a                                  # unique letters in a\n{'a', 'r', 'b', 'c', 'd'}\n>>> a - b                              # letters in a but not in b\n{'r', 'd', 'b'}\n>>> a | b                              # letters in a or b or both\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n>>> a & b                              # letters in both a and b\n{'a', 'c'}\n>>> a ^ b                              # letters in a or b but not both\n{'r', 'd', 'b', 'm', 'z', 'l'}\nSimilarly to list comprehensions, set comprehensions\nare also supported:\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'r', 'd'}\n5.5. DictionariesÂ¶\nAnother useful data type built into Python is the dictionary (see\nMapping Types â dict). Dictionaries are sometimes found in other languages as\nâassociative memoriesâ or âassociative arraysâ.  Unlike sequences, which are\nindexed by a range of numbers, dictionaries are indexed by keys, which can be\nany immutable type; strings and numbers can always be keys.  Tuples can be used\nas keys if they contain only strings, numbers, or tuples; if a tuple contains\nany mutable object either directly or indirectly, it cannot be used as a key.\nYou canât use lists as keys, since lists can be modified in place using index\nassignments, slice assignments, or methods like append() and\nextend().\nIt is best to think of a dictionary as a set of key: value pairs,\nwith the requirement that the keys are unique (within one dictionary). A pair of\nbraces creates an empty dictionary: {}. Placing a comma-separated list of\nkey:value pairs within the braces adds initial key:value pairs to the\ndictionary; this is also the way dictionaries are written on output.\nThe main operations on a dictionary are storing a value with some key and\nextracting the value given the key.  It is also possible to delete a key:value\npair with del. If you store using a key that is already in use, the old\nvalue associated with that key is forgotten.  It is an error to extract a value\nusing a non-existent key.\nPerforming list(d) on a dictionary returns a list of all the keys\nused in the dictionary, in insertion order (if you want it sorted, just use\nsorted(d) instead). To check whether a single key is in the\ndictionary, use the in keyword.\nHere is a small example using a dictionary:\n>>> tel = {'jack': 4098, 'sape': 4139}\n>>> tel['guido'] = 4127\n>>> tel\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n>>> tel['jack']\n4098\n>>> del tel['sape']\n>>> tel['irv'] = 4127\n>>> tel\n{'jack': 4098, 'guido': 4127, 'irv': 4127}\n>>> list(tel)\n['jack', 'guido', 'irv']\n>>> sorted(tel)\n['guido', 'irv', 'jack']\n>>> 'guido' in tel\nTrue\n>>> 'jack' not in tel\nFalse\nThe dict() constructor builds dictionaries directly from sequences of\nkey-value pairs:\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\nIn addition, dict comprehensions can be used to create dictionaries from\narbitrary key and value expressions:\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\nWhen the keys are simple strings, it is sometimes easier to specify pairs using\nkeyword arguments:\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n5.6. Looping TechniquesÂ¶\nWhen looping through dictionaries, the key and corresponding value can be\nretrieved at the same time using the items() method.\n>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.items():\n...     print(k, v)\n...\ngallahad the pure\nrobin the brave\nWhen looping through a sequence, the position index and corresponding value can\nbe retrieved at the same time using the enumerate() function.\n>>> for i, v in enumerate(['tic', 'tac', 'toe']):\n...     print(i, v)\n...\n0 tic\n1 tac\n2 toe\nTo loop over two or more sequences at the same time, the entries can be paired\nwith the zip() function.\n>>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n...     print('What is your {0}?  It is {1}.'.format(q, a))\n...\nWhat is your name?  It is lancelot.\nWhat is your quest?  It is the holy grail.\nWhat is your favorite color?  It is blue.\nTo loop over a sequence in reverse, first specify the sequence in a forward\ndirection and then call the reversed() function.\n>>> for i in reversed(range(1, 10, 2)):\n...     print(i)\n...\n9\n7\n5\n3\n1\nTo loop over a sequence in sorted order, use the sorted() function which\nreturns a new sorted list while leaving the source unaltered.\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for i in sorted(basket):\n...     print(i)\n...\napple\napple\nbanana\norange\norange\npear\nUsing set() on a sequence eliminates duplicate elements. The use of\nsorted() in combination with set() over a sequence is an idiomatic\nway to loop over unique elements of the sequence in sorted order.\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n...     print(f)\n...\napple\nbanana\norange\npear\nIt is sometimes tempting to change a list while you are looping over it;\nhowever, it is often simpler and safer to create a new list instead.\n>>> import math\n>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n>>> filtered_data = []\n>>> for value in raw_data:\n...     if not math.isnan(value):\n...         filtered_data.append(value)\n...\n>>> filtered_data\n[56.2, 51.7, 55.3, 52.5, 47.8]\n5.7. More on ConditionsÂ¶\nThe conditions used in while and if statements can contain any\noperators, not just comparisons.\nThe comparison operators in and not in are membership tests that\ndetermine whether a value is in (or not in) a container.  The operators is\nand is not compare whether two objects are really the same object.  All\ncomparison operators have the same priority, which is lower than that of all\nnumerical operators.\nComparisons can be chained.  For example, a < b == c tests whether a is\nless than b and moreover b equals c.\nComparisons may be combined using the Boolean operators and and or, and\nthe outcome of a comparison (or of any other Boolean expression) may be negated\nwith not.  These have lower priorities than comparison operators; between\nthem, not has the highest priority and or the lowest, so that A and\nnot B or C is equivalent to (A and (not B)) or C. As always, parentheses\ncan be used to express the desired composition.\nThe Boolean operators and and or are so-called short-circuit\noperators: their arguments are evaluated from left to right, and evaluation\nstops as soon as the outcome is determined.  For example, if A and C are\ntrue but B is false, A and B and C does not evaluate the expression\nC.  When used as a general value and not as a Boolean, the return value of a\nshort-circuit operator is the last evaluated argument.\nIt is possible to assign the result of a comparison or other Boolean expression\nto a variable.  For example,\n>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n>>> non_null = string1 or string2 or string3\n>>> non_null\n'Trondheim'\nNote that in Python, unlike C, assignment inside expressions must be done\nexplicitly with the\nwalrus operator :=.\nThis avoids a common class of problems encountered in C programs: typing =\nin an expression when == was intended.\n5.8. Comparing Sequences and Other TypesÂ¶\nSequence objects typically may be compared to other objects with the same sequence\ntype. The comparison uses lexicographical ordering: first the first two\nitems are compared, and if they differ this determines the outcome of the\ncomparison; if they are equal, the next two items are compared, and so on, until\neither sequence is exhausted. If two items to be compared are themselves\nsequences of the same type, the lexicographical comparison is carried out\nrecursively.  If all items of two sequences compare equal, the sequences are\nconsidered equal. If one sequence is an initial sub-sequence of the other, the\nshorter sequence is the smaller (lesser) one.  Lexicographical ordering for\nstrings uses the Unicode code point number to order individual characters.\nSome examples of comparisons between sequences of the same type:\n(1, 2, 3)              < (1, 2, 4)\n[1, 2, 3]              < [1, 2, 4]\n'ABC' < 'C' < 'Pascal' < 'Python'\n(1, 2, 3, 4)           < (1, 2, 4)\n(1, 2)                 < (1, 2, -1)\n(1, 2, 3)             == (1.0, 2.0, 3.0)\n(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)\nNote that comparing objects of different types with < or > is legal\nprovided that the objects have appropriate comparison methods.  For example,\nmixed numeric types are compared according to their numeric value, so 0 equals\n0.0, etc.  Otherwise, rather than providing an arbitrary ordering, the\ninterpreter will raise a TypeError exception.\nFootnotes\n[1]\nOther languages may return the mutated object, which allows method\nchaining, such as d->insert(\"a\")->remove(\"b\")->sort();.",
    "chunks": [
      {
        "chunk_id": "python_docs_data_structures_chunk_0",
        "original_index": 0,
        "content": "5. Data StructuresÂ¶\nThis chapter describes some things youâve learned about already in more detail,\nand adds some new things as well.\n5.1. More on ListsÂ¶\nThe list data type has some more methods.  Here are all of the methods of list\nobjects:\nlist.append(x)\nAdd an item to the end of the list.  Similar to a[len(a):] = [x].\nlist.extend(iterable)\nExtend the list by appending all the items from the iterable.  Similar to\na[len(a):] = iterable.\nlist.insert(i, x)\nInsert an item at a given position.  The first argument is the index of the\nelement before which to insert, so a.insert(0, x) inserts at the front of\nthe list, and a.insert(len(a), x) is equivalent to a.append(x).\nlist.remove(x)\nRemove the first item from the list whose value is equal to x.  It raises a\nValueError if there is no such item.\nlist.pop([i])\nRemove the item at the given position in the list, and return it.  If no index\nis specified, a.pop() removes and returns the last item in the list.\nIt raises an IndexError if the list is empty or the index is\noutside the list range.\nlist.clear()\nRemove all items from the list.  Similar to del a[:].\nlist.index(x[, start[, end]])\nReturn zero-based index in the list of the first item whose value is equal to x.\nRaises a ValueError if there is no such item.\nThe optional arguments start and end are interpreted as in the slice\nnotation and are used to limit the search to a particular subsequence of\nthe list.  The returned index is computed relative to the beginning of the full\nsequence rather than the start argument.\nlist.count(x)\nReturn the number of times x appears in the list.\nlist.sort(*, key=None, reverse=False)\nSort the items of the list in place (the arguments can be used for sort\ncustomization, see sorted() for their explanation).\nlist.reverse()\nReverse the elements of the list in place.\nlist.copy()\nReturn a shallow copy of the list.  Similar to a[:].\nAn example that uses most of the list methods:\n>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']\n>>> fruits.count('apple')\n2\n>>> fruits.count('tangerine')\n0\n>>> fruits.index('banana')\n3\n>>> fruits.index('banana', 4)  # Find next banana starting at position 4\n6\n>>> fruits.reverse()\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n>>> fruits.append('grape')\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n>>> fruits.sort()\n>>> fruits\n['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n>>> fruits.pop()\n'pear'\nYou might have noticed that methods like insert, remove or sort that\nonly modify the list have no return value printed â they return the default\nNone. [1]  This is a design principle for all mutable data structures in\nPython.\nAnother thing you might notice is that not all data can be sorted or\ncompared.  For instance, [None, 'hello', 10] doesnât sort because\nintegers canât be compared to strings and None canât be compared to\nother types.  Also, there are some types that donât have a defined\nordering relation.  For example, 3+4j < 5+7j isnât a valid\ncomparison.\n5.1.1. Using Lists as StacksÂ¶\nThe list methods make it very easy to use a list as a stack, where the last\nelement added is the first element retrieved (âlast-in, first-outâ).  To add an\nitem to the top of the stack, use append().  To retrieve an item from the\ntop of the stack, use pop() without an explicit index.  For example:\n>>> stack = [3, 4, 5]\n>>> stack.append(6)\n>>> stack.append(7)\n>>> stack\n[3, 4, 5, 6, 7]\n>>> stack.pop()\n7\n>>> stack\n[3, 4, 5, 6]\n>>> stack.pop()\n6\n>>> stack.pop()\n5\n>>> stack\n[3, 4]\n5.1.2. Using Lists as QueuesÂ¶\nIt is also possible to use a list as a queue, where the first element added is\nthe first element retrieved (âfirst-in, first-outâ); however, lists are not\nefficient for this purpose.  While appends and pops from the end of list are\nfast, doing inserts or pops from the beginning of a list is slow (because all"
      },
      {
        "chunk_id": "python_docs_data_structures_chunk_1",
        "original_index": 1,
        "content": "efficient for this purpose.  While appends and pops from the end of list are\nfast, doing inserts or pops from the beginning of a list is slow (because all\nof the other elements have to be shifted by one).\nTo implement a queue, use collections.deque which was designed to\nhave fast appends and pops from both ends.  For example:\n>>> from collections import deque\n>>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n>>> queue.append(\"Terry\")           # Terry arrives\n>>> queue.append(\"Graham\")          # Graham arrives\n>>> queue.popleft()                 # The first to arrive now leaves\n'Eric'\n>>> queue.popleft()                 # The second to arrive now leaves\n'John'\n>>> queue                           # Remaining queue in order of arrival\ndeque(['Michael', 'Terry', 'Graham'])\n5.1.3. List ComprehensionsÂ¶\nList comprehensions provide a concise way to create lists.\nCommon applications are to make new lists where each element is the result of\nsome operations applied to each member of another sequence or iterable, or to\ncreate a subsequence of those elements that satisfy a certain condition.\nFor example, assume we want to create a list of squares, like:\n>>> squares = []\n>>> for x in range(10):\n...     squares.append(x**2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nNote that this creates (or overwrites) a variable named x that still exists\nafter the loop completes.  We can calculate the list of squares without any\nside effects using:\nsquares = list(map(lambda x: x**2, range(10)))\nor, equivalently:\nsquares = [x**2 for x in range(10)]\nwhich is more concise and readable.\nA list comprehension consists of brackets containing an expression followed\nby a for clause, then zero or more for or if\nclauses.  The result will be a new list resulting from evaluating the expression\nin the context of the for and if clauses which follow it.\nFor example, this listcomp combines the elements of two lists if they are not\nequal:\n>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\nand itâs equivalent to:\n>>> combs = []\n>>> for x in [1,2,3]:\n...     for y in [3,1,4]:\n...         if x != y:\n...             combs.append((x, y))\n...\n>>> combs\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\nNote how the order of the for and if statements is the\nsame in both these snippets.\nIf the expression is a tuple (e.g. the (x, y) in the previous example),\nit must be parenthesized.\n>>> vec = [-4, -2, 0, 2, 4]\n>>> # create a new list with the values doubled\n>>> [x*2 for x in vec]\n[-8, -4, 0, 4, 8]\n>>> # filter the list to exclude negative numbers\n>>> [x for x in vec if x >= 0]\n[0, 2, 4]\n>>> # apply a function to all the elements\n>>> [abs(x) for x in vec]\n[4, 2, 0, 2, 4]\n>>> # call a method on each element\n>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n>>> [weapon.strip() for weapon in freshfruit]\n['banana', 'loganberry', 'passion fruit']\n>>> # create a list of 2-tuples like (number, square)\n>>> [(x, x**2) for x in range(6)]\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n>>> # the tuple must be parenthesized, otherwise an error is raised\n>>> [x, x**2 for x in range(6)]\nFile \"<stdin>\", line 1\n[x, x**2 for x in range(6)]\n^^^^^^^\nSyntaxError: did you forget parentheses around the comprehension target?\n>>> # flatten a list using a listcomp with two 'for'\n>>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n>>> [num for elem in vec for num in elem]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\nList comprehensions can contain complex expressions and nested functions:\n>>> from math import pi\n>>> [str(round(pi, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n5.1.4. Nested List ComprehensionsÂ¶\nThe initial expression in a list comprehension can be any arbitrary expression,\nincluding another list comprehension.\nConsider the following example of a 3x4 matrix implemented as a list of\n3 lists of length 4:\n>>> matrix = [\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12],\n... ]"
      },
      {
        "chunk_id": "python_docs_data_structures_chunk_2",
        "original_index": 2,
        "content": "Consider the following example of a 3x4 matrix implemented as a list of\n3 lists of length 4:\n>>> matrix = [\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12],\n... ]\nThe following list comprehension will transpose rows and columns:\n>>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nAs we saw in the previous section, the inner list comprehension is evaluated in\nthe context of the for that follows it, so this example is\nequivalent to:\n>>> transposed = []\n>>> for i in range(4):\n...     transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nwhich, in turn, is the same as:\n>>> transposed = []\n>>> for i in range(4):\n...     # the following 3 lines implement the nested listcomp\n...     transposed_row = []\n...     for row in matrix:\n...         transposed_row.append(row[i])\n...     transposed.append(transposed_row)\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nIn the real world, you should prefer built-in functions to complex flow statements.\nThe zip() function would do a great job for this use case:\n>>> list(zip(*matrix))\n[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]\nSee Unpacking Argument Lists for details on the asterisk in this line.\n5.2. The del statementÂ¶\nThere is a way to remove an item from a list given its index instead of its\nvalue: the del statement.  This differs from the pop() method\nwhich returns a value.  The del statement can also be used to remove\nslices from a list or clear the entire list (which we did earlier by assignment\nof an empty list to the slice).  For example:\n>>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a\n[1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[]\ndel can also be used to delete entire variables:\n>>> del a\nReferencing the name a hereafter is an error (at least until another value\nis assigned to it).  Weâll find other uses for del later.\n5.3. Tuples and SequencesÂ¶\nWe saw that lists and strings have many common properties, such as indexing and\nslicing operations.  They are two examples of sequence data types (see\nSequence Types â list, tuple, range).  Since Python is an evolving language, other sequence data\ntypes may be added.  There is also another standard sequence data type: the\ntuple.\nA tuple consists of a number of values separated by commas, for instance:\n>>> t = 12345, 54321, 'hello!'\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')\n>>> # Tuples may be nested:\n>>> u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n>>> # Tuples are immutable:\n>>> t[0] = 88888\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> # but they can contain mutable objects:\n>>> v = ([1, 2, 3], [3, 2, 1])\n>>> v\n([1, 2, 3], [3, 2, 1])\nAs you see, on output tuples are always enclosed in parentheses, so that nested\ntuples are interpreted correctly; they may be input with or without surrounding\nparentheses, although often parentheses are necessary anyway (if the tuple is\npart of a larger expression).  It is not possible to assign to the individual\nitems of a tuple, however it is possible to create tuples which contain mutable\nobjects, such as lists.\nThough tuples may seem similar to lists, they are often used in different\nsituations and for different purposes.\nTuples are immutable, and usually contain a heterogeneous sequence of\nelements that are accessed via unpacking (see later in this section) or indexing\n(or even by attribute in the case of namedtuples).\nLists are mutable, and their elements are usually homogeneous and are\naccessed by iterating over the list.\nA special problem is the construction of tuples containing 0 or 1 items: the\nsyntax has some extra quirks to accommodate these.  Empty tuples are constructed\nby an empty pair of parentheses; a tuple with one item is constructed by"
      },
      {
        "chunk_id": "python_docs_data_structures_chunk_3",
        "original_index": 3,
        "content": "syntax has some extra quirks to accommodate these.  Empty tuples are constructed\nby an empty pair of parentheses; a tuple with one item is constructed by\nfollowing a value with a comma (it is not sufficient to enclose a single value\nin parentheses). Ugly, but effective.  For example:\n>>> empty = ()\n>>> singleton = 'hello',    # <-- note trailing comma\n>>> len(empty)\n0\n>>> len(singleton)\n1\n>>> singleton\n('hello',)\nThe statement t = 12345, 54321, 'hello!' is an example of tuple packing:\nthe values 12345, 54321 and 'hello!' are packed together in a tuple.\nThe reverse operation is also possible:\n>>> x, y, z = t\nThis is called, appropriately enough, sequence unpacking and works for any\nsequence on the right-hand side.  Sequence unpacking requires that there are as\nmany variables on the left side of the equals sign as there are elements in the\nsequence.  Note that multiple assignment is really just a combination of tuple\npacking and sequence unpacking.\n5.4. SetsÂ¶\nPython also includes a data type for sets.  A set is an unordered collection\nwith no duplicate elements.  Basic uses include membership testing and\neliminating duplicate entries.  Set objects also support mathematical operations\nlike union, intersection, difference, and symmetric difference.\nCurly braces or the set() function can be used to create sets.  Note: to\ncreate an empty set you have to use set(), not {}; the latter creates an\nempty dictionary, a data structure that we discuss in the next section.\nHere is a brief demonstration:\n>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n>>> print(basket)                      # show that duplicates have been removed\n{'orange', 'banana', 'pear', 'apple'}\n>>> 'orange' in basket                 # fast membership testing\nTrue\n>>> 'crabgrass' in basket\nFalse\n>>> # Demonstrate set operations on unique letters from two words\n>>>\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a                                  # unique letters in a\n{'a', 'r', 'b', 'c', 'd'}\n>>> a - b                              # letters in a but not in b\n{'r', 'd', 'b'}\n>>> a | b                              # letters in a or b or both\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n>>> a & b                              # letters in both a and b\n{'a', 'c'}\n>>> a ^ b                              # letters in a or b but not both\n{'r', 'd', 'b', 'm', 'z', 'l'}\nSimilarly to list comprehensions, set comprehensions\nare also supported:\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'r', 'd'}\n5.5. DictionariesÂ¶\nAnother useful data type built into Python is the dictionary (see\nMapping Types â dict). Dictionaries are sometimes found in other languages as\nâassociative memoriesâ or âassociative arraysâ.  Unlike sequences, which are\nindexed by a range of numbers, dictionaries are indexed by keys, which can be\nany immutable type; strings and numbers can always be keys.  Tuples can be used\nas keys if they contain only strings, numbers, or tuples; if a tuple contains\nany mutable object either directly or indirectly, it cannot be used as a key.\nYou canât use lists as keys, since lists can be modified in place using index\nassignments, slice assignments, or methods like append() and\nextend().\nIt is best to think of a dictionary as a set of key: value pairs,\nwith the requirement that the keys are unique (within one dictionary). A pair of\nbraces creates an empty dictionary: {}. Placing a comma-separated list of\nkey:value pairs within the braces adds initial key:value pairs to the\ndictionary; this is also the way dictionaries are written on output.\nThe main operations on a dictionary are storing a value with some key and\nextracting the value given the key.  It is also possible to delete a key:value\npair with del. If you store using a key that is already in use, the old\nvalue associated with that key is forgotten.  It is an error to extract a value\nusing a non-existent key.\nPerforming list(d) on a dictionary returns a list of all the keys"
      },
      {
        "chunk_id": "python_docs_data_structures_chunk_4",
        "original_index": 4,
        "content": "value associated with that key is forgotten.  It is an error to extract a value\nusing a non-existent key.\nPerforming list(d) on a dictionary returns a list of all the keys\nused in the dictionary, in insertion order (if you want it sorted, just use\nsorted(d) instead). To check whether a single key is in the\ndictionary, use the in keyword.\nHere is a small example using a dictionary:\n>>> tel = {'jack': 4098, 'sape': 4139}\n>>> tel['guido'] = 4127\n>>> tel\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n>>> tel['jack']\n4098\n>>> del tel['sape']\n>>> tel['irv'] = 4127\n>>> tel\n{'jack': 4098, 'guido': 4127, 'irv': 4127}\n>>> list(tel)\n['jack', 'guido', 'irv']\n>>> sorted(tel)\n['guido', 'irv', 'jack']\n>>> 'guido' in tel\nTrue\n>>> 'jack' not in tel\nFalse\nThe dict() constructor builds dictionaries directly from sequences of\nkey-value pairs:\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\nIn addition, dict comprehensions can be used to create dictionaries from\narbitrary key and value expressions:\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\nWhen the keys are simple strings, it is sometimes easier to specify pairs using\nkeyword arguments:\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n5.6. Looping TechniquesÂ¶\nWhen looping through dictionaries, the key and corresponding value can be\nretrieved at the same time using the items() method.\n>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.items():\n...     print(k, v)\n...\ngallahad the pure\nrobin the brave\nWhen looping through a sequence, the position index and corresponding value can\nbe retrieved at the same time using the enumerate() function.\n>>> for i, v in enumerate(['tic', 'tac', 'toe']):\n...     print(i, v)\n...\n0 tic\n1 tac\n2 toe\nTo loop over two or more sequences at the same time, the entries can be paired\nwith the zip() function.\n>>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n...     print('What is your {0}?  It is {1}.'.format(q, a))\n...\nWhat is your name?  It is lancelot.\nWhat is your quest?  It is the holy grail.\nWhat is your favorite color?  It is blue.\nTo loop over a sequence in reverse, first specify the sequence in a forward\ndirection and then call the reversed() function.\n>>> for i in reversed(range(1, 10, 2)):\n...     print(i)\n...\n9\n7\n5\n3\n1\nTo loop over a sequence in sorted order, use the sorted() function which\nreturns a new sorted list while leaving the source unaltered.\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for i in sorted(basket):\n...     print(i)\n...\napple\napple\nbanana\norange\norange\npear\nUsing set() on a sequence eliminates duplicate elements. The use of\nsorted() in combination with set() over a sequence is an idiomatic\nway to loop over unique elements of the sequence in sorted order.\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n...     print(f)\n...\napple\nbanana\norange\npear\nIt is sometimes tempting to change a list while you are looping over it;\nhowever, it is often simpler and safer to create a new list instead.\n>>> import math\n>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n>>> filtered_data = []\n>>> for value in raw_data:\n...     if not math.isnan(value):\n...         filtered_data.append(value)\n...\n>>> filtered_data\n[56.2, 51.7, 55.3, 52.5, 47.8]\n5.7. More on ConditionsÂ¶\nThe conditions used in while and if statements can contain any\noperators, not just comparisons.\nThe comparison operators in and not in are membership tests that\ndetermine whether a value is in (or not in) a container.  The operators is\nand is not compare whether two objects are really the same object.  All\ncomparison operators have the same priority, which is lower than that of all\nnumerical operators."
      },
      {
        "chunk_id": "python_docs_data_structures_chunk_5",
        "original_index": 5,
        "content": "and is not compare whether two objects are really the same object.  All\ncomparison operators have the same priority, which is lower than that of all\nnumerical operators.\nComparisons can be chained.  For example, a < b == c tests whether a is\nless than b and moreover b equals c.\nComparisons may be combined using the Boolean operators and and or, and\nthe outcome of a comparison (or of any other Boolean expression) may be negated\nwith not.  These have lower priorities than comparison operators; between\nthem, not has the highest priority and or the lowest, so that A and\nnot B or C is equivalent to (A and (not B)) or C. As always, parentheses\ncan be used to express the desired composition.\nThe Boolean operators and and or are so-called short-circuit\noperators: their arguments are evaluated from left to right, and evaluation\nstops as soon as the outcome is determined.  For example, if A and C are\ntrue but B is false, A and B and C does not evaluate the expression\nC.  When used as a general value and not as a Boolean, the return value of a\nshort-circuit operator is the last evaluated argument.\nIt is possible to assign the result of a comparison or other Boolean expression\nto a variable.  For example,\n>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n>>> non_null = string1 or string2 or string3\n>>> non_null\n'Trondheim'\nNote that in Python, unlike C, assignment inside expressions must be done\nexplicitly with the\nwalrus operator :=.\nThis avoids a common class of problems encountered in C programs: typing =\nin an expression when == was intended.\n5.8. Comparing Sequences and Other TypesÂ¶\nSequence objects typically may be compared to other objects with the same sequence\ntype. The comparison uses lexicographical ordering: first the first two\nitems are compared, and if they differ this determines the outcome of the\ncomparison; if they are equal, the next two items are compared, and so on, until\neither sequence is exhausted. If two items to be compared are themselves\nsequences of the same type, the lexicographical comparison is carried out\nrecursively.  If all items of two sequences compare equal, the sequences are\nconsidered equal. If one sequence is an initial sub-sequence of the other, the\nshorter sequence is the smaller (lesser) one.  Lexicographical ordering for\nstrings uses the Unicode code point number to order individual characters.\nSome examples of comparisons between sequences of the same type:\n(1, 2, 3)              < (1, 2, 4)\n[1, 2, 3]              < [1, 2, 4]\n'ABC' < 'C' < 'Pascal' < 'Python'\n(1, 2, 3, 4)           < (1, 2, 4)\n(1, 2)                 < (1, 2, -1)\n(1, 2, 3)             == (1.0, 2.0, 3.0)\n(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)\nNote that comparing objects of different types with < or > is legal\nprovided that the objects have appropriate comparison methods.  For example,\nmixed numeric types are compared according to their numeric value, so 0 equals\n0.0, etc.  Otherwise, rather than providing an arbitrary ordering, the\ninterpreter will raise a TypeError exception.\nFootnotes\n[1]\nOther languages may return the mutated object, which allows method\nchaining, such as d->insert(\"a\")->remove(\"b\")->sort();."
      }
    ]
  },
  {
    "doc_id": "python_docs_control_flow",
    "original_uuid": "8854",
    "content": "4. More Control Flow ToolsÂ¶\nAs well as the while statement just introduced, Python uses a few more\nthat we will encounter in this chapter.\n4.1. if StatementsÂ¶\nPerhaps the most well-known statement type is the if statement.  For\nexample:\n>>> x = int(input(\"Please enter an integer: \"))\nPlease enter an integer: 42\n>>> if x < 0:\n...     x = 0\n...     print('Negative changed to zero')\n... elif x == 0:\n...     print('Zero')\n... elif x == 1:\n...     print('Single')\n... else:\n...     print('More')\n...\nMore\nThere can be zero or more elif parts, and the else part is\noptional.  The keyword âelifâ is short for âelse ifâ, and is useful\nto avoid excessive indentation.  An  if â¦ elif â¦\nelif â¦ sequence is a substitute for the switch or\ncase statements found in other languages.\nIf youâre comparing the same value to several constants, or checking for specific types or\nattributes, you may also find the match statement useful. For more\ndetails see match Statements.\n4.2. for StatementsÂ¶\nThe for statement in Python differs a bit from what you may be used\nto in C or Pascal.  Rather than always iterating over an arithmetic progression\nof numbers (like in Pascal), or giving the user the ability to define both the\niteration step and halting condition (as C), Pythonâs for statement\niterates over the items of any sequence (a list or a string), in the order that\nthey appear in the sequence.  For example (no pun intended):\n>>> # Measure some strings:\n>>> words = ['cat', 'window', 'defenestrate']\n>>> for w in words:\n...     print(w, len(w))\n...\ncat 3\nwindow 6\ndefenestrate 12\nCode that modifies a collection while iterating over that same collection can\nbe tricky to get right.  Instead, it is usually more straight-forward to loop\nover a copy of the collection or to create a new collection:\n# Create a sample collection\nusers = {'Hans': 'active', 'ÃlÃ©onore': 'inactive', 'æ¯å¤ªé': 'active'}\n# Strategy:  Iterate over a copy\nfor user, status in users.copy().items():\nif status == 'inactive':\ndel users[user]\n# Strategy:  Create a new collection\nactive_users = {}\nfor user, status in users.items():\nif status == 'active':\nactive_users[user] = status\n4.3. The range() FunctionÂ¶\nIf you do need to iterate over a sequence of numbers, the built-in function\nrange() comes in handy.  It generates arithmetic progressions:\n>>> for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\nThe given end point is never part of the generated sequence; range(10) generates\n10 values, the legal indices for items of a sequence of length 10.  It\nis possible to let the range start at another number, or to specify a different\nincrement (even negative; sometimes this is called the âstepâ):\n>>> list(range(5, 10))\n[5, 6, 7, 8, 9]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(-10, -100, -30))\n[-10, -40, -70]\nTo iterate over the indices of a sequence, you can combine range() and\nlen() as follows:\n>>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n>>> for i in range(len(a)):\n...     print(i, a[i])\n...\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\nIn most such cases, however, it is convenient to use the enumerate()\nfunction, see Looping Techniques.\nA strange thing happens if you just print a range:\n>>> range(10)\nrange(0, 10)\nIn many ways the object returned by range() behaves as if it is a list,\nbut in fact it isnât. It is an object which returns the successive items of\nthe desired sequence when you iterate over it, but it doesnât really make\nthe list, thus saving space.\nWe say such an object is iterable, that is, suitable as a target for\nfunctions and constructs that expect something from which they can\nobtain successive items until the supply is exhausted.  We have seen that\nthe for statement is such a construct, while an example of a function\nthat takes an iterable is sum():\n>>> sum(range(4))  # 0 + 1 + 2 + 3\n6\nLater we will see more functions that return iterables and take iterables as\narguments.  In chapter Data Structures, we will discuss in more detail about\nlist().\n4.4. break and continue StatementsÂ¶\nThe break statement breaks out of the innermost enclosing\nfor or while loop:\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(f\"{n} equals {x} * {n//x}\")\n...             break\n...\n4 equals 2 * 2\n6 equals 2 * 3\n8 equals 2 * 4\n9 equals 3 * 3\nThe continue statement continues with the next\niteration of the loop:\n>>> for num in range(2, 10):\n...     if num % 2 == 0:\n...         print(f\"Found an even number {num}\")\n...         continue\n...     print(f\"Found an odd number {num}\")\n...\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n4.5. else Clauses on LoopsÂ¶\nIn a for or while loop the break statement\nmay be paired with an else clause.  If the loop finishes without\nexecuting the break, the else clause executes.\nIn a for loop, the else clause is executed\nafter the loop finishes its final iteration, that is, if no break occurred.\nIn a while loop, itâs executed after the loopâs condition becomes false.\nIn either kind of loop, the else clause is not executed if the\nloop was terminated by a break.  Of course, other ways of ending the\nloop early, such as a return or a raised exception, will also skip\nexecution of the else clause.\nThis is exemplified in the following for loop,\nwhich searches for prime numbers:\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(n, 'equals', x, '*', n//x)\n...             break\n...     else:\n...         # loop fell through without finding a factor\n...         print(n, 'is a prime number')\n...\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n(Yes, this is the correct code.  Look closely: the else clause belongs to\nthe for loop, not the if statement.)\nOne way to think of the else clause is to imagine it paired with the if\ninside the loop.  As the loop executes, it will run a sequence like\nif/if/if/else. The if is inside the loop, encountered a number of times. If\nthe condition is ever true, a break will happen. If the condition is never\ntrue, the else clause outside the loop will execute.\nWhen used with a loop, the else clause has more in common with the else\nclause of a try statement than it does with that of if\nstatements: a try statementâs else clause runs when no exception\noccurs, and a loopâs else clause runs when no break occurs. For more on\nthe try statement and exceptions, see Handling Exceptions.\n4.6. pass StatementsÂ¶\nThe pass statement does nothing. It can be used when a statement is\nrequired syntactically but the program requires no action. For example:\n>>> while True:\n...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n...\nThis is commonly used for creating minimal classes:\n>>> class MyEmptyClass:\n...     pass\n...\nAnother place pass can be used is as a place-holder for a function or\nconditional body when you are working on new code, allowing you to keep thinking\nat a more abstract level.  The pass is silently ignored:\n>>> def initlog(*args):\n...     pass   # Remember to implement this!\n...\n4.7. match StatementsÂ¶\nA match statement takes an expression and compares its value to successive\npatterns given as one or more case blocks.  This is superficially\nsimilar to a switch statement in C, Java or JavaScript (and many\nother languages), but itâs more similar to pattern matching in\nlanguages like Rust or Haskell. Only the first pattern that matches\ngets executed and it can also extract components (sequence elements\nor object attributes) from the value into variables.\nThe simplest form compares a subject value against one or more literals:\ndef http_error(status):\nmatch status:\ncase 400:\nreturn \"Bad request\"\ncase 404:\nreturn \"Not found\"\ncase 418:\nreturn \"I'm a teapot\"\ncase _:\nreturn \"Something's wrong with the internet\"\nNote the last block: the âvariable nameâ _ acts as a wildcard and\nnever fails to match. If no case matches, none of the branches is executed.\nYou can combine several literals in a single pattern using | (âorâ):\ncase 401 | 403 | 404:\nreturn \"Not allowed\"\nPatterns can look like unpacking assignments, and can be used to bind\nvariables:\n# point is an (x, y) tuple\nmatch point:\ncase (0, 0):\nprint(\"Origin\")\ncase (0, y):\nprint(f\"Y={y}\")\ncase (x, 0):\nprint(f\"X={x}\")\ncase (x, y):\nprint(f\"X={x}, Y={y}\")\ncase _:\nraise ValueError(\"Not a point\")\nStudy that one carefully!  The first pattern has two literals, and can\nbe thought of as an extension of the literal pattern shown above.  But\nthe next two patterns combine a literal and a variable, and the\nvariable binds a value from the subject (point).  The fourth\npattern captures two values, which makes it conceptually similar to\nthe unpacking assignment (x, y) = point.\nIf you are using classes to structure your data\nyou can use the class name followed by an argument list resembling a\nconstructor, but with the ability to capture attributes into variables:\nclass Point:\ndef __init__(self, x, y):\nself.x = x\nself.y = y\ndef where_is(point):\nmatch point:\ncase Point(x=0, y=0):\nprint(\"Origin\")\ncase Point(x=0, y=y):\nprint(f\"Y={y}\")\ncase Point(x=x, y=0):\nprint(f\"X={x}\")\ncase Point():\nprint(\"Somewhere else\")\ncase _:\nprint(\"Not a point\")\nYou can use positional parameters with some builtin classes that provide an\nordering for their attributes (e.g. dataclasses). You can also define a specific\nposition for attributes in patterns by setting the __match_args__ special\nattribute in your classes. If itâs set to (âxâ, âyâ), the following patterns are all\nequivalent (and all bind the y attribute to the var variable):\nPoint(1, var)\nPoint(1, y=var)\nPoint(x=1, y=var)\nPoint(y=var, x=1)\nA recommended way to read patterns is to look at them as an extended form of what you\nwould put on the left of an assignment, to understand which variables would be set to\nwhat.\nOnly the standalone names (like var above) are assigned to by a match statement.\nDotted names (like foo.bar), attribute names (the x= and y= above) or class names\n(recognized by the â(â¦)â next to them like Point above) are never assigned to.\nPatterns can be arbitrarily nested.  For example, if we have a short\nlist of Points, with __match_args__ added, we could match it like this:\nclass Point:\n__match_args__ = ('x', 'y')\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nmatch points:\ncase []:\nprint(\"No points\")\ncase [Point(0, 0)]:\nprint(\"The origin\")\ncase [Point(x, y)]:\nprint(f\"Single point {x}, {y}\")\ncase [Point(0, y1), Point(0, y2)]:\nprint(f\"Two on the Y axis at {y1}, {y2}\")\ncase _:\nprint(\"Something else\")\nWe can add an if clause to a pattern, known as a âguardâ.  If the\nguard is false, match goes on to try the next case block.  Note\nthat value capture happens before the guard is evaluated:\nmatch point:\ncase Point(x, y) if x == y:\nprint(f\"Y=X at {x}\")\ncase Point(x, y):\nprint(f\"Not on the diagonal\")\nSeveral other key features of this statement:\nLike unpacking assignments, tuple and list patterns have exactly the\nsame meaning and actually match arbitrary sequences.  An important\nexception is that they donât match iterators or strings.\nSequence patterns support extended unpacking: [x, y, *rest] and (x, y,\n*rest) work similar to unpacking assignments.  The\nname after * may also be _, so (x, y, *_) matches a sequence\nof at least two items without binding the remaining items.\nMapping patterns: {\"bandwidth\": b, \"latency\": l} captures the\n\"bandwidth\" and \"latency\" values from a dictionary.  Unlike sequence\npatterns, extra keys are ignored.  An unpacking like **rest is also\nsupported.  (But **_ would be redundant, so it is not allowed.)\nSubpatterns may be captured using the as keyword:\ncase (Point(x1, y1), Point(x2, y2) as p2): ...\nwill capture the second element of the input as p2 (as long as the input is\na sequence of two points)\nMost literals are compared by equality, however the singletons True,\nFalse and None are compared by identity.\nPatterns may use named constants.  These must be dotted names\nto prevent them from being interpreted as capture variable:\nfrom enum import Enum\nclass Color(Enum):\nRED = 'red'\nGREEN = 'green'\nBLUE = 'blue'\ncolor = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\nmatch color:\ncase Color.RED:\nprint(\"I see red!\")\ncase Color.GREEN:\nprint(\"Grass is green\")\ncase Color.BLUE:\nprint(\"I'm feeling the blues :(\")\nFor a more detailed explanation and additional examples, you can look into\nPEP 636 which is written in a tutorial format.\n4.8. Defining FunctionsÂ¶\nWe can create a function that writes the Fibonacci series to an arbitrary\nboundary:\n>>> def fib(n):    # write Fibonacci series less than n\n...     \"\"\"Print a Fibonacci series less than n.\"\"\"\n...     a, b = 0, 1\n...     while a < n:\n...         print(a, end=' ')\n...         a, b = b, a+b\n...     print()\n...\n>>> # Now call the function we just defined:\n>>> fib(2000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\nThe keyword def introduces a function definition.  It must be\nfollowed by the function name and the parenthesized list of formal parameters.\nThe statements that form the body of the function start at the next line, and\nmust be indented.\nThe first statement of the function body can optionally be a string literal;\nthis string literal is the functionâs documentation string, or docstring.\n(More about docstrings can be found in the section Documentation Strings.)\nThere are tools which use docstrings to automatically produce online or printed\ndocumentation, or to let the user interactively browse through code; itâs good\npractice to include docstrings in code that you write, so make a habit of it.\nThe execution of a function introduces a new symbol table used for the local\nvariables of the function.  More precisely, all variable assignments in a\nfunction store the value in the local symbol table; whereas variable references\nfirst look in the local symbol table, then in the local symbol tables of\nenclosing functions, then in the global symbol table, and finally in the table\nof built-in names. Thus, global variables and variables of enclosing functions\ncannot be directly assigned a value within a function (unless, for global\nvariables, named in a global statement, or, for variables of enclosing\nfunctions, named in a nonlocal statement), although they may be\nreferenced.\nThe actual parameters (arguments) to a function call are introduced in the local\nsymbol table of the called function when it is called; thus, arguments are\npassed using call by value (where the value is always an object reference,\nnot the value of the object). [1] When a function calls another function,\nor calls itself recursively, a new\nlocal symbol table is created for that call.\nA function definition associates the function name with the function object in\nthe current symbol table.  The interpreter recognizes the object pointed to by\nthat name as a user-defined function.  Other names can also point to that same\nfunction object and can also be used to access the function:\n>>> fib\n<function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\nComing from other languages, you might object that fib is not a function but\na procedure since it doesnât return a value.  In fact, even functions without a\nreturn statement do return a value, albeit a rather boring one.  This\nvalue is called None (itâs a built-in name).  Writing the value None is\nnormally suppressed by the interpreter if it would be the only value written.\nYou can see it if you really want to using print():\n>>> fib(0)\n>>> print(fib(0))\nNone\nIt is simple to write a function that returns a list of the numbers of the\nFibonacci series, instead of printing it:\n>>> def fib2(n):  # return Fibonacci series up to n\n...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n...     result = []\n...     a, b = 0, 1\n...     while a < n:\n...         result.append(a)    # see below\n...         a, b = b, a+b\n...     return result\n...\n>>> f100 = fib2(100)    # call it\n>>> f100                # write the result\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\nThis example, as usual, demonstrates some new Python features:\nThe return statement returns with a value from a function.\nreturn without an expression argument returns None. Falling off\nthe end of a function also returns None.\nThe statement result.append(a) calls a method of the list object\nresult.  A method is a function that âbelongsâ to an object and is named\nobj.methodname, where obj is some object (this may be an expression),\nand methodname is the name of a method that is defined by the objectâs type.\nDifferent types define different methods.  Methods of different types may have\nthe same name without causing ambiguity.  (It is possible to define your own\nobject types and methods, using classes, see Classes)\nThe method append() shown in the example is defined for list objects; it\nadds a new element at the end of the list.  In this example it is equivalent to\nresult = result + [a], but more efficient.\n4.9. More on Defining FunctionsÂ¶\nIt is also possible to define functions with a variable number of arguments.\nThere are three forms, which can be combined.\n4.9.1. Default Argument ValuesÂ¶\nThe most useful form is to specify a default value for one or more arguments.\nThis creates a function that can be called with fewer arguments than it is\ndefined to allow.  For example:\ndef ask_ok(prompt, retries=4, reminder='Please try again!'):\nwhile True:\nreply = input(prompt)\nif reply in {'y', 'ye', 'yes'}:\nreturn True\nif reply in {'n', 'no', 'nop', 'nope'}:\nreturn False\nretries = retries - 1\nif retries < 0:\nraise ValueError('invalid user response')\nprint(reminder)\nThis function can be called in several ways:\ngiving only the mandatory argument:\nask_ok('Do you really want to quit?')\ngiving one of the optional arguments:\nask_ok('OK to overwrite the file?', 2)\nor even giving all arguments:\nask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')\nThis example also introduces the in keyword. This tests whether or\nnot a sequence contains a certain value.\nThe default values are evaluated at the point of function definition in the\ndefining scope, so that\ni = 5\ndef f(arg=i):\nprint(arg)\ni = 6\nf()\nwill print 5.\nImportant warning:  The default value is evaluated only once. This makes a\ndifference when the default is a mutable object such as a list, dictionary, or\ninstances of most classes.  For example, the following function accumulates the\narguments passed to it on subsequent calls:\ndef f(a, L=[]):\nL.append(a)\nreturn L\nprint(f(1))\nprint(f(2))\nprint(f(3))\nThis will print\n[1]\n[1, 2]\n[1, 2, 3]\nIf you donât want the default to be shared between subsequent calls, you can\nwrite the function like this instead:\ndef f(a, L=None):\nif L is None:\nL = []\nL.append(a)\nreturn L\n4.9.2. Keyword ArgumentsÂ¶\nFunctions can also be called using keyword arguments\nof the form kwarg=value.  For instance, the following function:\ndef parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\nprint(\"-- This parrot wouldn't\", action, end=' ')\nprint(\"if you put\", voltage, \"volts through it.\")\nprint(\"-- Lovely plumage, the\", type)\nprint(\"-- It's\", state, \"!\")\naccepts one required argument (voltage) and three optional arguments\n(state, action, and type).  This function can be called in any\nof the following ways:\nparrot(1000)                                          # 1 positional argument\nparrot(voltage=1000)                                  # 1 keyword argument\nparrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\nparrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\nparrot('a million', 'bereft of life', 'jump')         # 3 positional arguments\nparrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword\nbut all the following calls would be invalid:\nparrot()                     # required argument missing\nparrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument\nparrot(110, voltage=220)     # duplicate value for the same argument\nparrot(actor='John Cleese')  # unknown keyword argument\nIn a function call, keyword arguments must follow positional arguments.\nAll the keyword arguments passed must match one of the arguments\naccepted by the function (e.g. actor is not a valid argument for the\nparrot function), and their order is not important.  This also includes\nnon-optional arguments (e.g. parrot(voltage=1000) is valid too).\nNo argument may receive a value more than once.\nHereâs an example that fails due to this restriction:\n>>> def function(a):\n...     pass\n...\n>>> function(0, a=0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: function() got multiple values for argument 'a'\nWhen a final formal parameter of the form **name is present, it receives a\ndictionary (see Mapping Types â dict) containing all keyword arguments except for\nthose corresponding to a formal parameter.  This may be combined with a formal\nparameter of the form *name (described in the next subsection) which\nreceives a tuple containing the positional\narguments beyond the formal parameter list.  (*name must occur\nbefore **name.) For example, if we define a function like this:\ndef cheeseshop(kind, *arguments, **keywords):\nprint(\"-- Do you have any\", kind, \"?\")\nprint(\"-- I'm sorry, we're all out of\", kind)\nfor arg in arguments:\nprint(arg)\nprint(\"-\" * 40)\nfor kw in keywords:\nprint(kw, \":\", keywords[kw])\nIt could be called like this:\ncheeseshop(\"Limburger\", \"It's very runny, sir.\",\n\"It's really very, VERY runny, sir.\",\nshopkeeper=\"Michael Palin\",\nclient=\"John Cleese\",\nsketch=\"Cheese Shop Sketch\")\nand of course it would print:\n-- Do you have any Limburger ?\n-- I'm sorry, we're all out of Limburger\nIt's very runny, sir.\nIt's really very, VERY runny, sir.\n----------------------------------------\nshopkeeper : Michael Palin\nclient : John Cleese\nsketch : Cheese Shop Sketch\nNote that the order in which the keyword arguments are printed is guaranteed\nto match the order in which they were provided in the function call.\n4.9.3. Special parametersÂ¶\nBy default, arguments may be passed to a Python function either by position\nor explicitly by keyword. For readability and performance, it makes sense to\nrestrict the way arguments can be passed so that a developer need only look\nat the function definition to determine if items are passed by position, by\nposition or keyword, or by keyword.\nA function definition may look like:\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n-----------    ----------     ----------\n|             |                  |\n|        Positional or keyword   |\n|                                - Keyword only\n-- Positional only\nwhere / and * are optional. If used, these symbols indicate the kind of\nparameter by how the arguments may be passed to the function:\npositional-only, positional-or-keyword, and keyword-only. Keyword parameters\nare also referred to as named parameters.\n4.9.3.1. Positional-or-Keyword ArgumentsÂ¶\nIf / and * are not present in the function definition, arguments may\nbe passed to a function by position or by keyword.\n4.9.3.2. Positional-Only ParametersÂ¶\nLooking at this in a bit more detail, it is possible to mark certain parameters\nas positional-only. If positional-only, the parametersâ order matters, and\nthe parameters cannot be passed by keyword. Positional-only parameters are\nplaced before a / (forward-slash). The / is used to logically\nseparate the positional-only parameters from the rest of the parameters.\nIf there is no / in the function definition, there are no positional-only\nparameters.\nParameters following the / may be positional-or-keyword or keyword-only.\n4.9.3.3. Keyword-Only ArgumentsÂ¶\nTo mark parameters as keyword-only, indicating the parameters must be passed\nby keyword argument, place an * in the arguments list just before the first\nkeyword-only parameter.\n4.9.3.4. Function ExamplesÂ¶\nConsider the following example function definitions paying close attention to the\nmarkers / and *:\n>>> def standard_arg(arg):\n...     print(arg)\n...\n>>> def pos_only_arg(arg, /):\n...     print(arg)\n...\n>>> def kwd_only_arg(*, arg):\n...     print(arg)\n...\n>>> def combined_example(pos_only, /, standard, *, kwd_only):\n...     print(pos_only, standard, kwd_only)\nThe first function definition, standard_arg, the most familiar form,\nplaces no restrictions on the calling convention and arguments may be\npassed by position or keyword:\n>>> standard_arg(2)\n2\n>>> standard_arg(arg=2)\n2\nThe second function pos_only_arg is restricted to only use positional\nparameters as there is a / in the function definition:\n>>> pos_only_arg(1)\n1\n>>> pos_only_arg(arg=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'\nThe third function kwd_only_arg only allows keyword arguments as indicated\nby a * in the function definition:\n>>> kwd_only_arg(3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n>>> kwd_only_arg(arg=3)\n3\nAnd the last uses all three calling conventions in the same function\ndefinition:\n>>> combined_example(1, 2, 3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() takes 2 positional arguments but 3 were given\n>>> combined_example(1, 2, kwd_only=3)\n1 2 3\n>>> combined_example(1, standard=2, kwd_only=3)\n1 2 3\n>>> combined_example(pos_only=1, standard=2, kwd_only=3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'\nFinally, consider this function definition which has a potential collision between the positional argument name  and **kwds which has name as a key:\ndef foo(name, **kwds):\nreturn 'name' in kwds\nThere is no possible call that will make it return True as the keyword 'name'\nwill always bind to the first parameter. For example:\n>>> foo(1, **{'name': 2})\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: foo() got multiple values for argument 'name'\n>>>\nBut using / (positional only arguments), it is possible since it allows name as a positional argument and 'name' as a key in the keyword arguments:\n>>> def foo(name, /, **kwds):\n...     return 'name' in kwds\n...\n>>> foo(1, **{'name': 2})\nTrue\nIn other words, the names of positional-only parameters can be used in\n**kwds without ambiguity.\n4.9.3.5. RecapÂ¶\nThe use case will determine which parameters to use in the function definition:\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\nAs guidance:\nUse positional-only if you want the name of the parameters to not be\navailable to the user. This is useful when parameter names have no real\nmeaning, if you want to enforce the order of the arguments when the function\nis called or if you need to take some positional parameters and arbitrary\nkeywords.\nUse keyword-only when names have meaning and the function definition is\nmore understandable by being explicit with names or you want to prevent\nusers relying on the position of the argument being passed.\nFor an API, use positional-only to prevent breaking API changes\nif the parameterâs name is modified in the future.\n4.9.4. Arbitrary Argument ListsÂ¶\nFinally, the least frequently used option is to specify that a function can be\ncalled with an arbitrary number of arguments.  These arguments will be wrapped\nup in a tuple (see Tuples and Sequences).  Before the variable number of arguments,\nzero or more normal arguments may occur.\ndef write_multiple_items(file, separator, *args):\nfile.write(separator.join(args))\nNormally, these variadic arguments will be last in the list of formal\nparameters, because they scoop up all remaining input arguments that are\npassed to the function. Any formal parameters which occur after the *args\nparameter are âkeyword-onlyâ arguments, meaning that they can only be used as\nkeywords rather than positional arguments.\n>>> def concat(*args, sep=\"/\"):\n...     return sep.join(args)\n...\n>>> concat(\"earth\", \"mars\", \"venus\")\n'earth/mars/venus'\n>>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n'earth.mars.venus'\n4.9.5. Unpacking Argument ListsÂ¶\nThe reverse situation occurs when the arguments are already in a list or tuple\nbut need to be unpacked for a function call requiring separate positional\narguments.  For instance, the built-in range() function expects separate\nstart and stop arguments.  If they are not available separately, write the\nfunction call with the  *-operator to unpack the arguments out of a list\nor tuple:\n>>> list(range(3, 6))            # normal call with separate arguments\n[3, 4, 5]\n>>> args = [3, 6]\n>>> list(range(*args))            # call with arguments unpacked from a list\n[3, 4, 5]\nIn the same fashion, dictionaries can deliver keyword arguments with the\n**-operator:\n>>> def parrot(voltage, state='a stiff', action='voom'):\n...     print(\"-- This parrot wouldn't\", action, end=' ')\n...     print(\"if you put\", voltage, \"volts through it.\", end=' ')\n...     print(\"E's\", state, \"!\")\n...\n>>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n>>> parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !\n4.9.6. Lambda ExpressionsÂ¶\nSmall anonymous functions can be created with the lambda keyword.\nThis function returns the sum of its two arguments: lambda a, b: a+b.\nLambda functions can be used wherever function objects are required.  They are\nsyntactically restricted to a single expression.  Semantically, they are just\nsyntactic sugar for a normal function definition.  Like nested function\ndefinitions, lambda functions can reference variables from the containing\nscope:\n>>> def make_incrementor(n):\n...     return lambda x: x + n\n...\n>>> f = make_incrementor(42)\n>>> f(0)\n42\n>>> f(1)\n43\nThe above example uses a lambda expression to return a function.  Another use\nis to pass a small function as an argument:\n>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n>>> pairs.sort(key=lambda pair: pair[1])\n>>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n4.9.7. Documentation StringsÂ¶\nHere are some conventions about the content and formatting of documentation\nstrings.\nThe first line should always be a short, concise summary of the objectâs\npurpose.  For brevity, it should not explicitly state the objectâs name or type,\nsince these are available by other means (except if the name happens to be a\nverb describing a functionâs operation).  This line should begin with a capital\nletter and end with a period.\nIf there are more lines in the documentation string, the second line should be\nblank, visually separating the summary from the rest of the description.  The\nfollowing lines should be one or more paragraphs describing the objectâs calling\nconventions, its side effects, etc.\nThe Python parser does not strip indentation from multi-line string literals in\nPython, so tools that process documentation have to strip indentation if\ndesired.  This is done using the following convention. The first non-blank line\nafter the first line of the string determines the amount of indentation for\nthe entire documentation string.  (We canât use the first line since it is\ngenerally adjacent to the stringâs opening quotes so its indentation is not\napparent in the string literal.)  Whitespace âequivalentâ to this indentation is\nthen stripped from the start of all lines of the string.  Lines that are\nindented less should not occur, but if they occur all their leading whitespace\nshould be stripped.  Equivalence of whitespace should be tested after expansion\nof tabs (to 8 spaces, normally).\nHere is an example of a multi-line docstring:\n>>> def my_function():\n...     \"\"\"Do nothing, but document it.\n...\n...     No, really, it doesn't do anything.\n...     \"\"\"\n...     pass\n...\n>>> print(my_function.__doc__)\nDo nothing, but document it.\nNo, really, it doesn't do anything.\n4.9.8. Function AnnotationsÂ¶\nFunction annotations are completely optional metadata\ninformation about the types used by user-defined functions (see PEP 3107 and\nPEP 484 for more information).\nAnnotations are stored in the __annotations__\nattribute of the function as a dictionary and have no effect on any other part of the\nfunction.  Parameter annotations are defined by a colon after the parameter name, followed\nby an expression evaluating to the value of the annotation.  Return annotations are\ndefined by a literal ->, followed by an expression, between the parameter\nlist and the colon denoting the end of the def statement.  The\nfollowing example has a required argument, an optional argument, and the return\nvalue annotated:\n>>> def f(ham: str, eggs: str = 'eggs') -> str:\n...     print(\"Annotations:\", f.__annotations__)\n...     print(\"Arguments:\", ham, eggs)\n...     return ham + ' and ' + eggs\n...\n>>> f('spam')\nAnnotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}\nArguments: spam eggs\n'spam and eggs'\n4.10. Intermezzo: Coding StyleÂ¶\nNow that you are about to write longer, more complex pieces of Python, it is a\ngood time to talk about coding style.  Most languages can be written (or more\nconcise, formatted) in different styles; some are more readable than others.\nMaking it easy for others to read your code is always a good idea, and adopting\na nice coding style helps tremendously for that.\nFor Python, PEP 8 has emerged as the style guide that most projects adhere to;\nit promotes a very readable and eye-pleasing coding style.  Every Python\ndeveloper should read it at some point; here are the most important points\nextracted for you:\nUse 4-space indentation, and no tabs.\n4 spaces are a good compromise between small indentation (allows greater\nnesting depth) and large indentation (easier to read).  Tabs introduce\nconfusion, and are best left out.\nWrap lines so that they donât exceed 79 characters.\nThis helps users with small displays and makes it possible to have several\ncode files side-by-side on larger displays.\nUse blank lines to separate functions and classes, and larger blocks of\ncode inside functions.\nWhen possible, put comments on a line of their own.\nUse docstrings.\nUse spaces around operators and after commas, but not directly inside\nbracketing constructs: a = f(1, 2) + g(3, 4).\nName your classes and functions consistently; the convention is to use\nUpperCamelCase for classes and lowercase_with_underscores for functions\nand methods.  Always use self as the name for the first method argument\n(see A First Look at Classes for more on classes and methods).\nDonât use fancy encodings if your code is meant to be used in international\nenvironments.  Pythonâs default, UTF-8, or even plain ASCII work best in any\ncase.\nLikewise, donât use non-ASCII characters in identifiers if there is only the\nslightest chance people speaking a different language will read or maintain\nthe code.\nFootnotes\n[1]\nActually, call by object reference would be a better description,\nsince if a mutable object is passed, the caller will see any changes the\ncallee makes to it (items inserted into a list).",
    "chunks": [
      {
        "chunk_id": "python_docs_control_flow_chunk_0",
        "original_index": 0,
        "content": "4. More Control Flow ToolsÂ¶\nAs well as the while statement just introduced, Python uses a few more\nthat we will encounter in this chapter.\n4.1. if StatementsÂ¶\nPerhaps the most well-known statement type is the if statement.  For\nexample:\n>>> x = int(input(\"Please enter an integer: \"))\nPlease enter an integer: 42\n>>> if x < 0:\n...     x = 0\n...     print('Negative changed to zero')\n... elif x == 0:\n...     print('Zero')\n... elif x == 1:\n...     print('Single')\n... else:\n...     print('More')\n...\nMore\nThere can be zero or more elif parts, and the else part is\noptional.  The keyword âelifâ is short for âelse ifâ, and is useful\nto avoid excessive indentation.  An  if â¦ elif â¦\nelif â¦ sequence is a substitute for the switch or\ncase statements found in other languages.\nIf youâre comparing the same value to several constants, or checking for specific types or\nattributes, you may also find the match statement useful. For more\ndetails see match Statements.\n4.2. for StatementsÂ¶\nThe for statement in Python differs a bit from what you may be used\nto in C or Pascal.  Rather than always iterating over an arithmetic progression\nof numbers (like in Pascal), or giving the user the ability to define both the\niteration step and halting condition (as C), Pythonâs for statement\niterates over the items of any sequence (a list or a string), in the order that\nthey appear in the sequence.  For example (no pun intended):\n>>> # Measure some strings:\n>>> words = ['cat', 'window', 'defenestrate']\n>>> for w in words:\n...     print(w, len(w))\n...\ncat 3\nwindow 6\ndefenestrate 12\nCode that modifies a collection while iterating over that same collection can\nbe tricky to get right.  Instead, it is usually more straight-forward to loop\nover a copy of the collection or to create a new collection:\n# Create a sample collection\nusers = {'Hans': 'active', 'ÃlÃ©onore': 'inactive', 'æ¯å¤ªé': 'active'}\n# Strategy:  Iterate over a copy\nfor user, status in users.copy().items():\nif status == 'inactive':\ndel users[user]\n# Strategy:  Create a new collection\nactive_users = {}\nfor user, status in users.items():\nif status == 'active':\nactive_users[user] = status\n4.3. The range() FunctionÂ¶\nIf you do need to iterate over a sequence of numbers, the built-in function\nrange() comes in handy.  It generates arithmetic progressions:\n>>> for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\nThe given end point is never part of the generated sequence; range(10) generates\n10 values, the legal indices for items of a sequence of length 10.  It\nis possible to let the range start at another number, or to specify a different\nincrement (even negative; sometimes this is called the âstepâ):\n>>> list(range(5, 10))\n[5, 6, 7, 8, 9]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(-10, -100, -30))\n[-10, -40, -70]\nTo iterate over the indices of a sequence, you can combine range() and\nlen() as follows:\n>>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n>>> for i in range(len(a)):\n...     print(i, a[i])\n...\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\nIn most such cases, however, it is convenient to use the enumerate()\nfunction, see Looping Techniques.\nA strange thing happens if you just print a range:\n>>> range(10)\nrange(0, 10)\nIn many ways the object returned by range() behaves as if it is a list,\nbut in fact it isnât. It is an object which returns the successive items of\nthe desired sequence when you iterate over it, but it doesnât really make\nthe list, thus saving space.\nWe say such an object is iterable, that is, suitable as a target for\nfunctions and constructs that expect something from which they can\nobtain successive items until the supply is exhausted.  We have seen that\nthe for statement is such a construct, while an example of a function\nthat takes an iterable is sum():\n>>> sum(range(4))  # 0 + 1 + 2 + 3\n6\nLater we will see more functions that return iterables and take iterables as\narguments.  In chapter Data Structures, we will discuss in more detail about\nlist()."
      },
      {
        "chunk_id": "python_docs_control_flow_chunk_1",
        "original_index": 1,
        "content": ">>> sum(range(4))  # 0 + 1 + 2 + 3\n6\nLater we will see more functions that return iterables and take iterables as\narguments.  In chapter Data Structures, we will discuss in more detail about\nlist().\n4.4. break and continue StatementsÂ¶\nThe break statement breaks out of the innermost enclosing\nfor or while loop:\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(f\"{n} equals {x} * {n//x}\")\n...             break\n...\n4 equals 2 * 2\n6 equals 2 * 3\n8 equals 2 * 4\n9 equals 3 * 3\nThe continue statement continues with the next\niteration of the loop:\n>>> for num in range(2, 10):\n...     if num % 2 == 0:\n...         print(f\"Found an even number {num}\")\n...         continue\n...     print(f\"Found an odd number {num}\")\n...\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n4.5. else Clauses on LoopsÂ¶\nIn a for or while loop the break statement\nmay be paired with an else clause.  If the loop finishes without\nexecuting the break, the else clause executes.\nIn a for loop, the else clause is executed\nafter the loop finishes its final iteration, that is, if no break occurred.\nIn a while loop, itâs executed after the loopâs condition becomes false.\nIn either kind of loop, the else clause is not executed if the\nloop was terminated by a break.  Of course, other ways of ending the\nloop early, such as a return or a raised exception, will also skip\nexecution of the else clause.\nThis is exemplified in the following for loop,\nwhich searches for prime numbers:\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(n, 'equals', x, '*', n//x)\n...             break\n...     else:\n...         # loop fell through without finding a factor\n...         print(n, 'is a prime number')\n...\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n(Yes, this is the correct code.  Look closely: the else clause belongs to\nthe for loop, not the if statement.)\nOne way to think of the else clause is to imagine it paired with the if\ninside the loop.  As the loop executes, it will run a sequence like\nif/if/if/else. The if is inside the loop, encountered a number of times. If\nthe condition is ever true, a break will happen. If the condition is never\ntrue, the else clause outside the loop will execute.\nWhen used with a loop, the else clause has more in common with the else\nclause of a try statement than it does with that of if\nstatements: a try statementâs else clause runs when no exception\noccurs, and a loopâs else clause runs when no break occurs. For more on\nthe try statement and exceptions, see Handling Exceptions.\n4.6. pass StatementsÂ¶\nThe pass statement does nothing. It can be used when a statement is\nrequired syntactically but the program requires no action. For example:\n>>> while True:\n...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n...\nThis is commonly used for creating minimal classes:\n>>> class MyEmptyClass:\n...     pass\n...\nAnother place pass can be used is as a place-holder for a function or\nconditional body when you are working on new code, allowing you to keep thinking\nat a more abstract level.  The pass is silently ignored:\n>>> def initlog(*args):\n...     pass   # Remember to implement this!\n...\n4.7. match StatementsÂ¶\nA match statement takes an expression and compares its value to successive\npatterns given as one or more case blocks.  This is superficially\nsimilar to a switch statement in C, Java or JavaScript (and many\nother languages), but itâs more similar to pattern matching in\nlanguages like Rust or Haskell. Only the first pattern that matches\ngets executed and it can also extract components (sequence elements\nor object attributes) from the value into variables."
      },
      {
        "chunk_id": "python_docs_control_flow_chunk_2",
        "original_index": 2,
        "content": "languages like Rust or Haskell. Only the first pattern that matches\ngets executed and it can also extract components (sequence elements\nor object attributes) from the value into variables.\nThe simplest form compares a subject value against one or more literals:\ndef http_error(status):\nmatch status:\ncase 400:\nreturn \"Bad request\"\ncase 404:\nreturn \"Not found\"\ncase 418:\nreturn \"I'm a teapot\"\ncase _:\nreturn \"Something's wrong with the internet\"\nNote the last block: the âvariable nameâ _ acts as a wildcard and\nnever fails to match. If no case matches, none of the branches is executed.\nYou can combine several literals in a single pattern using | (âorâ):\ncase 401 | 403 | 404:\nreturn \"Not allowed\"\nPatterns can look like unpacking assignments, and can be used to bind\nvariables:\n# point is an (x, y) tuple\nmatch point:\ncase (0, 0):\nprint(\"Origin\")\ncase (0, y):\nprint(f\"Y={y}\")\ncase (x, 0):\nprint(f\"X={x}\")\ncase (x, y):\nprint(f\"X={x}, Y={y}\")\ncase _:\nraise ValueError(\"Not a point\")\nStudy that one carefully!  The first pattern has two literals, and can\nbe thought of as an extension of the literal pattern shown above.  But\nthe next two patterns combine a literal and a variable, and the\nvariable binds a value from the subject (point).  The fourth\npattern captures two values, which makes it conceptually similar to\nthe unpacking assignment (x, y) = point.\nIf you are using classes to structure your data\nyou can use the class name followed by an argument list resembling a\nconstructor, but with the ability to capture attributes into variables:\nclass Point:\ndef __init__(self, x, y):\nself.x = x\nself.y = y\ndef where_is(point):\nmatch point:\ncase Point(x=0, y=0):\nprint(\"Origin\")\ncase Point(x=0, y=y):\nprint(f\"Y={y}\")\ncase Point(x=x, y=0):\nprint(f\"X={x}\")\ncase Point():\nprint(\"Somewhere else\")\ncase _:\nprint(\"Not a point\")\nYou can use positional parameters with some builtin classes that provide an\nordering for their attributes (e.g. dataclasses). You can also define a specific\nposition for attributes in patterns by setting the __match_args__ special\nattribute in your classes. If itâs set to (âxâ, âyâ), the following patterns are all\nequivalent (and all bind the y attribute to the var variable):\nPoint(1, var)\nPoint(1, y=var)\nPoint(x=1, y=var)\nPoint(y=var, x=1)\nA recommended way to read patterns is to look at them as an extended form of what you\nwould put on the left of an assignment, to understand which variables would be set to\nwhat.\nOnly the standalone names (like var above) are assigned to by a match statement.\nDotted names (like foo.bar), attribute names (the x= and y= above) or class names\n(recognized by the â(â¦)â next to them like Point above) are never assigned to.\nPatterns can be arbitrarily nested.  For example, if we have a short\nlist of Points, with __match_args__ added, we could match it like this:\nclass Point:\n__match_args__ = ('x', 'y')\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nmatch points:\ncase []:\nprint(\"No points\")\ncase [Point(0, 0)]:\nprint(\"The origin\")\ncase [Point(x, y)]:\nprint(f\"Single point {x}, {y}\")\ncase [Point(0, y1), Point(0, y2)]:\nprint(f\"Two on the Y axis at {y1}, {y2}\")\ncase _:\nprint(\"Something else\")\nWe can add an if clause to a pattern, known as a âguardâ.  If the\nguard is false, match goes on to try the next case block.  Note\nthat value capture happens before the guard is evaluated:\nmatch point:\ncase Point(x, y) if x == y:\nprint(f\"Y=X at {x}\")\ncase Point(x, y):\nprint(f\"Not on the diagonal\")\nSeveral other key features of this statement:\nLike unpacking assignments, tuple and list patterns have exactly the\nsame meaning and actually match arbitrary sequences.  An important\nexception is that they donât match iterators or strings.\nSequence patterns support extended unpacking: [x, y, *rest] and (x, y,\n*rest) work similar to unpacking assignments.  The\nname after * may also be _, so (x, y, *_) matches a sequence\nof at least two items without binding the remaining items."
      },
      {
        "chunk_id": "python_docs_control_flow_chunk_3",
        "original_index": 3,
        "content": "*rest) work similar to unpacking assignments.  The\nname after * may also be _, so (x, y, *_) matches a sequence\nof at least two items without binding the remaining items.\nMapping patterns: {\"bandwidth\": b, \"latency\": l} captures the\n\"bandwidth\" and \"latency\" values from a dictionary.  Unlike sequence\npatterns, extra keys are ignored.  An unpacking like **rest is also\nsupported.  (But **_ would be redundant, so it is not allowed.)\nSubpatterns may be captured using the as keyword:\ncase (Point(x1, y1), Point(x2, y2) as p2): ...\nwill capture the second element of the input as p2 (as long as the input is\na sequence of two points)\nMost literals are compared by equality, however the singletons True,\nFalse and None are compared by identity.\nPatterns may use named constants.  These must be dotted names\nto prevent them from being interpreted as capture variable:\nfrom enum import Enum\nclass Color(Enum):\nRED = 'red'\nGREEN = 'green'\nBLUE = 'blue'\ncolor = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\nmatch color:\ncase Color.RED:\nprint(\"I see red!\")\ncase Color.GREEN:\nprint(\"Grass is green\")\ncase Color.BLUE:\nprint(\"I'm feeling the blues :(\")\nFor a more detailed explanation and additional examples, you can look into\nPEP 636 which is written in a tutorial format.\n4.8. Defining FunctionsÂ¶\nWe can create a function that writes the Fibonacci series to an arbitrary\nboundary:\n>>> def fib(n):    # write Fibonacci series less than n\n...     \"\"\"Print a Fibonacci series less than n.\"\"\"\n...     a, b = 0, 1\n...     while a < n:\n...         print(a, end=' ')\n...         a, b = b, a+b\n...     print()\n...\n>>> # Now call the function we just defined:\n>>> fib(2000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\nThe keyword def introduces a function definition.  It must be\nfollowed by the function name and the parenthesized list of formal parameters.\nThe statements that form the body of the function start at the next line, and\nmust be indented.\nThe first statement of the function body can optionally be a string literal;\nthis string literal is the functionâs documentation string, or docstring.\n(More about docstrings can be found in the section Documentation Strings.)\nThere are tools which use docstrings to automatically produce online or printed\ndocumentation, or to let the user interactively browse through code; itâs good\npractice to include docstrings in code that you write, so make a habit of it.\nThe execution of a function introduces a new symbol table used for the local\nvariables of the function.  More precisely, all variable assignments in a\nfunction store the value in the local symbol table; whereas variable references\nfirst look in the local symbol table, then in the local symbol tables of\nenclosing functions, then in the global symbol table, and finally in the table\nof built-in names. Thus, global variables and variables of enclosing functions\ncannot be directly assigned a value within a function (unless, for global\nvariables, named in a global statement, or, for variables of enclosing\nfunctions, named in a nonlocal statement), although they may be\nreferenced.\nThe actual parameters (arguments) to a function call are introduced in the local\nsymbol table of the called function when it is called; thus, arguments are\npassed using call by value (where the value is always an object reference,\nnot the value of the object). [1] When a function calls another function,\nor calls itself recursively, a new\nlocal symbol table is created for that call.\nA function definition associates the function name with the function object in\nthe current symbol table.  The interpreter recognizes the object pointed to by\nthat name as a user-defined function.  Other names can also point to that same\nfunction object and can also be used to access the function:\n>>> fib\n<function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\nComing from other languages, you might object that fib is not a function but"
      },
      {
        "chunk_id": "python_docs_control_flow_chunk_4",
        "original_index": 4,
        "content": ">>> fib\n<function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\nComing from other languages, you might object that fib is not a function but\na procedure since it doesnât return a value.  In fact, even functions without a\nreturn statement do return a value, albeit a rather boring one.  This\nvalue is called None (itâs a built-in name).  Writing the value None is\nnormally suppressed by the interpreter if it would be the only value written.\nYou can see it if you really want to using print():\n>>> fib(0)\n>>> print(fib(0))\nNone\nIt is simple to write a function that returns a list of the numbers of the\nFibonacci series, instead of printing it:\n>>> def fib2(n):  # return Fibonacci series up to n\n...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n...     result = []\n...     a, b = 0, 1\n...     while a < n:\n...         result.append(a)    # see below\n...         a, b = b, a+b\n...     return result\n...\n>>> f100 = fib2(100)    # call it\n>>> f100                # write the result\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\nThis example, as usual, demonstrates some new Python features:\nThe return statement returns with a value from a function.\nreturn without an expression argument returns None. Falling off\nthe end of a function also returns None.\nThe statement result.append(a) calls a method of the list object\nresult.  A method is a function that âbelongsâ to an object and is named\nobj.methodname, where obj is some object (this may be an expression),\nand methodname is the name of a method that is defined by the objectâs type.\nDifferent types define different methods.  Methods of different types may have\nthe same name without causing ambiguity.  (It is possible to define your own\nobject types and methods, using classes, see Classes)\nThe method append() shown in the example is defined for list objects; it\nadds a new element at the end of the list.  In this example it is equivalent to\nresult = result + [a], but more efficient.\n4.9. More on Defining FunctionsÂ¶\nIt is also possible to define functions with a variable number of arguments.\nThere are three forms, which can be combined.\n4.9.1. Default Argument ValuesÂ¶\nThe most useful form is to specify a default value for one or more arguments.\nThis creates a function that can be called with fewer arguments than it is\ndefined to allow.  For example:\ndef ask_ok(prompt, retries=4, reminder='Please try again!'):\nwhile True:\nreply = input(prompt)\nif reply in {'y', 'ye', 'yes'}:\nreturn True\nif reply in {'n', 'no', 'nop', 'nope'}:\nreturn False\nretries = retries - 1\nif retries < 0:\nraise ValueError('invalid user response')\nprint(reminder)\nThis function can be called in several ways:\ngiving only the mandatory argument:\nask_ok('Do you really want to quit?')\ngiving one of the optional arguments:\nask_ok('OK to overwrite the file?', 2)\nor even giving all arguments:\nask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')\nThis example also introduces the in keyword. This tests whether or\nnot a sequence contains a certain value.\nThe default values are evaluated at the point of function definition in the\ndefining scope, so that\ni = 5\ndef f(arg=i):\nprint(arg)\ni = 6\nf()\nwill print 5.\nImportant warning:  The default value is evaluated only once. This makes a\ndifference when the default is a mutable object such as a list, dictionary, or\ninstances of most classes.  For example, the following function accumulates the\narguments passed to it on subsequent calls:\ndef f(a, L=[]):\nL.append(a)\nreturn L\nprint(f(1))\nprint(f(2))\nprint(f(3))\nThis will print\n[1]\n[1, 2]\n[1, 2, 3]\nIf you donât want the default to be shared between subsequent calls, you can\nwrite the function like this instead:\ndef f(a, L=None):\nif L is None:\nL = []\nL.append(a)\nreturn L\n4.9.2. Keyword ArgumentsÂ¶\nFunctions can also be called using keyword arguments\nof the form kwarg=value.  For instance, the following function:\ndef parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):"
      },
      {
        "chunk_id": "python_docs_control_flow_chunk_5",
        "original_index": 5,
        "content": "Functions can also be called using keyword arguments\nof the form kwarg=value.  For instance, the following function:\ndef parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\nprint(\"-- This parrot wouldn't\", action, end=' ')\nprint(\"if you put\", voltage, \"volts through it.\")\nprint(\"-- Lovely plumage, the\", type)\nprint(\"-- It's\", state, \"!\")\naccepts one required argument (voltage) and three optional arguments\n(state, action, and type).  This function can be called in any\nof the following ways:\nparrot(1000)                                          # 1 positional argument\nparrot(voltage=1000)                                  # 1 keyword argument\nparrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\nparrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\nparrot('a million', 'bereft of life', 'jump')         # 3 positional arguments\nparrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword\nbut all the following calls would be invalid:\nparrot()                     # required argument missing\nparrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument\nparrot(110, voltage=220)     # duplicate value for the same argument\nparrot(actor='John Cleese')  # unknown keyword argument\nIn a function call, keyword arguments must follow positional arguments.\nAll the keyword arguments passed must match one of the arguments\naccepted by the function (e.g. actor is not a valid argument for the\nparrot function), and their order is not important.  This also includes\nnon-optional arguments (e.g. parrot(voltage=1000) is valid too).\nNo argument may receive a value more than once.\nHereâs an example that fails due to this restriction:\n>>> def function(a):\n...     pass\n...\n>>> function(0, a=0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: function() got multiple values for argument 'a'\nWhen a final formal parameter of the form **name is present, it receives a\ndictionary (see Mapping Types â dict) containing all keyword arguments except for\nthose corresponding to a formal parameter.  This may be combined with a formal\nparameter of the form *name (described in the next subsection) which\nreceives a tuple containing the positional\narguments beyond the formal parameter list.  (*name must occur\nbefore **name.) For example, if we define a function like this:\ndef cheeseshop(kind, *arguments, **keywords):\nprint(\"-- Do you have any\", kind, \"?\")\nprint(\"-- I'm sorry, we're all out of\", kind)\nfor arg in arguments:\nprint(arg)\nprint(\"-\" * 40)\nfor kw in keywords:\nprint(kw, \":\", keywords[kw])\nIt could be called like this:\ncheeseshop(\"Limburger\", \"It's very runny, sir.\",\n\"It's really very, VERY runny, sir.\",\nshopkeeper=\"Michael Palin\",\nclient=\"John Cleese\",\nsketch=\"Cheese Shop Sketch\")\nand of course it would print:\n-- Do you have any Limburger ?\n-- I'm sorry, we're all out of Limburger\nIt's very runny, sir.\nIt's really very, VERY runny, sir.\n----------------------------------------\nshopkeeper : Michael Palin\nclient : John Cleese\nsketch : Cheese Shop Sketch\nNote that the order in which the keyword arguments are printed is guaranteed\nto match the order in which they were provided in the function call.\n4.9.3. Special parametersÂ¶\nBy default, arguments may be passed to a Python function either by position\nor explicitly by keyword. For readability and performance, it makes sense to\nrestrict the way arguments can be passed so that a developer need only look\nat the function definition to determine if items are passed by position, by\nposition or keyword, or by keyword.\nA function definition may look like:\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n-----------    ----------     ----------\n|             |                  |\n|        Positional or keyword   |\n|                                - Keyword only\n-- Positional only\nwhere / and * are optional. If used, these symbols indicate the kind of"
      },
      {
        "chunk_id": "python_docs_control_flow_chunk_6",
        "original_index": 6,
        "content": "|        Positional or keyword   |\n|                                - Keyword only\n-- Positional only\nwhere / and * are optional. If used, these symbols indicate the kind of\nparameter by how the arguments may be passed to the function:\npositional-only, positional-or-keyword, and keyword-only. Keyword parameters\nare also referred to as named parameters.\n4.9.3.1. Positional-or-Keyword ArgumentsÂ¶\nIf / and * are not present in the function definition, arguments may\nbe passed to a function by position or by keyword.\n4.9.3.2. Positional-Only ParametersÂ¶\nLooking at this in a bit more detail, it is possible to mark certain parameters\nas positional-only. If positional-only, the parametersâ order matters, and\nthe parameters cannot be passed by keyword. Positional-only parameters are\nplaced before a / (forward-slash). The / is used to logically\nseparate the positional-only parameters from the rest of the parameters.\nIf there is no / in the function definition, there are no positional-only\nparameters.\nParameters following the / may be positional-or-keyword or keyword-only.\n4.9.3.3. Keyword-Only ArgumentsÂ¶\nTo mark parameters as keyword-only, indicating the parameters must be passed\nby keyword argument, place an * in the arguments list just before the first\nkeyword-only parameter.\n4.9.3.4. Function ExamplesÂ¶\nConsider the following example function definitions paying close attention to the\nmarkers / and *:\n>>> def standard_arg(arg):\n...     print(arg)\n...\n>>> def pos_only_arg(arg, /):\n...     print(arg)\n...\n>>> def kwd_only_arg(*, arg):\n...     print(arg)\n...\n>>> def combined_example(pos_only, /, standard, *, kwd_only):\n...     print(pos_only, standard, kwd_only)\nThe first function definition, standard_arg, the most familiar form,\nplaces no restrictions on the calling convention and arguments may be\npassed by position or keyword:\n>>> standard_arg(2)\n2\n>>> standard_arg(arg=2)\n2\nThe second function pos_only_arg is restricted to only use positional\nparameters as there is a / in the function definition:\n>>> pos_only_arg(1)\n1\n>>> pos_only_arg(arg=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'\nThe third function kwd_only_arg only allows keyword arguments as indicated\nby a * in the function definition:\n>>> kwd_only_arg(3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n>>> kwd_only_arg(arg=3)\n3\nAnd the last uses all three calling conventions in the same function\ndefinition:\n>>> combined_example(1, 2, 3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() takes 2 positional arguments but 3 were given\n>>> combined_example(1, 2, kwd_only=3)\n1 2 3\n>>> combined_example(1, standard=2, kwd_only=3)\n1 2 3\n>>> combined_example(pos_only=1, standard=2, kwd_only=3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'\nFinally, consider this function definition which has a potential collision between the positional argument name  and **kwds which has name as a key:\ndef foo(name, **kwds):\nreturn 'name' in kwds\nThere is no possible call that will make it return True as the keyword 'name'\nwill always bind to the first parameter. For example:\n>>> foo(1, **{'name': 2})\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: foo() got multiple values for argument 'name'\n>>>\nBut using / (positional only arguments), it is possible since it allows name as a positional argument and 'name' as a key in the keyword arguments:\n>>> def foo(name, /, **kwds):\n...     return 'name' in kwds\n...\n>>> foo(1, **{'name': 2})\nTrue\nIn other words, the names of positional-only parameters can be used in\n**kwds without ambiguity.\n4.9.3.5. RecapÂ¶"
      },
      {
        "chunk_id": "python_docs_control_flow_chunk_7",
        "original_index": 7,
        "content": "...     return 'name' in kwds\n...\n>>> foo(1, **{'name': 2})\nTrue\nIn other words, the names of positional-only parameters can be used in\n**kwds without ambiguity.\n4.9.3.5. RecapÂ¶\nThe use case will determine which parameters to use in the function definition:\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\nAs guidance:\nUse positional-only if you want the name of the parameters to not be\navailable to the user. This is useful when parameter names have no real\nmeaning, if you want to enforce the order of the arguments when the function\nis called or if you need to take some positional parameters and arbitrary\nkeywords.\nUse keyword-only when names have meaning and the function definition is\nmore understandable by being explicit with names or you want to prevent\nusers relying on the position of the argument being passed.\nFor an API, use positional-only to prevent breaking API changes\nif the parameterâs name is modified in the future.\n4.9.4. Arbitrary Argument ListsÂ¶\nFinally, the least frequently used option is to specify that a function can be\ncalled with an arbitrary number of arguments.  These arguments will be wrapped\nup in a tuple (see Tuples and Sequences).  Before the variable number of arguments,\nzero or more normal arguments may occur.\ndef write_multiple_items(file, separator, *args):\nfile.write(separator.join(args))\nNormally, these variadic arguments will be last in the list of formal\nparameters, because they scoop up all remaining input arguments that are\npassed to the function. Any formal parameters which occur after the *args\nparameter are âkeyword-onlyâ arguments, meaning that they can only be used as\nkeywords rather than positional arguments.\n>>> def concat(*args, sep=\"/\"):\n...     return sep.join(args)\n...\n>>> concat(\"earth\", \"mars\", \"venus\")\n'earth/mars/venus'\n>>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n'earth.mars.venus'\n4.9.5. Unpacking Argument ListsÂ¶\nThe reverse situation occurs when the arguments are already in a list or tuple\nbut need to be unpacked for a function call requiring separate positional\narguments.  For instance, the built-in range() function expects separate\nstart and stop arguments.  If they are not available separately, write the\nfunction call with the  *-operator to unpack the arguments out of a list\nor tuple:\n>>> list(range(3, 6))            # normal call with separate arguments\n[3, 4, 5]\n>>> args = [3, 6]\n>>> list(range(*args))            # call with arguments unpacked from a list\n[3, 4, 5]\nIn the same fashion, dictionaries can deliver keyword arguments with the\n**-operator:\n>>> def parrot(voltage, state='a stiff', action='voom'):\n...     print(\"-- This parrot wouldn't\", action, end=' ')\n...     print(\"if you put\", voltage, \"volts through it.\", end=' ')\n...     print(\"E's\", state, \"!\")\n...\n>>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n>>> parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !\n4.9.6. Lambda ExpressionsÂ¶\nSmall anonymous functions can be created with the lambda keyword.\nThis function returns the sum of its two arguments: lambda a, b: a+b.\nLambda functions can be used wherever function objects are required.  They are\nsyntactically restricted to a single expression.  Semantically, they are just\nsyntactic sugar for a normal function definition.  Like nested function\ndefinitions, lambda functions can reference variables from the containing\nscope:\n>>> def make_incrementor(n):\n...     return lambda x: x + n\n...\n>>> f = make_incrementor(42)\n>>> f(0)\n42\n>>> f(1)\n43\nThe above example uses a lambda expression to return a function.  Another use\nis to pass a small function as an argument:\n>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n>>> pairs.sort(key=lambda pair: pair[1])\n>>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n4.9.7. Documentation StringsÂ¶\nHere are some conventions about the content and formatting of documentation\nstrings."
      },
      {
        "chunk_id": "python_docs_control_flow_chunk_8",
        "original_index": 8,
        "content": ">>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n4.9.7. Documentation StringsÂ¶\nHere are some conventions about the content and formatting of documentation\nstrings.\nThe first line should always be a short, concise summary of the objectâs\npurpose.  For brevity, it should not explicitly state the objectâs name or type,\nsince these are available by other means (except if the name happens to be a\nverb describing a functionâs operation).  This line should begin with a capital\nletter and end with a period.\nIf there are more lines in the documentation string, the second line should be\nblank, visually separating the summary from the rest of the description.  The\nfollowing lines should be one or more paragraphs describing the objectâs calling\nconventions, its side effects, etc.\nThe Python parser does not strip indentation from multi-line string literals in\nPython, so tools that process documentation have to strip indentation if\ndesired.  This is done using the following convention. The first non-blank line\nafter the first line of the string determines the amount of indentation for\nthe entire documentation string.  (We canât use the first line since it is\ngenerally adjacent to the stringâs opening quotes so its indentation is not\napparent in the string literal.)  Whitespace âequivalentâ to this indentation is\nthen stripped from the start of all lines of the string.  Lines that are\nindented less should not occur, but if they occur all their leading whitespace\nshould be stripped.  Equivalence of whitespace should be tested after expansion\nof tabs (to 8 spaces, normally).\nHere is an example of a multi-line docstring:\n>>> def my_function():\n...     \"\"\"Do nothing, but document it.\n...\n...     No, really, it doesn't do anything.\n...     \"\"\"\n...     pass\n...\n>>> print(my_function.__doc__)\nDo nothing, but document it.\nNo, really, it doesn't do anything.\n4.9.8. Function AnnotationsÂ¶\nFunction annotations are completely optional metadata\ninformation about the types used by user-defined functions (see PEP 3107 and\nPEP 484 for more information).\nAnnotations are stored in the __annotations__\nattribute of the function as a dictionary and have no effect on any other part of the\nfunction.  Parameter annotations are defined by a colon after the parameter name, followed\nby an expression evaluating to the value of the annotation.  Return annotations are\ndefined by a literal ->, followed by an expression, between the parameter\nlist and the colon denoting the end of the def statement.  The\nfollowing example has a required argument, an optional argument, and the return\nvalue annotated:\n>>> def f(ham: str, eggs: str = 'eggs') -> str:\n...     print(\"Annotations:\", f.__annotations__)\n...     print(\"Arguments:\", ham, eggs)\n...     return ham + ' and ' + eggs\n...\n>>> f('spam')\nAnnotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}\nArguments: spam eggs\n'spam and eggs'\n4.10. Intermezzo: Coding StyleÂ¶\nNow that you are about to write longer, more complex pieces of Python, it is a\ngood time to talk about coding style.  Most languages can be written (or more\nconcise, formatted) in different styles; some are more readable than others.\nMaking it easy for others to read your code is always a good idea, and adopting\na nice coding style helps tremendously for that.\nFor Python, PEP 8 has emerged as the style guide that most projects adhere to;\nit promotes a very readable and eye-pleasing coding style.  Every Python\ndeveloper should read it at some point; here are the most important points\nextracted for you:\nUse 4-space indentation, and no tabs.\n4 spaces are a good compromise between small indentation (allows greater\nnesting depth) and large indentation (easier to read).  Tabs introduce\nconfusion, and are best left out.\nWrap lines so that they donât exceed 79 characters.\nThis helps users with small displays and makes it possible to have several\ncode files side-by-side on larger displays."
      },
      {
        "chunk_id": "python_docs_control_flow_chunk_9",
        "original_index": 9,
        "content": "Wrap lines so that they donât exceed 79 characters.\nThis helps users with small displays and makes it possible to have several\ncode files side-by-side on larger displays.\nUse blank lines to separate functions and classes, and larger blocks of\ncode inside functions.\nWhen possible, put comments on a line of their own.\nUse docstrings.\nUse spaces around operators and after commas, but not directly inside\nbracketing constructs: a = f(1, 2) + g(3, 4).\nName your classes and functions consistently; the convention is to use\nUpperCamelCase for classes and lowercase_with_underscores for functions\nand methods.  Always use self as the name for the first method argument\n(see A First Look at Classes for more on classes and methods).\nDonât use fancy encodings if your code is meant to be used in international\nenvironments.  Pythonâs default, UTF-8, or even plain ASCII work best in any\ncase.\nLikewise, donât use non-ASCII characters in identifiers if there is only the\nslightest chance people speaking a different language will read or maintain\nthe code.\nFootnotes\n[1]\nActually, call by object reference would be a better description,\nsince if a mutable object is passed, the caller will see any changes the\ncallee makes to it (items inserted into a list)."
      }
    ]
  },
  {
    "doc_id": "python_docs_errors",
    "original_uuid": "cda8",
    "content": "8. Errors and ExceptionsÂ¶\nUntil now error messages havenât been more than mentioned, but if you have tried\nout the examples you have probably seen some.  There are (at least) two\ndistinguishable kinds of errors: syntax errors and exceptions.\n8.1. Syntax ErrorsÂ¶\nSyntax errors, also known as parsing errors, are perhaps the most common kind of\ncomplaint you get while you are still learning Python:\n>>> while True print('Hello world')\nFile \"<stdin>\", line 1\nwhile True print('Hello world')\n^^^^^\nSyntaxError: invalid syntax\nThe parser repeats the offending line and displays little âarrowâs pointing\nat the token in the line where the error was detected.  The error may be\ncaused by the absence of a token before the indicated token.  In the\nexample, the error is detected at the function print(), since a colon\n(':') is missing before it.  File name and line number are printed so you\nknow where to look in case the input came from a script.\n8.2. ExceptionsÂ¶\nEven if a statement or expression is syntactically correct, it may cause an\nerror when an attempt is made to execute it. Errors detected during execution\nare called exceptions and are not unconditionally fatal: you will soon learn\nhow to handle them in Python programs.  Most exceptions are not handled by\nprograms, however, and result in error messages as shown here:\n>>> 10 * (1/0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nZeroDivisionError: division by zero\n>>> 4 + spam*3\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'spam' is not defined\n>>> '2' + 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate str (not \"int\") to str\nThe last line of the error message indicates what happened. Exceptions come in\ndifferent types, and the type is printed as part of the message: the types in\nthe example are ZeroDivisionError, NameError and TypeError.\nThe string printed as the exception type is the name of the built-in exception\nthat occurred.  This is true for all built-in exceptions, but need not be true\nfor user-defined exceptions (although it is a useful convention). Standard\nexception names are built-in identifiers (not reserved keywords).\nThe rest of the line provides detail based on the type of exception and what\ncaused it.\nThe preceding part of the error message shows the context where the exception\noccurred, in the form of a stack traceback. In general it contains a stack\ntraceback listing source lines; however, it will not display lines read from\nstandard input.\nBuilt-in Exceptions lists the built-in exceptions and their meanings.\n8.3. Handling ExceptionsÂ¶\nIt is possible to write programs that handle selected exceptions. Look at the\nfollowing example, which asks the user for input until a valid integer has been\nentered, but allows the user to interrupt the program (using Control-C or\nwhatever the operating system supports); note that a user-generated interruption\nis signalled by raising the KeyboardInterrupt exception.\n>>> while True:\n...     try:\n...         x = int(input(\"Please enter a number: \"))\n...         break\n...     except ValueError:\n...         print(\"Oops!  That was no valid number.  Try again...\")\n...\nThe try statement works as follows.\nFirst, the try clause (the statement(s) between the try and\nexcept keywords) is executed.\nIf no exception occurs, the except clause is skipped and execution of the\ntry statement is finished.\nIf an exception occurs during execution of the try clause, the rest of the\nclause is skipped.  Then, if its type matches the exception named after the\nexcept keyword, the except clause is executed, and then execution\ncontinues after the try/except block.\nIf an exception occurs which does not match the exception named in the except\nclause, it is passed on to outer try statements; if no handler is\nfound, it is an unhandled exception and execution stops with an error message.\nA try statement may have more than one except clause, to specify\nhandlers for different exceptions.  At most one handler will be executed.\nHandlers only handle exceptions that occur in the corresponding try clause,\nnot in other handlers of the same try statement.  An except clause\nmay name multiple exceptions as a parenthesized tuple, for example:\n... except (RuntimeError, TypeError, NameError):\n...     pass\nA class in an except clause matches exceptions which are instances of the\nclass itself or one of its derived classes (but not the other way around â an\nexcept clause listing a derived class does not match instances of its base classes).\nFor example, the following code will print B, C, D in that order:\nclass B(Exception):\npass\nclass C(B):\npass\nclass D(C):\npass\nfor cls in [B, C, D]:\ntry:\nraise cls()\nexcept D:\nprint(\"D\")\nexcept C:\nprint(\"C\")\nexcept B:\nprint(\"B\")\nNote that if the except clauses were reversed (with except B first), it\nwould have printed B, B, B â the first matching except clause is triggered.\nWhen an exception occurs, it may have associated values, also known as the\nexceptionâs arguments. The presence and types of the arguments depend on the\nexception type.\nThe except clause may specify a variable after the exception name.  The\nvariable is bound to the exception instance which typically has an args\nattribute that stores the arguments. For convenience, builtin exception\ntypes define __str__() to print all the arguments without explicitly\naccessing .args.\n>>> try:\n...     raise Exception('spam', 'eggs')\n... except Exception as inst:\n...     print(type(inst))    # the exception type\n...     print(inst.args)     # arguments stored in .args\n...     print(inst)          # __str__ allows args to be printed directly,\n...                          # but may be overridden in exception subclasses\n...     x, y = inst.args     # unpack args\n...     print('x =', x)\n...     print('y =', y)\n...\n<class 'Exception'>\n('spam', 'eggs')\n('spam', 'eggs')\nx = spam\ny = eggs\nThe exceptionâs __str__() output is printed as the last part (âdetailâ)\nof the message for unhandled exceptions.\nBaseException is the common base class of all exceptions. One of its\nsubclasses, Exception, is the base class of all the non-fatal exceptions.\nExceptions which are not subclasses of Exception are not typically\nhandled, because they are used to indicate that the program should terminate.\nThey include SystemExit which is raised by sys.exit() and\nKeyboardInterrupt which is raised when a user wishes to interrupt\nthe program.\nException can be used as a wildcard that catches (almost) everything.\nHowever, it is good practice to be as specific as possible with the types\nof exceptions that we intend to handle, and to allow any unexpected\nexceptions to propagate on.\nThe most common pattern for handling Exception is to print or log\nthe exception and then re-raise it (allowing a caller to handle the\nexception as well):\nimport sys\ntry:\nf = open('myfile.txt')\ns = f.readline()\ni = int(s.strip())\nexcept OSError as err:\nprint(\"OS error:\", err)\nexcept ValueError:\nprint(\"Could not convert data to an integer.\")\nexcept Exception as err:\nprint(f\"Unexpected {err=}, {type(err)=}\")\nraise\nThe try â¦ except statement has an optional else\nclause, which, when present, must follow all except clauses.  It is useful\nfor code that must be executed if the try clause does not raise an exception.\nFor example:\nfor arg in sys.argv[1:]:\ntry:\nf = open(arg, 'r')\nexcept OSError:\nprint('cannot open', arg)\nelse:\nprint(arg, 'has', len(f.readlines()), 'lines')\nf.close()\nThe use of the else clause is better than adding additional code to\nthe try clause because it avoids accidentally catching an exception\nthat wasnât raised by the code being protected by the try â¦\nexcept statement.\nException handlers do not handle only exceptions that occur immediately in the\ntry clause, but also those that occur inside functions that are called (even\nindirectly) in the try clause. For example:\n>>> def this_fails():\n...     x = 1/0\n...\n>>> try:\n...     this_fails()\n... except ZeroDivisionError as err:\n...     print('Handling run-time error:', err)\n...\nHandling run-time error: division by zero\n8.4. Raising ExceptionsÂ¶\nThe raise statement allows the programmer to force a specified\nexception to occur. For example:\n>>> raise NameError('HiThere')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: HiThere\nThe sole argument to raise indicates the exception to be raised.\nThis must be either an exception instance or an exception class (a class that\nderives from BaseException, such as Exception or one of its\nsubclasses).  If an exception class is passed, it will be implicitly\ninstantiated by calling its constructor with no arguments:\nraise ValueError  # shorthand for 'raise ValueError()'\nIf you need to determine whether an exception was raised but donât intend to\nhandle it, a simpler form of the raise statement allows you to\nre-raise the exception:\n>>> try:\n...     raise NameError('HiThere')\n... except NameError:\n...     print('An exception flew by!')\n...     raise\n...\nAn exception flew by!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nNameError: HiThere\n8.5. Exception ChainingÂ¶\nIf an unhandled exception occurs inside an except section, it will\nhave the exception being handled attached to it and included in the error\nmessage:\n>>> try:\n...     open(\"database.sqlite\")\n... except OSError:\n...     raise RuntimeError(\"unable to handle error\")\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nFileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: unable to handle error\nTo indicate that an exception is a direct consequence of another, the\nraise statement allows an optional from clause:\n# exc must be exception instance or None.\nraise RuntimeError from exc\nThis can be useful when you are transforming exceptions. For example:\n>>> def func():\n...     raise ConnectionError\n...\n>>> try:\n...     func()\n... except ConnectionError as exc:\n...     raise RuntimeError('Failed to open database') from exc\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nFile \"<stdin>\", line 2, in func\nConnectionError\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: Failed to open database\nIt also allows disabling automatic exception chaining using the from None\nidiom:\n>>> try:\n...     open('database.sqlite')\n... except OSError:\n...     raise RuntimeError from None\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError\nFor more information about chaining mechanics, see Built-in Exceptions.\n8.6. User-defined ExceptionsÂ¶\nPrograms may name their own exceptions by creating a new exception class (see\nClasses for more about Python classes).  Exceptions should typically\nbe derived from the Exception class, either directly or indirectly.\nException classes can be defined which do anything any other class can do, but\nare usually kept simple, often only offering a number of attributes that allow\ninformation about the error to be extracted by handlers for the exception.\nMost exceptions are defined with names that end in âErrorâ, similar to the\nnaming of the standard exceptions.\nMany standard modules define their own exceptions to report errors that may\noccur in functions they define.\n8.7. Defining Clean-up ActionsÂ¶\nThe try statement has another optional clause which is intended to\ndefine clean-up actions that must be executed under all circumstances.  For\nexample:\n>>> try:\n...     raise KeyboardInterrupt\n... finally:\n...     print('Goodbye, world!')\n...\nGoodbye, world!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nKeyboardInterrupt\nIf a finally clause is present, the finally\nclause will execute as the last task before the try\nstatement completes. The finally clause runs whether or\nnot the try statement produces an exception. The following\npoints discuss more complex cases when an exception occurs:\nIf an exception occurs during execution of the try\nclause, the exception may be handled by an except\nclause. If the exception is not handled by an except\nclause, the exception is re-raised after the finally\nclause has been executed.\nAn exception could occur during execution of an except\nor else clause. Again, the exception is re-raised after\nthe finally clause has been executed.\nIf the finally clause executes a break,\ncontinue or return statement, exceptions are not\nre-raised.\nIf the try statement reaches a break,\ncontinue or return statement, the\nfinally clause will execute just prior to the\nbreak, continue or return\nstatementâs execution.\nIf a finally clause includes a return\nstatement, the returned value will be the one from the\nfinally clauseâs return statement, not the\nvalue from the try clauseâs return\nstatement.\nFor example:\n>>> def bool_return():\n...     try:\n...         return True\n...     finally:\n...         return False\n...\n>>> bool_return()\nFalse\nA more complicated example:\n>>> def divide(x, y):\n...     try:\n...         result = x / y\n...     except ZeroDivisionError:\n...         print(\"division by zero!\")\n...     else:\n...         print(\"result is\", result)\n...     finally:\n...         print(\"executing finally clause\")\n...\n>>> divide(2, 1)\nresult is 2.0\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 3, in divide\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\nAs you can see, the finally clause is executed in any event.  The\nTypeError raised by dividing two strings is not handled by the\nexcept clause and therefore re-raised after the finally\nclause has been executed.\nIn real world applications, the finally clause is useful for\nreleasing external resources (such as files or network connections), regardless\nof whether the use of the resource was successful.\n8.8. Predefined Clean-up ActionsÂ¶\nSome objects define standard clean-up actions to be undertaken when the object\nis no longer needed, regardless of whether or not the operation using the object\nsucceeded or failed. Look at the following example, which tries to open a file\nand print its contents to the screen.\nfor line in open(\"myfile.txt\"):\nprint(line, end=\"\")\nThe problem with this code is that it leaves the file open for an indeterminate\namount of time after this part of the code has finished executing.\nThis is not an issue in simple scripts, but can be a problem for larger\napplications. The with statement allows objects like files to be\nused in a way that ensures they are always cleaned up promptly and correctly.\nwith open(\"myfile.txt\") as f:\nfor line in f:\nprint(line, end=\"\")\nAfter the statement is executed, the file f is always closed, even if a\nproblem was encountered while processing the lines. Objects which, like files,\nprovide predefined clean-up actions will indicate this in their documentation.\n8.9. Raising and Handling Multiple Unrelated ExceptionsÂ¶\nThere are situations where it is necessary to report several exceptions that\nhave occurred. This is often the case in concurrency frameworks, when several\ntasks may have failed in parallel, but there are also other use cases where\nit is desirable to continue execution and collect multiple errors rather than\nraise the first exception.\nThe builtin ExceptionGroup wraps a list of exception instances so\nthat they can be raised together. It is an exception itself, so it can be\ncaught like any other exception.\n>>> def f():\n...     excs = [OSError('error 1'), SystemError('error 2')]\n...     raise ExceptionGroup('there were problems', excs)\n...\n>>> f()\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 1, in <module>\n|   File \"<stdin>\", line 3, in f\n| ExceptionGroup: there were problems\n+-+---------------- 1 ----------------\n| OSError: error 1\n+---------------- 2 ----------------\n| SystemError: error 2\n+------------------------------------\n>>> try:\n...     f()\n... except Exception as e:\n...     print(f'caught {type(e)}: e')\n...\ncaught <class 'ExceptionGroup'>: e\n>>>\nBy using except* instead of except, we can selectively\nhandle only the exceptions in the group that match a certain\ntype. In the following example, which shows a nested exception\ngroup, each except* clause extracts from the group exceptions\nof a certain type while letting all other exceptions propagate to\nother clauses and eventually to be reraised.\n>>> def f():\n...     raise ExceptionGroup(\n...         \"group1\",\n...         [\n...             OSError(1),\n...             SystemError(2),\n...             ExceptionGroup(\n...                 \"group2\",\n...                 [\n...                     OSError(3),\n...                     RecursionError(4)\n...                 ]\n...             )\n...         ]\n...     )\n...\n>>> try:\n...     f()\n... except* OSError as e:\n...     print(\"There were OSErrors\")\n... except* SystemError as e:\n...     print(\"There were SystemErrors\")\n...\nThere were OSErrors\nThere were SystemErrors\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 2, in <module>\n|   File \"<stdin>\", line 2, in f\n| ExceptionGroup: group1\n+-+---------------- 1 ----------------\n| ExceptionGroup: group2\n+-+---------------- 1 ----------------\n| RecursionError: 4\n+------------------------------------\n>>>\nNote that the exceptions nested in an exception group must be instances,\nnot types. This is because in practice the exceptions would typically\nbe ones that have already been raised and caught by the program, along\nthe following pattern:\n>>> excs = []\n... for test in tests:\n...     try:\n...         test.run()\n...     except Exception as e:\n...         excs.append(e)\n...\n>>> if excs:\n...    raise ExceptionGroup(\"Test Failures\", excs)\n...\n8.10. Enriching Exceptions with NotesÂ¶\nWhen an exception is created in order to be raised, it is usually initialized\nwith information that describes the error that has occurred. There are cases\nwhere it is useful to add information after the exception was caught. For this\npurpose, exceptions have a method add_note(note) that accepts a string and\nadds it to the exceptionâs notes list. The standard traceback rendering\nincludes all notes, in the order they were added, after the exception.\n>>> try:\n...     raise TypeError('bad type')\n... except Exception as e:\n...     e.add_note('Add some information')\n...     e.add_note('Add some more information')\n...     raise\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nTypeError: bad type\nAdd some information\nAdd some more information\n>>>\nFor example, when collecting exceptions into an exception group, we may want\nto add context information for the individual errors. In the following each\nexception in the group has a note indicating when this error has occurred.\n>>> def f():\n...     raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n...     try:\n...         f()\n...     except Exception as e:\n...         e.add_note(f'Happened in Iteration {i+1}')\n...         excs.append(e)\n...\n>>> raise ExceptionGroup('We have some problems', excs)\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 1, in <module>\n| ExceptionGroup: We have some problems (3 sub-exceptions)\n+-+---------------- 1 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 1\n+---------------- 2 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 2\n+---------------- 3 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 3\n+------------------------------------\n>>>",
    "chunks": [
      {
        "chunk_id": "python_docs_errors_chunk_0",
        "original_index": 0,
        "content": "8. Errors and ExceptionsÂ¶\nUntil now error messages havenât been more than mentioned, but if you have tried\nout the examples you have probably seen some.  There are (at least) two\ndistinguishable kinds of errors: syntax errors and exceptions.\n8.1. Syntax ErrorsÂ¶\nSyntax errors, also known as parsing errors, are perhaps the most common kind of\ncomplaint you get while you are still learning Python:\n>>> while True print('Hello world')\nFile \"<stdin>\", line 1\nwhile True print('Hello world')\n^^^^^\nSyntaxError: invalid syntax\nThe parser repeats the offending line and displays little âarrowâs pointing\nat the token in the line where the error was detected.  The error may be\ncaused by the absence of a token before the indicated token.  In the\nexample, the error is detected at the function print(), since a colon\n(':') is missing before it.  File name and line number are printed so you\nknow where to look in case the input came from a script.\n8.2. ExceptionsÂ¶\nEven if a statement or expression is syntactically correct, it may cause an\nerror when an attempt is made to execute it. Errors detected during execution\nare called exceptions and are not unconditionally fatal: you will soon learn\nhow to handle them in Python programs.  Most exceptions are not handled by\nprograms, however, and result in error messages as shown here:\n>>> 10 * (1/0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nZeroDivisionError: division by zero\n>>> 4 + spam*3\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'spam' is not defined\n>>> '2' + 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate str (not \"int\") to str\nThe last line of the error message indicates what happened. Exceptions come in\ndifferent types, and the type is printed as part of the message: the types in\nthe example are ZeroDivisionError, NameError and TypeError.\nThe string printed as the exception type is the name of the built-in exception\nthat occurred.  This is true for all built-in exceptions, but need not be true\nfor user-defined exceptions (although it is a useful convention). Standard\nexception names are built-in identifiers (not reserved keywords).\nThe rest of the line provides detail based on the type of exception and what\ncaused it.\nThe preceding part of the error message shows the context where the exception\noccurred, in the form of a stack traceback. In general it contains a stack\ntraceback listing source lines; however, it will not display lines read from\nstandard input.\nBuilt-in Exceptions lists the built-in exceptions and their meanings.\n8.3. Handling ExceptionsÂ¶\nIt is possible to write programs that handle selected exceptions. Look at the\nfollowing example, which asks the user for input until a valid integer has been\nentered, but allows the user to interrupt the program (using Control-C or\nwhatever the operating system supports); note that a user-generated interruption\nis signalled by raising the KeyboardInterrupt exception.\n>>> while True:\n...     try:\n...         x = int(input(\"Please enter a number: \"))\n...         break\n...     except ValueError:\n...         print(\"Oops!  That was no valid number.  Try again...\")\n...\nThe try statement works as follows.\nFirst, the try clause (the statement(s) between the try and\nexcept keywords) is executed.\nIf no exception occurs, the except clause is skipped and execution of the\ntry statement is finished.\nIf an exception occurs during execution of the try clause, the rest of the\nclause is skipped.  Then, if its type matches the exception named after the\nexcept keyword, the except clause is executed, and then execution\ncontinues after the try/except block.\nIf an exception occurs which does not match the exception named in the except\nclause, it is passed on to outer try statements; if no handler is\nfound, it is an unhandled exception and execution stops with an error message."
      },
      {
        "chunk_id": "python_docs_errors_chunk_1",
        "original_index": 1,
        "content": "clause, it is passed on to outer try statements; if no handler is\nfound, it is an unhandled exception and execution stops with an error message.\nA try statement may have more than one except clause, to specify\nhandlers for different exceptions.  At most one handler will be executed.\nHandlers only handle exceptions that occur in the corresponding try clause,\nnot in other handlers of the same try statement.  An except clause\nmay name multiple exceptions as a parenthesized tuple, for example:\n... except (RuntimeError, TypeError, NameError):\n...     pass\nA class in an except clause matches exceptions which are instances of the\nclass itself or one of its derived classes (but not the other way around â an\nexcept clause listing a derived class does not match instances of its base classes).\nFor example, the following code will print B, C, D in that order:\nclass B(Exception):\npass\nclass C(B):\npass\nclass D(C):\npass\nfor cls in [B, C, D]:\ntry:\nraise cls()\nexcept D:\nprint(\"D\")\nexcept C:\nprint(\"C\")\nexcept B:\nprint(\"B\")\nNote that if the except clauses were reversed (with except B first), it\nwould have printed B, B, B â the first matching except clause is triggered.\nWhen an exception occurs, it may have associated values, also known as the\nexceptionâs arguments. The presence and types of the arguments depend on the\nexception type.\nThe except clause may specify a variable after the exception name.  The\nvariable is bound to the exception instance which typically has an args\nattribute that stores the arguments. For convenience, builtin exception\ntypes define __str__() to print all the arguments without explicitly\naccessing .args.\n>>> try:\n...     raise Exception('spam', 'eggs')\n... except Exception as inst:\n...     print(type(inst))    # the exception type\n...     print(inst.args)     # arguments stored in .args\n...     print(inst)          # __str__ allows args to be printed directly,\n...                          # but may be overridden in exception subclasses\n...     x, y = inst.args     # unpack args\n...     print('x =', x)\n...     print('y =', y)\n...\n<class 'Exception'>\n('spam', 'eggs')\n('spam', 'eggs')\nx = spam\ny = eggs\nThe exceptionâs __str__() output is printed as the last part (âdetailâ)\nof the message for unhandled exceptions.\nBaseException is the common base class of all exceptions. One of its\nsubclasses, Exception, is the base class of all the non-fatal exceptions.\nExceptions which are not subclasses of Exception are not typically\nhandled, because they are used to indicate that the program should terminate.\nThey include SystemExit which is raised by sys.exit() and\nKeyboardInterrupt which is raised when a user wishes to interrupt\nthe program.\nException can be used as a wildcard that catches (almost) everything.\nHowever, it is good practice to be as specific as possible with the types\nof exceptions that we intend to handle, and to allow any unexpected\nexceptions to propagate on.\nThe most common pattern for handling Exception is to print or log\nthe exception and then re-raise it (allowing a caller to handle the\nexception as well):\nimport sys\ntry:\nf = open('myfile.txt')\ns = f.readline()\ni = int(s.strip())\nexcept OSError as err:\nprint(\"OS error:\", err)\nexcept ValueError:\nprint(\"Could not convert data to an integer.\")\nexcept Exception as err:\nprint(f\"Unexpected {err=}, {type(err)=}\")\nraise\nThe try â¦ except statement has an optional else\nclause, which, when present, must follow all except clauses.  It is useful\nfor code that must be executed if the try clause does not raise an exception.\nFor example:\nfor arg in sys.argv[1:]:\ntry:\nf = open(arg, 'r')\nexcept OSError:\nprint('cannot open', arg)\nelse:\nprint(arg, 'has', len(f.readlines()), 'lines')\nf.close()\nThe use of the else clause is better than adding additional code to\nthe try clause because it avoids accidentally catching an exception\nthat wasnât raised by the code being protected by the try â¦\nexcept statement."
      },
      {
        "chunk_id": "python_docs_errors_chunk_2",
        "original_index": 2,
        "content": "the try clause because it avoids accidentally catching an exception\nthat wasnât raised by the code being protected by the try â¦\nexcept statement.\nException handlers do not handle only exceptions that occur immediately in the\ntry clause, but also those that occur inside functions that are called (even\nindirectly) in the try clause. For example:\n>>> def this_fails():\n...     x = 1/0\n...\n>>> try:\n...     this_fails()\n... except ZeroDivisionError as err:\n...     print('Handling run-time error:', err)\n...\nHandling run-time error: division by zero\n8.4. Raising ExceptionsÂ¶\nThe raise statement allows the programmer to force a specified\nexception to occur. For example:\n>>> raise NameError('HiThere')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: HiThere\nThe sole argument to raise indicates the exception to be raised.\nThis must be either an exception instance or an exception class (a class that\nderives from BaseException, such as Exception or one of its\nsubclasses).  If an exception class is passed, it will be implicitly\ninstantiated by calling its constructor with no arguments:\nraise ValueError  # shorthand for 'raise ValueError()'\nIf you need to determine whether an exception was raised but donât intend to\nhandle it, a simpler form of the raise statement allows you to\nre-raise the exception:\n>>> try:\n...     raise NameError('HiThere')\n... except NameError:\n...     print('An exception flew by!')\n...     raise\n...\nAn exception flew by!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nNameError: HiThere\n8.5. Exception ChainingÂ¶\nIf an unhandled exception occurs inside an except section, it will\nhave the exception being handled attached to it and included in the error\nmessage:\n>>> try:\n...     open(\"database.sqlite\")\n... except OSError:\n...     raise RuntimeError(\"unable to handle error\")\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nFileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: unable to handle error\nTo indicate that an exception is a direct consequence of another, the\nraise statement allows an optional from clause:\n# exc must be exception instance or None.\nraise RuntimeError from exc\nThis can be useful when you are transforming exceptions. For example:\n>>> def func():\n...     raise ConnectionError\n...\n>>> try:\n...     func()\n... except ConnectionError as exc:\n...     raise RuntimeError('Failed to open database') from exc\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nFile \"<stdin>\", line 2, in func\nConnectionError\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: Failed to open database\nIt also allows disabling automatic exception chaining using the from None\nidiom:\n>>> try:\n...     open('database.sqlite')\n... except OSError:\n...     raise RuntimeError from None\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError\nFor more information about chaining mechanics, see Built-in Exceptions.\n8.6. User-defined ExceptionsÂ¶\nPrograms may name their own exceptions by creating a new exception class (see\nClasses for more about Python classes).  Exceptions should typically\nbe derived from the Exception class, either directly or indirectly.\nException classes can be defined which do anything any other class can do, but\nare usually kept simple, often only offering a number of attributes that allow\ninformation about the error to be extracted by handlers for the exception.\nMost exceptions are defined with names that end in âErrorâ, similar to the\nnaming of the standard exceptions.\nMany standard modules define their own exceptions to report errors that may\noccur in functions they define."
      },
      {
        "chunk_id": "python_docs_errors_chunk_3",
        "original_index": 3,
        "content": "naming of the standard exceptions.\nMany standard modules define their own exceptions to report errors that may\noccur in functions they define.\n8.7. Defining Clean-up ActionsÂ¶\nThe try statement has another optional clause which is intended to\ndefine clean-up actions that must be executed under all circumstances.  For\nexample:\n>>> try:\n...     raise KeyboardInterrupt\n... finally:\n...     print('Goodbye, world!')\n...\nGoodbye, world!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nKeyboardInterrupt\nIf a finally clause is present, the finally\nclause will execute as the last task before the try\nstatement completes. The finally clause runs whether or\nnot the try statement produces an exception. The following\npoints discuss more complex cases when an exception occurs:\nIf an exception occurs during execution of the try\nclause, the exception may be handled by an except\nclause. If the exception is not handled by an except\nclause, the exception is re-raised after the finally\nclause has been executed.\nAn exception could occur during execution of an except\nor else clause. Again, the exception is re-raised after\nthe finally clause has been executed.\nIf the finally clause executes a break,\ncontinue or return statement, exceptions are not\nre-raised.\nIf the try statement reaches a break,\ncontinue or return statement, the\nfinally clause will execute just prior to the\nbreak, continue or return\nstatementâs execution.\nIf a finally clause includes a return\nstatement, the returned value will be the one from the\nfinally clauseâs return statement, not the\nvalue from the try clauseâs return\nstatement.\nFor example:\n>>> def bool_return():\n...     try:\n...         return True\n...     finally:\n...         return False\n...\n>>> bool_return()\nFalse\nA more complicated example:\n>>> def divide(x, y):\n...     try:\n...         result = x / y\n...     except ZeroDivisionError:\n...         print(\"division by zero!\")\n...     else:\n...         print(\"result is\", result)\n...     finally:\n...         print(\"executing finally clause\")\n...\n>>> divide(2, 1)\nresult is 2.0\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 3, in divide\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\nAs you can see, the finally clause is executed in any event.  The\nTypeError raised by dividing two strings is not handled by the\nexcept clause and therefore re-raised after the finally\nclause has been executed.\nIn real world applications, the finally clause is useful for\nreleasing external resources (such as files or network connections), regardless\nof whether the use of the resource was successful.\n8.8. Predefined Clean-up ActionsÂ¶\nSome objects define standard clean-up actions to be undertaken when the object\nis no longer needed, regardless of whether or not the operation using the object\nsucceeded or failed. Look at the following example, which tries to open a file\nand print its contents to the screen.\nfor line in open(\"myfile.txt\"):\nprint(line, end=\"\")\nThe problem with this code is that it leaves the file open for an indeterminate\namount of time after this part of the code has finished executing.\nThis is not an issue in simple scripts, but can be a problem for larger\napplications. The with statement allows objects like files to be\nused in a way that ensures they are always cleaned up promptly and correctly.\nwith open(\"myfile.txt\") as f:\nfor line in f:\nprint(line, end=\"\")\nAfter the statement is executed, the file f is always closed, even if a\nproblem was encountered while processing the lines. Objects which, like files,\nprovide predefined clean-up actions will indicate this in their documentation.\n8.9. Raising and Handling Multiple Unrelated ExceptionsÂ¶\nThere are situations where it is necessary to report several exceptions that"
      },
      {
        "chunk_id": "python_docs_errors_chunk_4",
        "original_index": 4,
        "content": "8.9. Raising and Handling Multiple Unrelated ExceptionsÂ¶\nThere are situations where it is necessary to report several exceptions that\nhave occurred. This is often the case in concurrency frameworks, when several\ntasks may have failed in parallel, but there are also other use cases where\nit is desirable to continue execution and collect multiple errors rather than\nraise the first exception.\nThe builtin ExceptionGroup wraps a list of exception instances so\nthat they can be raised together. It is an exception itself, so it can be\ncaught like any other exception.\n>>> def f():\n...     excs = [OSError('error 1'), SystemError('error 2')]\n...     raise ExceptionGroup('there were problems', excs)\n...\n>>> f()\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 1, in <module>\n|   File \"<stdin>\", line 3, in f\n| ExceptionGroup: there were problems\n+-+---------------- 1 ----------------\n| OSError: error 1\n+---------------- 2 ----------------\n| SystemError: error 2\n+------------------------------------\n>>> try:\n...     f()\n... except Exception as e:\n...     print(f'caught {type(e)}: e')\n...\ncaught <class 'ExceptionGroup'>: e\n>>>\nBy using except* instead of except, we can selectively\nhandle only the exceptions in the group that match a certain\ntype. In the following example, which shows a nested exception\ngroup, each except* clause extracts from the group exceptions\nof a certain type while letting all other exceptions propagate to\nother clauses and eventually to be reraised.\n>>> def f():\n...     raise ExceptionGroup(\n...         \"group1\",\n...         [\n...             OSError(1),\n...             SystemError(2),\n...             ExceptionGroup(\n...                 \"group2\",\n...                 [\n...                     OSError(3),\n...                     RecursionError(4)\n...                 ]\n...             )\n...         ]\n...     )\n...\n>>> try:\n...     f()\n... except* OSError as e:\n...     print(\"There were OSErrors\")\n... except* SystemError as e:\n...     print(\"There were SystemErrors\")\n...\nThere were OSErrors\nThere were SystemErrors\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 2, in <module>\n|   File \"<stdin>\", line 2, in f\n| ExceptionGroup: group1\n+-+---------------- 1 ----------------\n| ExceptionGroup: group2\n+-+---------------- 1 ----------------\n| RecursionError: 4\n+------------------------------------\n>>>\nNote that the exceptions nested in an exception group must be instances,\nnot types. This is because in practice the exceptions would typically\nbe ones that have already been raised and caught by the program, along\nthe following pattern:\n>>> excs = []\n... for test in tests:\n...     try:\n...         test.run()\n...     except Exception as e:\n...         excs.append(e)\n...\n>>> if excs:\n...    raise ExceptionGroup(\"Test Failures\", excs)\n...\n8.10. Enriching Exceptions with NotesÂ¶\nWhen an exception is created in order to be raised, it is usually initialized\nwith information that describes the error that has occurred. There are cases\nwhere it is useful to add information after the exception was caught. For this\npurpose, exceptions have a method add_note(note) that accepts a string and\nadds it to the exceptionâs notes list. The standard traceback rendering\nincludes all notes, in the order they were added, after the exception.\n>>> try:\n...     raise TypeError('bad type')\n... except Exception as e:\n...     e.add_note('Add some information')\n...     e.add_note('Add some more information')\n...     raise\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nTypeError: bad type\nAdd some information\nAdd some more information\n>>>\nFor example, when collecting exceptions into an exception group, we may want\nto add context information for the individual errors. In the following each\nexception in the group has a note indicating when this error has occurred.\n>>> def f():\n...     raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n...     try:"
      },
      {
        "chunk_id": "python_docs_errors_chunk_5",
        "original_index": 5,
        "content": "exception in the group has a note indicating when this error has occurred.\n>>> def f():\n...     raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n...     try:\n...         f()\n...     except Exception as e:\n...         e.add_note(f'Happened in Iteration {i+1}')\n...         excs.append(e)\n...\n>>> raise ExceptionGroup('We have some problems', excs)\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 1, in <module>\n| ExceptionGroup: We have some problems (3 sub-exceptions)\n+-+---------------- 1 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 1\n+---------------- 2 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 2\n+---------------- 3 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 3\n+------------------------------------\n>>>"
      }
    ]
  },
  {
    "doc_id": "python_docs_classes",
    "original_uuid": "6e71",
    "content": "9. ClassesÂ¶\nClasses provide a means of bundling data and functionality together.  Creating\na new class creates a new type of object, allowing new instances of that\ntype to be made.  Each class instance can have attributes attached to it for\nmaintaining its state.  Class instances can also have methods (defined by its\nclass) for modifying its state.\nCompared with other programming languages, Pythonâs class mechanism adds classes\nwith a minimum of new syntax and semantics.  It is a mixture of the class\nmechanisms found in C++ and Modula-3.  Python classes provide all the standard\nfeatures of Object Oriented Programming: the class inheritance mechanism allows\nmultiple base classes, a derived class can override any methods of its base\nclass or classes, and a method can call the method of a base class with the same\nname.  Objects can contain arbitrary amounts and kinds of data.  As is true for\nmodules, classes partake of the dynamic nature of Python: they are created at\nruntime, and can be modified further after creation.\nIn C++ terminology, normally class members (including the data members) are\npublic (except see below Private Variables), and all member functions are\nvirtual.  As in Modula-3, there are no shorthands for referencing the objectâs\nmembers from its methods: the method function is declared with an explicit first\nargument representing the object, which is provided implicitly by the call.  As\nin Smalltalk, classes themselves are objects.  This provides semantics for\nimporting and renaming.  Unlike C++ and Modula-3, built-in types can be used as\nbase classes for extension by the user.  Also, like in C++, most built-in\noperators with special syntax (arithmetic operators, subscripting etc.) can be\nredefined for class instances.\n(Lacking universally accepted terminology to talk about classes, I will make\noccasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, since\nits object-oriented semantics are closer to those of Python than C++, but I\nexpect that few readers have heard of it.)\n9.1. A Word About Names and ObjectsÂ¶\nObjects have individuality, and multiple names (in multiple scopes) can be bound\nto the same object.  This is known as aliasing in other languages.  This is\nusually not appreciated on a first glance at Python, and can be safely ignored\nwhen dealing with immutable basic types (numbers, strings, tuples).  However,\naliasing has a possibly surprising effect on the semantics of Python code\ninvolving mutable objects such as lists, dictionaries, and most other types.\nThis is usually used to the benefit of the program, since aliases behave like\npointers in some respects.  For example, passing an object is cheap since only a\npointer is passed by the implementation; and if a function modifies an object\npassed as an argument, the caller will see the change â this eliminates the\nneed for two different argument passing mechanisms as in Pascal.\n9.2. Python Scopes and NamespacesÂ¶\nBefore introducing classes, I first have to tell you something about Pythonâs\nscope rules.  Class definitions play some neat tricks with namespaces, and you\nneed to know how scopes and namespaces work to fully understand whatâs going on.\nIncidentally, knowledge about this subject is useful for any advanced Python\nprogrammer.\nLetâs begin with some definitions.\nA namespace is a mapping from names to objects.  Most namespaces are currently\nimplemented as Python dictionaries, but thatâs normally not noticeable in any\nway (except for performance), and it may change in the future.  Examples of\nnamespaces are: the set of built-in names (containing functions such as abs(), and\nbuilt-in exception names); the global names in a module; and the local names in\na function invocation.  In a sense the set of attributes of an object also form\na namespace.  The important thing to know about namespaces is that there is\nabsolutely no relation between names in different namespaces; for instance, two\ndifferent modules may both define a function maximize without confusion â\nusers of the modules must prefix it with the module name.\nBy the way, I use the word attribute for any name following a dot â for\nexample, in the expression z.real, real is an attribute of the object\nz.  Strictly speaking, references to names in modules are attribute\nreferences: in the expression modname.funcname, modname is a module\nobject and funcname is an attribute of it.  In this case there happens to be\na straightforward mapping between the moduleâs attributes and the global names\ndefined in the module: they share the same namespace!  [1]\nAttributes may be read-only or writable.  In the latter case, assignment to\nattributes is possible.  Module attributes are writable: you can write\nmodname.the_answer = 42.  Writable attributes may also be deleted with the\ndel statement.  For example, del modname.the_answer will remove\nthe attribute the_answer from the object named by modname.\nNamespaces are created at different moments and have different lifetimes.  The\nnamespace containing the built-in names is created when the Python interpreter\nstarts up, and is never deleted.  The global namespace for a module is created\nwhen the module definition is read in; normally, module namespaces also last\nuntil the interpreter quits.  The statements executed by the top-level\ninvocation of the interpreter, either read from a script file or interactively,\nare considered part of a module called __main__, so they have their own\nglobal namespace.  (The built-in names actually also live in a module; this is\ncalled builtins.)\nThe local namespace for a function is created when the function is called, and\ndeleted when the function returns or raises an exception that is not handled\nwithin the function.  (Actually, forgetting would be a better way to describe\nwhat actually happens.)  Of course, recursive invocations each have their own\nlocal namespace.\nA scope is a textual region of a Python program where a namespace is directly\naccessible.  âDirectly accessibleâ here means that an unqualified reference to a\nname attempts to find the name in the namespace.\nAlthough scopes are determined statically, they are used dynamically. At any\ntime during execution, there are 3 or 4 nested scopes whose namespaces are\ndirectly accessible:\nthe innermost scope, which is searched first, contains the local names\nthe scopes of any enclosing functions, which are searched starting with the\nnearest enclosing scope, contain non-local, but also non-global names\nthe next-to-last scope contains the current moduleâs global names\nthe outermost scope (searched last) is the namespace containing built-in names\nIf a name is declared global, then all references and assignments go directly to\nthe next-to-last scope containing the moduleâs global names.  To rebind variables\nfound outside of the innermost scope, the nonlocal statement can be\nused; if not declared nonlocal, those variables are read-only (an attempt to\nwrite to such a variable will simply create a new local variable in the\ninnermost scope, leaving the identically named outer variable unchanged).\nUsually, the local scope references the local names of the (textually) current\nfunction.  Outside functions, the local scope references the same namespace as\nthe global scope: the moduleâs namespace. Class definitions place yet another\nnamespace in the local scope.\nIt is important to realize that scopes are determined textually: the global\nscope of a function defined in a module is that moduleâs namespace, no matter\nfrom where or by what alias the function is called.  On the other hand, the\nactual search for names is done dynamically, at run time â however, the\nlanguage definition is evolving towards static name resolution, at âcompileâ\ntime, so donât rely on dynamic name resolution!  (In fact, local variables are\nalready determined statically.)\nA special quirk of Python is that â if no global or nonlocal\nstatement is in effect â assignments to names always go into the innermost scope.\nAssignments do not copy data â they just bind names to objects.  The same is true\nfor deletions: the statement del x removes the binding of x from the\nnamespace referenced by the local scope.  In fact, all operations that introduce\nnew names use the local scope: in particular, import statements and\nfunction definitions bind the module or function name in the local scope.\nThe global statement can be used to indicate that particular\nvariables live in the global scope and should be rebound there; the\nnonlocal statement indicates that particular variables live in\nan enclosing scope and should be rebound there.\n9.2.1. Scopes and Namespaces ExampleÂ¶\nThis is an example demonstrating how to reference the different scopes and\nnamespaces, and how global and nonlocal affect variable\nbinding:\ndef scope_test():\ndef do_local():\nspam = \"local spam\"\ndef do_nonlocal():\nnonlocal spam\nspam = \"nonlocal spam\"\ndef do_global():\nglobal spam\nspam = \"global spam\"\nspam = \"test spam\"\ndo_local()\nprint(\"After local assignment:\", spam)\ndo_nonlocal()\nprint(\"After nonlocal assignment:\", spam)\ndo_global()\nprint(\"After global assignment:\", spam)\nscope_test()\nprint(\"In global scope:\", spam)\nThe output of the example code is:\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\nNote how the local assignment (which is default) didnât change scope_test's\nbinding of spam.  The nonlocal assignment changed scope_test's\nbinding of spam, and the global assignment changed the module-level\nbinding.\nYou can also see that there was no previous binding for spam before the\nglobal assignment.\n9.3. A First Look at ClassesÂ¶\nClasses introduce a little bit of new syntax, three new object types, and some\nnew semantics.\n9.3.1. Class Definition SyntaxÂ¶\nThe simplest form of class definition looks like this:\nclass ClassName:\n<statement-1>\n.\n.\n.\n<statement-N>\nClass definitions, like function definitions (def statements) must be\nexecuted before they have any effect.  (You could conceivably place a class\ndefinition in a branch of an if statement, or inside a function.)\nIn practice, the statements inside a class definition will usually be function\ndefinitions, but other statements are allowed, and sometimes useful â weâll\ncome back to this later.  The function definitions inside a class normally have\na peculiar form of argument list, dictated by the calling conventions for\nmethods â again, this is explained later.\nWhen a class definition is entered, a new namespace is created, and used as the\nlocal scope â thus, all assignments to local variables go into this new\nnamespace.  In particular, function definitions bind the name of the new\nfunction here.\nWhen a class definition is left normally (via the end), a class object is\ncreated.  This is basically a wrapper around the contents of the namespace\ncreated by the class definition; weâll learn more about class objects in the\nnext section.  The original local scope (the one in effect just before the class\ndefinition was entered) is reinstated, and the class object is bound here to the\nclass name given in the class definition header (ClassName in the\nexample).\n9.3.2. Class ObjectsÂ¶\nClass objects support two kinds of operations: attribute references and\ninstantiation.\nAttribute references use the standard syntax used for all attribute references\nin Python: obj.name.  Valid attribute names are all the names that were in\nthe classâs namespace when the class object was created.  So, if the class\ndefinition looked like this:\nclass MyClass:\n\"\"\"A simple example class\"\"\"\ni = 12345\ndef f(self):\nreturn 'hello world'\nthen MyClass.i and MyClass.f are valid attribute references, returning\nan integer and a function object, respectively. Class attributes can also be\nassigned to, so you can change the value of MyClass.i by assignment.\n__doc__ is also a valid attribute, returning the docstring\nbelonging to the class: \"A simple example class\".\nClass instantiation uses function notation.  Just pretend that the class\nobject is a parameterless function that returns a new instance of the class.\nFor example (assuming the above class):\nx = MyClass()\ncreates a new instance of the class and assigns this object to the local\nvariable x.\nThe instantiation operation (âcallingâ a class object) creates an empty object.\nMany classes like to create objects with instances customized to a specific\ninitial state. Therefore a class may define a special method named\n__init__(), like this:\ndef __init__(self):\nself.data = []\nWhen a class defines an __init__() method, class instantiation\nautomatically invokes __init__() for the newly created class instance.  So\nin this example, a new, initialized instance can be obtained by:\nx = MyClass()\nOf course, the __init__() method may have arguments for greater\nflexibility.  In that case, arguments given to the class instantiation operator\nare passed on to __init__().  For example,\n>>> class Complex:\n...     def __init__(self, realpart, imagpart):\n...         self.r = realpart\n...         self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n9.3.3. Instance ObjectsÂ¶\nNow what can we do with instance objects?  The only operations understood by\ninstance objects are attribute references.  There are two kinds of valid\nattribute names: data attributes and methods.\ndata attributes correspond to âinstance variablesâ in Smalltalk, and to âdata\nmembersâ in C++.  Data attributes need not be declared; like local variables,\nthey spring into existence when they are first assigned to.  For example, if\nx is the instance of MyClass created above, the following piece of\ncode will print the value 16, without leaving a trace:\nx.counter = 1\nwhile x.counter < 10:\nx.counter = x.counter * 2\nprint(x.counter)\ndel x.counter\nThe other kind of instance attribute reference is a method. A method is a\nfunction that âbelongs toâ an object.\nValid method names of an instance object depend on its class.  By definition,\nall attributes of a class that are function  objects define corresponding\nmethods of its instances.  So in our example, x.f is a valid method\nreference, since MyClass.f is a function, but x.i is not, since\nMyClass.i is not.  But x.f is not the same thing as MyClass.f â it\nis a method object, not a function object.\n9.3.4. Method ObjectsÂ¶\nUsually, a method is called right after it is bound:\nx.f()\nIn the MyClass example, this will return the string 'hello world'.\nHowever, it is not necessary to call a method right away: x.f is a method\nobject, and can be stored away and called at a later time.  For example:\nxf = x.f\nwhile True:\nprint(xf())\nwill continue to print hello world until the end of time.\nWhat exactly happens when a method is called?  You may have noticed that\nx.f() was called without an argument above, even though the function\ndefinition for f() specified an argument.  What happened to the argument?\nSurely Python raises an exception when a function that requires an argument is\ncalled without any â even if the argument isnât actually usedâ¦\nActually, you may have guessed the answer: the special thing about methods is\nthat the instance object is passed as the first argument of the function.  In our\nexample, the call x.f() is exactly equivalent to MyClass.f(x).  In\ngeneral, calling a method with a list of n arguments is equivalent to calling\nthe corresponding function with an argument list that is created by inserting\nthe methodâs instance object before the first argument.\nIn general, methods work as follows.  When a non-data attribute\nof an instance is referenced, the instanceâs class is searched.\nIf the name denotes a valid class attribute that is a function object,\nreferences to both the instance object and the function object\nare packed into a method object.  When the method object is called\nwith an argument list, a new argument list is constructed from the instance\nobject and the argument list, and the function object is called with this new\nargument list.\n9.3.5. Class and Instance VariablesÂ¶\nGenerally speaking, instance variables are for data unique to each instance\nand class variables are for attributes and methods shared by all instances\nof the class:\nclass Dog:\nkind = 'canine'         # class variable shared by all instances\ndef __init__(self, name):\nself.name = name    # instance variable unique to each instance\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\nAs discussed in A Word About Names and Objects, shared data can have possibly surprising\neffects with involving mutable objects such as lists and dictionaries.\nFor example, the tricks list in the following code should not be used as a\nclass variable because just a single list would be shared by all Dog\ninstances:\nclass Dog:\ntricks = []             # mistaken use of a class variable\ndef __init__(self, name):\nself.name = name\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\nCorrect design of the class should use an instance variable instead:\nclass Dog:\ndef __init__(self, name):\nself.name = name\nself.tricks = []    # creates a new empty list for each dog\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n9.4. Random RemarksÂ¶\nIf the same attribute name occurs in both an instance and in a class,\nthen attribute lookup prioritizes the instance:\n>>> class Warehouse:\n...    purpose = 'storage'\n...    region = 'west'\n...\n>>> w1 = Warehouse()\n>>> print(w1.purpose, w1.region)\nstorage west\n>>> w2 = Warehouse()\n>>> w2.region = 'east'\n>>> print(w2.purpose, w2.region)\nstorage east\nData attributes may be referenced by methods as well as by ordinary users\n(âclientsâ) of an object.  In other words, classes are not usable to implement\npure abstract data types.  In fact, nothing in Python makes it possible to\nenforce data hiding â it is all based upon convention.  (On the other hand,\nthe Python implementation, written in C, can completely hide implementation\ndetails and control access to an object if necessary; this can be used by\nextensions to Python written in C.)\nClients should use data attributes with care â clients may mess up invariants\nmaintained by the methods by stamping on their data attributes.  Note that\nclients may add data attributes of their own to an instance object without\naffecting the validity of the methods, as long as name conflicts are avoided â\nagain, a naming convention can save a lot of headaches here.\nThere is no shorthand for referencing data attributes (or other methods!) from\nwithin methods.  I find that this actually increases the readability of methods:\nthere is no chance of confusing local variables and instance variables when\nglancing through a method.\nOften, the first argument of a method is called self.  This is nothing more\nthan a convention: the name self has absolutely no special meaning to\nPython.  Note, however, that by not following the convention your code may be\nless readable to other Python programmers, and it is also conceivable that a\nclass browser program might be written that relies upon such a convention.\nAny function object that is a class attribute defines a method for instances of\nthat class.  It is not necessary that the function definition is textually\nenclosed in the class definition: assigning a function object to a local\nvariable in the class is also ok.  For example:\n# Function defined outside the class\ndef f1(self, x, y):\nreturn min(x, x+y)\nclass C:\nf = f1\ndef g(self):\nreturn 'hello world'\nh = g\nNow f, g and h are all attributes of class C that refer to\nfunction objects, and consequently they are all methods of instances of\nC â h being exactly equivalent to g.  Note that this practice\nusually only serves to confuse the reader of a program.\nMethods may call other methods by using method attributes of the self\nargument:\nclass Bag:\ndef __init__(self):\nself.data = []\ndef add(self, x):\nself.data.append(x)\ndef addtwice(self, x):\nself.add(x)\nself.add(x)\nMethods may reference global names in the same way as ordinary functions.  The\nglobal scope associated with a method is the module containing its\ndefinition.  (A class is never used as a global scope.)  While one\nrarely encounters a good reason for using global data in a method, there are\nmany legitimate uses of the global scope: for one thing, functions and modules\nimported into the global scope can be used by methods, as well as functions and\nclasses defined in it.  Usually, the class containing the method is itself\ndefined in this global scope, and in the next section weâll find some good\nreasons why a method would want to reference its own class.\nEach value is an object, and therefore has a class (also called its type).\nIt is stored as object.__class__.\n9.5. InheritanceÂ¶\nOf course, a language feature would not be worthy of the name âclassâ without\nsupporting inheritance.  The syntax for a derived class definition looks like\nthis:\nclass DerivedClassName(BaseClassName):\n<statement-1>\n.\n.\n.\n<statement-N>\nThe name BaseClassName must be defined in a\nnamespace accessible from the scope containing the\nderived class definition.  In place of a base class name, other arbitrary\nexpressions are also allowed.  This can be useful, for example, when the base\nclass is defined in another module:\nclass DerivedClassName(modname.BaseClassName):\nExecution of a derived class definition proceeds the same as for a base class.\nWhen the class object is constructed, the base class is remembered.  This is\nused for resolving attribute references: if a requested attribute is not found\nin the class, the search proceeds to look in the base class.  This rule is\napplied recursively if the base class itself is derived from some other class.\nThereâs nothing special about instantiation of derived classes:\nDerivedClassName() creates a new instance of the class.  Method references\nare resolved as follows: the corresponding class attribute is searched,\ndescending down the chain of base classes if necessary, and the method reference\nis valid if this yields a function object.\nDerived classes may override methods of their base classes.  Because methods\nhave no special privileges when calling other methods of the same object, a\nmethod of a base class that calls another method defined in the same base class\nmay end up calling a method of a derived class that overrides it.  (For C++\nprogrammers: all methods in Python are effectively virtual.)\nAn overriding method in a derived class may in fact want to extend rather than\nsimply replace the base class method of the same name. There is a simple way to\ncall the base class method directly: just call BaseClassName.methodname(self,\narguments).  This is occasionally useful to clients as well.  (Note that this\nonly works if the base class is accessible as BaseClassName in the global\nscope.)\nPython has two built-in functions that work with inheritance:\nUse isinstance() to check an instanceâs type: isinstance(obj, int)\nwill be True only if obj.__class__ is int or some class\nderived from int.\nUse issubclass() to check class inheritance: issubclass(bool, int)\nis True since bool is a subclass of int.  However,\nissubclass(float, int) is False since float is not a\nsubclass of int.\n9.5.1. Multiple InheritanceÂ¶\nPython supports a form of multiple inheritance as well.  A class definition with\nmultiple base classes looks like this:\nclass DerivedClassName(Base1, Base2, Base3):\n<statement-1>\n.\n.\n.\n<statement-N>\nFor most purposes, in the simplest cases, you can think of the search for\nattributes inherited from a parent class as depth-first, left-to-right, not\nsearching twice in the same class where there is an overlap in the hierarchy.\nThus, if an attribute is not found in DerivedClassName, it is searched\nfor in Base1, then (recursively) in the base classes of Base1,\nand if it was not found there, it was searched for in Base2, and so on.\nIn fact, it is slightly more complex than that; the method resolution order\nchanges dynamically to support cooperative calls to super().  This\napproach is known in some other multiple-inheritance languages as\ncall-next-method and is more powerful than the super call found in\nsingle-inheritance languages.\nDynamic ordering is necessary because all cases of multiple inheritance exhibit\none or more diamond relationships (where at least one of the parent classes\ncan be accessed through multiple paths from the bottommost class).  For example,\nall classes inherit from object, so any case of multiple inheritance\nprovides more than one path to reach object.  To keep the base classes\nfrom being accessed more than once, the dynamic algorithm linearizes the search\norder in a way that preserves the left-to-right ordering specified in each\nclass, that calls each parent only once, and that is monotonic (meaning that a\nclass can be subclassed without affecting the precedence order of its parents).\nTaken together, these properties make it possible to design reliable and\nextensible classes with multiple inheritance.  For more detail, see\nThe Python 2.3 Method Resolution Order.\n9.6. Private VariablesÂ¶\nâPrivateâ instance variables that cannot be accessed except from inside an\nobject donât exist in Python.  However, there is a convention that is followed\nby most Python code: a name prefixed with an underscore (e.g. _spam) should\nbe treated as a non-public part of the API (whether it is a function, a method\nor a data member).  It should be considered an implementation detail and subject\nto change without notice.\nSince there is a valid use-case for class-private members (namely to avoid name\nclashes of names with names defined by subclasses), there is limited support for\nsuch a mechanism, called name mangling.  Any identifier of the form\n__spam (at least two leading underscores, at most one trailing underscore)\nis textually replaced with _classname__spam, where classname is the\ncurrent class name with leading underscore(s) stripped.  This mangling is done\nwithout regard to the syntactic position of the identifier, as long as it\noccurs within the definition of a class.\nSee also\nThe private name mangling specifications\nfor details and special cases.\nName mangling is helpful for letting subclasses override methods without\nbreaking intraclass method calls.  For example:\nclass Mapping:\ndef __init__(self, iterable):\nself.items_list = []\nself.__update(iterable)\ndef update(self, iterable):\nfor item in iterable:\nself.items_list.append(item)\n__update = update   # private copy of original update() method\nclass MappingSubclass(Mapping):\ndef update(self, keys, values):\n# provides new signature for update()\n# but does not break __init__()\nfor item in zip(keys, values):\nself.items_list.append(item)\nThe above example would work even if MappingSubclass were to introduce a\n__update identifier since it is replaced with _Mapping__update in the\nMapping class  and _MappingSubclass__update in the MappingSubclass\nclass respectively.\nNote that the mangling rules are designed mostly to avoid accidents; it still is\npossible to access or modify a variable that is considered private.  This can\neven be useful in special circumstances, such as in the debugger.\nNotice that code passed to exec() or eval() does not consider the\nclassname of the invoking class to be the current class; this is similar to the\neffect of the global statement, the effect of which is likewise restricted\nto code that is byte-compiled together.  The same restriction applies to\ngetattr(), setattr() and delattr(), as well as when referencing\n__dict__ directly.\n9.7. Odds and EndsÂ¶\nSometimes it is useful to have a data type similar to the Pascal ârecordâ or C\nâstructâ, bundling together a few named data items. The idiomatic approach\nis to use dataclasses for this purpose:\nfrom dataclasses import dataclass\n@dataclass\nclass Employee:\nname: str\ndept: str\nsalary: int\n>>> john = Employee('john', 'computer lab', 1000)\n>>> john.dept\n'computer lab'\n>>> john.salary\n1000\nA piece of Python code that expects a particular abstract data type can often be\npassed a class that emulates the methods of that data type instead.  For\ninstance, if you have a function that formats some data from a file object, you\ncan define a class with methods read() and\nreadline() that get the\ndata from a string buffer instead, and pass it as an argument.\nInstance method objects have attributes, too:\nm.__self__ is the instance\nobject with the method m(), and m.__func__ is\nthe function object\ncorresponding to the method.\n9.8. IteratorsÂ¶\nBy now you have probably noticed that most container objects can be looped over\nusing a for statement:\nfor element in [1, 2, 3]:\nprint(element)\nfor element in (1, 2, 3):\nprint(element)\nfor key in {'one':1, 'two':2}:\nprint(key)\nfor char in \"123\":\nprint(char)\nfor line in open(\"myfile.txt\"):\nprint(line, end='')\nThis style of access is clear, concise, and convenient.  The use of iterators\npervades and unifies Python.  Behind the scenes, the for statement\ncalls iter() on the container object.  The function returns an iterator\nobject that defines the method __next__() which accesses\nelements in the container one at a time.  When there are no more elements,\n__next__() raises a StopIteration exception which tells the\nfor loop to terminate.  You can call the __next__() method\nusing the next() built-in function; this example shows how it all works:\n>>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<str_iterator object at 0x10c90e650>\n>>> next(it)\n'a'\n>>> next(it)\n'b'\n>>> next(it)\n'c'\n>>> next(it)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nnext(it)\nStopIteration\nHaving seen the mechanics behind the iterator protocol, it is easy to add\niterator behavior to your classes.  Define an __iter__() method which\nreturns an object with a __next__() method.  If the class\ndefines __next__(), then __iter__() can just return self:\nclass Reverse:\n\"\"\"Iterator for looping over a sequence backwards.\"\"\"\ndef __init__(self, data):\nself.data = data\nself.index = len(data)\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.index == 0:\nraise StopIteration\nself.index = self.index - 1\nreturn self.data[self.index]\n>>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n...     print(char)\n...\nm\na\np\ns\n9.9. GeneratorsÂ¶\nGenerators are a simple and powerful tool for creating iterators.  They\nare written like regular functions but use the yield statement\nwhenever they want to return data.  Each time next() is called on it, the\ngenerator resumes where it left off (it remembers all the data values and which\nstatement was last executed).  An example shows that generators can be trivially\neasy to create:\ndef reverse(data):\nfor index in range(len(data)-1, -1, -1):\nyield data[index]\n>>> for char in reverse('golf'):\n...     print(char)\n...\nf\nl\no\ng\nAnything that can be done with generators can also be done with class-based\niterators as described in the previous section.  What makes generators so\ncompact is that the __iter__() and __next__() methods\nare created automatically.\nAnother key feature is that the local variables and execution state are\nautomatically saved between calls.  This made the function easier to write and\nmuch more clear than an approach using instance variables like self.index\nand self.data.\nIn addition to automatic method creation and saving program state, when\ngenerators terminate, they automatically raise StopIteration. In\ncombination, these features make it easy to create iterators with no more effort\nthan writing a regular function.\n9.10. Generator ExpressionsÂ¶\nSome simple generators can be coded succinctly as expressions using a syntax\nsimilar to list comprehensions but with parentheses instead of square brackets.\nThese expressions are designed for situations where the generator is used right\naway by an enclosing function.  Generator expressions are more compact but less\nversatile than full generator definitions and tend to be more memory friendly\nthan equivalent list comprehensions.\nExamples:\n>>> sum(i*i for i in range(10))                 # sum of squares\n285\n>>> xvec = [10, 20, 30]\n>>> yvec = [7, 5, 3]\n>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n260\n>>> unique_words = set(word for line in page  for word in line.split())\n>>> valedictorian = max((student.gpa, student.name) for student in graduates)\n>>> data = 'golf'\n>>> list(data[i] for i in range(len(data)-1, -1, -1))\n['f', 'l', 'o', 'g']\nFootnotes\n[1]\nExcept for one thing.  Module objects have a secret read-only attribute called\n__dict__ which returns the dictionary used to implement the moduleâs\nnamespace; the name __dict__ is an attribute but not a global name.\nObviously, using this violates the abstraction of namespace implementation, and\nshould be restricted to things like post-mortem debuggers.",
    "chunks": [
      {
        "chunk_id": "python_docs_classes_chunk_0",
        "original_index": 0,
        "content": "9. ClassesÂ¶\nClasses provide a means of bundling data and functionality together.  Creating\na new class creates a new type of object, allowing new instances of that\ntype to be made.  Each class instance can have attributes attached to it for\nmaintaining its state.  Class instances can also have methods (defined by its\nclass) for modifying its state.\nCompared with other programming languages, Pythonâs class mechanism adds classes\nwith a minimum of new syntax and semantics.  It is a mixture of the class\nmechanisms found in C++ and Modula-3.  Python classes provide all the standard\nfeatures of Object Oriented Programming: the class inheritance mechanism allows\nmultiple base classes, a derived class can override any methods of its base\nclass or classes, and a method can call the method of a base class with the same\nname.  Objects can contain arbitrary amounts and kinds of data.  As is true for\nmodules, classes partake of the dynamic nature of Python: they are created at\nruntime, and can be modified further after creation.\nIn C++ terminology, normally class members (including the data members) are\npublic (except see below Private Variables), and all member functions are\nvirtual.  As in Modula-3, there are no shorthands for referencing the objectâs\nmembers from its methods: the method function is declared with an explicit first\nargument representing the object, which is provided implicitly by the call.  As\nin Smalltalk, classes themselves are objects.  This provides semantics for\nimporting and renaming.  Unlike C++ and Modula-3, built-in types can be used as\nbase classes for extension by the user.  Also, like in C++, most built-in\noperators with special syntax (arithmetic operators, subscripting etc.) can be\nredefined for class instances.\n(Lacking universally accepted terminology to talk about classes, I will make\noccasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, since\nits object-oriented semantics are closer to those of Python than C++, but I\nexpect that few readers have heard of it.)\n9.1. A Word About Names and ObjectsÂ¶\nObjects have individuality, and multiple names (in multiple scopes) can be bound\nto the same object.  This is known as aliasing in other languages.  This is\nusually not appreciated on a first glance at Python, and can be safely ignored\nwhen dealing with immutable basic types (numbers, strings, tuples).  However,\naliasing has a possibly surprising effect on the semantics of Python code\ninvolving mutable objects such as lists, dictionaries, and most other types.\nThis is usually used to the benefit of the program, since aliases behave like\npointers in some respects.  For example, passing an object is cheap since only a\npointer is passed by the implementation; and if a function modifies an object\npassed as an argument, the caller will see the change â this eliminates the\nneed for two different argument passing mechanisms as in Pascal.\n9.2. Python Scopes and NamespacesÂ¶\nBefore introducing classes, I first have to tell you something about Pythonâs\nscope rules.  Class definitions play some neat tricks with namespaces, and you\nneed to know how scopes and namespaces work to fully understand whatâs going on.\nIncidentally, knowledge about this subject is useful for any advanced Python\nprogrammer.\nLetâs begin with some definitions.\nA namespace is a mapping from names to objects.  Most namespaces are currently\nimplemented as Python dictionaries, but thatâs normally not noticeable in any\nway (except for performance), and it may change in the future.  Examples of\nnamespaces are: the set of built-in names (containing functions such as abs(), and\nbuilt-in exception names); the global names in a module; and the local names in\na function invocation.  In a sense the set of attributes of an object also form\na namespace.  The important thing to know about namespaces is that there is\nabsolutely no relation between names in different namespaces; for instance, two"
      },
      {
        "chunk_id": "python_docs_classes_chunk_1",
        "original_index": 1,
        "content": "a namespace.  The important thing to know about namespaces is that there is\nabsolutely no relation between names in different namespaces; for instance, two\ndifferent modules may both define a function maximize without confusion â\nusers of the modules must prefix it with the module name.\nBy the way, I use the word attribute for any name following a dot â for\nexample, in the expression z.real, real is an attribute of the object\nz.  Strictly speaking, references to names in modules are attribute\nreferences: in the expression modname.funcname, modname is a module\nobject and funcname is an attribute of it.  In this case there happens to be\na straightforward mapping between the moduleâs attributes and the global names\ndefined in the module: they share the same namespace!  [1]\nAttributes may be read-only or writable.  In the latter case, assignment to\nattributes is possible.  Module attributes are writable: you can write\nmodname.the_answer = 42.  Writable attributes may also be deleted with the\ndel statement.  For example, del modname.the_answer will remove\nthe attribute the_answer from the object named by modname.\nNamespaces are created at different moments and have different lifetimes.  The\nnamespace containing the built-in names is created when the Python interpreter\nstarts up, and is never deleted.  The global namespace for a module is created\nwhen the module definition is read in; normally, module namespaces also last\nuntil the interpreter quits.  The statements executed by the top-level\ninvocation of the interpreter, either read from a script file or interactively,\nare considered part of a module called __main__, so they have their own\nglobal namespace.  (The built-in names actually also live in a module; this is\ncalled builtins.)\nThe local namespace for a function is created when the function is called, and\ndeleted when the function returns or raises an exception that is not handled\nwithin the function.  (Actually, forgetting would be a better way to describe\nwhat actually happens.)  Of course, recursive invocations each have their own\nlocal namespace.\nA scope is a textual region of a Python program where a namespace is directly\naccessible.  âDirectly accessibleâ here means that an unqualified reference to a\nname attempts to find the name in the namespace.\nAlthough scopes are determined statically, they are used dynamically. At any\ntime during execution, there are 3 or 4 nested scopes whose namespaces are\ndirectly accessible:\nthe innermost scope, which is searched first, contains the local names\nthe scopes of any enclosing functions, which are searched starting with the\nnearest enclosing scope, contain non-local, but also non-global names\nthe next-to-last scope contains the current moduleâs global names\nthe outermost scope (searched last) is the namespace containing built-in names\nIf a name is declared global, then all references and assignments go directly to\nthe next-to-last scope containing the moduleâs global names.  To rebind variables\nfound outside of the innermost scope, the nonlocal statement can be\nused; if not declared nonlocal, those variables are read-only (an attempt to\nwrite to such a variable will simply create a new local variable in the\ninnermost scope, leaving the identically named outer variable unchanged).\nUsually, the local scope references the local names of the (textually) current\nfunction.  Outside functions, the local scope references the same namespace as\nthe global scope: the moduleâs namespace. Class definitions place yet another\nnamespace in the local scope.\nIt is important to realize that scopes are determined textually: the global\nscope of a function defined in a module is that moduleâs namespace, no matter\nfrom where or by what alias the function is called.  On the other hand, the\nactual search for names is done dynamically, at run time â however, the\nlanguage definition is evolving towards static name resolution, at âcompileâ"
      },
      {
        "chunk_id": "python_docs_classes_chunk_2",
        "original_index": 2,
        "content": "actual search for names is done dynamically, at run time â however, the\nlanguage definition is evolving towards static name resolution, at âcompileâ\ntime, so donât rely on dynamic name resolution!  (In fact, local variables are\nalready determined statically.)\nA special quirk of Python is that â if no global or nonlocal\nstatement is in effect â assignments to names always go into the innermost scope.\nAssignments do not copy data â they just bind names to objects.  The same is true\nfor deletions: the statement del x removes the binding of x from the\nnamespace referenced by the local scope.  In fact, all operations that introduce\nnew names use the local scope: in particular, import statements and\nfunction definitions bind the module or function name in the local scope.\nThe global statement can be used to indicate that particular\nvariables live in the global scope and should be rebound there; the\nnonlocal statement indicates that particular variables live in\nan enclosing scope and should be rebound there.\n9.2.1. Scopes and Namespaces ExampleÂ¶\nThis is an example demonstrating how to reference the different scopes and\nnamespaces, and how global and nonlocal affect variable\nbinding:\ndef scope_test():\ndef do_local():\nspam = \"local spam\"\ndef do_nonlocal():\nnonlocal spam\nspam = \"nonlocal spam\"\ndef do_global():\nglobal spam\nspam = \"global spam\"\nspam = \"test spam\"\ndo_local()\nprint(\"After local assignment:\", spam)\ndo_nonlocal()\nprint(\"After nonlocal assignment:\", spam)\ndo_global()\nprint(\"After global assignment:\", spam)\nscope_test()\nprint(\"In global scope:\", spam)\nThe output of the example code is:\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\nNote how the local assignment (which is default) didnât change scope_test's\nbinding of spam.  The nonlocal assignment changed scope_test's\nbinding of spam, and the global assignment changed the module-level\nbinding.\nYou can also see that there was no previous binding for spam before the\nglobal assignment.\n9.3. A First Look at ClassesÂ¶\nClasses introduce a little bit of new syntax, three new object types, and some\nnew semantics.\n9.3.1. Class Definition SyntaxÂ¶\nThe simplest form of class definition looks like this:\nclass ClassName:\n<statement-1>\n.\n.\n.\n<statement-N>\nClass definitions, like function definitions (def statements) must be\nexecuted before they have any effect.  (You could conceivably place a class\ndefinition in a branch of an if statement, or inside a function.)\nIn practice, the statements inside a class definition will usually be function\ndefinitions, but other statements are allowed, and sometimes useful â weâll\ncome back to this later.  The function definitions inside a class normally have\na peculiar form of argument list, dictated by the calling conventions for\nmethods â again, this is explained later.\nWhen a class definition is entered, a new namespace is created, and used as the\nlocal scope â thus, all assignments to local variables go into this new\nnamespace.  In particular, function definitions bind the name of the new\nfunction here.\nWhen a class definition is left normally (via the end), a class object is\ncreated.  This is basically a wrapper around the contents of the namespace\ncreated by the class definition; weâll learn more about class objects in the\nnext section.  The original local scope (the one in effect just before the class\ndefinition was entered) is reinstated, and the class object is bound here to the\nclass name given in the class definition header (ClassName in the\nexample).\n9.3.2. Class ObjectsÂ¶\nClass objects support two kinds of operations: attribute references and\ninstantiation.\nAttribute references use the standard syntax used for all attribute references\nin Python: obj.name.  Valid attribute names are all the names that were in\nthe classâs namespace when the class object was created.  So, if the class\ndefinition looked like this:"
      },
      {
        "chunk_id": "python_docs_classes_chunk_3",
        "original_index": 3,
        "content": "in Python: obj.name.  Valid attribute names are all the names that were in\nthe classâs namespace when the class object was created.  So, if the class\ndefinition looked like this:\nclass MyClass:\n\"\"\"A simple example class\"\"\"\ni = 12345\ndef f(self):\nreturn 'hello world'\nthen MyClass.i and MyClass.f are valid attribute references, returning\nan integer and a function object, respectively. Class attributes can also be\nassigned to, so you can change the value of MyClass.i by assignment.\n__doc__ is also a valid attribute, returning the docstring\nbelonging to the class: \"A simple example class\".\nClass instantiation uses function notation.  Just pretend that the class\nobject is a parameterless function that returns a new instance of the class.\nFor example (assuming the above class):\nx = MyClass()\ncreates a new instance of the class and assigns this object to the local\nvariable x.\nThe instantiation operation (âcallingâ a class object) creates an empty object.\nMany classes like to create objects with instances customized to a specific\ninitial state. Therefore a class may define a special method named\n__init__(), like this:\ndef __init__(self):\nself.data = []\nWhen a class defines an __init__() method, class instantiation\nautomatically invokes __init__() for the newly created class instance.  So\nin this example, a new, initialized instance can be obtained by:\nx = MyClass()\nOf course, the __init__() method may have arguments for greater\nflexibility.  In that case, arguments given to the class instantiation operator\nare passed on to __init__().  For example,\n>>> class Complex:\n...     def __init__(self, realpart, imagpart):\n...         self.r = realpart\n...         self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n9.3.3. Instance ObjectsÂ¶\nNow what can we do with instance objects?  The only operations understood by\ninstance objects are attribute references.  There are two kinds of valid\nattribute names: data attributes and methods.\ndata attributes correspond to âinstance variablesâ in Smalltalk, and to âdata\nmembersâ in C++.  Data attributes need not be declared; like local variables,\nthey spring into existence when they are first assigned to.  For example, if\nx is the instance of MyClass created above, the following piece of\ncode will print the value 16, without leaving a trace:\nx.counter = 1\nwhile x.counter < 10:\nx.counter = x.counter * 2\nprint(x.counter)\ndel x.counter\nThe other kind of instance attribute reference is a method. A method is a\nfunction that âbelongs toâ an object.\nValid method names of an instance object depend on its class.  By definition,\nall attributes of a class that are function  objects define corresponding\nmethods of its instances.  So in our example, x.f is a valid method\nreference, since MyClass.f is a function, but x.i is not, since\nMyClass.i is not.  But x.f is not the same thing as MyClass.f â it\nis a method object, not a function object.\n9.3.4. Method ObjectsÂ¶\nUsually, a method is called right after it is bound:\nx.f()\nIn the MyClass example, this will return the string 'hello world'.\nHowever, it is not necessary to call a method right away: x.f is a method\nobject, and can be stored away and called at a later time.  For example:\nxf = x.f\nwhile True:\nprint(xf())\nwill continue to print hello world until the end of time.\nWhat exactly happens when a method is called?  You may have noticed that\nx.f() was called without an argument above, even though the function\ndefinition for f() specified an argument.  What happened to the argument?\nSurely Python raises an exception when a function that requires an argument is\ncalled without any â even if the argument isnât actually usedâ¦\nActually, you may have guessed the answer: the special thing about methods is\nthat the instance object is passed as the first argument of the function.  In our\nexample, the call x.f() is exactly equivalent to MyClass.f(x).  In"
      },
      {
        "chunk_id": "python_docs_classes_chunk_4",
        "original_index": 4,
        "content": "that the instance object is passed as the first argument of the function.  In our\nexample, the call x.f() is exactly equivalent to MyClass.f(x).  In\ngeneral, calling a method with a list of n arguments is equivalent to calling\nthe corresponding function with an argument list that is created by inserting\nthe methodâs instance object before the first argument.\nIn general, methods work as follows.  When a non-data attribute\nof an instance is referenced, the instanceâs class is searched.\nIf the name denotes a valid class attribute that is a function object,\nreferences to both the instance object and the function object\nare packed into a method object.  When the method object is called\nwith an argument list, a new argument list is constructed from the instance\nobject and the argument list, and the function object is called with this new\nargument list.\n9.3.5. Class and Instance VariablesÂ¶\nGenerally speaking, instance variables are for data unique to each instance\nand class variables are for attributes and methods shared by all instances\nof the class:\nclass Dog:\nkind = 'canine'         # class variable shared by all instances\ndef __init__(self, name):\nself.name = name    # instance variable unique to each instance\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\nAs discussed in A Word About Names and Objects, shared data can have possibly surprising\neffects with involving mutable objects such as lists and dictionaries.\nFor example, the tricks list in the following code should not be used as a\nclass variable because just a single list would be shared by all Dog\ninstances:\nclass Dog:\ntricks = []             # mistaken use of a class variable\ndef __init__(self, name):\nself.name = name\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\nCorrect design of the class should use an instance variable instead:\nclass Dog:\ndef __init__(self, name):\nself.name = name\nself.tricks = []    # creates a new empty list for each dog\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n9.4. Random RemarksÂ¶\nIf the same attribute name occurs in both an instance and in a class,\nthen attribute lookup prioritizes the instance:\n>>> class Warehouse:\n...    purpose = 'storage'\n...    region = 'west'\n...\n>>> w1 = Warehouse()\n>>> print(w1.purpose, w1.region)\nstorage west\n>>> w2 = Warehouse()\n>>> w2.region = 'east'\n>>> print(w2.purpose, w2.region)\nstorage east\nData attributes may be referenced by methods as well as by ordinary users\n(âclientsâ) of an object.  In other words, classes are not usable to implement\npure abstract data types.  In fact, nothing in Python makes it possible to\nenforce data hiding â it is all based upon convention.  (On the other hand,\nthe Python implementation, written in C, can completely hide implementation\ndetails and control access to an object if necessary; this can be used by\nextensions to Python written in C.)\nClients should use data attributes with care â clients may mess up invariants\nmaintained by the methods by stamping on their data attributes.  Note that\nclients may add data attributes of their own to an instance object without\naffecting the validity of the methods, as long as name conflicts are avoided â\nagain, a naming convention can save a lot of headaches here.\nThere is no shorthand for referencing data attributes (or other methods!) from\nwithin methods.  I find that this actually increases the readability of methods:"
      },
      {
        "chunk_id": "python_docs_classes_chunk_5",
        "original_index": 5,
        "content": "There is no shorthand for referencing data attributes (or other methods!) from\nwithin methods.  I find that this actually increases the readability of methods:\nthere is no chance of confusing local variables and instance variables when\nglancing through a method.\nOften, the first argument of a method is called self.  This is nothing more\nthan a convention: the name self has absolutely no special meaning to\nPython.  Note, however, that by not following the convention your code may be\nless readable to other Python programmers, and it is also conceivable that a\nclass browser program might be written that relies upon such a convention.\nAny function object that is a class attribute defines a method for instances of\nthat class.  It is not necessary that the function definition is textually\nenclosed in the class definition: assigning a function object to a local\nvariable in the class is also ok.  For example:\n# Function defined outside the class\ndef f1(self, x, y):\nreturn min(x, x+y)\nclass C:\nf = f1\ndef g(self):\nreturn 'hello world'\nh = g\nNow f, g and h are all attributes of class C that refer to\nfunction objects, and consequently they are all methods of instances of\nC â h being exactly equivalent to g.  Note that this practice\nusually only serves to confuse the reader of a program.\nMethods may call other methods by using method attributes of the self\nargument:\nclass Bag:\ndef __init__(self):\nself.data = []\ndef add(self, x):\nself.data.append(x)\ndef addtwice(self, x):\nself.add(x)\nself.add(x)\nMethods may reference global names in the same way as ordinary functions.  The\nglobal scope associated with a method is the module containing its\ndefinition.  (A class is never used as a global scope.)  While one\nrarely encounters a good reason for using global data in a method, there are\nmany legitimate uses of the global scope: for one thing, functions and modules\nimported into the global scope can be used by methods, as well as functions and\nclasses defined in it.  Usually, the class containing the method is itself\ndefined in this global scope, and in the next section weâll find some good\nreasons why a method would want to reference its own class.\nEach value is an object, and therefore has a class (also called its type).\nIt is stored as object.__class__.\n9.5. InheritanceÂ¶\nOf course, a language feature would not be worthy of the name âclassâ without\nsupporting inheritance.  The syntax for a derived class definition looks like\nthis:\nclass DerivedClassName(BaseClassName):\n<statement-1>\n.\n.\n.\n<statement-N>\nThe name BaseClassName must be defined in a\nnamespace accessible from the scope containing the\nderived class definition.  In place of a base class name, other arbitrary\nexpressions are also allowed.  This can be useful, for example, when the base\nclass is defined in another module:\nclass DerivedClassName(modname.BaseClassName):\nExecution of a derived class definition proceeds the same as for a base class.\nWhen the class object is constructed, the base class is remembered.  This is\nused for resolving attribute references: if a requested attribute is not found\nin the class, the search proceeds to look in the base class.  This rule is\napplied recursively if the base class itself is derived from some other class.\nThereâs nothing special about instantiation of derived classes:\nDerivedClassName() creates a new instance of the class.  Method references\nare resolved as follows: the corresponding class attribute is searched,\ndescending down the chain of base classes if necessary, and the method reference\nis valid if this yields a function object.\nDerived classes may override methods of their base classes.  Because methods\nhave no special privileges when calling other methods of the same object, a\nmethod of a base class that calls another method defined in the same base class\nmay end up calling a method of a derived class that overrides it.  (For C++\nprogrammers: all methods in Python are effectively virtual.)"
      },
      {
        "chunk_id": "python_docs_classes_chunk_6",
        "original_index": 6,
        "content": "may end up calling a method of a derived class that overrides it.  (For C++\nprogrammers: all methods in Python are effectively virtual.)\nAn overriding method in a derived class may in fact want to extend rather than\nsimply replace the base class method of the same name. There is a simple way to\ncall the base class method directly: just call BaseClassName.methodname(self,\narguments).  This is occasionally useful to clients as well.  (Note that this\nonly works if the base class is accessible as BaseClassName in the global\nscope.)\nPython has two built-in functions that work with inheritance:\nUse isinstance() to check an instanceâs type: isinstance(obj, int)\nwill be True only if obj.__class__ is int or some class\nderived from int.\nUse issubclass() to check class inheritance: issubclass(bool, int)\nis True since bool is a subclass of int.  However,\nissubclass(float, int) is False since float is not a\nsubclass of int.\n9.5.1. Multiple InheritanceÂ¶\nPython supports a form of multiple inheritance as well.  A class definition with\nmultiple base classes looks like this:\nclass DerivedClassName(Base1, Base2, Base3):\n<statement-1>\n.\n.\n.\n<statement-N>\nFor most purposes, in the simplest cases, you can think of the search for\nattributes inherited from a parent class as depth-first, left-to-right, not\nsearching twice in the same class where there is an overlap in the hierarchy.\nThus, if an attribute is not found in DerivedClassName, it is searched\nfor in Base1, then (recursively) in the base classes of Base1,\nand if it was not found there, it was searched for in Base2, and so on.\nIn fact, it is slightly more complex than that; the method resolution order\nchanges dynamically to support cooperative calls to super().  This\napproach is known in some other multiple-inheritance languages as\ncall-next-method and is more powerful than the super call found in\nsingle-inheritance languages.\nDynamic ordering is necessary because all cases of multiple inheritance exhibit\none or more diamond relationships (where at least one of the parent classes\ncan be accessed through multiple paths from the bottommost class).  For example,\nall classes inherit from object, so any case of multiple inheritance\nprovides more than one path to reach object.  To keep the base classes\nfrom being accessed more than once, the dynamic algorithm linearizes the search\norder in a way that preserves the left-to-right ordering specified in each\nclass, that calls each parent only once, and that is monotonic (meaning that a\nclass can be subclassed without affecting the precedence order of its parents).\nTaken together, these properties make it possible to design reliable and\nextensible classes with multiple inheritance.  For more detail, see\nThe Python 2.3 Method Resolution Order.\n9.6. Private VariablesÂ¶\nâPrivateâ instance variables that cannot be accessed except from inside an\nobject donât exist in Python.  However, there is a convention that is followed\nby most Python code: a name prefixed with an underscore (e.g. _spam) should\nbe treated as a non-public part of the API (whether it is a function, a method\nor a data member).  It should be considered an implementation detail and subject\nto change without notice.\nSince there is a valid use-case for class-private members (namely to avoid name\nclashes of names with names defined by subclasses), there is limited support for\nsuch a mechanism, called name mangling.  Any identifier of the form\n__spam (at least two leading underscores, at most one trailing underscore)\nis textually replaced with _classname__spam, where classname is the\ncurrent class name with leading underscore(s) stripped.  This mangling is done\nwithout regard to the syntactic position of the identifier, as long as it\noccurs within the definition of a class.\nSee also\nThe private name mangling specifications\nfor details and special cases.\nName mangling is helpful for letting subclasses override methods without\nbreaking intraclass method calls.  For example:\nclass Mapping:"
      },
      {
        "chunk_id": "python_docs_classes_chunk_7",
        "original_index": 7,
        "content": "for details and special cases.\nName mangling is helpful for letting subclasses override methods without\nbreaking intraclass method calls.  For example:\nclass Mapping:\ndef __init__(self, iterable):\nself.items_list = []\nself.__update(iterable)\ndef update(self, iterable):\nfor item in iterable:\nself.items_list.append(item)\n__update = update   # private copy of original update() method\nclass MappingSubclass(Mapping):\ndef update(self, keys, values):\n# provides new signature for update()\n# but does not break __init__()\nfor item in zip(keys, values):\nself.items_list.append(item)\nThe above example would work even if MappingSubclass were to introduce a\n__update identifier since it is replaced with _Mapping__update in the\nMapping class  and _MappingSubclass__update in the MappingSubclass\nclass respectively.\nNote that the mangling rules are designed mostly to avoid accidents; it still is\npossible to access or modify a variable that is considered private.  This can\neven be useful in special circumstances, such as in the debugger.\nNotice that code passed to exec() or eval() does not consider the\nclassname of the invoking class to be the current class; this is similar to the\neffect of the global statement, the effect of which is likewise restricted\nto code that is byte-compiled together.  The same restriction applies to\ngetattr(), setattr() and delattr(), as well as when referencing\n__dict__ directly.\n9.7. Odds and EndsÂ¶\nSometimes it is useful to have a data type similar to the Pascal ârecordâ or C\nâstructâ, bundling together a few named data items. The idiomatic approach\nis to use dataclasses for this purpose:\nfrom dataclasses import dataclass\n@dataclass\nclass Employee:\nname: str\ndept: str\nsalary: int\n>>> john = Employee('john', 'computer lab', 1000)\n>>> john.dept\n'computer lab'\n>>> john.salary\n1000\nA piece of Python code that expects a particular abstract data type can often be\npassed a class that emulates the methods of that data type instead.  For\ninstance, if you have a function that formats some data from a file object, you\ncan define a class with methods read() and\nreadline() that get the\ndata from a string buffer instead, and pass it as an argument.\nInstance method objects have attributes, too:\nm.__self__ is the instance\nobject with the method m(), and m.__func__ is\nthe function object\ncorresponding to the method.\n9.8. IteratorsÂ¶\nBy now you have probably noticed that most container objects can be looped over\nusing a for statement:\nfor element in [1, 2, 3]:\nprint(element)\nfor element in (1, 2, 3):\nprint(element)\nfor key in {'one':1, 'two':2}:\nprint(key)\nfor char in \"123\":\nprint(char)\nfor line in open(\"myfile.txt\"):\nprint(line, end='')\nThis style of access is clear, concise, and convenient.  The use of iterators\npervades and unifies Python.  Behind the scenes, the for statement\ncalls iter() on the container object.  The function returns an iterator\nobject that defines the method __next__() which accesses\nelements in the container one at a time.  When there are no more elements,\n__next__() raises a StopIteration exception which tells the\nfor loop to terminate.  You can call the __next__() method\nusing the next() built-in function; this example shows how it all works:\n>>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<str_iterator object at 0x10c90e650>\n>>> next(it)\n'a'\n>>> next(it)\n'b'\n>>> next(it)\n'c'\n>>> next(it)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nnext(it)\nStopIteration\nHaving seen the mechanics behind the iterator protocol, it is easy to add\niterator behavior to your classes.  Define an __iter__() method which\nreturns an object with a __next__() method.  If the class\ndefines __next__(), then __iter__() can just return self:\nclass Reverse:\n\"\"\"Iterator for looping over a sequence backwards.\"\"\"\ndef __init__(self, data):\nself.data = data\nself.index = len(data)\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.index == 0:\nraise StopIteration\nself.index = self.index - 1"
      },
      {
        "chunk_id": "python_docs_classes_chunk_8",
        "original_index": 8,
        "content": "def __init__(self, data):\nself.data = data\nself.index = len(data)\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.index == 0:\nraise StopIteration\nself.index = self.index - 1\nreturn self.data[self.index]\n>>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n...     print(char)\n...\nm\na\np\ns\n9.9. GeneratorsÂ¶\nGenerators are a simple and powerful tool for creating iterators.  They\nare written like regular functions but use the yield statement\nwhenever they want to return data.  Each time next() is called on it, the\ngenerator resumes where it left off (it remembers all the data values and which\nstatement was last executed).  An example shows that generators can be trivially\neasy to create:\ndef reverse(data):\nfor index in range(len(data)-1, -1, -1):\nyield data[index]\n>>> for char in reverse('golf'):\n...     print(char)\n...\nf\nl\no\ng\nAnything that can be done with generators can also be done with class-based\niterators as described in the previous section.  What makes generators so\ncompact is that the __iter__() and __next__() methods\nare created automatically.\nAnother key feature is that the local variables and execution state are\nautomatically saved between calls.  This made the function easier to write and\nmuch more clear than an approach using instance variables like self.index\nand self.data.\nIn addition to automatic method creation and saving program state, when\ngenerators terminate, they automatically raise StopIteration. In\ncombination, these features make it easy to create iterators with no more effort\nthan writing a regular function.\n9.10. Generator ExpressionsÂ¶\nSome simple generators can be coded succinctly as expressions using a syntax\nsimilar to list comprehensions but with parentheses instead of square brackets.\nThese expressions are designed for situations where the generator is used right\naway by an enclosing function.  Generator expressions are more compact but less\nversatile than full generator definitions and tend to be more memory friendly\nthan equivalent list comprehensions.\nExamples:\n>>> sum(i*i for i in range(10))                 # sum of squares\n285\n>>> xvec = [10, 20, 30]\n>>> yvec = [7, 5, 3]\n>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n260\n>>> unique_words = set(word for line in page  for word in line.split())\n>>> valedictorian = max((student.gpa, student.name) for student in graduates)\n>>> data = 'golf'\n>>> list(data[i] for i in range(len(data)-1, -1, -1))\n['f', 'l', 'o', 'g']\nFootnotes\n[1]\nExcept for one thing.  Module objects have a secret read-only attribute called\n__dict__ which returns the dictionary used to implement the moduleâs\nnamespace; the name __dict__ is an attribute but not a global name.\nObviously, using this violates the abstraction of namespace implementation, and\nshould be restricted to things like post-mortem debuggers."
      }
    ]
  },
  {
    "doc_id": "python_docs_modules",
    "original_uuid": "1d5c",
    "content": "6. ModulesÂ¶\nIf you quit from the Python interpreter and enter it again, the definitions you\nhave made (functions and variables) are lost. Therefore, if you want to write a\nsomewhat longer program, you are better off using a text editor to prepare the\ninput for the interpreter and running it with that file as input instead.  This\nis known as creating a script.  As your program gets longer, you may want to\nsplit it into several files for easier maintenance.  You may also want to use a\nhandy function that youâve written in several programs without copying its\ndefinition into each program.\nTo support this, Python has a way to put definitions in a file and use them in a\nscript or in an interactive instance of the interpreter. Such a file is called a\nmodule; definitions from a module can be imported into other modules or into\nthe main module (the collection of variables that you have access to in a\nscript executed at the top level and in calculator mode).\nA module is a file containing Python definitions and statements.  The file name\nis the module name with the suffix .py appended.  Within a module, the\nmoduleâs name (as a string) is available as the value of the global variable\n__name__.  For instance, use your favorite text editor to create a file\ncalled fibo.py in the current directory with the following contents:\n# Fibonacci numbers module\ndef fib(n):    # write Fibonacci series up to n\na, b = 0, 1\nwhile a < n:\nprint(a, end=' ')\na, b = b, a+b\nprint()\ndef fib2(n):   # return Fibonacci series up to n\nresult = []\na, b = 0, 1\nwhile a < n:\nresult.append(a)\na, b = b, a+b\nreturn result\nNow enter the Python interpreter and import this module with the following\ncommand:\n>>> import fibo\nThis does not add the names of the functions defined in fibo  directly to\nthe current namespace (see Python Scopes and Namespaces for more details);\nit only adds the module name fibo there. Using\nthe module name you can access the functions:\n>>> fibo.fib(1000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\nIf you intend to use a function often you can assign it to a local name:\n>>> fib = fibo.fib\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n6.1. More on ModulesÂ¶\nA module can contain executable statements as well as function definitions.\nThese statements are intended to initialize the module. They are executed only\nthe first time the module name is encountered in an import statement. [1]\n(They are also run if the file is executed as a script.)\nEach module has its own private namespace, which is used as the global namespace\nby all functions defined in the module. Thus, the author of a module can\nuse global variables in the module without worrying about accidental clashes\nwith a userâs global variables. On the other hand, if you know what you are\ndoing you can touch a moduleâs global variables with the same notation used to\nrefer to its functions, modname.itemname.\nModules can import other modules.  It is customary but not required to place all\nimport statements at the beginning of a module (or script, for that\nmatter).  The imported module names, if placed at the top level of a module\n(outside any functions or classes), are added to the moduleâs global namespace.\nThere is a variant of the import statement that imports names from a\nmodule directly into the importing moduleâs namespace.  For example:\n>>> from fibo import fib, fib2\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis does not introduce the module name from which the imports are taken in the\nlocal namespace (so in the example, fibo is not defined).\nThere is even a variant to import all names that a module defines:\n>>> from fibo import *\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis imports all names except those beginning with an underscore (_).\nIn most cases Python programmers do not use this facility since it introduces\nan unknown set of names into the interpreter, possibly hiding some things\nyou have already defined.\nNote that in general the practice of importing * from a module or package is\nfrowned upon, since it often causes poorly readable code. However, it is okay to\nuse it to save typing in interactive sessions.\nIf the module name is followed by as, then the name\nfollowing as is bound directly to the imported module.\n>>> import fibo as fib\n>>> fib.fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis is effectively importing the module in the same way that import fibo\nwill do, with the only difference of it being available as fib.\nIt can also be used when utilising from with similar effects:\n>>> from fibo import fib as fibonacci\n>>> fibonacci(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nNote\nFor efficiency reasons, each module is only imported once per interpreter\nsession.  Therefore, if you change your modules, you must restart the\ninterpreter â or, if itâs just one module you want to test interactively,\nuse importlib.reload(), e.g. import importlib;\nimportlib.reload(modulename).\n6.1.1. Executing modules as scriptsÂ¶\nWhen you run a Python module with\npython fibo.py <arguments>\nthe code in the module will be executed, just as if you imported it, but with\nthe __name__ set to \"__main__\".  That means that by adding this code at\nthe end of your module:\nif __name__ == \"__main__\":\nimport sys\nfib(int(sys.argv[1]))\nyou can make the file usable as a script as well as an importable module,\nbecause the code that parses the command line only runs if the module is\nexecuted as the âmainâ file:\n$ python fibo.py 50\n0 1 1 2 3 5 8 13 21 34\nIf the module is imported, the code is not run:\n>>> import fibo\n>>>\nThis is often used either to provide a convenient user interface to a module, or\nfor testing purposes (running the module as a script executes a test suite).\n6.1.2. The Module Search PathÂ¶\nWhen a module named spam is imported, the interpreter first searches for\na built-in module with that name. These module names are listed in\nsys.builtin_module_names. If not found, it then searches for a file\nnamed spam.py in a list of directories given by the variable\nsys.path.  sys.path is initialized from these locations:\nThe directory containing the input script (or the current directory when no\nfile is specified).\nPYTHONPATH (a list of directory names, with the same syntax as the\nshell variable PATH).\nThe installation-dependent default (by convention including a\nsite-packages directory, handled by the site module).\nMore details are at The initialization of the sys.path module search path.\nNote\nOn file systems which support symlinks, the directory containing the input\nscript is calculated after the symlink is followed. In other words the\ndirectory containing the symlink is not added to the module search path.\nAfter initialization, Python programs can modify sys.path.  The\ndirectory containing the script being run is placed at the beginning of the\nsearch path, ahead of the standard library path. This means that scripts in that\ndirectory will be loaded instead of modules of the same name in the library\ndirectory. This is an error unless the replacement is intended.  See section\nStandard Modules for more information.\n6.1.3. âCompiledâ Python filesÂ¶\nTo speed up loading modules, Python caches the compiled version of each module\nin the __pycache__ directory under the name module.version.pyc,\nwhere the version encodes the format of the compiled file; it generally contains\nthe Python version number.  For example, in CPython release 3.3 the compiled\nversion of spam.py would be cached as __pycache__/spam.cpython-33.pyc.  This\nnaming convention allows compiled modules from different releases and different\nversions of Python to coexist.\nPython checks the modification date of the source against the compiled version\nto see if itâs out of date and needs to be recompiled.  This is a completely\nautomatic process.  Also, the compiled modules are platform-independent, so the\nsame library can be shared among systems with different architectures.\nPython does not check the cache in two circumstances.  First, it always\nrecompiles and does not store the result for the module thatâs loaded directly\nfrom the command line.  Second, it does not check the cache if there is no\nsource module.  To support a non-source (compiled only) distribution, the\ncompiled module must be in the source directory, and there must not be a source\nmodule.\nSome tips for experts:\nYou can use the -O or -OO switches on the Python command\nto reduce the size of a compiled module.  The -O switch removes assert\nstatements, the -OO switch removes both assert statements and __doc__\nstrings.  Since some programs may rely on having these available, you should\nonly use this option if you know what youâre doing.  âOptimizedâ modules have\nan opt- tag and are usually smaller.  Future releases may\nchange the effects of optimization.\nA program doesnât run any faster when it is read from a .pyc\nfile than when it is read from a .py file; the only thing thatâs faster\nabout .pyc files is the speed with which they are loaded.\nThe module compileall can create .pyc files for all modules in a\ndirectory.\nThere is more detail on this process, including a flow chart of the\ndecisions, in PEP 3147.\n6.2. Standard ModulesÂ¶\nPython comes with a library of standard modules, described in a separate\ndocument, the Python Library Reference (âLibrary Referenceâ hereafter).  Some\nmodules are built into the interpreter; these provide access to operations that\nare not part of the core of the language but are nevertheless built in, either\nfor efficiency or to provide access to operating system primitives such as\nsystem calls.  The set of such modules is a configuration option which also\ndepends on the underlying platform.  For example, the winreg module is only\nprovided on Windows systems. One particular module deserves some attention:\nsys, which is built into every Python interpreter.  The variables\nsys.ps1 and sys.ps2 define the strings used as primary and secondary\nprompts:\n>>> import sys\n>>> sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print('Yuck!')\nYuck!\nC>\nThese two variables are only defined if the interpreter is in interactive mode.\nThe variable sys.path is a list of strings that determines the interpreterâs\nsearch path for modules. It is initialized to a default path taken from the\nenvironment variable PYTHONPATH, or from a built-in default if\nPYTHONPATH is not set.  You can modify it using standard list\noperations:\n>>> import sys\n>>> sys.path.append('/ufs/guido/lib/python')\n6.3. The dir() FunctionÂ¶\nThe built-in function dir() is used to find out which names a module\ndefines.  It returns a sorted list of strings:\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)\n['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n'__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n'__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n'_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n'_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',\n'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n'warnoptions']\nWithout arguments, dir() lists the names you have defined currently:\n>>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir()\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']\nNote that it lists all types of names: variables, modules, functions, etc.\ndir() does not list the names of built-in functions and variables.  If you\nwant a list of those, they are defined in the standard module\nbuiltins:\n>>> import builtins\n>>> dir(builtins)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n'NotImplementedError', 'OSError', 'OverflowError',\n'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n'__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n'zip']\n6.4. PackagesÂ¶\nPackages are a way of structuring Pythonâs module namespace by using âdotted\nmodule namesâ.  For example, the module name A.B designates a submodule\nnamed B in a package named A.  Just like the use of modules saves the\nauthors of different modules from having to worry about each otherâs global\nvariable names, the use of dotted module names saves the authors of multi-module\npackages like NumPy or Pillow from having to worry about\neach otherâs module names.\nSuppose you want to design a collection of modules (a âpackageâ) for the uniform\nhandling of sound files and sound data.  There are many different sound file\nformats (usually recognized by their extension, for example: .wav,\n.aiff, .au), so you may need to create and maintain a growing\ncollection of modules for the conversion between the various file formats.\nThere are also many different operations you might want to perform on sound data\n(such as mixing, adding echo, applying an equalizer function, creating an\nartificial stereo effect), so in addition you will be writing a never-ending\nstream of modules to perform these operations.  Hereâs a possible structure for\nyour package (expressed in terms of a hierarchical filesystem):\nsound/                          Top-level package\n__init__.py               Initialize the sound package\nformats/                  Subpackage for file format conversions\n__init__.py\nwavread.py\nwavwrite.py\naiffread.py\naiffwrite.py\nauread.py\nauwrite.py\n...\neffects/                  Subpackage for sound effects\n__init__.py\necho.py\nsurround.py\nreverse.py\n...\nfilters/                  Subpackage for filters\n__init__.py\nequalizer.py\nvocoder.py\nkaraoke.py\n...\nWhen importing the package, Python searches through the directories on\nsys.path looking for the package subdirectory.\nThe __init__.py files are required to make Python treat directories\ncontaining the file as packages (unless using a namespace package, a\nrelatively advanced feature). This prevents directories with a common name,\nsuch as string, from unintentionally hiding valid modules that occur later\non the module search path. In the simplest case, __init__.py can just be\nan empty file, but it can also execute initialization code for the package or\nset the __all__ variable, described later.\nUsers of the package can import individual modules from the package, for\nexample:\nimport sound.effects.echo\nThis loads the submodule sound.effects.echo.  It must be referenced with\nits full name.\nsound.effects.echo.echofilter(input, output, delay=0.7, atten=4)\nAn alternative way of importing the submodule is:\nfrom sound.effects import echo\nThis also loads the submodule echo, and makes it available without its\npackage prefix, so it can be used as follows:\necho.echofilter(input, output, delay=0.7, atten=4)\nYet another variation is to import the desired function or variable directly:\nfrom sound.effects.echo import echofilter\nAgain, this loads the submodule echo, but this makes its function\nechofilter() directly available:\nechofilter(input, output, delay=0.7, atten=4)\nNote that when using from package import item, the item can be either a\nsubmodule (or subpackage) of the package, or some  other name defined in the\npackage, like a function, class or variable.  The import statement first\ntests whether the item is defined in the package; if not, it assumes it is a\nmodule and attempts to load it.  If it fails to find it, an ImportError\nexception is raised.\nContrarily, when using syntax like import item.subitem.subsubitem, each item\nexcept for the last must be a package; the last item can be a module or a\npackage but canât be a class or function or variable defined in the previous\nitem.\n6.4.1. Importing * From a PackageÂ¶\nNow what happens when the user writes from sound.effects import *?  Ideally,\none would hope that this somehow goes out to the filesystem, finds which\nsubmodules are present in the package, and imports them all.  This could take a\nlong time and importing sub-modules might have unwanted side-effects that should\nonly happen when the sub-module is explicitly imported.\nThe only solution is for the package author to provide an explicit index of the\npackage.  The import statement uses the following convention: if a packageâs\n__init__.py code defines a list named __all__, it is taken to be the\nlist of module names that should be imported when from package import * is\nencountered.  It is up to the package author to keep this list up-to-date when a\nnew version of the package is released.  Package authors may also decide not to\nsupport it, if they donât see a use for importing * from their package.  For\nexample, the file sound/effects/__init__.py could contain the following\ncode:\n__all__ = [\"echo\", \"surround\", \"reverse\"]\nThis would mean that from sound.effects import * would import the three\nnamed submodules of the sound.effects package.\nBe aware that submodules might become shadowed by locally defined names. For\nexample, if you added a reverse function to the\nsound/effects/__init__.py file, the from sound.effects import *\nwould only import the two submodules echo and surround, but not the\nreverse submodule, because it is shadowed by the locally defined\nreverse function:\n__all__ = [\n\"echo\",      # refers to the 'echo.py' file\n\"surround\",  # refers to the 'surround.py' file\n\"reverse\",   # !!! refers to the 'reverse' function now !!!\n]\ndef reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule\nreturn msg[::-1]    #     in the case of a 'from sound.effects import *'\nIf __all__ is not defined, the statement from sound.effects import *\ndoes not import all submodules from the package sound.effects into the\ncurrent namespace; it only ensures that the package sound.effects has\nbeen imported (possibly running any initialization code in __init__.py)\nand then imports whatever names are defined in the package.  This includes any\nnames defined (and submodules explicitly loaded) by __init__.py.  It\nalso includes any submodules of the package that were explicitly loaded by\nprevious import statements.  Consider this code:\nimport sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import *\nIn this example, the echo and surround modules are imported in the\ncurrent namespace because they are defined in the sound.effects package\nwhen the from...import statement is executed.  (This also works when\n__all__ is defined.)\nAlthough certain modules are designed to export only names that follow certain\npatterns when you use import *, it is still considered bad practice in\nproduction code.\nRemember, there is nothing wrong with using from package import\nspecific_submodule!  In fact, this is the recommended notation unless the\nimporting module needs to use submodules with the same name from different\npackages.\n6.4.2. Intra-package ReferencesÂ¶\nWhen packages are structured into subpackages (as with the sound package\nin the example), you can use absolute imports to refer to submodules of siblings\npackages.  For example, if the module sound.filters.vocoder needs to use\nthe echo module in the sound.effects package, it can use from\nsound.effects import echo.\nYou can also write relative imports, with the from module import name form\nof import statement.  These imports use leading dots to indicate the current and\nparent packages involved in the relative import.  From the surround\nmodule for example, you might use:\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\nNote that relative imports are based on the name of the current module.  Since\nthe name of the main module is always \"__main__\", modules intended for use\nas the main module of a Python application must always use absolute imports.\n6.4.3. Packages in Multiple DirectoriesÂ¶\nPackages support one more special attribute, __path__.  This is\ninitialized to be a sequence of strings containing the name of the\ndirectory holding the\npackageâs __init__.py before the code in that file is executed.  This\nvariable can be modified; doing so affects future searches for modules and\nsubpackages contained in the package.\nWhile this feature is not often needed, it can be used to extend the set of\nmodules found in a package.\nFootnotes\n[1]\nIn fact function definitions are also âstatementsâ that are âexecutedâ; the\nexecution of a module-level function definition adds the function name to\nthe moduleâs global namespace.",
    "chunks": [
      {
        "chunk_id": "python_docs_modules_chunk_0",
        "original_index": 0,
        "content": "6. ModulesÂ¶\nIf you quit from the Python interpreter and enter it again, the definitions you\nhave made (functions and variables) are lost. Therefore, if you want to write a\nsomewhat longer program, you are better off using a text editor to prepare the\ninput for the interpreter and running it with that file as input instead.  This\nis known as creating a script.  As your program gets longer, you may want to\nsplit it into several files for easier maintenance.  You may also want to use a\nhandy function that youâve written in several programs without copying its\ndefinition into each program.\nTo support this, Python has a way to put definitions in a file and use them in a\nscript or in an interactive instance of the interpreter. Such a file is called a\nmodule; definitions from a module can be imported into other modules or into\nthe main module (the collection of variables that you have access to in a\nscript executed at the top level and in calculator mode).\nA module is a file containing Python definitions and statements.  The file name\nis the module name with the suffix .py appended.  Within a module, the\nmoduleâs name (as a string) is available as the value of the global variable\n__name__.  For instance, use your favorite text editor to create a file\ncalled fibo.py in the current directory with the following contents:\n# Fibonacci numbers module\ndef fib(n):    # write Fibonacci series up to n\na, b = 0, 1\nwhile a < n:\nprint(a, end=' ')\na, b = b, a+b\nprint()\ndef fib2(n):   # return Fibonacci series up to n\nresult = []\na, b = 0, 1\nwhile a < n:\nresult.append(a)\na, b = b, a+b\nreturn result\nNow enter the Python interpreter and import this module with the following\ncommand:\n>>> import fibo\nThis does not add the names of the functions defined in fibo  directly to\nthe current namespace (see Python Scopes and Namespaces for more details);\nit only adds the module name fibo there. Using\nthe module name you can access the functions:\n>>> fibo.fib(1000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\nIf you intend to use a function often you can assign it to a local name:\n>>> fib = fibo.fib\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n6.1. More on ModulesÂ¶\nA module can contain executable statements as well as function definitions.\nThese statements are intended to initialize the module. They are executed only\nthe first time the module name is encountered in an import statement. [1]\n(They are also run if the file is executed as a script.)\nEach module has its own private namespace, which is used as the global namespace\nby all functions defined in the module. Thus, the author of a module can\nuse global variables in the module without worrying about accidental clashes\nwith a userâs global variables. On the other hand, if you know what you are\ndoing you can touch a moduleâs global variables with the same notation used to\nrefer to its functions, modname.itemname.\nModules can import other modules.  It is customary but not required to place all\nimport statements at the beginning of a module (or script, for that\nmatter).  The imported module names, if placed at the top level of a module\n(outside any functions or classes), are added to the moduleâs global namespace.\nThere is a variant of the import statement that imports names from a\nmodule directly into the importing moduleâs namespace.  For example:\n>>> from fibo import fib, fib2\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis does not introduce the module name from which the imports are taken in the\nlocal namespace (so in the example, fibo is not defined).\nThere is even a variant to import all names that a module defines:\n>>> from fibo import *\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis imports all names except those beginning with an underscore (_).\nIn most cases Python programmers do not use this facility since it introduces"
      },
      {
        "chunk_id": "python_docs_modules_chunk_1",
        "original_index": 1,
        "content": "0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis imports all names except those beginning with an underscore (_).\nIn most cases Python programmers do not use this facility since it introduces\nan unknown set of names into the interpreter, possibly hiding some things\nyou have already defined.\nNote that in general the practice of importing * from a module or package is\nfrowned upon, since it often causes poorly readable code. However, it is okay to\nuse it to save typing in interactive sessions.\nIf the module name is followed by as, then the name\nfollowing as is bound directly to the imported module.\n>>> import fibo as fib\n>>> fib.fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis is effectively importing the module in the same way that import fibo\nwill do, with the only difference of it being available as fib.\nIt can also be used when utilising from with similar effects:\n>>> from fibo import fib as fibonacci\n>>> fibonacci(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nNote\nFor efficiency reasons, each module is only imported once per interpreter\nsession.  Therefore, if you change your modules, you must restart the\ninterpreter â or, if itâs just one module you want to test interactively,\nuse importlib.reload(), e.g. import importlib;\nimportlib.reload(modulename).\n6.1.1. Executing modules as scriptsÂ¶\nWhen you run a Python module with\npython fibo.py <arguments>\nthe code in the module will be executed, just as if you imported it, but with\nthe __name__ set to \"__main__\".  That means that by adding this code at\nthe end of your module:\nif __name__ == \"__main__\":\nimport sys\nfib(int(sys.argv[1]))\nyou can make the file usable as a script as well as an importable module,\nbecause the code that parses the command line only runs if the module is\nexecuted as the âmainâ file:\n$ python fibo.py 50\n0 1 1 2 3 5 8 13 21 34\nIf the module is imported, the code is not run:\n>>> import fibo\n>>>\nThis is often used either to provide a convenient user interface to a module, or\nfor testing purposes (running the module as a script executes a test suite).\n6.1.2. The Module Search PathÂ¶\nWhen a module named spam is imported, the interpreter first searches for\na built-in module with that name. These module names are listed in\nsys.builtin_module_names. If not found, it then searches for a file\nnamed spam.py in a list of directories given by the variable\nsys.path.  sys.path is initialized from these locations:\nThe directory containing the input script (or the current directory when no\nfile is specified).\nPYTHONPATH (a list of directory names, with the same syntax as the\nshell variable PATH).\nThe installation-dependent default (by convention including a\nsite-packages directory, handled by the site module).\nMore details are at The initialization of the sys.path module search path.\nNote\nOn file systems which support symlinks, the directory containing the input\nscript is calculated after the symlink is followed. In other words the\ndirectory containing the symlink is not added to the module search path.\nAfter initialization, Python programs can modify sys.path.  The\ndirectory containing the script being run is placed at the beginning of the\nsearch path, ahead of the standard library path. This means that scripts in that\ndirectory will be loaded instead of modules of the same name in the library\ndirectory. This is an error unless the replacement is intended.  See section\nStandard Modules for more information.\n6.1.3. âCompiledâ Python filesÂ¶\nTo speed up loading modules, Python caches the compiled version of each module\nin the __pycache__ directory under the name module.version.pyc,\nwhere the version encodes the format of the compiled file; it generally contains\nthe Python version number.  For example, in CPython release 3.3 the compiled\nversion of spam.py would be cached as __pycache__/spam.cpython-33.pyc.  This\nnaming convention allows compiled modules from different releases and different\nversions of Python to coexist."
      },
      {
        "chunk_id": "python_docs_modules_chunk_2",
        "original_index": 2,
        "content": "version of spam.py would be cached as __pycache__/spam.cpython-33.pyc.  This\nnaming convention allows compiled modules from different releases and different\nversions of Python to coexist.\nPython checks the modification date of the source against the compiled version\nto see if itâs out of date and needs to be recompiled.  This is a completely\nautomatic process.  Also, the compiled modules are platform-independent, so the\nsame library can be shared among systems with different architectures.\nPython does not check the cache in two circumstances.  First, it always\nrecompiles and does not store the result for the module thatâs loaded directly\nfrom the command line.  Second, it does not check the cache if there is no\nsource module.  To support a non-source (compiled only) distribution, the\ncompiled module must be in the source directory, and there must not be a source\nmodule.\nSome tips for experts:\nYou can use the -O or -OO switches on the Python command\nto reduce the size of a compiled module.  The -O switch removes assert\nstatements, the -OO switch removes both assert statements and __doc__\nstrings.  Since some programs may rely on having these available, you should\nonly use this option if you know what youâre doing.  âOptimizedâ modules have\nan opt- tag and are usually smaller.  Future releases may\nchange the effects of optimization.\nA program doesnât run any faster when it is read from a .pyc\nfile than when it is read from a .py file; the only thing thatâs faster\nabout .pyc files is the speed with which they are loaded.\nThe module compileall can create .pyc files for all modules in a\ndirectory.\nThere is more detail on this process, including a flow chart of the\ndecisions, in PEP 3147.\n6.2. Standard ModulesÂ¶\nPython comes with a library of standard modules, described in a separate\ndocument, the Python Library Reference (âLibrary Referenceâ hereafter).  Some\nmodules are built into the interpreter; these provide access to operations that\nare not part of the core of the language but are nevertheless built in, either\nfor efficiency or to provide access to operating system primitives such as\nsystem calls.  The set of such modules is a configuration option which also\ndepends on the underlying platform.  For example, the winreg module is only\nprovided on Windows systems. One particular module deserves some attention:\nsys, which is built into every Python interpreter.  The variables\nsys.ps1 and sys.ps2 define the strings used as primary and secondary\nprompts:\n>>> import sys\n>>> sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print('Yuck!')\nYuck!\nC>\nThese two variables are only defined if the interpreter is in interactive mode.\nThe variable sys.path is a list of strings that determines the interpreterâs\nsearch path for modules. It is initialized to a default path taken from the\nenvironment variable PYTHONPATH, or from a built-in default if\nPYTHONPATH is not set.  You can modify it using standard list\noperations:\n>>> import sys\n>>> sys.path.append('/ufs/guido/lib/python')\n6.3. The dir() FunctionÂ¶\nThe built-in function dir() is used to find out which names a module\ndefines.  It returns a sorted list of strings:\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)\n['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n'__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n'__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n'_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n'_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',\n'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',"
      },
      {
        "chunk_id": "python_docs_modules_chunk_3",
        "original_index": 3,
        "content": "'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n'warnoptions']\nWithout arguments, dir() lists the names you have defined currently:\n>>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir()\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']\nNote that it lists all types of names: variables, modules, functions, etc.\ndir() does not list the names of built-in functions and variables.  If you\nwant a list of those, they are defined in the standard module\nbuiltins:\n>>> import builtins\n>>> dir(builtins)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n'NotImplementedError', 'OSError', 'OverflowError',\n'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n'__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n'zip']\n6.4. PackagesÂ¶\nPackages are a way of structuring Pythonâs module namespace by using âdotted\nmodule namesâ.  For example, the module name A.B designates a submodule\nnamed B in a package named A.  Just like the use of modules saves the\nauthors of different modules from having to worry about each otherâs global\nvariable names, the use of dotted module names saves the authors of multi-module\npackages like NumPy or Pillow from having to worry about\neach otherâs module names.\nSuppose you want to design a collection of modules (a âpackageâ) for the uniform\nhandling of sound files and sound data.  There are many different sound file"
      },
      {
        "chunk_id": "python_docs_modules_chunk_4",
        "original_index": 4,
        "content": "each otherâs module names.\nSuppose you want to design a collection of modules (a âpackageâ) for the uniform\nhandling of sound files and sound data.  There are many different sound file\nformats (usually recognized by their extension, for example: .wav,\n.aiff, .au), so you may need to create and maintain a growing\ncollection of modules for the conversion between the various file formats.\nThere are also many different operations you might want to perform on sound data\n(such as mixing, adding echo, applying an equalizer function, creating an\nartificial stereo effect), so in addition you will be writing a never-ending\nstream of modules to perform these operations.  Hereâs a possible structure for\nyour package (expressed in terms of a hierarchical filesystem):\nsound/                          Top-level package\n__init__.py               Initialize the sound package\nformats/                  Subpackage for file format conversions\n__init__.py\nwavread.py\nwavwrite.py\naiffread.py\naiffwrite.py\nauread.py\nauwrite.py\n...\neffects/                  Subpackage for sound effects\n__init__.py\necho.py\nsurround.py\nreverse.py\n...\nfilters/                  Subpackage for filters\n__init__.py\nequalizer.py\nvocoder.py\nkaraoke.py\n...\nWhen importing the package, Python searches through the directories on\nsys.path looking for the package subdirectory.\nThe __init__.py files are required to make Python treat directories\ncontaining the file as packages (unless using a namespace package, a\nrelatively advanced feature). This prevents directories with a common name,\nsuch as string, from unintentionally hiding valid modules that occur later\non the module search path. In the simplest case, __init__.py can just be\nan empty file, but it can also execute initialization code for the package or\nset the __all__ variable, described later.\nUsers of the package can import individual modules from the package, for\nexample:\nimport sound.effects.echo\nThis loads the submodule sound.effects.echo.  It must be referenced with\nits full name.\nsound.effects.echo.echofilter(input, output, delay=0.7, atten=4)\nAn alternative way of importing the submodule is:\nfrom sound.effects import echo\nThis also loads the submodule echo, and makes it available without its\npackage prefix, so it can be used as follows:\necho.echofilter(input, output, delay=0.7, atten=4)\nYet another variation is to import the desired function or variable directly:\nfrom sound.effects.echo import echofilter\nAgain, this loads the submodule echo, but this makes its function\nechofilter() directly available:\nechofilter(input, output, delay=0.7, atten=4)\nNote that when using from package import item, the item can be either a\nsubmodule (or subpackage) of the package, or some  other name defined in the\npackage, like a function, class or variable.  The import statement first\ntests whether the item is defined in the package; if not, it assumes it is a\nmodule and attempts to load it.  If it fails to find it, an ImportError\nexception is raised.\nContrarily, when using syntax like import item.subitem.subsubitem, each item\nexcept for the last must be a package; the last item can be a module or a\npackage but canât be a class or function or variable defined in the previous\nitem.\n6.4.1. Importing * From a PackageÂ¶\nNow what happens when the user writes from sound.effects import *?  Ideally,\none would hope that this somehow goes out to the filesystem, finds which\nsubmodules are present in the package, and imports them all.  This could take a\nlong time and importing sub-modules might have unwanted side-effects that should\nonly happen when the sub-module is explicitly imported.\nThe only solution is for the package author to provide an explicit index of the\npackage.  The import statement uses the following convention: if a packageâs\n__init__.py code defines a list named __all__, it is taken to be the\nlist of module names that should be imported when from package import * is"
      },
      {
        "chunk_id": "python_docs_modules_chunk_5",
        "original_index": 5,
        "content": "__init__.py code defines a list named __all__, it is taken to be the\nlist of module names that should be imported when from package import * is\nencountered.  It is up to the package author to keep this list up-to-date when a\nnew version of the package is released.  Package authors may also decide not to\nsupport it, if they donât see a use for importing * from their package.  For\nexample, the file sound/effects/__init__.py could contain the following\ncode:\n__all__ = [\"echo\", \"surround\", \"reverse\"]\nThis would mean that from sound.effects import * would import the three\nnamed submodules of the sound.effects package.\nBe aware that submodules might become shadowed by locally defined names. For\nexample, if you added a reverse function to the\nsound/effects/__init__.py file, the from sound.effects import *\nwould only import the two submodules echo and surround, but not the\nreverse submodule, because it is shadowed by the locally defined\nreverse function:\n__all__ = [\n\"echo\",      # refers to the 'echo.py' file\n\"surround\",  # refers to the 'surround.py' file\n\"reverse\",   # !!! refers to the 'reverse' function now !!!\n]\ndef reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule\nreturn msg[::-1]    #     in the case of a 'from sound.effects import *'\nIf __all__ is not defined, the statement from sound.effects import *\ndoes not import all submodules from the package sound.effects into the\ncurrent namespace; it only ensures that the package sound.effects has\nbeen imported (possibly running any initialization code in __init__.py)\nand then imports whatever names are defined in the package.  This includes any\nnames defined (and submodules explicitly loaded) by __init__.py.  It\nalso includes any submodules of the package that were explicitly loaded by\nprevious import statements.  Consider this code:\nimport sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import *\nIn this example, the echo and surround modules are imported in the\ncurrent namespace because they are defined in the sound.effects package\nwhen the from...import statement is executed.  (This also works when\n__all__ is defined.)\nAlthough certain modules are designed to export only names that follow certain\npatterns when you use import *, it is still considered bad practice in\nproduction code.\nRemember, there is nothing wrong with using from package import\nspecific_submodule!  In fact, this is the recommended notation unless the\nimporting module needs to use submodules with the same name from different\npackages.\n6.4.2. Intra-package ReferencesÂ¶\nWhen packages are structured into subpackages (as with the sound package\nin the example), you can use absolute imports to refer to submodules of siblings\npackages.  For example, if the module sound.filters.vocoder needs to use\nthe echo module in the sound.effects package, it can use from\nsound.effects import echo.\nYou can also write relative imports, with the from module import name form\nof import statement.  These imports use leading dots to indicate the current and\nparent packages involved in the relative import.  From the surround\nmodule for example, you might use:\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\nNote that relative imports are based on the name of the current module.  Since\nthe name of the main module is always \"__main__\", modules intended for use\nas the main module of a Python application must always use absolute imports.\n6.4.3. Packages in Multiple DirectoriesÂ¶\nPackages support one more special attribute, __path__.  This is\ninitialized to be a sequence of strings containing the name of the\ndirectory holding the\npackageâs __init__.py before the code in that file is executed.  This\nvariable can be modified; doing so affects future searches for modules and\nsubpackages contained in the package.\nWhile this feature is not often needed, it can be used to extend the set of\nmodules found in a package.\nFootnotes\n[1]"
      },
      {
        "chunk_id": "python_docs_modules_chunk_6",
        "original_index": 6,
        "content": "subpackages contained in the package.\nWhile this feature is not often needed, it can be used to extend the set of\nmodules found in a package.\nFootnotes\n[1]\nIn fact function definitions are also âstatementsâ that are âexecutedâ; the\nexecution of a module-level function definition adds the function name to\nthe moduleâs global namespace."
      }
    ]
  },
  {
    "doc_id": "python_docs_introduction",
    "original_uuid": "6bd5",
    "content": "1. Whetting Your AppetiteÂ¶\nIf you do much work on computers, eventually you find that thereâs some task\nyouâd like to automate.  For example, you may wish to perform a\nsearch-and-replace over a large number of text files, or rename and rearrange a\nbunch of photo files in a complicated way. Perhaps youâd like to write a small\ncustom database, or a specialized GUI application, or a simple game.\nIf youâre a professional software developer, you may have to work with several\nC/C++/Java libraries but find the usual write/compile/test/re-compile cycle is\ntoo slow.  Perhaps youâre writing a test suite for such a library and find\nwriting the testing code a tedious task.  Or maybe youâve written a program that\ncould use an extension language, and you donât want to design and implement a\nwhole new language for your application.\nPython is just the language for you.\nYou could write a Unix shell script or Windows batch files for some of these\ntasks, but shell scripts are best at moving around files and changing text data,\nnot well-suited for GUI applications or games. You could write a C/C++/Java\nprogram, but it can take a lot of development time to get even a first-draft\nprogram.  Python is simpler to use, available on Windows, macOS, and Unix\noperating systems, and will help you get the job done more quickly.\nPython is simple to use, but it is a real programming language, offering much\nmore structure and support for large programs than shell scripts or batch files\ncan offer.  On the other hand, Python also offers much more error checking than\nC, and, being a very-high-level language, it has high-level data types built\nin, such as flexible arrays and dictionaries.  Because of its more general data\ntypes Python is applicable to a much larger problem domain than Awk or even\nPerl, yet many things are at least as easy in Python as in those languages.\nPython allows you to split your program into modules that can be reused in other\nPython programs.  It comes with a large collection of standard modules that you\ncan use as the basis of your programs â or as examples to start learning to\nprogram in Python.  Some of these modules provide things like file I/O, system\ncalls, sockets, and even interfaces to graphical user interface toolkits like\nTk.\nPython is an interpreted language, which can save you considerable time during\nprogram development because no compilation and linking is necessary.  The\ninterpreter can be used interactively, which makes it easy to experiment with\nfeatures of the language, to write throw-away programs, or to test functions\nduring bottom-up program development. It is also a handy desk calculator.\nPython enables programs to be written compactly and readably.  Programs written\nin Python are typically much shorter than equivalent C,  C++, or Java programs,\nfor several reasons:\nthe high-level data types allow you to express complex operations in a single\nstatement;\nstatement grouping is done by indentation instead of beginning and ending\nbrackets;\nno variable or argument declarations are necessary.\nPython is extensible: if you know how to program in C it is easy to add a new\nbuilt-in function or module to the interpreter, either to perform critical\noperations at maximum speed, or to link Python programs to libraries that may\nonly be available in binary form (such as a vendor-specific graphics library).\nOnce you are really hooked, you can link the Python interpreter into an\napplication written in C and use it as an extension or command language for that\napplication.\nBy the way, the language is named after the BBC show âMonty Pythonâs Flying\nCircusâ and has nothing to do with reptiles.  Making references to Monty\nPython skits in documentation is not only allowed, it is encouraged!\nNow that you are all excited about Python, youâll want to examine it in some\nmore detail.  Since the best way to learn a language is to use it, the tutorial\ninvites you to play with the Python interpreter as you read.\nIn the next chapter, the mechanics of using the interpreter are explained.  This\nis rather mundane information, but essential for trying out the examples shown\nlater.\nThe rest of the tutorial introduces various features of the Python language and\nsystem through examples, beginning with simple expressions, statements and data\ntypes, through functions and modules, and finally touching upon advanced\nconcepts like exceptions and user-defined classes.",
    "chunks": [
      {
        "chunk_id": "python_docs_introduction_chunk_0",
        "original_index": 0,
        "content": "1. Whetting Your AppetiteÂ¶\nIf you do much work on computers, eventually you find that thereâs some task\nyouâd like to automate.  For example, you may wish to perform a\nsearch-and-replace over a large number of text files, or rename and rearrange a\nbunch of photo files in a complicated way. Perhaps youâd like to write a small\ncustom database, or a specialized GUI application, or a simple game.\nIf youâre a professional software developer, you may have to work with several\nC/C++/Java libraries but find the usual write/compile/test/re-compile cycle is\ntoo slow.  Perhaps youâre writing a test suite for such a library and find\nwriting the testing code a tedious task.  Or maybe youâve written a program that\ncould use an extension language, and you donât want to design and implement a\nwhole new language for your application.\nPython is just the language for you.\nYou could write a Unix shell script or Windows batch files for some of these\ntasks, but shell scripts are best at moving around files and changing text data,\nnot well-suited for GUI applications or games. You could write a C/C++/Java\nprogram, but it can take a lot of development time to get even a first-draft\nprogram.  Python is simpler to use, available on Windows, macOS, and Unix\noperating systems, and will help you get the job done more quickly.\nPython is simple to use, but it is a real programming language, offering much\nmore structure and support for large programs than shell scripts or batch files\ncan offer.  On the other hand, Python also offers much more error checking than\nC, and, being a very-high-level language, it has high-level data types built\nin, such as flexible arrays and dictionaries.  Because of its more general data\ntypes Python is applicable to a much larger problem domain than Awk or even\nPerl, yet many things are at least as easy in Python as in those languages.\nPython allows you to split your program into modules that can be reused in other\nPython programs.  It comes with a large collection of standard modules that you\ncan use as the basis of your programs â or as examples to start learning to\nprogram in Python.  Some of these modules provide things like file I/O, system\ncalls, sockets, and even interfaces to graphical user interface toolkits like\nTk.\nPython is an interpreted language, which can save you considerable time during\nprogram development because no compilation and linking is necessary.  The\ninterpreter can be used interactively, which makes it easy to experiment with\nfeatures of the language, to write throw-away programs, or to test functions\nduring bottom-up program development. It is also a handy desk calculator.\nPython enables programs to be written compactly and readably.  Programs written\nin Python are typically much shorter than equivalent C,  C++, or Java programs,\nfor several reasons:\nthe high-level data types allow you to express complex operations in a single\nstatement;\nstatement grouping is done by indentation instead of beginning and ending\nbrackets;\nno variable or argument declarations are necessary.\nPython is extensible: if you know how to program in C it is easy to add a new\nbuilt-in function or module to the interpreter, either to perform critical\noperations at maximum speed, or to link Python programs to libraries that may\nonly be available in binary form (such as a vendor-specific graphics library).\nOnce you are really hooked, you can link the Python interpreter into an\napplication written in C and use it as an extension or command language for that\napplication.\nBy the way, the language is named after the BBC show âMonty Pythonâs Flying\nCircusâ and has nothing to do with reptiles.  Making references to Monty\nPython skits in documentation is not only allowed, it is encouraged!\nNow that you are all excited about Python, youâll want to examine it in some\nmore detail.  Since the best way to learn a language is to use it, the tutorial\ninvites you to play with the Python interpreter as you read."
      },
      {
        "chunk_id": "python_docs_introduction_chunk_1",
        "original_index": 1,
        "content": "more detail.  Since the best way to learn a language is to use it, the tutorial\ninvites you to play with the Python interpreter as you read.\nIn the next chapter, the mechanics of using the interpreter are explained.  This\nis rather mundane information, but essential for trying out the examples shown\nlater.\nThe rest of the tutorial introduces various features of the Python language and\nsystem through examples, beginning with simple expressions, statements and data\ntypes, through functions and modules, and finally touching upon advanced\nconcepts like exceptions and user-defined classes."
      }
    ]
  },
  {
    "doc_id": "python_docs_complete",
    "original_uuid": "8e4d",
    "content": "\n\n==================== INTRODUCTION ====================\n\n1. Whetting Your AppetiteÂ¶\nIf you do much work on computers, eventually you find that thereâs some task\nyouâd like to automate.  For example, you may wish to perform a\nsearch-and-replace over a large number of text files, or rename and rearrange a\nbunch of photo files in a complicated way. Perhaps youâd like to write a small\ncustom database, or a specialized GUI application, or a simple game.\nIf youâre a professional software developer, you may have to work with several\nC/C++/Java libraries but find the usual write/compile/test/re-compile cycle is\ntoo slow.  Perhaps youâre writing a test suite for such a library and find\nwriting the testing code a tedious task.  Or maybe youâve written a program that\ncould use an extension language, and you donât want to design and implement a\nwhole new language for your application.\nPython is just the language for you.\nYou could write a Unix shell script or Windows batch files for some of these\ntasks, but shell scripts are best at moving around files and changing text data,\nnot well-suited for GUI applications or games. You could write a C/C++/Java\nprogram, but it can take a lot of development time to get even a first-draft\nprogram.  Python is simpler to use, available on Windows, macOS, and Unix\noperating systems, and will help you get the job done more quickly.\nPython is simple to use, but it is a real programming language, offering much\nmore structure and support for large programs than shell scripts or batch files\ncan offer.  On the other hand, Python also offers much more error checking than\nC, and, being a very-high-level language, it has high-level data types built\nin, such as flexible arrays and dictionaries.  Because of its more general data\ntypes Python is applicable to a much larger problem domain than Awk or even\nPerl, yet many things are at least as easy in Python as in those languages.\nPython allows you to split your program into modules that can be reused in other\nPython programs.  It comes with a large collection of standard modules that you\ncan use as the basis of your programs â or as examples to start learning to\nprogram in Python.  Some of these modules provide things like file I/O, system\ncalls, sockets, and even interfaces to graphical user interface toolkits like\nTk.\nPython is an interpreted language, which can save you considerable time during\nprogram development because no compilation and linking is necessary.  The\ninterpreter can be used interactively, which makes it easy to experiment with\nfeatures of the language, to write throw-away programs, or to test functions\nduring bottom-up program development. It is also a handy desk calculator.\nPython enables programs to be written compactly and readably.  Programs written\nin Python are typically much shorter than equivalent C,  C++, or Java programs,\nfor several reasons:\nthe high-level data types allow you to express complex operations in a single\nstatement;\nstatement grouping is done by indentation instead of beginning and ending\nbrackets;\nno variable or argument declarations are necessary.\nPython is extensible: if you know how to program in C it is easy to add a new\nbuilt-in function or module to the interpreter, either to perform critical\noperations at maximum speed, or to link Python programs to libraries that may\nonly be available in binary form (such as a vendor-specific graphics library).\nOnce you are really hooked, you can link the Python interpreter into an\napplication written in C and use it as an extension or command language for that\napplication.\nBy the way, the language is named after the BBC show âMonty Pythonâs Flying\nCircusâ and has nothing to do with reptiles.  Making references to Monty\nPython skits in documentation is not only allowed, it is encouraged!\nNow that you are all excited about Python, youâll want to examine it in some\nmore detail.  Since the best way to learn a language is to use it, the tutorial\ninvites you to play with the Python interpreter as you read.\nIn the next chapter, the mechanics of using the interpreter are explained.  This\nis rather mundane information, but essential for trying out the examples shown\nlater.\nThe rest of the tutorial introduces various features of the Python language and\nsystem through examples, beginning with simple expressions, statements and data\ntypes, through functions and modules, and finally touching upon advanced\nconcepts like exceptions and user-defined classes.\n\n==================== CONTROL_FLOW ====================\n\n4. More Control Flow ToolsÂ¶\nAs well as the while statement just introduced, Python uses a few more\nthat we will encounter in this chapter.\n4.1. if StatementsÂ¶\nPerhaps the most well-known statement type is the if statement.  For\nexample:\n>>> x = int(input(\"Please enter an integer: \"))\nPlease enter an integer: 42\n>>> if x < 0:\n...     x = 0\n...     print('Negative changed to zero')\n... elif x == 0:\n...     print('Zero')\n... elif x == 1:\n...     print('Single')\n... else:\n...     print('More')\n...\nMore\nThere can be zero or more elif parts, and the else part is\noptional.  The keyword âelifâ is short for âelse ifâ, and is useful\nto avoid excessive indentation.  An  if â¦ elif â¦\nelif â¦ sequence is a substitute for the switch or\ncase statements found in other languages.\nIf youâre comparing the same value to several constants, or checking for specific types or\nattributes, you may also find the match statement useful. For more\ndetails see match Statements.\n4.2. for StatementsÂ¶\nThe for statement in Python differs a bit from what you may be used\nto in C or Pascal.  Rather than always iterating over an arithmetic progression\nof numbers (like in Pascal), or giving the user the ability to define both the\niteration step and halting condition (as C), Pythonâs for statement\niterates over the items of any sequence (a list or a string), in the order that\nthey appear in the sequence.  For example (no pun intended):\n>>> # Measure some strings:\n>>> words = ['cat', 'window', 'defenestrate']\n>>> for w in words:\n...     print(w, len(w))\n...\ncat 3\nwindow 6\ndefenestrate 12\nCode that modifies a collection while iterating over that same collection can\nbe tricky to get right.  Instead, it is usually more straight-forward to loop\nover a copy of the collection or to create a new collection:\n# Create a sample collection\nusers = {'Hans': 'active', 'ÃlÃ©onore': 'inactive', 'æ¯å¤ªé': 'active'}\n# Strategy:  Iterate over a copy\nfor user, status in users.copy().items():\nif status == 'inactive':\ndel users[user]\n# Strategy:  Create a new collection\nactive_users = {}\nfor user, status in users.items():\nif status == 'active':\nactive_users[user] = status\n4.3. The range() FunctionÂ¶\nIf you do need to iterate over a sequence of numbers, the built-in function\nrange() comes in handy.  It generates arithmetic progressions:\n>>> for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\nThe given end point is never part of the generated sequence; range(10) generates\n10 values, the legal indices for items of a sequence of length 10.  It\nis possible to let the range start at another number, or to specify a different\nincrement (even negative; sometimes this is called the âstepâ):\n>>> list(range(5, 10))\n[5, 6, 7, 8, 9]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(-10, -100, -30))\n[-10, -40, -70]\nTo iterate over the indices of a sequence, you can combine range() and\nlen() as follows:\n>>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n>>> for i in range(len(a)):\n...     print(i, a[i])\n...\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\nIn most such cases, however, it is convenient to use the enumerate()\nfunction, see Looping Techniques.\nA strange thing happens if you just print a range:\n>>> range(10)\nrange(0, 10)\nIn many ways the object returned by range() behaves as if it is a list,\nbut in fact it isnât. It is an object which returns the successive items of\nthe desired sequence when you iterate over it, but it doesnât really make\nthe list, thus saving space.\nWe say such an object is iterable, that is, suitable as a target for\nfunctions and constructs that expect something from which they can\nobtain successive items until the supply is exhausted.  We have seen that\nthe for statement is such a construct, while an example of a function\nthat takes an iterable is sum():\n>>> sum(range(4))  # 0 + 1 + 2 + 3\n6\nLater we will see more functions that return iterables and take iterables as\narguments.  In chapter Data Structures, we will discuss in more detail about\nlist().\n4.4. break and continue StatementsÂ¶\nThe break statement breaks out of the innermost enclosing\nfor or while loop:\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(f\"{n} equals {x} * {n//x}\")\n...             break\n...\n4 equals 2 * 2\n6 equals 2 * 3\n8 equals 2 * 4\n9 equals 3 * 3\nThe continue statement continues with the next\niteration of the loop:\n>>> for num in range(2, 10):\n...     if num % 2 == 0:\n...         print(f\"Found an even number {num}\")\n...         continue\n...     print(f\"Found an odd number {num}\")\n...\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n4.5. else Clauses on LoopsÂ¶\nIn a for or while loop the break statement\nmay be paired with an else clause.  If the loop finishes without\nexecuting the break, the else clause executes.\nIn a for loop, the else clause is executed\nafter the loop finishes its final iteration, that is, if no break occurred.\nIn a while loop, itâs executed after the loopâs condition becomes false.\nIn either kind of loop, the else clause is not executed if the\nloop was terminated by a break.  Of course, other ways of ending the\nloop early, such as a return or a raised exception, will also skip\nexecution of the else clause.\nThis is exemplified in the following for loop,\nwhich searches for prime numbers:\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(n, 'equals', x, '*', n//x)\n...             break\n...     else:\n...         # loop fell through without finding a factor\n...         print(n, 'is a prime number')\n...\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n(Yes, this is the correct code.  Look closely: the else clause belongs to\nthe for loop, not the if statement.)\nOne way to think of the else clause is to imagine it paired with the if\ninside the loop.  As the loop executes, it will run a sequence like\nif/if/if/else. The if is inside the loop, encountered a number of times. If\nthe condition is ever true, a break will happen. If the condition is never\ntrue, the else clause outside the loop will execute.\nWhen used with a loop, the else clause has more in common with the else\nclause of a try statement than it does with that of if\nstatements: a try statementâs else clause runs when no exception\noccurs, and a loopâs else clause runs when no break occurs. For more on\nthe try statement and exceptions, see Handling Exceptions.\n4.6. pass StatementsÂ¶\nThe pass statement does nothing. It can be used when a statement is\nrequired syntactically but the program requires no action. For example:\n>>> while True:\n...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n...\nThis is commonly used for creating minimal classes:\n>>> class MyEmptyClass:\n...     pass\n...\nAnother place pass can be used is as a place-holder for a function or\nconditional body when you are working on new code, allowing you to keep thinking\nat a more abstract level.  The pass is silently ignored:\n>>> def initlog(*args):\n...     pass   # Remember to implement this!\n...\n4.7. match StatementsÂ¶\nA match statement takes an expression and compares its value to successive\npatterns given as one or more case blocks.  This is superficially\nsimilar to a switch statement in C, Java or JavaScript (and many\nother languages), but itâs more similar to pattern matching in\nlanguages like Rust or Haskell. Only the first pattern that matches\ngets executed and it can also extract components (sequence elements\nor object attributes) from the value into variables.\nThe simplest form compares a subject value against one or more literals:\ndef http_error(status):\nmatch status:\ncase 400:\nreturn \"Bad request\"\ncase 404:\nreturn \"Not found\"\ncase 418:\nreturn \"I'm a teapot\"\ncase _:\nreturn \"Something's wrong with the internet\"\nNote the last block: the âvariable nameâ _ acts as a wildcard and\nnever fails to match. If no case matches, none of the branches is executed.\nYou can combine several literals in a single pattern using | (âorâ):\ncase 401 | 403 | 404:\nreturn \"Not allowed\"\nPatterns can look like unpacking assignments, and can be used to bind\nvariables:\n# point is an (x, y) tuple\nmatch point:\ncase (0, 0):\nprint(\"Origin\")\ncase (0, y):\nprint(f\"Y={y}\")\ncase (x, 0):\nprint(f\"X={x}\")\ncase (x, y):\nprint(f\"X={x}, Y={y}\")\ncase _:\nraise ValueError(\"Not a point\")\nStudy that one carefully!  The first pattern has two literals, and can\nbe thought of as an extension of the literal pattern shown above.  But\nthe next two patterns combine a literal and a variable, and the\nvariable binds a value from the subject (point).  The fourth\npattern captures two values, which makes it conceptually similar to\nthe unpacking assignment (x, y) = point.\nIf you are using classes to structure your data\nyou can use the class name followed by an argument list resembling a\nconstructor, but with the ability to capture attributes into variables:\nclass Point:\ndef __init__(self, x, y):\nself.x = x\nself.y = y\ndef where_is(point):\nmatch point:\ncase Point(x=0, y=0):\nprint(\"Origin\")\ncase Point(x=0, y=y):\nprint(f\"Y={y}\")\ncase Point(x=x, y=0):\nprint(f\"X={x}\")\ncase Point():\nprint(\"Somewhere else\")\ncase _:\nprint(\"Not a point\")\nYou can use positional parameters with some builtin classes that provide an\nordering for their attributes (e.g. dataclasses). You can also define a specific\nposition for attributes in patterns by setting the __match_args__ special\nattribute in your classes. If itâs set to (âxâ, âyâ), the following patterns are all\nequivalent (and all bind the y attribute to the var variable):\nPoint(1, var)\nPoint(1, y=var)\nPoint(x=1, y=var)\nPoint(y=var, x=1)\nA recommended way to read patterns is to look at them as an extended form of what you\nwould put on the left of an assignment, to understand which variables would be set to\nwhat.\nOnly the standalone names (like var above) are assigned to by a match statement.\nDotted names (like foo.bar), attribute names (the x= and y= above) or class names\n(recognized by the â(â¦)â next to them like Point above) are never assigned to.\nPatterns can be arbitrarily nested.  For example, if we have a short\nlist of Points, with __match_args__ added, we could match it like this:\nclass Point:\n__match_args__ = ('x', 'y')\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nmatch points:\ncase []:\nprint(\"No points\")\ncase [Point(0, 0)]:\nprint(\"The origin\")\ncase [Point(x, y)]:\nprint(f\"Single point {x}, {y}\")\ncase [Point(0, y1), Point(0, y2)]:\nprint(f\"Two on the Y axis at {y1}, {y2}\")\ncase _:\nprint(\"Something else\")\nWe can add an if clause to a pattern, known as a âguardâ.  If the\nguard is false, match goes on to try the next case block.  Note\nthat value capture happens before the guard is evaluated:\nmatch point:\ncase Point(x, y) if x == y:\nprint(f\"Y=X at {x}\")\ncase Point(x, y):\nprint(f\"Not on the diagonal\")\nSeveral other key features of this statement:\nLike unpacking assignments, tuple and list patterns have exactly the\nsame meaning and actually match arbitrary sequences.  An important\nexception is that they donât match iterators or strings.\nSequence patterns support extended unpacking: [x, y, *rest] and (x, y,\n*rest) work similar to unpacking assignments.  The\nname after * may also be _, so (x, y, *_) matches a sequence\nof at least two items without binding the remaining items.\nMapping patterns: {\"bandwidth\": b, \"latency\": l} captures the\n\"bandwidth\" and \"latency\" values from a dictionary.  Unlike sequence\npatterns, extra keys are ignored.  An unpacking like **rest is also\nsupported.  (But **_ would be redundant, so it is not allowed.)\nSubpatterns may be captured using the as keyword:\ncase (Point(x1, y1), Point(x2, y2) as p2): ...\nwill capture the second element of the input as p2 (as long as the input is\na sequence of two points)\nMost literals are compared by equality, however the singletons True,\nFalse and None are compared by identity.\nPatterns may use named constants.  These must be dotted names\nto prevent them from being interpreted as capture variable:\nfrom enum import Enum\nclass Color(Enum):\nRED = 'red'\nGREEN = 'green'\nBLUE = 'blue'\ncolor = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\nmatch color:\ncase Color.RED:\nprint(\"I see red!\")\ncase Color.GREEN:\nprint(\"Grass is green\")\ncase Color.BLUE:\nprint(\"I'm feeling the blues :(\")\nFor a more detailed explanation and additional examples, you can look into\nPEP 636 which is written in a tutorial format.\n4.8. Defining FunctionsÂ¶\nWe can create a function that writes the Fibonacci series to an arbitrary\nboundary:\n>>> def fib(n):    # write Fibonacci series less than n\n...     \"\"\"Print a Fibonacci series less than n.\"\"\"\n...     a, b = 0, 1\n...     while a < n:\n...         print(a, end=' ')\n...         a, b = b, a+b\n...     print()\n...\n>>> # Now call the function we just defined:\n>>> fib(2000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\nThe keyword def introduces a function definition.  It must be\nfollowed by the function name and the parenthesized list of formal parameters.\nThe statements that form the body of the function start at the next line, and\nmust be indented.\nThe first statement of the function body can optionally be a string literal;\nthis string literal is the functionâs documentation string, or docstring.\n(More about docstrings can be found in the section Documentation Strings.)\nThere are tools which use docstrings to automatically produce online or printed\ndocumentation, or to let the user interactively browse through code; itâs good\npractice to include docstrings in code that you write, so make a habit of it.\nThe execution of a function introduces a new symbol table used for the local\nvariables of the function.  More precisely, all variable assignments in a\nfunction store the value in the local symbol table; whereas variable references\nfirst look in the local symbol table, then in the local symbol tables of\nenclosing functions, then in the global symbol table, and finally in the table\nof built-in names. Thus, global variables and variables of enclosing functions\ncannot be directly assigned a value within a function (unless, for global\nvariables, named in a global statement, or, for variables of enclosing\nfunctions, named in a nonlocal statement), although they may be\nreferenced.\nThe actual parameters (arguments) to a function call are introduced in the local\nsymbol table of the called function when it is called; thus, arguments are\npassed using call by value (where the value is always an object reference,\nnot the value of the object). [1] When a function calls another function,\nor calls itself recursively, a new\nlocal symbol table is created for that call.\nA function definition associates the function name with the function object in\nthe current symbol table.  The interpreter recognizes the object pointed to by\nthat name as a user-defined function.  Other names can also point to that same\nfunction object and can also be used to access the function:\n>>> fib\n<function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\nComing from other languages, you might object that fib is not a function but\na procedure since it doesnât return a value.  In fact, even functions without a\nreturn statement do return a value, albeit a rather boring one.  This\nvalue is called None (itâs a built-in name).  Writing the value None is\nnormally suppressed by the interpreter if it would be the only value written.\nYou can see it if you really want to using print():\n>>> fib(0)\n>>> print(fib(0))\nNone\nIt is simple to write a function that returns a list of the numbers of the\nFibonacci series, instead of printing it:\n>>> def fib2(n):  # return Fibonacci series up to n\n...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n...     result = []\n...     a, b = 0, 1\n...     while a < n:\n...         result.append(a)    # see below\n...         a, b = b, a+b\n...     return result\n...\n>>> f100 = fib2(100)    # call it\n>>> f100                # write the result\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\nThis example, as usual, demonstrates some new Python features:\nThe return statement returns with a value from a function.\nreturn without an expression argument returns None. Falling off\nthe end of a function also returns None.\nThe statement result.append(a) calls a method of the list object\nresult.  A method is a function that âbelongsâ to an object and is named\nobj.methodname, where obj is some object (this may be an expression),\nand methodname is the name of a method that is defined by the objectâs type.\nDifferent types define different methods.  Methods of different types may have\nthe same name without causing ambiguity.  (It is possible to define your own\nobject types and methods, using classes, see Classes)\nThe method append() shown in the example is defined for list objects; it\nadds a new element at the end of the list.  In this example it is equivalent to\nresult = result + [a], but more efficient.\n4.9. More on Defining FunctionsÂ¶\nIt is also possible to define functions with a variable number of arguments.\nThere are three forms, which can be combined.\n4.9.1. Default Argument ValuesÂ¶\nThe most useful form is to specify a default value for one or more arguments.\nThis creates a function that can be called with fewer arguments than it is\ndefined to allow.  For example:\ndef ask_ok(prompt, retries=4, reminder='Please try again!'):\nwhile True:\nreply = input(prompt)\nif reply in {'y', 'ye', 'yes'}:\nreturn True\nif reply in {'n', 'no', 'nop', 'nope'}:\nreturn False\nretries = retries - 1\nif retries < 0:\nraise ValueError('invalid user response')\nprint(reminder)\nThis function can be called in several ways:\ngiving only the mandatory argument:\nask_ok('Do you really want to quit?')\ngiving one of the optional arguments:\nask_ok('OK to overwrite the file?', 2)\nor even giving all arguments:\nask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')\nThis example also introduces the in keyword. This tests whether or\nnot a sequence contains a certain value.\nThe default values are evaluated at the point of function definition in the\ndefining scope, so that\ni = 5\ndef f(arg=i):\nprint(arg)\ni = 6\nf()\nwill print 5.\nImportant warning:  The default value is evaluated only once. This makes a\ndifference when the default is a mutable object such as a list, dictionary, or\ninstances of most classes.  For example, the following function accumulates the\narguments passed to it on subsequent calls:\ndef f(a, L=[]):\nL.append(a)\nreturn L\nprint(f(1))\nprint(f(2))\nprint(f(3))\nThis will print\n[1]\n[1, 2]\n[1, 2, 3]\nIf you donât want the default to be shared between subsequent calls, you can\nwrite the function like this instead:\ndef f(a, L=None):\nif L is None:\nL = []\nL.append(a)\nreturn L\n4.9.2. Keyword ArgumentsÂ¶\nFunctions can also be called using keyword arguments\nof the form kwarg=value.  For instance, the following function:\ndef parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\nprint(\"-- This parrot wouldn't\", action, end=' ')\nprint(\"if you put\", voltage, \"volts through it.\")\nprint(\"-- Lovely plumage, the\", type)\nprint(\"-- It's\", state, \"!\")\naccepts one required argument (voltage) and three optional arguments\n(state, action, and type).  This function can be called in any\nof the following ways:\nparrot(1000)                                          # 1 positional argument\nparrot(voltage=1000)                                  # 1 keyword argument\nparrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\nparrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\nparrot('a million', 'bereft of life', 'jump')         # 3 positional arguments\nparrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword\nbut all the following calls would be invalid:\nparrot()                     # required argument missing\nparrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument\nparrot(110, voltage=220)     # duplicate value for the same argument\nparrot(actor='John Cleese')  # unknown keyword argument\nIn a function call, keyword arguments must follow positional arguments.\nAll the keyword arguments passed must match one of the arguments\naccepted by the function (e.g. actor is not a valid argument for the\nparrot function), and their order is not important.  This also includes\nnon-optional arguments (e.g. parrot(voltage=1000) is valid too).\nNo argument may receive a value more than once.\nHereâs an example that fails due to this restriction:\n>>> def function(a):\n...     pass\n...\n>>> function(0, a=0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: function() got multiple values for argument 'a'\nWhen a final formal parameter of the form **name is present, it receives a\ndictionary (see Mapping Types â dict) containing all keyword arguments except for\nthose corresponding to a formal parameter.  This may be combined with a formal\nparameter of the form *name (described in the next subsection) which\nreceives a tuple containing the positional\narguments beyond the formal parameter list.  (*name must occur\nbefore **name.) For example, if we define a function like this:\ndef cheeseshop(kind, *arguments, **keywords):\nprint(\"-- Do you have any\", kind, \"?\")\nprint(\"-- I'm sorry, we're all out of\", kind)\nfor arg in arguments:\nprint(arg)\nprint(\"-\" * 40)\nfor kw in keywords:\nprint(kw, \":\", keywords[kw])\nIt could be called like this:\ncheeseshop(\"Limburger\", \"It's very runny, sir.\",\n\"It's really very, VERY runny, sir.\",\nshopkeeper=\"Michael Palin\",\nclient=\"John Cleese\",\nsketch=\"Cheese Shop Sketch\")\nand of course it would print:\n-- Do you have any Limburger ?\n-- I'm sorry, we're all out of Limburger\nIt's very runny, sir.\nIt's really very, VERY runny, sir.\n----------------------------------------\nshopkeeper : Michael Palin\nclient : John Cleese\nsketch : Cheese Shop Sketch\nNote that the order in which the keyword arguments are printed is guaranteed\nto match the order in which they were provided in the function call.\n4.9.3. Special parametersÂ¶\nBy default, arguments may be passed to a Python function either by position\nor explicitly by keyword. For readability and performance, it makes sense to\nrestrict the way arguments can be passed so that a developer need only look\nat the function definition to determine if items are passed by position, by\nposition or keyword, or by keyword.\nA function definition may look like:\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n-----------    ----------     ----------\n|             |                  |\n|        Positional or keyword   |\n|                                - Keyword only\n-- Positional only\nwhere / and * are optional. If used, these symbols indicate the kind of\nparameter by how the arguments may be passed to the function:\npositional-only, positional-or-keyword, and keyword-only. Keyword parameters\nare also referred to as named parameters.\n4.9.3.1. Positional-or-Keyword ArgumentsÂ¶\nIf / and * are not present in the function definition, arguments may\nbe passed to a function by position or by keyword.\n4.9.3.2. Positional-Only ParametersÂ¶\nLooking at this in a bit more detail, it is possible to mark certain parameters\nas positional-only. If positional-only, the parametersâ order matters, and\nthe parameters cannot be passed by keyword. Positional-only parameters are\nplaced before a / (forward-slash). The / is used to logically\nseparate the positional-only parameters from the rest of the parameters.\nIf there is no / in the function definition, there are no positional-only\nparameters.\nParameters following the / may be positional-or-keyword or keyword-only.\n4.9.3.3. Keyword-Only ArgumentsÂ¶\nTo mark parameters as keyword-only, indicating the parameters must be passed\nby keyword argument, place an * in the arguments list just before the first\nkeyword-only parameter.\n4.9.3.4. Function ExamplesÂ¶\nConsider the following example function definitions paying close attention to the\nmarkers / and *:\n>>> def standard_arg(arg):\n...     print(arg)\n...\n>>> def pos_only_arg(arg, /):\n...     print(arg)\n...\n>>> def kwd_only_arg(*, arg):\n...     print(arg)\n...\n>>> def combined_example(pos_only, /, standard, *, kwd_only):\n...     print(pos_only, standard, kwd_only)\nThe first function definition, standard_arg, the most familiar form,\nplaces no restrictions on the calling convention and arguments may be\npassed by position or keyword:\n>>> standard_arg(2)\n2\n>>> standard_arg(arg=2)\n2\nThe second function pos_only_arg is restricted to only use positional\nparameters as there is a / in the function definition:\n>>> pos_only_arg(1)\n1\n>>> pos_only_arg(arg=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'\nThe third function kwd_only_arg only allows keyword arguments as indicated\nby a * in the function definition:\n>>> kwd_only_arg(3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n>>> kwd_only_arg(arg=3)\n3\nAnd the last uses all three calling conventions in the same function\ndefinition:\n>>> combined_example(1, 2, 3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() takes 2 positional arguments but 3 were given\n>>> combined_example(1, 2, kwd_only=3)\n1 2 3\n>>> combined_example(1, standard=2, kwd_only=3)\n1 2 3\n>>> combined_example(pos_only=1, standard=2, kwd_only=3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'\nFinally, consider this function definition which has a potential collision between the positional argument name  and **kwds which has name as a key:\ndef foo(name, **kwds):\nreturn 'name' in kwds\nThere is no possible call that will make it return True as the keyword 'name'\nwill always bind to the first parameter. For example:\n>>> foo(1, **{'name': 2})\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: foo() got multiple values for argument 'name'\n>>>\nBut using / (positional only arguments), it is possible since it allows name as a positional argument and 'name' as a key in the keyword arguments:\n>>> def foo(name, /, **kwds):\n...     return 'name' in kwds\n...\n>>> foo(1, **{'name': 2})\nTrue\nIn other words, the names of positional-only parameters can be used in\n**kwds without ambiguity.\n4.9.3.5. RecapÂ¶\nThe use case will determine which parameters to use in the function definition:\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\nAs guidance:\nUse positional-only if you want the name of the parameters to not be\navailable to the user. This is useful when parameter names have no real\nmeaning, if you want to enforce the order of the arguments when the function\nis called or if you need to take some positional parameters and arbitrary\nkeywords.\nUse keyword-only when names have meaning and the function definition is\nmore understandable by being explicit with names or you want to prevent\nusers relying on the position of the argument being passed.\nFor an API, use positional-only to prevent breaking API changes\nif the parameterâs name is modified in the future.\n4.9.4. Arbitrary Argument ListsÂ¶\nFinally, the least frequently used option is to specify that a function can be\ncalled with an arbitrary number of arguments.  These arguments will be wrapped\nup in a tuple (see Tuples and Sequences).  Before the variable number of arguments,\nzero or more normal arguments may occur.\ndef write_multiple_items(file, separator, *args):\nfile.write(separator.join(args))\nNormally, these variadic arguments will be last in the list of formal\nparameters, because they scoop up all remaining input arguments that are\npassed to the function. Any formal parameters which occur after the *args\nparameter are âkeyword-onlyâ arguments, meaning that they can only be used as\nkeywords rather than positional arguments.\n>>> def concat(*args, sep=\"/\"):\n...     return sep.join(args)\n...\n>>> concat(\"earth\", \"mars\", \"venus\")\n'earth/mars/venus'\n>>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n'earth.mars.venus'\n4.9.5. Unpacking Argument ListsÂ¶\nThe reverse situation occurs when the arguments are already in a list or tuple\nbut need to be unpacked for a function call requiring separate positional\narguments.  For instance, the built-in range() function expects separate\nstart and stop arguments.  If they are not available separately, write the\nfunction call with the  *-operator to unpack the arguments out of a list\nor tuple:\n>>> list(range(3, 6))            # normal call with separate arguments\n[3, 4, 5]\n>>> args = [3, 6]\n>>> list(range(*args))            # call with arguments unpacked from a list\n[3, 4, 5]\nIn the same fashion, dictionaries can deliver keyword arguments with the\n**-operator:\n>>> def parrot(voltage, state='a stiff', action='voom'):\n...     print(\"-- This parrot wouldn't\", action, end=' ')\n...     print(\"if you put\", voltage, \"volts through it.\", end=' ')\n...     print(\"E's\", state, \"!\")\n...\n>>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n>>> parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !\n4.9.6. Lambda ExpressionsÂ¶\nSmall anonymous functions can be created with the lambda keyword.\nThis function returns the sum of its two arguments: lambda a, b: a+b.\nLambda functions can be used wherever function objects are required.  They are\nsyntactically restricted to a single expression.  Semantically, they are just\nsyntactic sugar for a normal function definition.  Like nested function\ndefinitions, lambda functions can reference variables from the containing\nscope:\n>>> def make_incrementor(n):\n...     return lambda x: x + n\n...\n>>> f = make_incrementor(42)\n>>> f(0)\n42\n>>> f(1)\n43\nThe above example uses a lambda expression to return a function.  Another use\nis to pass a small function as an argument:\n>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n>>> pairs.sort(key=lambda pair: pair[1])\n>>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n4.9.7. Documentation StringsÂ¶\nHere are some conventions about the content and formatting of documentation\nstrings.\nThe first line should always be a short, concise summary of the objectâs\npurpose.  For brevity, it should not explicitly state the objectâs name or type,\nsince these are available by other means (except if the name happens to be a\nverb describing a functionâs operation).  This line should begin with a capital\nletter and end with a period.\nIf there are more lines in the documentation string, the second line should be\nblank, visually separating the summary from the rest of the description.  The\nfollowing lines should be one or more paragraphs describing the objectâs calling\nconventions, its side effects, etc.\nThe Python parser does not strip indentation from multi-line string literals in\nPython, so tools that process documentation have to strip indentation if\ndesired.  This is done using the following convention. The first non-blank line\nafter the first line of the string determines the amount of indentation for\nthe entire documentation string.  (We canât use the first line since it is\ngenerally adjacent to the stringâs opening quotes so its indentation is not\napparent in the string literal.)  Whitespace âequivalentâ to this indentation is\nthen stripped from the start of all lines of the string.  Lines that are\nindented less should not occur, but if they occur all their leading whitespace\nshould be stripped.  Equivalence of whitespace should be tested after expansion\nof tabs (to 8 spaces, normally).\nHere is an example of a multi-line docstring:\n>>> def my_function():\n...     \"\"\"Do nothing, but document it.\n...\n...     No, really, it doesn't do anything.\n...     \"\"\"\n...     pass\n...\n>>> print(my_function.__doc__)\nDo nothing, but document it.\nNo, really, it doesn't do anything.\n4.9.8. Function AnnotationsÂ¶\nFunction annotations are completely optional metadata\ninformation about the types used by user-defined functions (see PEP 3107 and\nPEP 484 for more information).\nAnnotations are stored in the __annotations__\nattribute of the function as a dictionary and have no effect on any other part of the\nfunction.  Parameter annotations are defined by a colon after the parameter name, followed\nby an expression evaluating to the value of the annotation.  Return annotations are\ndefined by a literal ->, followed by an expression, between the parameter\nlist and the colon denoting the end of the def statement.  The\nfollowing example has a required argument, an optional argument, and the return\nvalue annotated:\n>>> def f(ham: str, eggs: str = 'eggs') -> str:\n...     print(\"Annotations:\", f.__annotations__)\n...     print(\"Arguments:\", ham, eggs)\n...     return ham + ' and ' + eggs\n...\n>>> f('spam')\nAnnotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}\nArguments: spam eggs\n'spam and eggs'\n4.10. Intermezzo: Coding StyleÂ¶\nNow that you are about to write longer, more complex pieces of Python, it is a\ngood time to talk about coding style.  Most languages can be written (or more\nconcise, formatted) in different styles; some are more readable than others.\nMaking it easy for others to read your code is always a good idea, and adopting\na nice coding style helps tremendously for that.\nFor Python, PEP 8 has emerged as the style guide that most projects adhere to;\nit promotes a very readable and eye-pleasing coding style.  Every Python\ndeveloper should read it at some point; here are the most important points\nextracted for you:\nUse 4-space indentation, and no tabs.\n4 spaces are a good compromise between small indentation (allows greater\nnesting depth) and large indentation (easier to read).  Tabs introduce\nconfusion, and are best left out.\nWrap lines so that they donât exceed 79 characters.\nThis helps users with small displays and makes it possible to have several\ncode files side-by-side on larger displays.\nUse blank lines to separate functions and classes, and larger blocks of\ncode inside functions.\nWhen possible, put comments on a line of their own.\nUse docstrings.\nUse spaces around operators and after commas, but not directly inside\nbracketing constructs: a = f(1, 2) + g(3, 4).\nName your classes and functions consistently; the convention is to use\nUpperCamelCase for classes and lowercase_with_underscores for functions\nand methods.  Always use self as the name for the first method argument\n(see A First Look at Classes for more on classes and methods).\nDonât use fancy encodings if your code is meant to be used in international\nenvironments.  Pythonâs default, UTF-8, or even plain ASCII work best in any\ncase.\nLikewise, donât use non-ASCII characters in identifiers if there is only the\nslightest chance people speaking a different language will read or maintain\nthe code.\nFootnotes\n[1]\nActually, call by object reference would be a better description,\nsince if a mutable object is passed, the caller will see any changes the\ncallee makes to it (items inserted into a list).\n\n==================== DATA_STRUCTURES ====================\n\n5. Data StructuresÂ¶\nThis chapter describes some things youâve learned about already in more detail,\nand adds some new things as well.\n5.1. More on ListsÂ¶\nThe list data type has some more methods.  Here are all of the methods of list\nobjects:\nlist.append(x)\nAdd an item to the end of the list.  Similar to a[len(a):] = [x].\nlist.extend(iterable)\nExtend the list by appending all the items from the iterable.  Similar to\na[len(a):] = iterable.\nlist.insert(i, x)\nInsert an item at a given position.  The first argument is the index of the\nelement before which to insert, so a.insert(0, x) inserts at the front of\nthe list, and a.insert(len(a), x) is equivalent to a.append(x).\nlist.remove(x)\nRemove the first item from the list whose value is equal to x.  It raises a\nValueError if there is no such item.\nlist.pop([i])\nRemove the item at the given position in the list, and return it.  If no index\nis specified, a.pop() removes and returns the last item in the list.\nIt raises an IndexError if the list is empty or the index is\noutside the list range.\nlist.clear()\nRemove all items from the list.  Similar to del a[:].\nlist.index(x[, start[, end]])\nReturn zero-based index in the list of the first item whose value is equal to x.\nRaises a ValueError if there is no such item.\nThe optional arguments start and end are interpreted as in the slice\nnotation and are used to limit the search to a particular subsequence of\nthe list.  The returned index is computed relative to the beginning of the full\nsequence rather than the start argument.\nlist.count(x)\nReturn the number of times x appears in the list.\nlist.sort(*, key=None, reverse=False)\nSort the items of the list in place (the arguments can be used for sort\ncustomization, see sorted() for their explanation).\nlist.reverse()\nReverse the elements of the list in place.\nlist.copy()\nReturn a shallow copy of the list.  Similar to a[:].\nAn example that uses most of the list methods:\n>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']\n>>> fruits.count('apple')\n2\n>>> fruits.count('tangerine')\n0\n>>> fruits.index('banana')\n3\n>>> fruits.index('banana', 4)  # Find next banana starting at position 4\n6\n>>> fruits.reverse()\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n>>> fruits.append('grape')\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n>>> fruits.sort()\n>>> fruits\n['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n>>> fruits.pop()\n'pear'\nYou might have noticed that methods like insert, remove or sort that\nonly modify the list have no return value printed â they return the default\nNone. [1]  This is a design principle for all mutable data structures in\nPython.\nAnother thing you might notice is that not all data can be sorted or\ncompared.  For instance, [None, 'hello', 10] doesnât sort because\nintegers canât be compared to strings and None canât be compared to\nother types.  Also, there are some types that donât have a defined\nordering relation.  For example, 3+4j < 5+7j isnât a valid\ncomparison.\n5.1.1. Using Lists as StacksÂ¶\nThe list methods make it very easy to use a list as a stack, where the last\nelement added is the first element retrieved (âlast-in, first-outâ).  To add an\nitem to the top of the stack, use append().  To retrieve an item from the\ntop of the stack, use pop() without an explicit index.  For example:\n>>> stack = [3, 4, 5]\n>>> stack.append(6)\n>>> stack.append(7)\n>>> stack\n[3, 4, 5, 6, 7]\n>>> stack.pop()\n7\n>>> stack\n[3, 4, 5, 6]\n>>> stack.pop()\n6\n>>> stack.pop()\n5\n>>> stack\n[3, 4]\n5.1.2. Using Lists as QueuesÂ¶\nIt is also possible to use a list as a queue, where the first element added is\nthe first element retrieved (âfirst-in, first-outâ); however, lists are not\nefficient for this purpose.  While appends and pops from the end of list are\nfast, doing inserts or pops from the beginning of a list is slow (because all\nof the other elements have to be shifted by one).\nTo implement a queue, use collections.deque which was designed to\nhave fast appends and pops from both ends.  For example:\n>>> from collections import deque\n>>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n>>> queue.append(\"Terry\")           # Terry arrives\n>>> queue.append(\"Graham\")          # Graham arrives\n>>> queue.popleft()                 # The first to arrive now leaves\n'Eric'\n>>> queue.popleft()                 # The second to arrive now leaves\n'John'\n>>> queue                           # Remaining queue in order of arrival\ndeque(['Michael', 'Terry', 'Graham'])\n5.1.3. List ComprehensionsÂ¶\nList comprehensions provide a concise way to create lists.\nCommon applications are to make new lists where each element is the result of\nsome operations applied to each member of another sequence or iterable, or to\ncreate a subsequence of those elements that satisfy a certain condition.\nFor example, assume we want to create a list of squares, like:\n>>> squares = []\n>>> for x in range(10):\n...     squares.append(x**2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nNote that this creates (or overwrites) a variable named x that still exists\nafter the loop completes.  We can calculate the list of squares without any\nside effects using:\nsquares = list(map(lambda x: x**2, range(10)))\nor, equivalently:\nsquares = [x**2 for x in range(10)]\nwhich is more concise and readable.\nA list comprehension consists of brackets containing an expression followed\nby a for clause, then zero or more for or if\nclauses.  The result will be a new list resulting from evaluating the expression\nin the context of the for and if clauses which follow it.\nFor example, this listcomp combines the elements of two lists if they are not\nequal:\n>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\nand itâs equivalent to:\n>>> combs = []\n>>> for x in [1,2,3]:\n...     for y in [3,1,4]:\n...         if x != y:\n...             combs.append((x, y))\n...\n>>> combs\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\nNote how the order of the for and if statements is the\nsame in both these snippets.\nIf the expression is a tuple (e.g. the (x, y) in the previous example),\nit must be parenthesized.\n>>> vec = [-4, -2, 0, 2, 4]\n>>> # create a new list with the values doubled\n>>> [x*2 for x in vec]\n[-8, -4, 0, 4, 8]\n>>> # filter the list to exclude negative numbers\n>>> [x for x in vec if x >= 0]\n[0, 2, 4]\n>>> # apply a function to all the elements\n>>> [abs(x) for x in vec]\n[4, 2, 0, 2, 4]\n>>> # call a method on each element\n>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n>>> [weapon.strip() for weapon in freshfruit]\n['banana', 'loganberry', 'passion fruit']\n>>> # create a list of 2-tuples like (number, square)\n>>> [(x, x**2) for x in range(6)]\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n>>> # the tuple must be parenthesized, otherwise an error is raised\n>>> [x, x**2 for x in range(6)]\nFile \"<stdin>\", line 1\n[x, x**2 for x in range(6)]\n^^^^^^^\nSyntaxError: did you forget parentheses around the comprehension target?\n>>> # flatten a list using a listcomp with two 'for'\n>>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n>>> [num for elem in vec for num in elem]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\nList comprehensions can contain complex expressions and nested functions:\n>>> from math import pi\n>>> [str(round(pi, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n5.1.4. Nested List ComprehensionsÂ¶\nThe initial expression in a list comprehension can be any arbitrary expression,\nincluding another list comprehension.\nConsider the following example of a 3x4 matrix implemented as a list of\n3 lists of length 4:\n>>> matrix = [\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12],\n... ]\nThe following list comprehension will transpose rows and columns:\n>>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nAs we saw in the previous section, the inner list comprehension is evaluated in\nthe context of the for that follows it, so this example is\nequivalent to:\n>>> transposed = []\n>>> for i in range(4):\n...     transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nwhich, in turn, is the same as:\n>>> transposed = []\n>>> for i in range(4):\n...     # the following 3 lines implement the nested listcomp\n...     transposed_row = []\n...     for row in matrix:\n...         transposed_row.append(row[i])\n...     transposed.append(transposed_row)\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nIn the real world, you should prefer built-in functions to complex flow statements.\nThe zip() function would do a great job for this use case:\n>>> list(zip(*matrix))\n[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]\nSee Unpacking Argument Lists for details on the asterisk in this line.\n5.2. The del statementÂ¶\nThere is a way to remove an item from a list given its index instead of its\nvalue: the del statement.  This differs from the pop() method\nwhich returns a value.  The del statement can also be used to remove\nslices from a list or clear the entire list (which we did earlier by assignment\nof an empty list to the slice).  For example:\n>>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a\n[1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[]\ndel can also be used to delete entire variables:\n>>> del a\nReferencing the name a hereafter is an error (at least until another value\nis assigned to it).  Weâll find other uses for del later.\n5.3. Tuples and SequencesÂ¶\nWe saw that lists and strings have many common properties, such as indexing and\nslicing operations.  They are two examples of sequence data types (see\nSequence Types â list, tuple, range).  Since Python is an evolving language, other sequence data\ntypes may be added.  There is also another standard sequence data type: the\ntuple.\nA tuple consists of a number of values separated by commas, for instance:\n>>> t = 12345, 54321, 'hello!'\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')\n>>> # Tuples may be nested:\n>>> u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n>>> # Tuples are immutable:\n>>> t[0] = 88888\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> # but they can contain mutable objects:\n>>> v = ([1, 2, 3], [3, 2, 1])\n>>> v\n([1, 2, 3], [3, 2, 1])\nAs you see, on output tuples are always enclosed in parentheses, so that nested\ntuples are interpreted correctly; they may be input with or without surrounding\nparentheses, although often parentheses are necessary anyway (if the tuple is\npart of a larger expression).  It is not possible to assign to the individual\nitems of a tuple, however it is possible to create tuples which contain mutable\nobjects, such as lists.\nThough tuples may seem similar to lists, they are often used in different\nsituations and for different purposes.\nTuples are immutable, and usually contain a heterogeneous sequence of\nelements that are accessed via unpacking (see later in this section) or indexing\n(or even by attribute in the case of namedtuples).\nLists are mutable, and their elements are usually homogeneous and are\naccessed by iterating over the list.\nA special problem is the construction of tuples containing 0 or 1 items: the\nsyntax has some extra quirks to accommodate these.  Empty tuples are constructed\nby an empty pair of parentheses; a tuple with one item is constructed by\nfollowing a value with a comma (it is not sufficient to enclose a single value\nin parentheses). Ugly, but effective.  For example:\n>>> empty = ()\n>>> singleton = 'hello',    # <-- note trailing comma\n>>> len(empty)\n0\n>>> len(singleton)\n1\n>>> singleton\n('hello',)\nThe statement t = 12345, 54321, 'hello!' is an example of tuple packing:\nthe values 12345, 54321 and 'hello!' are packed together in a tuple.\nThe reverse operation is also possible:\n>>> x, y, z = t\nThis is called, appropriately enough, sequence unpacking and works for any\nsequence on the right-hand side.  Sequence unpacking requires that there are as\nmany variables on the left side of the equals sign as there are elements in the\nsequence.  Note that multiple assignment is really just a combination of tuple\npacking and sequence unpacking.\n5.4. SetsÂ¶\nPython also includes a data type for sets.  A set is an unordered collection\nwith no duplicate elements.  Basic uses include membership testing and\neliminating duplicate entries.  Set objects also support mathematical operations\nlike union, intersection, difference, and symmetric difference.\nCurly braces or the set() function can be used to create sets.  Note: to\ncreate an empty set you have to use set(), not {}; the latter creates an\nempty dictionary, a data structure that we discuss in the next section.\nHere is a brief demonstration:\n>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n>>> print(basket)                      # show that duplicates have been removed\n{'orange', 'banana', 'pear', 'apple'}\n>>> 'orange' in basket                 # fast membership testing\nTrue\n>>> 'crabgrass' in basket\nFalse\n>>> # Demonstrate set operations on unique letters from two words\n>>>\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a                                  # unique letters in a\n{'a', 'r', 'b', 'c', 'd'}\n>>> a - b                              # letters in a but not in b\n{'r', 'd', 'b'}\n>>> a | b                              # letters in a or b or both\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n>>> a & b                              # letters in both a and b\n{'a', 'c'}\n>>> a ^ b                              # letters in a or b but not both\n{'r', 'd', 'b', 'm', 'z', 'l'}\nSimilarly to list comprehensions, set comprehensions\nare also supported:\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'r', 'd'}\n5.5. DictionariesÂ¶\nAnother useful data type built into Python is the dictionary (see\nMapping Types â dict). Dictionaries are sometimes found in other languages as\nâassociative memoriesâ or âassociative arraysâ.  Unlike sequences, which are\nindexed by a range of numbers, dictionaries are indexed by keys, which can be\nany immutable type; strings and numbers can always be keys.  Tuples can be used\nas keys if they contain only strings, numbers, or tuples; if a tuple contains\nany mutable object either directly or indirectly, it cannot be used as a key.\nYou canât use lists as keys, since lists can be modified in place using index\nassignments, slice assignments, or methods like append() and\nextend().\nIt is best to think of a dictionary as a set of key: value pairs,\nwith the requirement that the keys are unique (within one dictionary). A pair of\nbraces creates an empty dictionary: {}. Placing a comma-separated list of\nkey:value pairs within the braces adds initial key:value pairs to the\ndictionary; this is also the way dictionaries are written on output.\nThe main operations on a dictionary are storing a value with some key and\nextracting the value given the key.  It is also possible to delete a key:value\npair with del. If you store using a key that is already in use, the old\nvalue associated with that key is forgotten.  It is an error to extract a value\nusing a non-existent key.\nPerforming list(d) on a dictionary returns a list of all the keys\nused in the dictionary, in insertion order (if you want it sorted, just use\nsorted(d) instead). To check whether a single key is in the\ndictionary, use the in keyword.\nHere is a small example using a dictionary:\n>>> tel = {'jack': 4098, 'sape': 4139}\n>>> tel['guido'] = 4127\n>>> tel\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n>>> tel['jack']\n4098\n>>> del tel['sape']\n>>> tel['irv'] = 4127\n>>> tel\n{'jack': 4098, 'guido': 4127, 'irv': 4127}\n>>> list(tel)\n['jack', 'guido', 'irv']\n>>> sorted(tel)\n['guido', 'irv', 'jack']\n>>> 'guido' in tel\nTrue\n>>> 'jack' not in tel\nFalse\nThe dict() constructor builds dictionaries directly from sequences of\nkey-value pairs:\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\nIn addition, dict comprehensions can be used to create dictionaries from\narbitrary key and value expressions:\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\nWhen the keys are simple strings, it is sometimes easier to specify pairs using\nkeyword arguments:\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n5.6. Looping TechniquesÂ¶\nWhen looping through dictionaries, the key and corresponding value can be\nretrieved at the same time using the items() method.\n>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.items():\n...     print(k, v)\n...\ngallahad the pure\nrobin the brave\nWhen looping through a sequence, the position index and corresponding value can\nbe retrieved at the same time using the enumerate() function.\n>>> for i, v in enumerate(['tic', 'tac', 'toe']):\n...     print(i, v)\n...\n0 tic\n1 tac\n2 toe\nTo loop over two or more sequences at the same time, the entries can be paired\nwith the zip() function.\n>>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n...     print('What is your {0}?  It is {1}.'.format(q, a))\n...\nWhat is your name?  It is lancelot.\nWhat is your quest?  It is the holy grail.\nWhat is your favorite color?  It is blue.\nTo loop over a sequence in reverse, first specify the sequence in a forward\ndirection and then call the reversed() function.\n>>> for i in reversed(range(1, 10, 2)):\n...     print(i)\n...\n9\n7\n5\n3\n1\nTo loop over a sequence in sorted order, use the sorted() function which\nreturns a new sorted list while leaving the source unaltered.\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for i in sorted(basket):\n...     print(i)\n...\napple\napple\nbanana\norange\norange\npear\nUsing set() on a sequence eliminates duplicate elements. The use of\nsorted() in combination with set() over a sequence is an idiomatic\nway to loop over unique elements of the sequence in sorted order.\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n...     print(f)\n...\napple\nbanana\norange\npear\nIt is sometimes tempting to change a list while you are looping over it;\nhowever, it is often simpler and safer to create a new list instead.\n>>> import math\n>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n>>> filtered_data = []\n>>> for value in raw_data:\n...     if not math.isnan(value):\n...         filtered_data.append(value)\n...\n>>> filtered_data\n[56.2, 51.7, 55.3, 52.5, 47.8]\n5.7. More on ConditionsÂ¶\nThe conditions used in while and if statements can contain any\noperators, not just comparisons.\nThe comparison operators in and not in are membership tests that\ndetermine whether a value is in (or not in) a container.  The operators is\nand is not compare whether two objects are really the same object.  All\ncomparison operators have the same priority, which is lower than that of all\nnumerical operators.\nComparisons can be chained.  For example, a < b == c tests whether a is\nless than b and moreover b equals c.\nComparisons may be combined using the Boolean operators and and or, and\nthe outcome of a comparison (or of any other Boolean expression) may be negated\nwith not.  These have lower priorities than comparison operators; between\nthem, not has the highest priority and or the lowest, so that A and\nnot B or C is equivalent to (A and (not B)) or C. As always, parentheses\ncan be used to express the desired composition.\nThe Boolean operators and and or are so-called short-circuit\noperators: their arguments are evaluated from left to right, and evaluation\nstops as soon as the outcome is determined.  For example, if A and C are\ntrue but B is false, A and B and C does not evaluate the expression\nC.  When used as a general value and not as a Boolean, the return value of a\nshort-circuit operator is the last evaluated argument.\nIt is possible to assign the result of a comparison or other Boolean expression\nto a variable.  For example,\n>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n>>> non_null = string1 or string2 or string3\n>>> non_null\n'Trondheim'\nNote that in Python, unlike C, assignment inside expressions must be done\nexplicitly with the\nwalrus operator :=.\nThis avoids a common class of problems encountered in C programs: typing =\nin an expression when == was intended.\n5.8. Comparing Sequences and Other TypesÂ¶\nSequence objects typically may be compared to other objects with the same sequence\ntype. The comparison uses lexicographical ordering: first the first two\nitems are compared, and if they differ this determines the outcome of the\ncomparison; if they are equal, the next two items are compared, and so on, until\neither sequence is exhausted. If two items to be compared are themselves\nsequences of the same type, the lexicographical comparison is carried out\nrecursively.  If all items of two sequences compare equal, the sequences are\nconsidered equal. If one sequence is an initial sub-sequence of the other, the\nshorter sequence is the smaller (lesser) one.  Lexicographical ordering for\nstrings uses the Unicode code point number to order individual characters.\nSome examples of comparisons between sequences of the same type:\n(1, 2, 3)              < (1, 2, 4)\n[1, 2, 3]              < [1, 2, 4]\n'ABC' < 'C' < 'Pascal' < 'Python'\n(1, 2, 3, 4)           < (1, 2, 4)\n(1, 2)                 < (1, 2, -1)\n(1, 2, 3)             == (1.0, 2.0, 3.0)\n(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)\nNote that comparing objects of different types with < or > is legal\nprovided that the objects have appropriate comparison methods.  For example,\nmixed numeric types are compared according to their numeric value, so 0 equals\n0.0, etc.  Otherwise, rather than providing an arbitrary ordering, the\ninterpreter will raise a TypeError exception.\nFootnotes\n[1]\nOther languages may return the mutated object, which allows method\nchaining, such as d->insert(\"a\")->remove(\"b\")->sort();.\n\n==================== MODULES ====================\n\n6. ModulesÂ¶\nIf you quit from the Python interpreter and enter it again, the definitions you\nhave made (functions and variables) are lost. Therefore, if you want to write a\nsomewhat longer program, you are better off using a text editor to prepare the\ninput for the interpreter and running it with that file as input instead.  This\nis known as creating a script.  As your program gets longer, you may want to\nsplit it into several files for easier maintenance.  You may also want to use a\nhandy function that youâve written in several programs without copying its\ndefinition into each program.\nTo support this, Python has a way to put definitions in a file and use them in a\nscript or in an interactive instance of the interpreter. Such a file is called a\nmodule; definitions from a module can be imported into other modules or into\nthe main module (the collection of variables that you have access to in a\nscript executed at the top level and in calculator mode).\nA module is a file containing Python definitions and statements.  The file name\nis the module name with the suffix .py appended.  Within a module, the\nmoduleâs name (as a string) is available as the value of the global variable\n__name__.  For instance, use your favorite text editor to create a file\ncalled fibo.py in the current directory with the following contents:\n# Fibonacci numbers module\ndef fib(n):    # write Fibonacci series up to n\na, b = 0, 1\nwhile a < n:\nprint(a, end=' ')\na, b = b, a+b\nprint()\ndef fib2(n):   # return Fibonacci series up to n\nresult = []\na, b = 0, 1\nwhile a < n:\nresult.append(a)\na, b = b, a+b\nreturn result\nNow enter the Python interpreter and import this module with the following\ncommand:\n>>> import fibo\nThis does not add the names of the functions defined in fibo  directly to\nthe current namespace (see Python Scopes and Namespaces for more details);\nit only adds the module name fibo there. Using\nthe module name you can access the functions:\n>>> fibo.fib(1000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\nIf you intend to use a function often you can assign it to a local name:\n>>> fib = fibo.fib\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n6.1. More on ModulesÂ¶\nA module can contain executable statements as well as function definitions.\nThese statements are intended to initialize the module. They are executed only\nthe first time the module name is encountered in an import statement. [1]\n(They are also run if the file is executed as a script.)\nEach module has its own private namespace, which is used as the global namespace\nby all functions defined in the module. Thus, the author of a module can\nuse global variables in the module without worrying about accidental clashes\nwith a userâs global variables. On the other hand, if you know what you are\ndoing you can touch a moduleâs global variables with the same notation used to\nrefer to its functions, modname.itemname.\nModules can import other modules.  It is customary but not required to place all\nimport statements at the beginning of a module (or script, for that\nmatter).  The imported module names, if placed at the top level of a module\n(outside any functions or classes), are added to the moduleâs global namespace.\nThere is a variant of the import statement that imports names from a\nmodule directly into the importing moduleâs namespace.  For example:\n>>> from fibo import fib, fib2\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis does not introduce the module name from which the imports are taken in the\nlocal namespace (so in the example, fibo is not defined).\nThere is even a variant to import all names that a module defines:\n>>> from fibo import *\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis imports all names except those beginning with an underscore (_).\nIn most cases Python programmers do not use this facility since it introduces\nan unknown set of names into the interpreter, possibly hiding some things\nyou have already defined.\nNote that in general the practice of importing * from a module or package is\nfrowned upon, since it often causes poorly readable code. However, it is okay to\nuse it to save typing in interactive sessions.\nIf the module name is followed by as, then the name\nfollowing as is bound directly to the imported module.\n>>> import fibo as fib\n>>> fib.fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis is effectively importing the module in the same way that import fibo\nwill do, with the only difference of it being available as fib.\nIt can also be used when utilising from with similar effects:\n>>> from fibo import fib as fibonacci\n>>> fibonacci(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nNote\nFor efficiency reasons, each module is only imported once per interpreter\nsession.  Therefore, if you change your modules, you must restart the\ninterpreter â or, if itâs just one module you want to test interactively,\nuse importlib.reload(), e.g. import importlib;\nimportlib.reload(modulename).\n6.1.1. Executing modules as scriptsÂ¶\nWhen you run a Python module with\npython fibo.py <arguments>\nthe code in the module will be executed, just as if you imported it, but with\nthe __name__ set to \"__main__\".  That means that by adding this code at\nthe end of your module:\nif __name__ == \"__main__\":\nimport sys\nfib(int(sys.argv[1]))\nyou can make the file usable as a script as well as an importable module,\nbecause the code that parses the command line only runs if the module is\nexecuted as the âmainâ file:\n$ python fibo.py 50\n0 1 1 2 3 5 8 13 21 34\nIf the module is imported, the code is not run:\n>>> import fibo\n>>>\nThis is often used either to provide a convenient user interface to a module, or\nfor testing purposes (running the module as a script executes a test suite).\n6.1.2. The Module Search PathÂ¶\nWhen a module named spam is imported, the interpreter first searches for\na built-in module with that name. These module names are listed in\nsys.builtin_module_names. If not found, it then searches for a file\nnamed spam.py in a list of directories given by the variable\nsys.path.  sys.path is initialized from these locations:\nThe directory containing the input script (or the current directory when no\nfile is specified).\nPYTHONPATH (a list of directory names, with the same syntax as the\nshell variable PATH).\nThe installation-dependent default (by convention including a\nsite-packages directory, handled by the site module).\nMore details are at The initialization of the sys.path module search path.\nNote\nOn file systems which support symlinks, the directory containing the input\nscript is calculated after the symlink is followed. In other words the\ndirectory containing the symlink is not added to the module search path.\nAfter initialization, Python programs can modify sys.path.  The\ndirectory containing the script being run is placed at the beginning of the\nsearch path, ahead of the standard library path. This means that scripts in that\ndirectory will be loaded instead of modules of the same name in the library\ndirectory. This is an error unless the replacement is intended.  See section\nStandard Modules for more information.\n6.1.3. âCompiledâ Python filesÂ¶\nTo speed up loading modules, Python caches the compiled version of each module\nin the __pycache__ directory under the name module.version.pyc,\nwhere the version encodes the format of the compiled file; it generally contains\nthe Python version number.  For example, in CPython release 3.3 the compiled\nversion of spam.py would be cached as __pycache__/spam.cpython-33.pyc.  This\nnaming convention allows compiled modules from different releases and different\nversions of Python to coexist.\nPython checks the modification date of the source against the compiled version\nto see if itâs out of date and needs to be recompiled.  This is a completely\nautomatic process.  Also, the compiled modules are platform-independent, so the\nsame library can be shared among systems with different architectures.\nPython does not check the cache in two circumstances.  First, it always\nrecompiles and does not store the result for the module thatâs loaded directly\nfrom the command line.  Second, it does not check the cache if there is no\nsource module.  To support a non-source (compiled only) distribution, the\ncompiled module must be in the source directory, and there must not be a source\nmodule.\nSome tips for experts:\nYou can use the -O or -OO switches on the Python command\nto reduce the size of a compiled module.  The -O switch removes assert\nstatements, the -OO switch removes both assert statements and __doc__\nstrings.  Since some programs may rely on having these available, you should\nonly use this option if you know what youâre doing.  âOptimizedâ modules have\nan opt- tag and are usually smaller.  Future releases may\nchange the effects of optimization.\nA program doesnât run any faster when it is read from a .pyc\nfile than when it is read from a .py file; the only thing thatâs faster\nabout .pyc files is the speed with which they are loaded.\nThe module compileall can create .pyc files for all modules in a\ndirectory.\nThere is more detail on this process, including a flow chart of the\ndecisions, in PEP 3147.\n6.2. Standard ModulesÂ¶\nPython comes with a library of standard modules, described in a separate\ndocument, the Python Library Reference (âLibrary Referenceâ hereafter).  Some\nmodules are built into the interpreter; these provide access to operations that\nare not part of the core of the language but are nevertheless built in, either\nfor efficiency or to provide access to operating system primitives such as\nsystem calls.  The set of such modules is a configuration option which also\ndepends on the underlying platform.  For example, the winreg module is only\nprovided on Windows systems. One particular module deserves some attention:\nsys, which is built into every Python interpreter.  The variables\nsys.ps1 and sys.ps2 define the strings used as primary and secondary\nprompts:\n>>> import sys\n>>> sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print('Yuck!')\nYuck!\nC>\nThese two variables are only defined if the interpreter is in interactive mode.\nThe variable sys.path is a list of strings that determines the interpreterâs\nsearch path for modules. It is initialized to a default path taken from the\nenvironment variable PYTHONPATH, or from a built-in default if\nPYTHONPATH is not set.  You can modify it using standard list\noperations:\n>>> import sys\n>>> sys.path.append('/ufs/guido/lib/python')\n6.3. The dir() FunctionÂ¶\nThe built-in function dir() is used to find out which names a module\ndefines.  It returns a sorted list of strings:\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)\n['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n'__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n'__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n'_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n'_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',\n'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n'warnoptions']\nWithout arguments, dir() lists the names you have defined currently:\n>>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir()\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']\nNote that it lists all types of names: variables, modules, functions, etc.\ndir() does not list the names of built-in functions and variables.  If you\nwant a list of those, they are defined in the standard module\nbuiltins:\n>>> import builtins\n>>> dir(builtins)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n'NotImplementedError', 'OSError', 'OverflowError',\n'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n'__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n'zip']\n6.4. PackagesÂ¶\nPackages are a way of structuring Pythonâs module namespace by using âdotted\nmodule namesâ.  For example, the module name A.B designates a submodule\nnamed B in a package named A.  Just like the use of modules saves the\nauthors of different modules from having to worry about each otherâs global\nvariable names, the use of dotted module names saves the authors of multi-module\npackages like NumPy or Pillow from having to worry about\neach otherâs module names.\nSuppose you want to design a collection of modules (a âpackageâ) for the uniform\nhandling of sound files and sound data.  There are many different sound file\nformats (usually recognized by their extension, for example: .wav,\n.aiff, .au), so you may need to create and maintain a growing\ncollection of modules for the conversion between the various file formats.\nThere are also many different operations you might want to perform on sound data\n(such as mixing, adding echo, applying an equalizer function, creating an\nartificial stereo effect), so in addition you will be writing a never-ending\nstream of modules to perform these operations.  Hereâs a possible structure for\nyour package (expressed in terms of a hierarchical filesystem):\nsound/                          Top-level package\n__init__.py               Initialize the sound package\nformats/                  Subpackage for file format conversions\n__init__.py\nwavread.py\nwavwrite.py\naiffread.py\naiffwrite.py\nauread.py\nauwrite.py\n...\neffects/                  Subpackage for sound effects\n__init__.py\necho.py\nsurround.py\nreverse.py\n...\nfilters/                  Subpackage for filters\n__init__.py\nequalizer.py\nvocoder.py\nkaraoke.py\n...\nWhen importing the package, Python searches through the directories on\nsys.path looking for the package subdirectory.\nThe __init__.py files are required to make Python treat directories\ncontaining the file as packages (unless using a namespace package, a\nrelatively advanced feature). This prevents directories with a common name,\nsuch as string, from unintentionally hiding valid modules that occur later\non the module search path. In the simplest case, __init__.py can just be\nan empty file, but it can also execute initialization code for the package or\nset the __all__ variable, described later.\nUsers of the package can import individual modules from the package, for\nexample:\nimport sound.effects.echo\nThis loads the submodule sound.effects.echo.  It must be referenced with\nits full name.\nsound.effects.echo.echofilter(input, output, delay=0.7, atten=4)\nAn alternative way of importing the submodule is:\nfrom sound.effects import echo\nThis also loads the submodule echo, and makes it available without its\npackage prefix, so it can be used as follows:\necho.echofilter(input, output, delay=0.7, atten=4)\nYet another variation is to import the desired function or variable directly:\nfrom sound.effects.echo import echofilter\nAgain, this loads the submodule echo, but this makes its function\nechofilter() directly available:\nechofilter(input, output, delay=0.7, atten=4)\nNote that when using from package import item, the item can be either a\nsubmodule (or subpackage) of the package, or some  other name defined in the\npackage, like a function, class or variable.  The import statement first\ntests whether the item is defined in the package; if not, it assumes it is a\nmodule and attempts to load it.  If it fails to find it, an ImportError\nexception is raised.\nContrarily, when using syntax like import item.subitem.subsubitem, each item\nexcept for the last must be a package; the last item can be a module or a\npackage but canât be a class or function or variable defined in the previous\nitem.\n6.4.1. Importing * From a PackageÂ¶\nNow what happens when the user writes from sound.effects import *?  Ideally,\none would hope that this somehow goes out to the filesystem, finds which\nsubmodules are present in the package, and imports them all.  This could take a\nlong time and importing sub-modules might have unwanted side-effects that should\nonly happen when the sub-module is explicitly imported.\nThe only solution is for the package author to provide an explicit index of the\npackage.  The import statement uses the following convention: if a packageâs\n__init__.py code defines a list named __all__, it is taken to be the\nlist of module names that should be imported when from package import * is\nencountered.  It is up to the package author to keep this list up-to-date when a\nnew version of the package is released.  Package authors may also decide not to\nsupport it, if they donât see a use for importing * from their package.  For\nexample, the file sound/effects/__init__.py could contain the following\ncode:\n__all__ = [\"echo\", \"surround\", \"reverse\"]\nThis would mean that from sound.effects import * would import the three\nnamed submodules of the sound.effects package.\nBe aware that submodules might become shadowed by locally defined names. For\nexample, if you added a reverse function to the\nsound/effects/__init__.py file, the from sound.effects import *\nwould only import the two submodules echo and surround, but not the\nreverse submodule, because it is shadowed by the locally defined\nreverse function:\n__all__ = [\n\"echo\",      # refers to the 'echo.py' file\n\"surround\",  # refers to the 'surround.py' file\n\"reverse\",   # !!! refers to the 'reverse' function now !!!\n]\ndef reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule\nreturn msg[::-1]    #     in the case of a 'from sound.effects import *'\nIf __all__ is not defined, the statement from sound.effects import *\ndoes not import all submodules from the package sound.effects into the\ncurrent namespace; it only ensures that the package sound.effects has\nbeen imported (possibly running any initialization code in __init__.py)\nand then imports whatever names are defined in the package.  This includes any\nnames defined (and submodules explicitly loaded) by __init__.py.  It\nalso includes any submodules of the package that were explicitly loaded by\nprevious import statements.  Consider this code:\nimport sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import *\nIn this example, the echo and surround modules are imported in the\ncurrent namespace because they are defined in the sound.effects package\nwhen the from...import statement is executed.  (This also works when\n__all__ is defined.)\nAlthough certain modules are designed to export only names that follow certain\npatterns when you use import *, it is still considered bad practice in\nproduction code.\nRemember, there is nothing wrong with using from package import\nspecific_submodule!  In fact, this is the recommended notation unless the\nimporting module needs to use submodules with the same name from different\npackages.\n6.4.2. Intra-package ReferencesÂ¶\nWhen packages are structured into subpackages (as with the sound package\nin the example), you can use absolute imports to refer to submodules of siblings\npackages.  For example, if the module sound.filters.vocoder needs to use\nthe echo module in the sound.effects package, it can use from\nsound.effects import echo.\nYou can also write relative imports, with the from module import name form\nof import statement.  These imports use leading dots to indicate the current and\nparent packages involved in the relative import.  From the surround\nmodule for example, you might use:\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\nNote that relative imports are based on the name of the current module.  Since\nthe name of the main module is always \"__main__\", modules intended for use\nas the main module of a Python application must always use absolute imports.\n6.4.3. Packages in Multiple DirectoriesÂ¶\nPackages support one more special attribute, __path__.  This is\ninitialized to be a sequence of strings containing the name of the\ndirectory holding the\npackageâs __init__.py before the code in that file is executed.  This\nvariable can be modified; doing so affects future searches for modules and\nsubpackages contained in the package.\nWhile this feature is not often needed, it can be used to extend the set of\nmodules found in a package.\nFootnotes\n[1]\nIn fact function definitions are also âstatementsâ that are âexecutedâ; the\nexecution of a module-level function definition adds the function name to\nthe moduleâs global namespace.\n\n==================== CLASSES ====================\n\n9. ClassesÂ¶\nClasses provide a means of bundling data and functionality together.  Creating\na new class creates a new type of object, allowing new instances of that\ntype to be made.  Each class instance can have attributes attached to it for\nmaintaining its state.  Class instances can also have methods (defined by its\nclass) for modifying its state.\nCompared with other programming languages, Pythonâs class mechanism adds classes\nwith a minimum of new syntax and semantics.  It is a mixture of the class\nmechanisms found in C++ and Modula-3.  Python classes provide all the standard\nfeatures of Object Oriented Programming: the class inheritance mechanism allows\nmultiple base classes, a derived class can override any methods of its base\nclass or classes, and a method can call the method of a base class with the same\nname.  Objects can contain arbitrary amounts and kinds of data.  As is true for\nmodules, classes partake of the dynamic nature of Python: they are created at\nruntime, and can be modified further after creation.\nIn C++ terminology, normally class members (including the data members) are\npublic (except see below Private Variables), and all member functions are\nvirtual.  As in Modula-3, there are no shorthands for referencing the objectâs\nmembers from its methods: the method function is declared with an explicit first\nargument representing the object, which is provided implicitly by the call.  As\nin Smalltalk, classes themselves are objects.  This provides semantics for\nimporting and renaming.  Unlike C++ and Modula-3, built-in types can be used as\nbase classes for extension by the user.  Also, like in C++, most built-in\noperators with special syntax (arithmetic operators, subscripting etc.) can be\nredefined for class instances.\n(Lacking universally accepted terminology to talk about classes, I will make\noccasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, since\nits object-oriented semantics are closer to those of Python than C++, but I\nexpect that few readers have heard of it.)\n9.1. A Word About Names and ObjectsÂ¶\nObjects have individuality, and multiple names (in multiple scopes) can be bound\nto the same object.  This is known as aliasing in other languages.  This is\nusually not appreciated on a first glance at Python, and can be safely ignored\nwhen dealing with immutable basic types (numbers, strings, tuples).  However,\naliasing has a possibly surprising effect on the semantics of Python code\ninvolving mutable objects such as lists, dictionaries, and most other types.\nThis is usually used to the benefit of the program, since aliases behave like\npointers in some respects.  For example, passing an object is cheap since only a\npointer is passed by the implementation; and if a function modifies an object\npassed as an argument, the caller will see the change â this eliminates the\nneed for two different argument passing mechanisms as in Pascal.\n9.2. Python Scopes and NamespacesÂ¶\nBefore introducing classes, I first have to tell you something about Pythonâs\nscope rules.  Class definitions play some neat tricks with namespaces, and you\nneed to know how scopes and namespaces work to fully understand whatâs going on.\nIncidentally, knowledge about this subject is useful for any advanced Python\nprogrammer.\nLetâs begin with some definitions.\nA namespace is a mapping from names to objects.  Most namespaces are currently\nimplemented as Python dictionaries, but thatâs normally not noticeable in any\nway (except for performance), and it may change in the future.  Examples of\nnamespaces are: the set of built-in names (containing functions such as abs(), and\nbuilt-in exception names); the global names in a module; and the local names in\na function invocation.  In a sense the set of attributes of an object also form\na namespace.  The important thing to know about namespaces is that there is\nabsolutely no relation between names in different namespaces; for instance, two\ndifferent modules may both define a function maximize without confusion â\nusers of the modules must prefix it with the module name.\nBy the way, I use the word attribute for any name following a dot â for\nexample, in the expression z.real, real is an attribute of the object\nz.  Strictly speaking, references to names in modules are attribute\nreferences: in the expression modname.funcname, modname is a module\nobject and funcname is an attribute of it.  In this case there happens to be\na straightforward mapping between the moduleâs attributes and the global names\ndefined in the module: they share the same namespace!  [1]\nAttributes may be read-only or writable.  In the latter case, assignment to\nattributes is possible.  Module attributes are writable: you can write\nmodname.the_answer = 42.  Writable attributes may also be deleted with the\ndel statement.  For example, del modname.the_answer will remove\nthe attribute the_answer from the object named by modname.\nNamespaces are created at different moments and have different lifetimes.  The\nnamespace containing the built-in names is created when the Python interpreter\nstarts up, and is never deleted.  The global namespace for a module is created\nwhen the module definition is read in; normally, module namespaces also last\nuntil the interpreter quits.  The statements executed by the top-level\ninvocation of the interpreter, either read from a script file or interactively,\nare considered part of a module called __main__, so they have their own\nglobal namespace.  (The built-in names actually also live in a module; this is\ncalled builtins.)\nThe local namespace for a function is created when the function is called, and\ndeleted when the function returns or raises an exception that is not handled\nwithin the function.  (Actually, forgetting would be a better way to describe\nwhat actually happens.)  Of course, recursive invocations each have their own\nlocal namespace.\nA scope is a textual region of a Python program where a namespace is directly\naccessible.  âDirectly accessibleâ here means that an unqualified reference to a\nname attempts to find the name in the namespace.\nAlthough scopes are determined statically, they are used dynamically. At any\ntime during execution, there are 3 or 4 nested scopes whose namespaces are\ndirectly accessible:\nthe innermost scope, which is searched first, contains the local names\nthe scopes of any enclosing functions, which are searched starting with the\nnearest enclosing scope, contain non-local, but also non-global names\nthe next-to-last scope contains the current moduleâs global names\nthe outermost scope (searched last) is the namespace containing built-in names\nIf a name is declared global, then all references and assignments go directly to\nthe next-to-last scope containing the moduleâs global names.  To rebind variables\nfound outside of the innermost scope, the nonlocal statement can be\nused; if not declared nonlocal, those variables are read-only (an attempt to\nwrite to such a variable will simply create a new local variable in the\ninnermost scope, leaving the identically named outer variable unchanged).\nUsually, the local scope references the local names of the (textually) current\nfunction.  Outside functions, the local scope references the same namespace as\nthe global scope: the moduleâs namespace. Class definitions place yet another\nnamespace in the local scope.\nIt is important to realize that scopes are determined textually: the global\nscope of a function defined in a module is that moduleâs namespace, no matter\nfrom where or by what alias the function is called.  On the other hand, the\nactual search for names is done dynamically, at run time â however, the\nlanguage definition is evolving towards static name resolution, at âcompileâ\ntime, so donât rely on dynamic name resolution!  (In fact, local variables are\nalready determined statically.)\nA special quirk of Python is that â if no global or nonlocal\nstatement is in effect â assignments to names always go into the innermost scope.\nAssignments do not copy data â they just bind names to objects.  The same is true\nfor deletions: the statement del x removes the binding of x from the\nnamespace referenced by the local scope.  In fact, all operations that introduce\nnew names use the local scope: in particular, import statements and\nfunction definitions bind the module or function name in the local scope.\nThe global statement can be used to indicate that particular\nvariables live in the global scope and should be rebound there; the\nnonlocal statement indicates that particular variables live in\nan enclosing scope and should be rebound there.\n9.2.1. Scopes and Namespaces ExampleÂ¶\nThis is an example demonstrating how to reference the different scopes and\nnamespaces, and how global and nonlocal affect variable\nbinding:\ndef scope_test():\ndef do_local():\nspam = \"local spam\"\ndef do_nonlocal():\nnonlocal spam\nspam = \"nonlocal spam\"\ndef do_global():\nglobal spam\nspam = \"global spam\"\nspam = \"test spam\"\ndo_local()\nprint(\"After local assignment:\", spam)\ndo_nonlocal()\nprint(\"After nonlocal assignment:\", spam)\ndo_global()\nprint(\"After global assignment:\", spam)\nscope_test()\nprint(\"In global scope:\", spam)\nThe output of the example code is:\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\nNote how the local assignment (which is default) didnât change scope_test's\nbinding of spam.  The nonlocal assignment changed scope_test's\nbinding of spam, and the global assignment changed the module-level\nbinding.\nYou can also see that there was no previous binding for spam before the\nglobal assignment.\n9.3. A First Look at ClassesÂ¶\nClasses introduce a little bit of new syntax, three new object types, and some\nnew semantics.\n9.3.1. Class Definition SyntaxÂ¶\nThe simplest form of class definition looks like this:\nclass ClassName:\n<statement-1>\n.\n.\n.\n<statement-N>\nClass definitions, like function definitions (def statements) must be\nexecuted before they have any effect.  (You could conceivably place a class\ndefinition in a branch of an if statement, or inside a function.)\nIn practice, the statements inside a class definition will usually be function\ndefinitions, but other statements are allowed, and sometimes useful â weâll\ncome back to this later.  The function definitions inside a class normally have\na peculiar form of argument list, dictated by the calling conventions for\nmethods â again, this is explained later.\nWhen a class definition is entered, a new namespace is created, and used as the\nlocal scope â thus, all assignments to local variables go into this new\nnamespace.  In particular, function definitions bind the name of the new\nfunction here.\nWhen a class definition is left normally (via the end), a class object is\ncreated.  This is basically a wrapper around the contents of the namespace\ncreated by the class definition; weâll learn more about class objects in the\nnext section.  The original local scope (the one in effect just before the class\ndefinition was entered) is reinstated, and the class object is bound here to the\nclass name given in the class definition header (ClassName in the\nexample).\n9.3.2. Class ObjectsÂ¶\nClass objects support two kinds of operations: attribute references and\ninstantiation.\nAttribute references use the standard syntax used for all attribute references\nin Python: obj.name.  Valid attribute names are all the names that were in\nthe classâs namespace when the class object was created.  So, if the class\ndefinition looked like this:\nclass MyClass:\n\"\"\"A simple example class\"\"\"\ni = 12345\ndef f(self):\nreturn 'hello world'\nthen MyClass.i and MyClass.f are valid attribute references, returning\nan integer and a function object, respectively. Class attributes can also be\nassigned to, so you can change the value of MyClass.i by assignment.\n__doc__ is also a valid attribute, returning the docstring\nbelonging to the class: \"A simple example class\".\nClass instantiation uses function notation.  Just pretend that the class\nobject is a parameterless function that returns a new instance of the class.\nFor example (assuming the above class):\nx = MyClass()\ncreates a new instance of the class and assigns this object to the local\nvariable x.\nThe instantiation operation (âcallingâ a class object) creates an empty object.\nMany classes like to create objects with instances customized to a specific\ninitial state. Therefore a class may define a special method named\n__init__(), like this:\ndef __init__(self):\nself.data = []\nWhen a class defines an __init__() method, class instantiation\nautomatically invokes __init__() for the newly created class instance.  So\nin this example, a new, initialized instance can be obtained by:\nx = MyClass()\nOf course, the __init__() method may have arguments for greater\nflexibility.  In that case, arguments given to the class instantiation operator\nare passed on to __init__().  For example,\n>>> class Complex:\n...     def __init__(self, realpart, imagpart):\n...         self.r = realpart\n...         self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n9.3.3. Instance ObjectsÂ¶\nNow what can we do with instance objects?  The only operations understood by\ninstance objects are attribute references.  There are two kinds of valid\nattribute names: data attributes and methods.\ndata attributes correspond to âinstance variablesâ in Smalltalk, and to âdata\nmembersâ in C++.  Data attributes need not be declared; like local variables,\nthey spring into existence when they are first assigned to.  For example, if\nx is the instance of MyClass created above, the following piece of\ncode will print the value 16, without leaving a trace:\nx.counter = 1\nwhile x.counter < 10:\nx.counter = x.counter * 2\nprint(x.counter)\ndel x.counter\nThe other kind of instance attribute reference is a method. A method is a\nfunction that âbelongs toâ an object.\nValid method names of an instance object depend on its class.  By definition,\nall attributes of a class that are function  objects define corresponding\nmethods of its instances.  So in our example, x.f is a valid method\nreference, since MyClass.f is a function, but x.i is not, since\nMyClass.i is not.  But x.f is not the same thing as MyClass.f â it\nis a method object, not a function object.\n9.3.4. Method ObjectsÂ¶\nUsually, a method is called right after it is bound:\nx.f()\nIn the MyClass example, this will return the string 'hello world'.\nHowever, it is not necessary to call a method right away: x.f is a method\nobject, and can be stored away and called at a later time.  For example:\nxf = x.f\nwhile True:\nprint(xf())\nwill continue to print hello world until the end of time.\nWhat exactly happens when a method is called?  You may have noticed that\nx.f() was called without an argument above, even though the function\ndefinition for f() specified an argument.  What happened to the argument?\nSurely Python raises an exception when a function that requires an argument is\ncalled without any â even if the argument isnât actually usedâ¦\nActually, you may have guessed the answer: the special thing about methods is\nthat the instance object is passed as the first argument of the function.  In our\nexample, the call x.f() is exactly equivalent to MyClass.f(x).  In\ngeneral, calling a method with a list of n arguments is equivalent to calling\nthe corresponding function with an argument list that is created by inserting\nthe methodâs instance object before the first argument.\nIn general, methods work as follows.  When a non-data attribute\nof an instance is referenced, the instanceâs class is searched.\nIf the name denotes a valid class attribute that is a function object,\nreferences to both the instance object and the function object\nare packed into a method object.  When the method object is called\nwith an argument list, a new argument list is constructed from the instance\nobject and the argument list, and the function object is called with this new\nargument list.\n9.3.5. Class and Instance VariablesÂ¶\nGenerally speaking, instance variables are for data unique to each instance\nand class variables are for attributes and methods shared by all instances\nof the class:\nclass Dog:\nkind = 'canine'         # class variable shared by all instances\ndef __init__(self, name):\nself.name = name    # instance variable unique to each instance\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\nAs discussed in A Word About Names and Objects, shared data can have possibly surprising\neffects with involving mutable objects such as lists and dictionaries.\nFor example, the tricks list in the following code should not be used as a\nclass variable because just a single list would be shared by all Dog\ninstances:\nclass Dog:\ntricks = []             # mistaken use of a class variable\ndef __init__(self, name):\nself.name = name\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\nCorrect design of the class should use an instance variable instead:\nclass Dog:\ndef __init__(self, name):\nself.name = name\nself.tricks = []    # creates a new empty list for each dog\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n9.4. Random RemarksÂ¶\nIf the same attribute name occurs in both an instance and in a class,\nthen attribute lookup prioritizes the instance:\n>>> class Warehouse:\n...    purpose = 'storage'\n...    region = 'west'\n...\n>>> w1 = Warehouse()\n>>> print(w1.purpose, w1.region)\nstorage west\n>>> w2 = Warehouse()\n>>> w2.region = 'east'\n>>> print(w2.purpose, w2.region)\nstorage east\nData attributes may be referenced by methods as well as by ordinary users\n(âclientsâ) of an object.  In other words, classes are not usable to implement\npure abstract data types.  In fact, nothing in Python makes it possible to\nenforce data hiding â it is all based upon convention.  (On the other hand,\nthe Python implementation, written in C, can completely hide implementation\ndetails and control access to an object if necessary; this can be used by\nextensions to Python written in C.)\nClients should use data attributes with care â clients may mess up invariants\nmaintained by the methods by stamping on their data attributes.  Note that\nclients may add data attributes of their own to an instance object without\naffecting the validity of the methods, as long as name conflicts are avoided â\nagain, a naming convention can save a lot of headaches here.\nThere is no shorthand for referencing data attributes (or other methods!) from\nwithin methods.  I find that this actually increases the readability of methods:\nthere is no chance of confusing local variables and instance variables when\nglancing through a method.\nOften, the first argument of a method is called self.  This is nothing more\nthan a convention: the name self has absolutely no special meaning to\nPython.  Note, however, that by not following the convention your code may be\nless readable to other Python programmers, and it is also conceivable that a\nclass browser program might be written that relies upon such a convention.\nAny function object that is a class attribute defines a method for instances of\nthat class.  It is not necessary that the function definition is textually\nenclosed in the class definition: assigning a function object to a local\nvariable in the class is also ok.  For example:\n# Function defined outside the class\ndef f1(self, x, y):\nreturn min(x, x+y)\nclass C:\nf = f1\ndef g(self):\nreturn 'hello world'\nh = g\nNow f, g and h are all attributes of class C that refer to\nfunction objects, and consequently they are all methods of instances of\nC â h being exactly equivalent to g.  Note that this practice\nusually only serves to confuse the reader of a program.\nMethods may call other methods by using method attributes of the self\nargument:\nclass Bag:\ndef __init__(self):\nself.data = []\ndef add(self, x):\nself.data.append(x)\ndef addtwice(self, x):\nself.add(x)\nself.add(x)\nMethods may reference global names in the same way as ordinary functions.  The\nglobal scope associated with a method is the module containing its\ndefinition.  (A class is never used as a global scope.)  While one\nrarely encounters a good reason for using global data in a method, there are\nmany legitimate uses of the global scope: for one thing, functions and modules\nimported into the global scope can be used by methods, as well as functions and\nclasses defined in it.  Usually, the class containing the method is itself\ndefined in this global scope, and in the next section weâll find some good\nreasons why a method would want to reference its own class.\nEach value is an object, and therefore has a class (also called its type).\nIt is stored as object.__class__.\n9.5. InheritanceÂ¶\nOf course, a language feature would not be worthy of the name âclassâ without\nsupporting inheritance.  The syntax for a derived class definition looks like\nthis:\nclass DerivedClassName(BaseClassName):\n<statement-1>\n.\n.\n.\n<statement-N>\nThe name BaseClassName must be defined in a\nnamespace accessible from the scope containing the\nderived class definition.  In place of a base class name, other arbitrary\nexpressions are also allowed.  This can be useful, for example, when the base\nclass is defined in another module:\nclass DerivedClassName(modname.BaseClassName):\nExecution of a derived class definition proceeds the same as for a base class.\nWhen the class object is constructed, the base class is remembered.  This is\nused for resolving attribute references: if a requested attribute is not found\nin the class, the search proceeds to look in the base class.  This rule is\napplied recursively if the base class itself is derived from some other class.\nThereâs nothing special about instantiation of derived classes:\nDerivedClassName() creates a new instance of the class.  Method references\nare resolved as follows: the corresponding class attribute is searched,\ndescending down the chain of base classes if necessary, and the method reference\nis valid if this yields a function object.\nDerived classes may override methods of their base classes.  Because methods\nhave no special privileges when calling other methods of the same object, a\nmethod of a base class that calls another method defined in the same base class\nmay end up calling a method of a derived class that overrides it.  (For C++\nprogrammers: all methods in Python are effectively virtual.)\nAn overriding method in a derived class may in fact want to extend rather than\nsimply replace the base class method of the same name. There is a simple way to\ncall the base class method directly: just call BaseClassName.methodname(self,\narguments).  This is occasionally useful to clients as well.  (Note that this\nonly works if the base class is accessible as BaseClassName in the global\nscope.)\nPython has two built-in functions that work with inheritance:\nUse isinstance() to check an instanceâs type: isinstance(obj, int)\nwill be True only if obj.__class__ is int or some class\nderived from int.\nUse issubclass() to check class inheritance: issubclass(bool, int)\nis True since bool is a subclass of int.  However,\nissubclass(float, int) is False since float is not a\nsubclass of int.\n9.5.1. Multiple InheritanceÂ¶\nPython supports a form of multiple inheritance as well.  A class definition with\nmultiple base classes looks like this:\nclass DerivedClassName(Base1, Base2, Base3):\n<statement-1>\n.\n.\n.\n<statement-N>\nFor most purposes, in the simplest cases, you can think of the search for\nattributes inherited from a parent class as depth-first, left-to-right, not\nsearching twice in the same class where there is an overlap in the hierarchy.\nThus, if an attribute is not found in DerivedClassName, it is searched\nfor in Base1, then (recursively) in the base classes of Base1,\nand if it was not found there, it was searched for in Base2, and so on.\nIn fact, it is slightly more complex than that; the method resolution order\nchanges dynamically to support cooperative calls to super().  This\napproach is known in some other multiple-inheritance languages as\ncall-next-method and is more powerful than the super call found in\nsingle-inheritance languages.\nDynamic ordering is necessary because all cases of multiple inheritance exhibit\none or more diamond relationships (where at least one of the parent classes\ncan be accessed through multiple paths from the bottommost class).  For example,\nall classes inherit from object, so any case of multiple inheritance\nprovides more than one path to reach object.  To keep the base classes\nfrom being accessed more than once, the dynamic algorithm linearizes the search\norder in a way that preserves the left-to-right ordering specified in each\nclass, that calls each parent only once, and that is monotonic (meaning that a\nclass can be subclassed without affecting the precedence order of its parents).\nTaken together, these properties make it possible to design reliable and\nextensible classes with multiple inheritance.  For more detail, see\nThe Python 2.3 Method Resolution Order.\n9.6. Private VariablesÂ¶\nâPrivateâ instance variables that cannot be accessed except from inside an\nobject donât exist in Python.  However, there is a convention that is followed\nby most Python code: a name prefixed with an underscore (e.g. _spam) should\nbe treated as a non-public part of the API (whether it is a function, a method\nor a data member).  It should be considered an implementation detail and subject\nto change without notice.\nSince there is a valid use-case for class-private members (namely to avoid name\nclashes of names with names defined by subclasses), there is limited support for\nsuch a mechanism, called name mangling.  Any identifier of the form\n__spam (at least two leading underscores, at most one trailing underscore)\nis textually replaced with _classname__spam, where classname is the\ncurrent class name with leading underscore(s) stripped.  This mangling is done\nwithout regard to the syntactic position of the identifier, as long as it\noccurs within the definition of a class.\nSee also\nThe private name mangling specifications\nfor details and special cases.\nName mangling is helpful for letting subclasses override methods without\nbreaking intraclass method calls.  For example:\nclass Mapping:\ndef __init__(self, iterable):\nself.items_list = []\nself.__update(iterable)\ndef update(self, iterable):\nfor item in iterable:\nself.items_list.append(item)\n__update = update   # private copy of original update() method\nclass MappingSubclass(Mapping):\ndef update(self, keys, values):\n# provides new signature for update()\n# but does not break __init__()\nfor item in zip(keys, values):\nself.items_list.append(item)\nThe above example would work even if MappingSubclass were to introduce a\n__update identifier since it is replaced with _Mapping__update in the\nMapping class  and _MappingSubclass__update in the MappingSubclass\nclass respectively.\nNote that the mangling rules are designed mostly to avoid accidents; it still is\npossible to access or modify a variable that is considered private.  This can\neven be useful in special circumstances, such as in the debugger.\nNotice that code passed to exec() or eval() does not consider the\nclassname of the invoking class to be the current class; this is similar to the\neffect of the global statement, the effect of which is likewise restricted\nto code that is byte-compiled together.  The same restriction applies to\ngetattr(), setattr() and delattr(), as well as when referencing\n__dict__ directly.\n9.7. Odds and EndsÂ¶\nSometimes it is useful to have a data type similar to the Pascal ârecordâ or C\nâstructâ, bundling together a few named data items. The idiomatic approach\nis to use dataclasses for this purpose:\nfrom dataclasses import dataclass\n@dataclass\nclass Employee:\nname: str\ndept: str\nsalary: int\n>>> john = Employee('john', 'computer lab', 1000)\n>>> john.dept\n'computer lab'\n>>> john.salary\n1000\nA piece of Python code that expects a particular abstract data type can often be\npassed a class that emulates the methods of that data type instead.  For\ninstance, if you have a function that formats some data from a file object, you\ncan define a class with methods read() and\nreadline() that get the\ndata from a string buffer instead, and pass it as an argument.\nInstance method objects have attributes, too:\nm.__self__ is the instance\nobject with the method m(), and m.__func__ is\nthe function object\ncorresponding to the method.\n9.8. IteratorsÂ¶\nBy now you have probably noticed that most container objects can be looped over\nusing a for statement:\nfor element in [1, 2, 3]:\nprint(element)\nfor element in (1, 2, 3):\nprint(element)\nfor key in {'one':1, 'two':2}:\nprint(key)\nfor char in \"123\":\nprint(char)\nfor line in open(\"myfile.txt\"):\nprint(line, end='')\nThis style of access is clear, concise, and convenient.  The use of iterators\npervades and unifies Python.  Behind the scenes, the for statement\ncalls iter() on the container object.  The function returns an iterator\nobject that defines the method __next__() which accesses\nelements in the container one at a time.  When there are no more elements,\n__next__() raises a StopIteration exception which tells the\nfor loop to terminate.  You can call the __next__() method\nusing the next() built-in function; this example shows how it all works:\n>>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<str_iterator object at 0x10c90e650>\n>>> next(it)\n'a'\n>>> next(it)\n'b'\n>>> next(it)\n'c'\n>>> next(it)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nnext(it)\nStopIteration\nHaving seen the mechanics behind the iterator protocol, it is easy to add\niterator behavior to your classes.  Define an __iter__() method which\nreturns an object with a __next__() method.  If the class\ndefines __next__(), then __iter__() can just return self:\nclass Reverse:\n\"\"\"Iterator for looping over a sequence backwards.\"\"\"\ndef __init__(self, data):\nself.data = data\nself.index = len(data)\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.index == 0:\nraise StopIteration\nself.index = self.index - 1\nreturn self.data[self.index]\n>>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n...     print(char)\n...\nm\na\np\ns\n9.9. GeneratorsÂ¶\nGenerators are a simple and powerful tool for creating iterators.  They\nare written like regular functions but use the yield statement\nwhenever they want to return data.  Each time next() is called on it, the\ngenerator resumes where it left off (it remembers all the data values and which\nstatement was last executed).  An example shows that generators can be trivially\neasy to create:\ndef reverse(data):\nfor index in range(len(data)-1, -1, -1):\nyield data[index]\n>>> for char in reverse('golf'):\n...     print(char)\n...\nf\nl\no\ng\nAnything that can be done with generators can also be done with class-based\niterators as described in the previous section.  What makes generators so\ncompact is that the __iter__() and __next__() methods\nare created automatically.\nAnother key feature is that the local variables and execution state are\nautomatically saved between calls.  This made the function easier to write and\nmuch more clear than an approach using instance variables like self.index\nand self.data.\nIn addition to automatic method creation and saving program state, when\ngenerators terminate, they automatically raise StopIteration. In\ncombination, these features make it easy to create iterators with no more effort\nthan writing a regular function.\n9.10. Generator ExpressionsÂ¶\nSome simple generators can be coded succinctly as expressions using a syntax\nsimilar to list comprehensions but with parentheses instead of square brackets.\nThese expressions are designed for situations where the generator is used right\naway by an enclosing function.  Generator expressions are more compact but less\nversatile than full generator definitions and tend to be more memory friendly\nthan equivalent list comprehensions.\nExamples:\n>>> sum(i*i for i in range(10))                 # sum of squares\n285\n>>> xvec = [10, 20, 30]\n>>> yvec = [7, 5, 3]\n>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n260\n>>> unique_words = set(word for line in page  for word in line.split())\n>>> valedictorian = max((student.gpa, student.name) for student in graduates)\n>>> data = 'golf'\n>>> list(data[i] for i in range(len(data)-1, -1, -1))\n['f', 'l', 'o', 'g']\nFootnotes\n[1]\nExcept for one thing.  Module objects have a secret read-only attribute called\n__dict__ which returns the dictionary used to implement the moduleâs\nnamespace; the name __dict__ is an attribute but not a global name.\nObviously, using this violates the abstraction of namespace implementation, and\nshould be restricted to things like post-mortem debuggers.\n\n==================== ERRORS ====================\n\n8. Errors and ExceptionsÂ¶\nUntil now error messages havenât been more than mentioned, but if you have tried\nout the examples you have probably seen some.  There are (at least) two\ndistinguishable kinds of errors: syntax errors and exceptions.\n8.1. Syntax ErrorsÂ¶\nSyntax errors, also known as parsing errors, are perhaps the most common kind of\ncomplaint you get while you are still learning Python:\n>>> while True print('Hello world')\nFile \"<stdin>\", line 1\nwhile True print('Hello world')\n^^^^^\nSyntaxError: invalid syntax\nThe parser repeats the offending line and displays little âarrowâs pointing\nat the token in the line where the error was detected.  The error may be\ncaused by the absence of a token before the indicated token.  In the\nexample, the error is detected at the function print(), since a colon\n(':') is missing before it.  File name and line number are printed so you\nknow where to look in case the input came from a script.\n8.2. ExceptionsÂ¶\nEven if a statement or expression is syntactically correct, it may cause an\nerror when an attempt is made to execute it. Errors detected during execution\nare called exceptions and are not unconditionally fatal: you will soon learn\nhow to handle them in Python programs.  Most exceptions are not handled by\nprograms, however, and result in error messages as shown here:\n>>> 10 * (1/0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nZeroDivisionError: division by zero\n>>> 4 + spam*3\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'spam' is not defined\n>>> '2' + 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate str (not \"int\") to str\nThe last line of the error message indicates what happened. Exceptions come in\ndifferent types, and the type is printed as part of the message: the types in\nthe example are ZeroDivisionError, NameError and TypeError.\nThe string printed as the exception type is the name of the built-in exception\nthat occurred.  This is true for all built-in exceptions, but need not be true\nfor user-defined exceptions (although it is a useful convention). Standard\nexception names are built-in identifiers (not reserved keywords).\nThe rest of the line provides detail based on the type of exception and what\ncaused it.\nThe preceding part of the error message shows the context where the exception\noccurred, in the form of a stack traceback. In general it contains a stack\ntraceback listing source lines; however, it will not display lines read from\nstandard input.\nBuilt-in Exceptions lists the built-in exceptions and their meanings.\n8.3. Handling ExceptionsÂ¶\nIt is possible to write programs that handle selected exceptions. Look at the\nfollowing example, which asks the user for input until a valid integer has been\nentered, but allows the user to interrupt the program (using Control-C or\nwhatever the operating system supports); note that a user-generated interruption\nis signalled by raising the KeyboardInterrupt exception.\n>>> while True:\n...     try:\n...         x = int(input(\"Please enter a number: \"))\n...         break\n...     except ValueError:\n...         print(\"Oops!  That was no valid number.  Try again...\")\n...\nThe try statement works as follows.\nFirst, the try clause (the statement(s) between the try and\nexcept keywords) is executed.\nIf no exception occurs, the except clause is skipped and execution of the\ntry statement is finished.\nIf an exception occurs during execution of the try clause, the rest of the\nclause is skipped.  Then, if its type matches the exception named after the\nexcept keyword, the except clause is executed, and then execution\ncontinues after the try/except block.\nIf an exception occurs which does not match the exception named in the except\nclause, it is passed on to outer try statements; if no handler is\nfound, it is an unhandled exception and execution stops with an error message.\nA try statement may have more than one except clause, to specify\nhandlers for different exceptions.  At most one handler will be executed.\nHandlers only handle exceptions that occur in the corresponding try clause,\nnot in other handlers of the same try statement.  An except clause\nmay name multiple exceptions as a parenthesized tuple, for example:\n... except (RuntimeError, TypeError, NameError):\n...     pass\nA class in an except clause matches exceptions which are instances of the\nclass itself or one of its derived classes (but not the other way around â an\nexcept clause listing a derived class does not match instances of its base classes).\nFor example, the following code will print B, C, D in that order:\nclass B(Exception):\npass\nclass C(B):\npass\nclass D(C):\npass\nfor cls in [B, C, D]:\ntry:\nraise cls()\nexcept D:\nprint(\"D\")\nexcept C:\nprint(\"C\")\nexcept B:\nprint(\"B\")\nNote that if the except clauses were reversed (with except B first), it\nwould have printed B, B, B â the first matching except clause is triggered.\nWhen an exception occurs, it may have associated values, also known as the\nexceptionâs arguments. The presence and types of the arguments depend on the\nexception type.\nThe except clause may specify a variable after the exception name.  The\nvariable is bound to the exception instance which typically has an args\nattribute that stores the arguments. For convenience, builtin exception\ntypes define __str__() to print all the arguments without explicitly\naccessing .args.\n>>> try:\n...     raise Exception('spam', 'eggs')\n... except Exception as inst:\n...     print(type(inst))    # the exception type\n...     print(inst.args)     # arguments stored in .args\n...     print(inst)          # __str__ allows args to be printed directly,\n...                          # but may be overridden in exception subclasses\n...     x, y = inst.args     # unpack args\n...     print('x =', x)\n...     print('y =', y)\n...\n<class 'Exception'>\n('spam', 'eggs')\n('spam', 'eggs')\nx = spam\ny = eggs\nThe exceptionâs __str__() output is printed as the last part (âdetailâ)\nof the message for unhandled exceptions.\nBaseException is the common base class of all exceptions. One of its\nsubclasses, Exception, is the base class of all the non-fatal exceptions.\nExceptions which are not subclasses of Exception are not typically\nhandled, because they are used to indicate that the program should terminate.\nThey include SystemExit which is raised by sys.exit() and\nKeyboardInterrupt which is raised when a user wishes to interrupt\nthe program.\nException can be used as a wildcard that catches (almost) everything.\nHowever, it is good practice to be as specific as possible with the types\nof exceptions that we intend to handle, and to allow any unexpected\nexceptions to propagate on.\nThe most common pattern for handling Exception is to print or log\nthe exception and then re-raise it (allowing a caller to handle the\nexception as well):\nimport sys\ntry:\nf = open('myfile.txt')\ns = f.readline()\ni = int(s.strip())\nexcept OSError as err:\nprint(\"OS error:\", err)\nexcept ValueError:\nprint(\"Could not convert data to an integer.\")\nexcept Exception as err:\nprint(f\"Unexpected {err=}, {type(err)=}\")\nraise\nThe try â¦ except statement has an optional else\nclause, which, when present, must follow all except clauses.  It is useful\nfor code that must be executed if the try clause does not raise an exception.\nFor example:\nfor arg in sys.argv[1:]:\ntry:\nf = open(arg, 'r')\nexcept OSError:\nprint('cannot open', arg)\nelse:\nprint(arg, 'has', len(f.readlines()), 'lines')\nf.close()\nThe use of the else clause is better than adding additional code to\nthe try clause because it avoids accidentally catching an exception\nthat wasnât raised by the code being protected by the try â¦\nexcept statement.\nException handlers do not handle only exceptions that occur immediately in the\ntry clause, but also those that occur inside functions that are called (even\nindirectly) in the try clause. For example:\n>>> def this_fails():\n...     x = 1/0\n...\n>>> try:\n...     this_fails()\n... except ZeroDivisionError as err:\n...     print('Handling run-time error:', err)\n...\nHandling run-time error: division by zero\n8.4. Raising ExceptionsÂ¶\nThe raise statement allows the programmer to force a specified\nexception to occur. For example:\n>>> raise NameError('HiThere')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: HiThere\nThe sole argument to raise indicates the exception to be raised.\nThis must be either an exception instance or an exception class (a class that\nderives from BaseException, such as Exception or one of its\nsubclasses).  If an exception class is passed, it will be implicitly\ninstantiated by calling its constructor with no arguments:\nraise ValueError  # shorthand for 'raise ValueError()'\nIf you need to determine whether an exception was raised but donât intend to\nhandle it, a simpler form of the raise statement allows you to\nre-raise the exception:\n>>> try:\n...     raise NameError('HiThere')\n... except NameError:\n...     print('An exception flew by!')\n...     raise\n...\nAn exception flew by!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nNameError: HiThere\n8.5. Exception ChainingÂ¶\nIf an unhandled exception occurs inside an except section, it will\nhave the exception being handled attached to it and included in the error\nmessage:\n>>> try:\n...     open(\"database.sqlite\")\n... except OSError:\n...     raise RuntimeError(\"unable to handle error\")\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nFileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: unable to handle error\nTo indicate that an exception is a direct consequence of another, the\nraise statement allows an optional from clause:\n# exc must be exception instance or None.\nraise RuntimeError from exc\nThis can be useful when you are transforming exceptions. For example:\n>>> def func():\n...     raise ConnectionError\n...\n>>> try:\n...     func()\n... except ConnectionError as exc:\n...     raise RuntimeError('Failed to open database') from exc\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nFile \"<stdin>\", line 2, in func\nConnectionError\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: Failed to open database\nIt also allows disabling automatic exception chaining using the from None\nidiom:\n>>> try:\n...     open('database.sqlite')\n... except OSError:\n...     raise RuntimeError from None\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError\nFor more information about chaining mechanics, see Built-in Exceptions.\n8.6. User-defined ExceptionsÂ¶\nPrograms may name their own exceptions by creating a new exception class (see\nClasses for more about Python classes).  Exceptions should typically\nbe derived from the Exception class, either directly or indirectly.\nException classes can be defined which do anything any other class can do, but\nare usually kept simple, often only offering a number of attributes that allow\ninformation about the error to be extracted by handlers for the exception.\nMost exceptions are defined with names that end in âErrorâ, similar to the\nnaming of the standard exceptions.\nMany standard modules define their own exceptions to report errors that may\noccur in functions they define.\n8.7. Defining Clean-up ActionsÂ¶\nThe try statement has another optional clause which is intended to\ndefine clean-up actions that must be executed under all circumstances.  For\nexample:\n>>> try:\n...     raise KeyboardInterrupt\n... finally:\n...     print('Goodbye, world!')\n...\nGoodbye, world!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nKeyboardInterrupt\nIf a finally clause is present, the finally\nclause will execute as the last task before the try\nstatement completes. The finally clause runs whether or\nnot the try statement produces an exception. The following\npoints discuss more complex cases when an exception occurs:\nIf an exception occurs during execution of the try\nclause, the exception may be handled by an except\nclause. If the exception is not handled by an except\nclause, the exception is re-raised after the finally\nclause has been executed.\nAn exception could occur during execution of an except\nor else clause. Again, the exception is re-raised after\nthe finally clause has been executed.\nIf the finally clause executes a break,\ncontinue or return statement, exceptions are not\nre-raised.\nIf the try statement reaches a break,\ncontinue or return statement, the\nfinally clause will execute just prior to the\nbreak, continue or return\nstatementâs execution.\nIf a finally clause includes a return\nstatement, the returned value will be the one from the\nfinally clauseâs return statement, not the\nvalue from the try clauseâs return\nstatement.\nFor example:\n>>> def bool_return():\n...     try:\n...         return True\n...     finally:\n...         return False\n...\n>>> bool_return()\nFalse\nA more complicated example:\n>>> def divide(x, y):\n...     try:\n...         result = x / y\n...     except ZeroDivisionError:\n...         print(\"division by zero!\")\n...     else:\n...         print(\"result is\", result)\n...     finally:\n...         print(\"executing finally clause\")\n...\n>>> divide(2, 1)\nresult is 2.0\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 3, in divide\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\nAs you can see, the finally clause is executed in any event.  The\nTypeError raised by dividing two strings is not handled by the\nexcept clause and therefore re-raised after the finally\nclause has been executed.\nIn real world applications, the finally clause is useful for\nreleasing external resources (such as files or network connections), regardless\nof whether the use of the resource was successful.\n8.8. Predefined Clean-up ActionsÂ¶\nSome objects define standard clean-up actions to be undertaken when the object\nis no longer needed, regardless of whether or not the operation using the object\nsucceeded or failed. Look at the following example, which tries to open a file\nand print its contents to the screen.\nfor line in open(\"myfile.txt\"):\nprint(line, end=\"\")\nThe problem with this code is that it leaves the file open for an indeterminate\namount of time after this part of the code has finished executing.\nThis is not an issue in simple scripts, but can be a problem for larger\napplications. The with statement allows objects like files to be\nused in a way that ensures they are always cleaned up promptly and correctly.\nwith open(\"myfile.txt\") as f:\nfor line in f:\nprint(line, end=\"\")\nAfter the statement is executed, the file f is always closed, even if a\nproblem was encountered while processing the lines. Objects which, like files,\nprovide predefined clean-up actions will indicate this in their documentation.\n8.9. Raising and Handling Multiple Unrelated ExceptionsÂ¶\nThere are situations where it is necessary to report several exceptions that\nhave occurred. This is often the case in concurrency frameworks, when several\ntasks may have failed in parallel, but there are also other use cases where\nit is desirable to continue execution and collect multiple errors rather than\nraise the first exception.\nThe builtin ExceptionGroup wraps a list of exception instances so\nthat they can be raised together. It is an exception itself, so it can be\ncaught like any other exception.\n>>> def f():\n...     excs = [OSError('error 1'), SystemError('error 2')]\n...     raise ExceptionGroup('there were problems', excs)\n...\n>>> f()\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 1, in <module>\n|   File \"<stdin>\", line 3, in f\n| ExceptionGroup: there were problems\n+-+---------------- 1 ----------------\n| OSError: error 1\n+---------------- 2 ----------------\n| SystemError: error 2\n+------------------------------------\n>>> try:\n...     f()\n... except Exception as e:\n...     print(f'caught {type(e)}: e')\n...\ncaught <class 'ExceptionGroup'>: e\n>>>\nBy using except* instead of except, we can selectively\nhandle only the exceptions in the group that match a certain\ntype. In the following example, which shows a nested exception\ngroup, each except* clause extracts from the group exceptions\nof a certain type while letting all other exceptions propagate to\nother clauses and eventually to be reraised.\n>>> def f():\n...     raise ExceptionGroup(\n...         \"group1\",\n...         [\n...             OSError(1),\n...             SystemError(2),\n...             ExceptionGroup(\n...                 \"group2\",\n...                 [\n...                     OSError(3),\n...                     RecursionError(4)\n...                 ]\n...             )\n...         ]\n...     )\n...\n>>> try:\n...     f()\n... except* OSError as e:\n...     print(\"There were OSErrors\")\n... except* SystemError as e:\n...     print(\"There were SystemErrors\")\n...\nThere were OSErrors\nThere were SystemErrors\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 2, in <module>\n|   File \"<stdin>\", line 2, in f\n| ExceptionGroup: group1\n+-+---------------- 1 ----------------\n| ExceptionGroup: group2\n+-+---------------- 1 ----------------\n| RecursionError: 4\n+------------------------------------\n>>>\nNote that the exceptions nested in an exception group must be instances,\nnot types. This is because in practice the exceptions would typically\nbe ones that have already been raised and caught by the program, along\nthe following pattern:\n>>> excs = []\n... for test in tests:\n...     try:\n...         test.run()\n...     except Exception as e:\n...         excs.append(e)\n...\n>>> if excs:\n...    raise ExceptionGroup(\"Test Failures\", excs)\n...\n8.10. Enriching Exceptions with NotesÂ¶\nWhen an exception is created in order to be raised, it is usually initialized\nwith information that describes the error that has occurred. There are cases\nwhere it is useful to add information after the exception was caught. For this\npurpose, exceptions have a method add_note(note) that accepts a string and\nadds it to the exceptionâs notes list. The standard traceback rendering\nincludes all notes, in the order they were added, after the exception.\n>>> try:\n...     raise TypeError('bad type')\n... except Exception as e:\n...     e.add_note('Add some information')\n...     e.add_note('Add some more information')\n...     raise\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nTypeError: bad type\nAdd some information\nAdd some more information\n>>>\nFor example, when collecting exceptions into an exception group, we may want\nto add context information for the individual errors. In the following each\nexception in the group has a note indicating when this error has occurred.\n>>> def f():\n...     raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n...     try:\n...         f()\n...     except Exception as e:\n...         e.add_note(f'Happened in Iteration {i+1}')\n...         excs.append(e)\n...\n>>> raise ExceptionGroup('We have some problems', excs)\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 1, in <module>\n| ExceptionGroup: We have some problems (3 sub-exceptions)\n+-+---------------- 1 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 1\n+---------------- 2 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 2\n+---------------- 3 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 3\n+------------------------------------\n>>>",
    "chunks": [
      {
        "chunk_id": "python_docs_complete_chunk_0",
        "original_index": 0,
        "content": "==================== INTRODUCTION ===================="
      },
      {
        "chunk_id": "python_docs_complete_chunk_1",
        "original_index": 1,
        "content": "1. Whetting Your AppetiteÂ¶\nIf you do much work on computers, eventually you find that thereâs some task\nyouâd like to automate.  For example, you may wish to perform a\nsearch-and-replace over a large number of text files, or rename and rearrange a\nbunch of photo files in a complicated way. Perhaps youâd like to write a small\ncustom database, or a specialized GUI application, or a simple game.\nIf youâre a professional software developer, you may have to work with several\nC/C++/Java libraries but find the usual write/compile/test/re-compile cycle is\ntoo slow.  Perhaps youâre writing a test suite for such a library and find\nwriting the testing code a tedious task.  Or maybe youâve written a program that\ncould use an extension language, and you donât want to design and implement a\nwhole new language for your application.\nPython is just the language for you.\nYou could write a Unix shell script or Windows batch files for some of these\ntasks, but shell scripts are best at moving around files and changing text data,\nnot well-suited for GUI applications or games. You could write a C/C++/Java\nprogram, but it can take a lot of development time to get even a first-draft\nprogram.  Python is simpler to use, available on Windows, macOS, and Unix\noperating systems, and will help you get the job done more quickly.\nPython is simple to use, but it is a real programming language, offering much\nmore structure and support for large programs than shell scripts or batch files\ncan offer.  On the other hand, Python also offers much more error checking than\nC, and, being a very-high-level language, it has high-level data types built\nin, such as flexible arrays and dictionaries.  Because of its more general data\ntypes Python is applicable to a much larger problem domain than Awk or even\nPerl, yet many things are at least as easy in Python as in those languages.\nPython allows you to split your program into modules that can be reused in other\nPython programs.  It comes with a large collection of standard modules that you\ncan use as the basis of your programs â or as examples to start learning to\nprogram in Python.  Some of these modules provide things like file I/O, system\ncalls, sockets, and even interfaces to graphical user interface toolkits like\nTk.\nPython is an interpreted language, which can save you considerable time during\nprogram development because no compilation and linking is necessary.  The\ninterpreter can be used interactively, which makes it easy to experiment with\nfeatures of the language, to write throw-away programs, or to test functions\nduring bottom-up program development. It is also a handy desk calculator.\nPython enables programs to be written compactly and readably.  Programs written\nin Python are typically much shorter than equivalent C,  C++, or Java programs,\nfor several reasons:\nthe high-level data types allow you to express complex operations in a single\nstatement;\nstatement grouping is done by indentation instead of beginning and ending\nbrackets;\nno variable or argument declarations are necessary.\nPython is extensible: if you know how to program in C it is easy to add a new\nbuilt-in function or module to the interpreter, either to perform critical\noperations at maximum speed, or to link Python programs to libraries that may\nonly be available in binary form (such as a vendor-specific graphics library).\nOnce you are really hooked, you can link the Python interpreter into an\napplication written in C and use it as an extension or command language for that\napplication.\nBy the way, the language is named after the BBC show âMonty Pythonâs Flying\nCircusâ and has nothing to do with reptiles.  Making references to Monty\nPython skits in documentation is not only allowed, it is encouraged!\nNow that you are all excited about Python, youâll want to examine it in some\nmore detail.  Since the best way to learn a language is to use it, the tutorial\ninvites you to play with the Python interpreter as you read."
      },
      {
        "chunk_id": "python_docs_complete_chunk_2",
        "original_index": 2,
        "content": "more detail.  Since the best way to learn a language is to use it, the tutorial\ninvites you to play with the Python interpreter as you read.\nIn the next chapter, the mechanics of using the interpreter are explained.  This\nis rather mundane information, but essential for trying out the examples shown\nlater.\nThe rest of the tutorial introduces various features of the Python language and\nsystem through examples, beginning with simple expressions, statements and data\ntypes, through functions and modules, and finally touching upon advanced\nconcepts like exceptions and user-defined classes."
      },
      {
        "chunk_id": "python_docs_complete_chunk_3",
        "original_index": 3,
        "content": "==================== CONTROL_FLOW ===================="
      },
      {
        "chunk_id": "python_docs_complete_chunk_4",
        "original_index": 4,
        "content": "4. More Control Flow ToolsÂ¶\nAs well as the while statement just introduced, Python uses a few more\nthat we will encounter in this chapter.\n4.1. if StatementsÂ¶\nPerhaps the most well-known statement type is the if statement.  For\nexample:\n>>> x = int(input(\"Please enter an integer: \"))\nPlease enter an integer: 42\n>>> if x < 0:\n...     x = 0\n...     print('Negative changed to zero')\n... elif x == 0:\n...     print('Zero')\n... elif x == 1:\n...     print('Single')\n... else:\n...     print('More')\n...\nMore\nThere can be zero or more elif parts, and the else part is\noptional.  The keyword âelifâ is short for âelse ifâ, and is useful\nto avoid excessive indentation.  An  if â¦ elif â¦\nelif â¦ sequence is a substitute for the switch or\ncase statements found in other languages.\nIf youâre comparing the same value to several constants, or checking for specific types or\nattributes, you may also find the match statement useful. For more\ndetails see match Statements.\n4.2. for StatementsÂ¶\nThe for statement in Python differs a bit from what you may be used\nto in C or Pascal.  Rather than always iterating over an arithmetic progression\nof numbers (like in Pascal), or giving the user the ability to define both the\niteration step and halting condition (as C), Pythonâs for statement\niterates over the items of any sequence (a list or a string), in the order that\nthey appear in the sequence.  For example (no pun intended):\n>>> # Measure some strings:\n>>> words = ['cat', 'window', 'defenestrate']\n>>> for w in words:\n...     print(w, len(w))\n...\ncat 3\nwindow 6\ndefenestrate 12\nCode that modifies a collection while iterating over that same collection can\nbe tricky to get right.  Instead, it is usually more straight-forward to loop\nover a copy of the collection or to create a new collection:\n# Create a sample collection\nusers = {'Hans': 'active', 'ÃlÃ©onore': 'inactive', 'æ¯å¤ªé': 'active'}\n# Strategy:  Iterate over a copy\nfor user, status in users.copy().items():\nif status == 'inactive':\ndel users[user]\n# Strategy:  Create a new collection\nactive_users = {}\nfor user, status in users.items():\nif status == 'active':\nactive_users[user] = status\n4.3. The range() FunctionÂ¶\nIf you do need to iterate over a sequence of numbers, the built-in function\nrange() comes in handy.  It generates arithmetic progressions:\n>>> for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\nThe given end point is never part of the generated sequence; range(10) generates\n10 values, the legal indices for items of a sequence of length 10.  It\nis possible to let the range start at another number, or to specify a different\nincrement (even negative; sometimes this is called the âstepâ):\n>>> list(range(5, 10))\n[5, 6, 7, 8, 9]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(-10, -100, -30))\n[-10, -40, -70]\nTo iterate over the indices of a sequence, you can combine range() and\nlen() as follows:\n>>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n>>> for i in range(len(a)):\n...     print(i, a[i])\n...\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\nIn most such cases, however, it is convenient to use the enumerate()\nfunction, see Looping Techniques.\nA strange thing happens if you just print a range:\n>>> range(10)\nrange(0, 10)\nIn many ways the object returned by range() behaves as if it is a list,\nbut in fact it isnât. It is an object which returns the successive items of\nthe desired sequence when you iterate over it, but it doesnât really make\nthe list, thus saving space.\nWe say such an object is iterable, that is, suitable as a target for\nfunctions and constructs that expect something from which they can\nobtain successive items until the supply is exhausted.  We have seen that\nthe for statement is such a construct, while an example of a function\nthat takes an iterable is sum():\n>>> sum(range(4))  # 0 + 1 + 2 + 3\n6\nLater we will see more functions that return iterables and take iterables as\narguments.  In chapter Data Structures, we will discuss in more detail about\nlist()."
      },
      {
        "chunk_id": "python_docs_complete_chunk_5",
        "original_index": 5,
        "content": ">>> sum(range(4))  # 0 + 1 + 2 + 3\n6\nLater we will see more functions that return iterables and take iterables as\narguments.  In chapter Data Structures, we will discuss in more detail about\nlist().\n4.4. break and continue StatementsÂ¶\nThe break statement breaks out of the innermost enclosing\nfor or while loop:\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(f\"{n} equals {x} * {n//x}\")\n...             break\n...\n4 equals 2 * 2\n6 equals 2 * 3\n8 equals 2 * 4\n9 equals 3 * 3\nThe continue statement continues with the next\niteration of the loop:\n>>> for num in range(2, 10):\n...     if num % 2 == 0:\n...         print(f\"Found an even number {num}\")\n...         continue\n...     print(f\"Found an odd number {num}\")\n...\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n4.5. else Clauses on LoopsÂ¶\nIn a for or while loop the break statement\nmay be paired with an else clause.  If the loop finishes without\nexecuting the break, the else clause executes.\nIn a for loop, the else clause is executed\nafter the loop finishes its final iteration, that is, if no break occurred.\nIn a while loop, itâs executed after the loopâs condition becomes false.\nIn either kind of loop, the else clause is not executed if the\nloop was terminated by a break.  Of course, other ways of ending the\nloop early, such as a return or a raised exception, will also skip\nexecution of the else clause.\nThis is exemplified in the following for loop,\nwhich searches for prime numbers:\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(n, 'equals', x, '*', n//x)\n...             break\n...     else:\n...         # loop fell through without finding a factor\n...         print(n, 'is a prime number')\n...\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n(Yes, this is the correct code.  Look closely: the else clause belongs to\nthe for loop, not the if statement.)\nOne way to think of the else clause is to imagine it paired with the if\ninside the loop.  As the loop executes, it will run a sequence like\nif/if/if/else. The if is inside the loop, encountered a number of times. If\nthe condition is ever true, a break will happen. If the condition is never\ntrue, the else clause outside the loop will execute.\nWhen used with a loop, the else clause has more in common with the else\nclause of a try statement than it does with that of if\nstatements: a try statementâs else clause runs when no exception\noccurs, and a loopâs else clause runs when no break occurs. For more on\nthe try statement and exceptions, see Handling Exceptions.\n4.6. pass StatementsÂ¶\nThe pass statement does nothing. It can be used when a statement is\nrequired syntactically but the program requires no action. For example:\n>>> while True:\n...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n...\nThis is commonly used for creating minimal classes:\n>>> class MyEmptyClass:\n...     pass\n...\nAnother place pass can be used is as a place-holder for a function or\nconditional body when you are working on new code, allowing you to keep thinking\nat a more abstract level.  The pass is silently ignored:\n>>> def initlog(*args):\n...     pass   # Remember to implement this!\n...\n4.7. match StatementsÂ¶\nA match statement takes an expression and compares its value to successive\npatterns given as one or more case blocks.  This is superficially\nsimilar to a switch statement in C, Java or JavaScript (and many\nother languages), but itâs more similar to pattern matching in\nlanguages like Rust or Haskell. Only the first pattern that matches\ngets executed and it can also extract components (sequence elements\nor object attributes) from the value into variables."
      },
      {
        "chunk_id": "python_docs_complete_chunk_6",
        "original_index": 6,
        "content": "languages like Rust or Haskell. Only the first pattern that matches\ngets executed and it can also extract components (sequence elements\nor object attributes) from the value into variables.\nThe simplest form compares a subject value against one or more literals:\ndef http_error(status):\nmatch status:\ncase 400:\nreturn \"Bad request\"\ncase 404:\nreturn \"Not found\"\ncase 418:\nreturn \"I'm a teapot\"\ncase _:\nreturn \"Something's wrong with the internet\"\nNote the last block: the âvariable nameâ _ acts as a wildcard and\nnever fails to match. If no case matches, none of the branches is executed.\nYou can combine several literals in a single pattern using | (âorâ):\ncase 401 | 403 | 404:\nreturn \"Not allowed\"\nPatterns can look like unpacking assignments, and can be used to bind\nvariables:\n# point is an (x, y) tuple\nmatch point:\ncase (0, 0):\nprint(\"Origin\")\ncase (0, y):\nprint(f\"Y={y}\")\ncase (x, 0):\nprint(f\"X={x}\")\ncase (x, y):\nprint(f\"X={x}, Y={y}\")\ncase _:\nraise ValueError(\"Not a point\")\nStudy that one carefully!  The first pattern has two literals, and can\nbe thought of as an extension of the literal pattern shown above.  But\nthe next two patterns combine a literal and a variable, and the\nvariable binds a value from the subject (point).  The fourth\npattern captures two values, which makes it conceptually similar to\nthe unpacking assignment (x, y) = point.\nIf you are using classes to structure your data\nyou can use the class name followed by an argument list resembling a\nconstructor, but with the ability to capture attributes into variables:\nclass Point:\ndef __init__(self, x, y):\nself.x = x\nself.y = y\ndef where_is(point):\nmatch point:\ncase Point(x=0, y=0):\nprint(\"Origin\")\ncase Point(x=0, y=y):\nprint(f\"Y={y}\")\ncase Point(x=x, y=0):\nprint(f\"X={x}\")\ncase Point():\nprint(\"Somewhere else\")\ncase _:\nprint(\"Not a point\")\nYou can use positional parameters with some builtin classes that provide an\nordering for their attributes (e.g. dataclasses). You can also define a specific\nposition for attributes in patterns by setting the __match_args__ special\nattribute in your classes. If itâs set to (âxâ, âyâ), the following patterns are all\nequivalent (and all bind the y attribute to the var variable):\nPoint(1, var)\nPoint(1, y=var)\nPoint(x=1, y=var)\nPoint(y=var, x=1)\nA recommended way to read patterns is to look at them as an extended form of what you\nwould put on the left of an assignment, to understand which variables would be set to\nwhat.\nOnly the standalone names (like var above) are assigned to by a match statement.\nDotted names (like foo.bar), attribute names (the x= and y= above) or class names\n(recognized by the â(â¦)â next to them like Point above) are never assigned to.\nPatterns can be arbitrarily nested.  For example, if we have a short\nlist of Points, with __match_args__ added, we could match it like this:\nclass Point:\n__match_args__ = ('x', 'y')\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nmatch points:\ncase []:\nprint(\"No points\")\ncase [Point(0, 0)]:\nprint(\"The origin\")\ncase [Point(x, y)]:\nprint(f\"Single point {x}, {y}\")\ncase [Point(0, y1), Point(0, y2)]:\nprint(f\"Two on the Y axis at {y1}, {y2}\")\ncase _:\nprint(\"Something else\")\nWe can add an if clause to a pattern, known as a âguardâ.  If the\nguard is false, match goes on to try the next case block.  Note\nthat value capture happens before the guard is evaluated:\nmatch point:\ncase Point(x, y) if x == y:\nprint(f\"Y=X at {x}\")\ncase Point(x, y):\nprint(f\"Not on the diagonal\")\nSeveral other key features of this statement:\nLike unpacking assignments, tuple and list patterns have exactly the\nsame meaning and actually match arbitrary sequences.  An important\nexception is that they donât match iterators or strings.\nSequence patterns support extended unpacking: [x, y, *rest] and (x, y,\n*rest) work similar to unpacking assignments.  The\nname after * may also be _, so (x, y, *_) matches a sequence\nof at least two items without binding the remaining items."
      },
      {
        "chunk_id": "python_docs_complete_chunk_7",
        "original_index": 7,
        "content": "*rest) work similar to unpacking assignments.  The\nname after * may also be _, so (x, y, *_) matches a sequence\nof at least two items without binding the remaining items.\nMapping patterns: {\"bandwidth\": b, \"latency\": l} captures the\n\"bandwidth\" and \"latency\" values from a dictionary.  Unlike sequence\npatterns, extra keys are ignored.  An unpacking like **rest is also\nsupported.  (But **_ would be redundant, so it is not allowed.)\nSubpatterns may be captured using the as keyword:\ncase (Point(x1, y1), Point(x2, y2) as p2): ...\nwill capture the second element of the input as p2 (as long as the input is\na sequence of two points)\nMost literals are compared by equality, however the singletons True,\nFalse and None are compared by identity.\nPatterns may use named constants.  These must be dotted names\nto prevent them from being interpreted as capture variable:\nfrom enum import Enum\nclass Color(Enum):\nRED = 'red'\nGREEN = 'green'\nBLUE = 'blue'\ncolor = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\nmatch color:\ncase Color.RED:\nprint(\"I see red!\")\ncase Color.GREEN:\nprint(\"Grass is green\")\ncase Color.BLUE:\nprint(\"I'm feeling the blues :(\")\nFor a more detailed explanation and additional examples, you can look into\nPEP 636 which is written in a tutorial format.\n4.8. Defining FunctionsÂ¶\nWe can create a function that writes the Fibonacci series to an arbitrary\nboundary:\n>>> def fib(n):    # write Fibonacci series less than n\n...     \"\"\"Print a Fibonacci series less than n.\"\"\"\n...     a, b = 0, 1\n...     while a < n:\n...         print(a, end=' ')\n...         a, b = b, a+b\n...     print()\n...\n>>> # Now call the function we just defined:\n>>> fib(2000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\nThe keyword def introduces a function definition.  It must be\nfollowed by the function name and the parenthesized list of formal parameters.\nThe statements that form the body of the function start at the next line, and\nmust be indented.\nThe first statement of the function body can optionally be a string literal;\nthis string literal is the functionâs documentation string, or docstring.\n(More about docstrings can be found in the section Documentation Strings.)\nThere are tools which use docstrings to automatically produce online or printed\ndocumentation, or to let the user interactively browse through code; itâs good\npractice to include docstrings in code that you write, so make a habit of it.\nThe execution of a function introduces a new symbol table used for the local\nvariables of the function.  More precisely, all variable assignments in a\nfunction store the value in the local symbol table; whereas variable references\nfirst look in the local symbol table, then in the local symbol tables of\nenclosing functions, then in the global symbol table, and finally in the table\nof built-in names. Thus, global variables and variables of enclosing functions\ncannot be directly assigned a value within a function (unless, for global\nvariables, named in a global statement, or, for variables of enclosing\nfunctions, named in a nonlocal statement), although they may be\nreferenced.\nThe actual parameters (arguments) to a function call are introduced in the local\nsymbol table of the called function when it is called; thus, arguments are\npassed using call by value (where the value is always an object reference,\nnot the value of the object). [1] When a function calls another function,\nor calls itself recursively, a new\nlocal symbol table is created for that call.\nA function definition associates the function name with the function object in\nthe current symbol table.  The interpreter recognizes the object pointed to by\nthat name as a user-defined function.  Other names can also point to that same\nfunction object and can also be used to access the function:\n>>> fib\n<function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\nComing from other languages, you might object that fib is not a function but"
      },
      {
        "chunk_id": "python_docs_complete_chunk_8",
        "original_index": 8,
        "content": ">>> fib\n<function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\nComing from other languages, you might object that fib is not a function but\na procedure since it doesnât return a value.  In fact, even functions without a\nreturn statement do return a value, albeit a rather boring one.  This\nvalue is called None (itâs a built-in name).  Writing the value None is\nnormally suppressed by the interpreter if it would be the only value written.\nYou can see it if you really want to using print():\n>>> fib(0)\n>>> print(fib(0))\nNone\nIt is simple to write a function that returns a list of the numbers of the\nFibonacci series, instead of printing it:\n>>> def fib2(n):  # return Fibonacci series up to n\n...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n...     result = []\n...     a, b = 0, 1\n...     while a < n:\n...         result.append(a)    # see below\n...         a, b = b, a+b\n...     return result\n...\n>>> f100 = fib2(100)    # call it\n>>> f100                # write the result\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\nThis example, as usual, demonstrates some new Python features:\nThe return statement returns with a value from a function.\nreturn without an expression argument returns None. Falling off\nthe end of a function also returns None.\nThe statement result.append(a) calls a method of the list object\nresult.  A method is a function that âbelongsâ to an object and is named\nobj.methodname, where obj is some object (this may be an expression),\nand methodname is the name of a method that is defined by the objectâs type.\nDifferent types define different methods.  Methods of different types may have\nthe same name without causing ambiguity.  (It is possible to define your own\nobject types and methods, using classes, see Classes)\nThe method append() shown in the example is defined for list objects; it\nadds a new element at the end of the list.  In this example it is equivalent to\nresult = result + [a], but more efficient.\n4.9. More on Defining FunctionsÂ¶\nIt is also possible to define functions with a variable number of arguments.\nThere are three forms, which can be combined.\n4.9.1. Default Argument ValuesÂ¶\nThe most useful form is to specify a default value for one or more arguments.\nThis creates a function that can be called with fewer arguments than it is\ndefined to allow.  For example:\ndef ask_ok(prompt, retries=4, reminder='Please try again!'):\nwhile True:\nreply = input(prompt)\nif reply in {'y', 'ye', 'yes'}:\nreturn True\nif reply in {'n', 'no', 'nop', 'nope'}:\nreturn False\nretries = retries - 1\nif retries < 0:\nraise ValueError('invalid user response')\nprint(reminder)\nThis function can be called in several ways:\ngiving only the mandatory argument:\nask_ok('Do you really want to quit?')\ngiving one of the optional arguments:\nask_ok('OK to overwrite the file?', 2)\nor even giving all arguments:\nask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')\nThis example also introduces the in keyword. This tests whether or\nnot a sequence contains a certain value.\nThe default values are evaluated at the point of function definition in the\ndefining scope, so that\ni = 5\ndef f(arg=i):\nprint(arg)\ni = 6\nf()\nwill print 5.\nImportant warning:  The default value is evaluated only once. This makes a\ndifference when the default is a mutable object such as a list, dictionary, or\ninstances of most classes.  For example, the following function accumulates the\narguments passed to it on subsequent calls:\ndef f(a, L=[]):\nL.append(a)\nreturn L\nprint(f(1))\nprint(f(2))\nprint(f(3))\nThis will print\n[1]\n[1, 2]\n[1, 2, 3]\nIf you donât want the default to be shared between subsequent calls, you can\nwrite the function like this instead:\ndef f(a, L=None):\nif L is None:\nL = []\nL.append(a)\nreturn L\n4.9.2. Keyword ArgumentsÂ¶\nFunctions can also be called using keyword arguments\nof the form kwarg=value.  For instance, the following function:\ndef parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):"
      },
      {
        "chunk_id": "python_docs_complete_chunk_9",
        "original_index": 9,
        "content": "Functions can also be called using keyword arguments\nof the form kwarg=value.  For instance, the following function:\ndef parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\nprint(\"-- This parrot wouldn't\", action, end=' ')\nprint(\"if you put\", voltage, \"volts through it.\")\nprint(\"-- Lovely plumage, the\", type)\nprint(\"-- It's\", state, \"!\")\naccepts one required argument (voltage) and three optional arguments\n(state, action, and type).  This function can be called in any\nof the following ways:\nparrot(1000)                                          # 1 positional argument\nparrot(voltage=1000)                                  # 1 keyword argument\nparrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\nparrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\nparrot('a million', 'bereft of life', 'jump')         # 3 positional arguments\nparrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword\nbut all the following calls would be invalid:\nparrot()                     # required argument missing\nparrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument\nparrot(110, voltage=220)     # duplicate value for the same argument\nparrot(actor='John Cleese')  # unknown keyword argument\nIn a function call, keyword arguments must follow positional arguments.\nAll the keyword arguments passed must match one of the arguments\naccepted by the function (e.g. actor is not a valid argument for the\nparrot function), and their order is not important.  This also includes\nnon-optional arguments (e.g. parrot(voltage=1000) is valid too).\nNo argument may receive a value more than once.\nHereâs an example that fails due to this restriction:\n>>> def function(a):\n...     pass\n...\n>>> function(0, a=0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: function() got multiple values for argument 'a'\nWhen a final formal parameter of the form **name is present, it receives a\ndictionary (see Mapping Types â dict) containing all keyword arguments except for\nthose corresponding to a formal parameter.  This may be combined with a formal\nparameter of the form *name (described in the next subsection) which\nreceives a tuple containing the positional\narguments beyond the formal parameter list.  (*name must occur\nbefore **name.) For example, if we define a function like this:\ndef cheeseshop(kind, *arguments, **keywords):\nprint(\"-- Do you have any\", kind, \"?\")\nprint(\"-- I'm sorry, we're all out of\", kind)\nfor arg in arguments:\nprint(arg)\nprint(\"-\" * 40)\nfor kw in keywords:\nprint(kw, \":\", keywords[kw])\nIt could be called like this:\ncheeseshop(\"Limburger\", \"It's very runny, sir.\",\n\"It's really very, VERY runny, sir.\",\nshopkeeper=\"Michael Palin\",\nclient=\"John Cleese\",\nsketch=\"Cheese Shop Sketch\")\nand of course it would print:\n-- Do you have any Limburger ?\n-- I'm sorry, we're all out of Limburger\nIt's very runny, sir.\nIt's really very, VERY runny, sir.\n----------------------------------------\nshopkeeper : Michael Palin\nclient : John Cleese\nsketch : Cheese Shop Sketch\nNote that the order in which the keyword arguments are printed is guaranteed\nto match the order in which they were provided in the function call.\n4.9.3. Special parametersÂ¶\nBy default, arguments may be passed to a Python function either by position\nor explicitly by keyword. For readability and performance, it makes sense to\nrestrict the way arguments can be passed so that a developer need only look\nat the function definition to determine if items are passed by position, by\nposition or keyword, or by keyword.\nA function definition may look like:\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n-----------    ----------     ----------\n|             |                  |\n|        Positional or keyword   |\n|                                - Keyword only\n-- Positional only\nwhere / and * are optional. If used, these symbols indicate the kind of"
      },
      {
        "chunk_id": "python_docs_complete_chunk_10",
        "original_index": 10,
        "content": "|        Positional or keyword   |\n|                                - Keyword only\n-- Positional only\nwhere / and * are optional. If used, these symbols indicate the kind of\nparameter by how the arguments may be passed to the function:\npositional-only, positional-or-keyword, and keyword-only. Keyword parameters\nare also referred to as named parameters.\n4.9.3.1. Positional-or-Keyword ArgumentsÂ¶\nIf / and * are not present in the function definition, arguments may\nbe passed to a function by position or by keyword.\n4.9.3.2. Positional-Only ParametersÂ¶\nLooking at this in a bit more detail, it is possible to mark certain parameters\nas positional-only. If positional-only, the parametersâ order matters, and\nthe parameters cannot be passed by keyword. Positional-only parameters are\nplaced before a / (forward-slash). The / is used to logically\nseparate the positional-only parameters from the rest of the parameters.\nIf there is no / in the function definition, there are no positional-only\nparameters.\nParameters following the / may be positional-or-keyword or keyword-only.\n4.9.3.3. Keyword-Only ArgumentsÂ¶\nTo mark parameters as keyword-only, indicating the parameters must be passed\nby keyword argument, place an * in the arguments list just before the first\nkeyword-only parameter.\n4.9.3.4. Function ExamplesÂ¶\nConsider the following example function definitions paying close attention to the\nmarkers / and *:\n>>> def standard_arg(arg):\n...     print(arg)\n...\n>>> def pos_only_arg(arg, /):\n...     print(arg)\n...\n>>> def kwd_only_arg(*, arg):\n...     print(arg)\n...\n>>> def combined_example(pos_only, /, standard, *, kwd_only):\n...     print(pos_only, standard, kwd_only)\nThe first function definition, standard_arg, the most familiar form,\nplaces no restrictions on the calling convention and arguments may be\npassed by position or keyword:\n>>> standard_arg(2)\n2\n>>> standard_arg(arg=2)\n2\nThe second function pos_only_arg is restricted to only use positional\nparameters as there is a / in the function definition:\n>>> pos_only_arg(1)\n1\n>>> pos_only_arg(arg=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'\nThe third function kwd_only_arg only allows keyword arguments as indicated\nby a * in the function definition:\n>>> kwd_only_arg(3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n>>> kwd_only_arg(arg=3)\n3\nAnd the last uses all three calling conventions in the same function\ndefinition:\n>>> combined_example(1, 2, 3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() takes 2 positional arguments but 3 were given\n>>> combined_example(1, 2, kwd_only=3)\n1 2 3\n>>> combined_example(1, standard=2, kwd_only=3)\n1 2 3\n>>> combined_example(pos_only=1, standard=2, kwd_only=3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'\nFinally, consider this function definition which has a potential collision between the positional argument name  and **kwds which has name as a key:\ndef foo(name, **kwds):\nreturn 'name' in kwds\nThere is no possible call that will make it return True as the keyword 'name'\nwill always bind to the first parameter. For example:\n>>> foo(1, **{'name': 2})\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: foo() got multiple values for argument 'name'\n>>>\nBut using / (positional only arguments), it is possible since it allows name as a positional argument and 'name' as a key in the keyword arguments:\n>>> def foo(name, /, **kwds):\n...     return 'name' in kwds\n...\n>>> foo(1, **{'name': 2})\nTrue\nIn other words, the names of positional-only parameters can be used in\n**kwds without ambiguity.\n4.9.3.5. RecapÂ¶"
      },
      {
        "chunk_id": "python_docs_complete_chunk_11",
        "original_index": 11,
        "content": "...     return 'name' in kwds\n...\n>>> foo(1, **{'name': 2})\nTrue\nIn other words, the names of positional-only parameters can be used in\n**kwds without ambiguity.\n4.9.3.5. RecapÂ¶\nThe use case will determine which parameters to use in the function definition:\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\nAs guidance:\nUse positional-only if you want the name of the parameters to not be\navailable to the user. This is useful when parameter names have no real\nmeaning, if you want to enforce the order of the arguments when the function\nis called or if you need to take some positional parameters and arbitrary\nkeywords.\nUse keyword-only when names have meaning and the function definition is\nmore understandable by being explicit with names or you want to prevent\nusers relying on the position of the argument being passed.\nFor an API, use positional-only to prevent breaking API changes\nif the parameterâs name is modified in the future.\n4.9.4. Arbitrary Argument ListsÂ¶\nFinally, the least frequently used option is to specify that a function can be\ncalled with an arbitrary number of arguments.  These arguments will be wrapped\nup in a tuple (see Tuples and Sequences).  Before the variable number of arguments,\nzero or more normal arguments may occur.\ndef write_multiple_items(file, separator, *args):\nfile.write(separator.join(args))\nNormally, these variadic arguments will be last in the list of formal\nparameters, because they scoop up all remaining input arguments that are\npassed to the function. Any formal parameters which occur after the *args\nparameter are âkeyword-onlyâ arguments, meaning that they can only be used as\nkeywords rather than positional arguments.\n>>> def concat(*args, sep=\"/\"):\n...     return sep.join(args)\n...\n>>> concat(\"earth\", \"mars\", \"venus\")\n'earth/mars/venus'\n>>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n'earth.mars.venus'\n4.9.5. Unpacking Argument ListsÂ¶\nThe reverse situation occurs when the arguments are already in a list or tuple\nbut need to be unpacked for a function call requiring separate positional\narguments.  For instance, the built-in range() function expects separate\nstart and stop arguments.  If they are not available separately, write the\nfunction call with the  *-operator to unpack the arguments out of a list\nor tuple:\n>>> list(range(3, 6))            # normal call with separate arguments\n[3, 4, 5]\n>>> args = [3, 6]\n>>> list(range(*args))            # call with arguments unpacked from a list\n[3, 4, 5]\nIn the same fashion, dictionaries can deliver keyword arguments with the\n**-operator:\n>>> def parrot(voltage, state='a stiff', action='voom'):\n...     print(\"-- This parrot wouldn't\", action, end=' ')\n...     print(\"if you put\", voltage, \"volts through it.\", end=' ')\n...     print(\"E's\", state, \"!\")\n...\n>>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n>>> parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !\n4.9.6. Lambda ExpressionsÂ¶\nSmall anonymous functions can be created with the lambda keyword.\nThis function returns the sum of its two arguments: lambda a, b: a+b.\nLambda functions can be used wherever function objects are required.  They are\nsyntactically restricted to a single expression.  Semantically, they are just\nsyntactic sugar for a normal function definition.  Like nested function\ndefinitions, lambda functions can reference variables from the containing\nscope:\n>>> def make_incrementor(n):\n...     return lambda x: x + n\n...\n>>> f = make_incrementor(42)\n>>> f(0)\n42\n>>> f(1)\n43\nThe above example uses a lambda expression to return a function.  Another use\nis to pass a small function as an argument:\n>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n>>> pairs.sort(key=lambda pair: pair[1])\n>>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n4.9.7. Documentation StringsÂ¶\nHere are some conventions about the content and formatting of documentation\nstrings."
      },
      {
        "chunk_id": "python_docs_complete_chunk_12",
        "original_index": 12,
        "content": ">>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n4.9.7. Documentation StringsÂ¶\nHere are some conventions about the content and formatting of documentation\nstrings.\nThe first line should always be a short, concise summary of the objectâs\npurpose.  For brevity, it should not explicitly state the objectâs name or type,\nsince these are available by other means (except if the name happens to be a\nverb describing a functionâs operation).  This line should begin with a capital\nletter and end with a period.\nIf there are more lines in the documentation string, the second line should be\nblank, visually separating the summary from the rest of the description.  The\nfollowing lines should be one or more paragraphs describing the objectâs calling\nconventions, its side effects, etc.\nThe Python parser does not strip indentation from multi-line string literals in\nPython, so tools that process documentation have to strip indentation if\ndesired.  This is done using the following convention. The first non-blank line\nafter the first line of the string determines the amount of indentation for\nthe entire documentation string.  (We canât use the first line since it is\ngenerally adjacent to the stringâs opening quotes so its indentation is not\napparent in the string literal.)  Whitespace âequivalentâ to this indentation is\nthen stripped from the start of all lines of the string.  Lines that are\nindented less should not occur, but if they occur all their leading whitespace\nshould be stripped.  Equivalence of whitespace should be tested after expansion\nof tabs (to 8 spaces, normally).\nHere is an example of a multi-line docstring:\n>>> def my_function():\n...     \"\"\"Do nothing, but document it.\n...\n...     No, really, it doesn't do anything.\n...     \"\"\"\n...     pass\n...\n>>> print(my_function.__doc__)\nDo nothing, but document it.\nNo, really, it doesn't do anything.\n4.9.8. Function AnnotationsÂ¶\nFunction annotations are completely optional metadata\ninformation about the types used by user-defined functions (see PEP 3107 and\nPEP 484 for more information).\nAnnotations are stored in the __annotations__\nattribute of the function as a dictionary and have no effect on any other part of the\nfunction.  Parameter annotations are defined by a colon after the parameter name, followed\nby an expression evaluating to the value of the annotation.  Return annotations are\ndefined by a literal ->, followed by an expression, between the parameter\nlist and the colon denoting the end of the def statement.  The\nfollowing example has a required argument, an optional argument, and the return\nvalue annotated:\n>>> def f(ham: str, eggs: str = 'eggs') -> str:\n...     print(\"Annotations:\", f.__annotations__)\n...     print(\"Arguments:\", ham, eggs)\n...     return ham + ' and ' + eggs\n...\n>>> f('spam')\nAnnotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}\nArguments: spam eggs\n'spam and eggs'\n4.10. Intermezzo: Coding StyleÂ¶\nNow that you are about to write longer, more complex pieces of Python, it is a\ngood time to talk about coding style.  Most languages can be written (or more\nconcise, formatted) in different styles; some are more readable than others.\nMaking it easy for others to read your code is always a good idea, and adopting\na nice coding style helps tremendously for that.\nFor Python, PEP 8 has emerged as the style guide that most projects adhere to;\nit promotes a very readable and eye-pleasing coding style.  Every Python\ndeveloper should read it at some point; here are the most important points\nextracted for you:\nUse 4-space indentation, and no tabs.\n4 spaces are a good compromise between small indentation (allows greater\nnesting depth) and large indentation (easier to read).  Tabs introduce\nconfusion, and are best left out.\nWrap lines so that they donât exceed 79 characters.\nThis helps users with small displays and makes it possible to have several\ncode files side-by-side on larger displays."
      },
      {
        "chunk_id": "python_docs_complete_chunk_13",
        "original_index": 13,
        "content": "Wrap lines so that they donât exceed 79 characters.\nThis helps users with small displays and makes it possible to have several\ncode files side-by-side on larger displays.\nUse blank lines to separate functions and classes, and larger blocks of\ncode inside functions.\nWhen possible, put comments on a line of their own.\nUse docstrings.\nUse spaces around operators and after commas, but not directly inside\nbracketing constructs: a = f(1, 2) + g(3, 4).\nName your classes and functions consistently; the convention is to use\nUpperCamelCase for classes and lowercase_with_underscores for functions\nand methods.  Always use self as the name for the first method argument\n(see A First Look at Classes for more on classes and methods).\nDonât use fancy encodings if your code is meant to be used in international\nenvironments.  Pythonâs default, UTF-8, or even plain ASCII work best in any\ncase.\nLikewise, donât use non-ASCII characters in identifiers if there is only the\nslightest chance people speaking a different language will read or maintain\nthe code.\nFootnotes\n[1]\nActually, call by object reference would be a better description,\nsince if a mutable object is passed, the caller will see any changes the\ncallee makes to it (items inserted into a list)."
      },
      {
        "chunk_id": "python_docs_complete_chunk_14",
        "original_index": 14,
        "content": "==================== DATA_STRUCTURES ===================="
      },
      {
        "chunk_id": "python_docs_complete_chunk_15",
        "original_index": 15,
        "content": "5. Data StructuresÂ¶\nThis chapter describes some things youâve learned about already in more detail,\nand adds some new things as well.\n5.1. More on ListsÂ¶\nThe list data type has some more methods.  Here are all of the methods of list\nobjects:\nlist.append(x)\nAdd an item to the end of the list.  Similar to a[len(a):] = [x].\nlist.extend(iterable)\nExtend the list by appending all the items from the iterable.  Similar to\na[len(a):] = iterable.\nlist.insert(i, x)\nInsert an item at a given position.  The first argument is the index of the\nelement before which to insert, so a.insert(0, x) inserts at the front of\nthe list, and a.insert(len(a), x) is equivalent to a.append(x).\nlist.remove(x)\nRemove the first item from the list whose value is equal to x.  It raises a\nValueError if there is no such item.\nlist.pop([i])\nRemove the item at the given position in the list, and return it.  If no index\nis specified, a.pop() removes and returns the last item in the list.\nIt raises an IndexError if the list is empty or the index is\noutside the list range.\nlist.clear()\nRemove all items from the list.  Similar to del a[:].\nlist.index(x[, start[, end]])\nReturn zero-based index in the list of the first item whose value is equal to x.\nRaises a ValueError if there is no such item.\nThe optional arguments start and end are interpreted as in the slice\nnotation and are used to limit the search to a particular subsequence of\nthe list.  The returned index is computed relative to the beginning of the full\nsequence rather than the start argument.\nlist.count(x)\nReturn the number of times x appears in the list.\nlist.sort(*, key=None, reverse=False)\nSort the items of the list in place (the arguments can be used for sort\ncustomization, see sorted() for their explanation).\nlist.reverse()\nReverse the elements of the list in place.\nlist.copy()\nReturn a shallow copy of the list.  Similar to a[:].\nAn example that uses most of the list methods:\n>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']\n>>> fruits.count('apple')\n2\n>>> fruits.count('tangerine')\n0\n>>> fruits.index('banana')\n3\n>>> fruits.index('banana', 4)  # Find next banana starting at position 4\n6\n>>> fruits.reverse()\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n>>> fruits.append('grape')\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n>>> fruits.sort()\n>>> fruits\n['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n>>> fruits.pop()\n'pear'\nYou might have noticed that methods like insert, remove or sort that\nonly modify the list have no return value printed â they return the default\nNone. [1]  This is a design principle for all mutable data structures in\nPython.\nAnother thing you might notice is that not all data can be sorted or\ncompared.  For instance, [None, 'hello', 10] doesnât sort because\nintegers canât be compared to strings and None canât be compared to\nother types.  Also, there are some types that donât have a defined\nordering relation.  For example, 3+4j < 5+7j isnât a valid\ncomparison.\n5.1.1. Using Lists as StacksÂ¶\nThe list methods make it very easy to use a list as a stack, where the last\nelement added is the first element retrieved (âlast-in, first-outâ).  To add an\nitem to the top of the stack, use append().  To retrieve an item from the\ntop of the stack, use pop() without an explicit index.  For example:\n>>> stack = [3, 4, 5]\n>>> stack.append(6)\n>>> stack.append(7)\n>>> stack\n[3, 4, 5, 6, 7]\n>>> stack.pop()\n7\n>>> stack\n[3, 4, 5, 6]\n>>> stack.pop()\n6\n>>> stack.pop()\n5\n>>> stack\n[3, 4]\n5.1.2. Using Lists as QueuesÂ¶\nIt is also possible to use a list as a queue, where the first element added is\nthe first element retrieved (âfirst-in, first-outâ); however, lists are not\nefficient for this purpose.  While appends and pops from the end of list are\nfast, doing inserts or pops from the beginning of a list is slow (because all"
      },
      {
        "chunk_id": "python_docs_complete_chunk_16",
        "original_index": 16,
        "content": "efficient for this purpose.  While appends and pops from the end of list are\nfast, doing inserts or pops from the beginning of a list is slow (because all\nof the other elements have to be shifted by one).\nTo implement a queue, use collections.deque which was designed to\nhave fast appends and pops from both ends.  For example:\n>>> from collections import deque\n>>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n>>> queue.append(\"Terry\")           # Terry arrives\n>>> queue.append(\"Graham\")          # Graham arrives\n>>> queue.popleft()                 # The first to arrive now leaves\n'Eric'\n>>> queue.popleft()                 # The second to arrive now leaves\n'John'\n>>> queue                           # Remaining queue in order of arrival\ndeque(['Michael', 'Terry', 'Graham'])\n5.1.3. List ComprehensionsÂ¶\nList comprehensions provide a concise way to create lists.\nCommon applications are to make new lists where each element is the result of\nsome operations applied to each member of another sequence or iterable, or to\ncreate a subsequence of those elements that satisfy a certain condition.\nFor example, assume we want to create a list of squares, like:\n>>> squares = []\n>>> for x in range(10):\n...     squares.append(x**2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nNote that this creates (or overwrites) a variable named x that still exists\nafter the loop completes.  We can calculate the list of squares without any\nside effects using:\nsquares = list(map(lambda x: x**2, range(10)))\nor, equivalently:\nsquares = [x**2 for x in range(10)]\nwhich is more concise and readable.\nA list comprehension consists of brackets containing an expression followed\nby a for clause, then zero or more for or if\nclauses.  The result will be a new list resulting from evaluating the expression\nin the context of the for and if clauses which follow it.\nFor example, this listcomp combines the elements of two lists if they are not\nequal:\n>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\nand itâs equivalent to:\n>>> combs = []\n>>> for x in [1,2,3]:\n...     for y in [3,1,4]:\n...         if x != y:\n...             combs.append((x, y))\n...\n>>> combs\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\nNote how the order of the for and if statements is the\nsame in both these snippets.\nIf the expression is a tuple (e.g. the (x, y) in the previous example),\nit must be parenthesized.\n>>> vec = [-4, -2, 0, 2, 4]\n>>> # create a new list with the values doubled\n>>> [x*2 for x in vec]\n[-8, -4, 0, 4, 8]\n>>> # filter the list to exclude negative numbers\n>>> [x for x in vec if x >= 0]\n[0, 2, 4]\n>>> # apply a function to all the elements\n>>> [abs(x) for x in vec]\n[4, 2, 0, 2, 4]\n>>> # call a method on each element\n>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n>>> [weapon.strip() for weapon in freshfruit]\n['banana', 'loganberry', 'passion fruit']\n>>> # create a list of 2-tuples like (number, square)\n>>> [(x, x**2) for x in range(6)]\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n>>> # the tuple must be parenthesized, otherwise an error is raised\n>>> [x, x**2 for x in range(6)]\nFile \"<stdin>\", line 1\n[x, x**2 for x in range(6)]\n^^^^^^^\nSyntaxError: did you forget parentheses around the comprehension target?\n>>> # flatten a list using a listcomp with two 'for'\n>>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n>>> [num for elem in vec for num in elem]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\nList comprehensions can contain complex expressions and nested functions:\n>>> from math import pi\n>>> [str(round(pi, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n5.1.4. Nested List ComprehensionsÂ¶\nThe initial expression in a list comprehension can be any arbitrary expression,\nincluding another list comprehension.\nConsider the following example of a 3x4 matrix implemented as a list of\n3 lists of length 4:\n>>> matrix = [\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12],\n... ]"
      },
      {
        "chunk_id": "python_docs_complete_chunk_17",
        "original_index": 17,
        "content": "Consider the following example of a 3x4 matrix implemented as a list of\n3 lists of length 4:\n>>> matrix = [\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12],\n... ]\nThe following list comprehension will transpose rows and columns:\n>>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nAs we saw in the previous section, the inner list comprehension is evaluated in\nthe context of the for that follows it, so this example is\nequivalent to:\n>>> transposed = []\n>>> for i in range(4):\n...     transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nwhich, in turn, is the same as:\n>>> transposed = []\n>>> for i in range(4):\n...     # the following 3 lines implement the nested listcomp\n...     transposed_row = []\n...     for row in matrix:\n...         transposed_row.append(row[i])\n...     transposed.append(transposed_row)\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nIn the real world, you should prefer built-in functions to complex flow statements.\nThe zip() function would do a great job for this use case:\n>>> list(zip(*matrix))\n[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]\nSee Unpacking Argument Lists for details on the asterisk in this line.\n5.2. The del statementÂ¶\nThere is a way to remove an item from a list given its index instead of its\nvalue: the del statement.  This differs from the pop() method\nwhich returns a value.  The del statement can also be used to remove\nslices from a list or clear the entire list (which we did earlier by assignment\nof an empty list to the slice).  For example:\n>>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a\n[1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[]\ndel can also be used to delete entire variables:\n>>> del a\nReferencing the name a hereafter is an error (at least until another value\nis assigned to it).  Weâll find other uses for del later.\n5.3. Tuples and SequencesÂ¶\nWe saw that lists and strings have many common properties, such as indexing and\nslicing operations.  They are two examples of sequence data types (see\nSequence Types â list, tuple, range).  Since Python is an evolving language, other sequence data\ntypes may be added.  There is also another standard sequence data type: the\ntuple.\nA tuple consists of a number of values separated by commas, for instance:\n>>> t = 12345, 54321, 'hello!'\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')\n>>> # Tuples may be nested:\n>>> u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n>>> # Tuples are immutable:\n>>> t[0] = 88888\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> # but they can contain mutable objects:\n>>> v = ([1, 2, 3], [3, 2, 1])\n>>> v\n([1, 2, 3], [3, 2, 1])\nAs you see, on output tuples are always enclosed in parentheses, so that nested\ntuples are interpreted correctly; they may be input with or without surrounding\nparentheses, although often parentheses are necessary anyway (if the tuple is\npart of a larger expression).  It is not possible to assign to the individual\nitems of a tuple, however it is possible to create tuples which contain mutable\nobjects, such as lists.\nThough tuples may seem similar to lists, they are often used in different\nsituations and for different purposes.\nTuples are immutable, and usually contain a heterogeneous sequence of\nelements that are accessed via unpacking (see later in this section) or indexing\n(or even by attribute in the case of namedtuples).\nLists are mutable, and their elements are usually homogeneous and are\naccessed by iterating over the list.\nA special problem is the construction of tuples containing 0 or 1 items: the\nsyntax has some extra quirks to accommodate these.  Empty tuples are constructed\nby an empty pair of parentheses; a tuple with one item is constructed by"
      },
      {
        "chunk_id": "python_docs_complete_chunk_18",
        "original_index": 18,
        "content": "syntax has some extra quirks to accommodate these.  Empty tuples are constructed\nby an empty pair of parentheses; a tuple with one item is constructed by\nfollowing a value with a comma (it is not sufficient to enclose a single value\nin parentheses). Ugly, but effective.  For example:\n>>> empty = ()\n>>> singleton = 'hello',    # <-- note trailing comma\n>>> len(empty)\n0\n>>> len(singleton)\n1\n>>> singleton\n('hello',)\nThe statement t = 12345, 54321, 'hello!' is an example of tuple packing:\nthe values 12345, 54321 and 'hello!' are packed together in a tuple.\nThe reverse operation is also possible:\n>>> x, y, z = t\nThis is called, appropriately enough, sequence unpacking and works for any\nsequence on the right-hand side.  Sequence unpacking requires that there are as\nmany variables on the left side of the equals sign as there are elements in the\nsequence.  Note that multiple assignment is really just a combination of tuple\npacking and sequence unpacking.\n5.4. SetsÂ¶\nPython also includes a data type for sets.  A set is an unordered collection\nwith no duplicate elements.  Basic uses include membership testing and\neliminating duplicate entries.  Set objects also support mathematical operations\nlike union, intersection, difference, and symmetric difference.\nCurly braces or the set() function can be used to create sets.  Note: to\ncreate an empty set you have to use set(), not {}; the latter creates an\nempty dictionary, a data structure that we discuss in the next section.\nHere is a brief demonstration:\n>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n>>> print(basket)                      # show that duplicates have been removed\n{'orange', 'banana', 'pear', 'apple'}\n>>> 'orange' in basket                 # fast membership testing\nTrue\n>>> 'crabgrass' in basket\nFalse\n>>> # Demonstrate set operations on unique letters from two words\n>>>\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a                                  # unique letters in a\n{'a', 'r', 'b', 'c', 'd'}\n>>> a - b                              # letters in a but not in b\n{'r', 'd', 'b'}\n>>> a | b                              # letters in a or b or both\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n>>> a & b                              # letters in both a and b\n{'a', 'c'}\n>>> a ^ b                              # letters in a or b but not both\n{'r', 'd', 'b', 'm', 'z', 'l'}\nSimilarly to list comprehensions, set comprehensions\nare also supported:\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'r', 'd'}\n5.5. DictionariesÂ¶\nAnother useful data type built into Python is the dictionary (see\nMapping Types â dict). Dictionaries are sometimes found in other languages as\nâassociative memoriesâ or âassociative arraysâ.  Unlike sequences, which are\nindexed by a range of numbers, dictionaries are indexed by keys, which can be\nany immutable type; strings and numbers can always be keys.  Tuples can be used\nas keys if they contain only strings, numbers, or tuples; if a tuple contains\nany mutable object either directly or indirectly, it cannot be used as a key.\nYou canât use lists as keys, since lists can be modified in place using index\nassignments, slice assignments, or methods like append() and\nextend().\nIt is best to think of a dictionary as a set of key: value pairs,\nwith the requirement that the keys are unique (within one dictionary). A pair of\nbraces creates an empty dictionary: {}. Placing a comma-separated list of\nkey:value pairs within the braces adds initial key:value pairs to the\ndictionary; this is also the way dictionaries are written on output.\nThe main operations on a dictionary are storing a value with some key and\nextracting the value given the key.  It is also possible to delete a key:value\npair with del. If you store using a key that is already in use, the old\nvalue associated with that key is forgotten.  It is an error to extract a value\nusing a non-existent key.\nPerforming list(d) on a dictionary returns a list of all the keys"
      },
      {
        "chunk_id": "python_docs_complete_chunk_19",
        "original_index": 19,
        "content": "value associated with that key is forgotten.  It is an error to extract a value\nusing a non-existent key.\nPerforming list(d) on a dictionary returns a list of all the keys\nused in the dictionary, in insertion order (if you want it sorted, just use\nsorted(d) instead). To check whether a single key is in the\ndictionary, use the in keyword.\nHere is a small example using a dictionary:\n>>> tel = {'jack': 4098, 'sape': 4139}\n>>> tel['guido'] = 4127\n>>> tel\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n>>> tel['jack']\n4098\n>>> del tel['sape']\n>>> tel['irv'] = 4127\n>>> tel\n{'jack': 4098, 'guido': 4127, 'irv': 4127}\n>>> list(tel)\n['jack', 'guido', 'irv']\n>>> sorted(tel)\n['guido', 'irv', 'jack']\n>>> 'guido' in tel\nTrue\n>>> 'jack' not in tel\nFalse\nThe dict() constructor builds dictionaries directly from sequences of\nkey-value pairs:\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\nIn addition, dict comprehensions can be used to create dictionaries from\narbitrary key and value expressions:\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\nWhen the keys are simple strings, it is sometimes easier to specify pairs using\nkeyword arguments:\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n5.6. Looping TechniquesÂ¶\nWhen looping through dictionaries, the key and corresponding value can be\nretrieved at the same time using the items() method.\n>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.items():\n...     print(k, v)\n...\ngallahad the pure\nrobin the brave\nWhen looping through a sequence, the position index and corresponding value can\nbe retrieved at the same time using the enumerate() function.\n>>> for i, v in enumerate(['tic', 'tac', 'toe']):\n...     print(i, v)\n...\n0 tic\n1 tac\n2 toe\nTo loop over two or more sequences at the same time, the entries can be paired\nwith the zip() function.\n>>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n...     print('What is your {0}?  It is {1}.'.format(q, a))\n...\nWhat is your name?  It is lancelot.\nWhat is your quest?  It is the holy grail.\nWhat is your favorite color?  It is blue.\nTo loop over a sequence in reverse, first specify the sequence in a forward\ndirection and then call the reversed() function.\n>>> for i in reversed(range(1, 10, 2)):\n...     print(i)\n...\n9\n7\n5\n3\n1\nTo loop over a sequence in sorted order, use the sorted() function which\nreturns a new sorted list while leaving the source unaltered.\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for i in sorted(basket):\n...     print(i)\n...\napple\napple\nbanana\norange\norange\npear\nUsing set() on a sequence eliminates duplicate elements. The use of\nsorted() in combination with set() over a sequence is an idiomatic\nway to loop over unique elements of the sequence in sorted order.\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n...     print(f)\n...\napple\nbanana\norange\npear\nIt is sometimes tempting to change a list while you are looping over it;\nhowever, it is often simpler and safer to create a new list instead.\n>>> import math\n>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n>>> filtered_data = []\n>>> for value in raw_data:\n...     if not math.isnan(value):\n...         filtered_data.append(value)\n...\n>>> filtered_data\n[56.2, 51.7, 55.3, 52.5, 47.8]\n5.7. More on ConditionsÂ¶\nThe conditions used in while and if statements can contain any\noperators, not just comparisons.\nThe comparison operators in and not in are membership tests that\ndetermine whether a value is in (or not in) a container.  The operators is\nand is not compare whether two objects are really the same object.  All\ncomparison operators have the same priority, which is lower than that of all\nnumerical operators."
      },
      {
        "chunk_id": "python_docs_complete_chunk_20",
        "original_index": 20,
        "content": "and is not compare whether two objects are really the same object.  All\ncomparison operators have the same priority, which is lower than that of all\nnumerical operators.\nComparisons can be chained.  For example, a < b == c tests whether a is\nless than b and moreover b equals c.\nComparisons may be combined using the Boolean operators and and or, and\nthe outcome of a comparison (or of any other Boolean expression) may be negated\nwith not.  These have lower priorities than comparison operators; between\nthem, not has the highest priority and or the lowest, so that A and\nnot B or C is equivalent to (A and (not B)) or C. As always, parentheses\ncan be used to express the desired composition.\nThe Boolean operators and and or are so-called short-circuit\noperators: their arguments are evaluated from left to right, and evaluation\nstops as soon as the outcome is determined.  For example, if A and C are\ntrue but B is false, A and B and C does not evaluate the expression\nC.  When used as a general value and not as a Boolean, the return value of a\nshort-circuit operator is the last evaluated argument.\nIt is possible to assign the result of a comparison or other Boolean expression\nto a variable.  For example,\n>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n>>> non_null = string1 or string2 or string3\n>>> non_null\n'Trondheim'\nNote that in Python, unlike C, assignment inside expressions must be done\nexplicitly with the\nwalrus operator :=.\nThis avoids a common class of problems encountered in C programs: typing =\nin an expression when == was intended.\n5.8. Comparing Sequences and Other TypesÂ¶\nSequence objects typically may be compared to other objects with the same sequence\ntype. The comparison uses lexicographical ordering: first the first two\nitems are compared, and if they differ this determines the outcome of the\ncomparison; if they are equal, the next two items are compared, and so on, until\neither sequence is exhausted. If two items to be compared are themselves\nsequences of the same type, the lexicographical comparison is carried out\nrecursively.  If all items of two sequences compare equal, the sequences are\nconsidered equal. If one sequence is an initial sub-sequence of the other, the\nshorter sequence is the smaller (lesser) one.  Lexicographical ordering for\nstrings uses the Unicode code point number to order individual characters.\nSome examples of comparisons between sequences of the same type:\n(1, 2, 3)              < (1, 2, 4)\n[1, 2, 3]              < [1, 2, 4]\n'ABC' < 'C' < 'Pascal' < 'Python'\n(1, 2, 3, 4)           < (1, 2, 4)\n(1, 2)                 < (1, 2, -1)\n(1, 2, 3)             == (1.0, 2.0, 3.0)\n(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)\nNote that comparing objects of different types with < or > is legal\nprovided that the objects have appropriate comparison methods.  For example,\nmixed numeric types are compared according to their numeric value, so 0 equals\n0.0, etc.  Otherwise, rather than providing an arbitrary ordering, the\ninterpreter will raise a TypeError exception.\nFootnotes\n[1]\nOther languages may return the mutated object, which allows method\nchaining, such as d->insert(\"a\")->remove(\"b\")->sort();."
      },
      {
        "chunk_id": "python_docs_complete_chunk_21",
        "original_index": 21,
        "content": "==================== MODULES ===================="
      },
      {
        "chunk_id": "python_docs_complete_chunk_22",
        "original_index": 22,
        "content": "6. ModulesÂ¶\nIf you quit from the Python interpreter and enter it again, the definitions you\nhave made (functions and variables) are lost. Therefore, if you want to write a\nsomewhat longer program, you are better off using a text editor to prepare the\ninput for the interpreter and running it with that file as input instead.  This\nis known as creating a script.  As your program gets longer, you may want to\nsplit it into several files for easier maintenance.  You may also want to use a\nhandy function that youâve written in several programs without copying its\ndefinition into each program.\nTo support this, Python has a way to put definitions in a file and use them in a\nscript or in an interactive instance of the interpreter. Such a file is called a\nmodule; definitions from a module can be imported into other modules or into\nthe main module (the collection of variables that you have access to in a\nscript executed at the top level and in calculator mode).\nA module is a file containing Python definitions and statements.  The file name\nis the module name with the suffix .py appended.  Within a module, the\nmoduleâs name (as a string) is available as the value of the global variable\n__name__.  For instance, use your favorite text editor to create a file\ncalled fibo.py in the current directory with the following contents:\n# Fibonacci numbers module\ndef fib(n):    # write Fibonacci series up to n\na, b = 0, 1\nwhile a < n:\nprint(a, end=' ')\na, b = b, a+b\nprint()\ndef fib2(n):   # return Fibonacci series up to n\nresult = []\na, b = 0, 1\nwhile a < n:\nresult.append(a)\na, b = b, a+b\nreturn result\nNow enter the Python interpreter and import this module with the following\ncommand:\n>>> import fibo\nThis does not add the names of the functions defined in fibo  directly to\nthe current namespace (see Python Scopes and Namespaces for more details);\nit only adds the module name fibo there. Using\nthe module name you can access the functions:\n>>> fibo.fib(1000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\nIf you intend to use a function often you can assign it to a local name:\n>>> fib = fibo.fib\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n6.1. More on ModulesÂ¶\nA module can contain executable statements as well as function definitions.\nThese statements are intended to initialize the module. They are executed only\nthe first time the module name is encountered in an import statement. [1]\n(They are also run if the file is executed as a script.)\nEach module has its own private namespace, which is used as the global namespace\nby all functions defined in the module. Thus, the author of a module can\nuse global variables in the module without worrying about accidental clashes\nwith a userâs global variables. On the other hand, if you know what you are\ndoing you can touch a moduleâs global variables with the same notation used to\nrefer to its functions, modname.itemname.\nModules can import other modules.  It is customary but not required to place all\nimport statements at the beginning of a module (or script, for that\nmatter).  The imported module names, if placed at the top level of a module\n(outside any functions or classes), are added to the moduleâs global namespace.\nThere is a variant of the import statement that imports names from a\nmodule directly into the importing moduleâs namespace.  For example:\n>>> from fibo import fib, fib2\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis does not introduce the module name from which the imports are taken in the\nlocal namespace (so in the example, fibo is not defined).\nThere is even a variant to import all names that a module defines:\n>>> from fibo import *\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis imports all names except those beginning with an underscore (_).\nIn most cases Python programmers do not use this facility since it introduces"
      },
      {
        "chunk_id": "python_docs_complete_chunk_23",
        "original_index": 23,
        "content": "0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis imports all names except those beginning with an underscore (_).\nIn most cases Python programmers do not use this facility since it introduces\nan unknown set of names into the interpreter, possibly hiding some things\nyou have already defined.\nNote that in general the practice of importing * from a module or package is\nfrowned upon, since it often causes poorly readable code. However, it is okay to\nuse it to save typing in interactive sessions.\nIf the module name is followed by as, then the name\nfollowing as is bound directly to the imported module.\n>>> import fibo as fib\n>>> fib.fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nThis is effectively importing the module in the same way that import fibo\nwill do, with the only difference of it being available as fib.\nIt can also be used when utilising from with similar effects:\n>>> from fibo import fib as fibonacci\n>>> fibonacci(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\nNote\nFor efficiency reasons, each module is only imported once per interpreter\nsession.  Therefore, if you change your modules, you must restart the\ninterpreter â or, if itâs just one module you want to test interactively,\nuse importlib.reload(), e.g. import importlib;\nimportlib.reload(modulename).\n6.1.1. Executing modules as scriptsÂ¶\nWhen you run a Python module with\npython fibo.py <arguments>\nthe code in the module will be executed, just as if you imported it, but with\nthe __name__ set to \"__main__\".  That means that by adding this code at\nthe end of your module:\nif __name__ == \"__main__\":\nimport sys\nfib(int(sys.argv[1]))\nyou can make the file usable as a script as well as an importable module,\nbecause the code that parses the command line only runs if the module is\nexecuted as the âmainâ file:\n$ python fibo.py 50\n0 1 1 2 3 5 8 13 21 34\nIf the module is imported, the code is not run:\n>>> import fibo\n>>>\nThis is often used either to provide a convenient user interface to a module, or\nfor testing purposes (running the module as a script executes a test suite).\n6.1.2. The Module Search PathÂ¶\nWhen a module named spam is imported, the interpreter first searches for\na built-in module with that name. These module names are listed in\nsys.builtin_module_names. If not found, it then searches for a file\nnamed spam.py in a list of directories given by the variable\nsys.path.  sys.path is initialized from these locations:\nThe directory containing the input script (or the current directory when no\nfile is specified).\nPYTHONPATH (a list of directory names, with the same syntax as the\nshell variable PATH).\nThe installation-dependent default (by convention including a\nsite-packages directory, handled by the site module).\nMore details are at The initialization of the sys.path module search path.\nNote\nOn file systems which support symlinks, the directory containing the input\nscript is calculated after the symlink is followed. In other words the\ndirectory containing the symlink is not added to the module search path.\nAfter initialization, Python programs can modify sys.path.  The\ndirectory containing the script being run is placed at the beginning of the\nsearch path, ahead of the standard library path. This means that scripts in that\ndirectory will be loaded instead of modules of the same name in the library\ndirectory. This is an error unless the replacement is intended.  See section\nStandard Modules for more information.\n6.1.3. âCompiledâ Python filesÂ¶\nTo speed up loading modules, Python caches the compiled version of each module\nin the __pycache__ directory under the name module.version.pyc,\nwhere the version encodes the format of the compiled file; it generally contains\nthe Python version number.  For example, in CPython release 3.3 the compiled\nversion of spam.py would be cached as __pycache__/spam.cpython-33.pyc.  This\nnaming convention allows compiled modules from different releases and different\nversions of Python to coexist."
      },
      {
        "chunk_id": "python_docs_complete_chunk_24",
        "original_index": 24,
        "content": "version of spam.py would be cached as __pycache__/spam.cpython-33.pyc.  This\nnaming convention allows compiled modules from different releases and different\nversions of Python to coexist.\nPython checks the modification date of the source against the compiled version\nto see if itâs out of date and needs to be recompiled.  This is a completely\nautomatic process.  Also, the compiled modules are platform-independent, so the\nsame library can be shared among systems with different architectures.\nPython does not check the cache in two circumstances.  First, it always\nrecompiles and does not store the result for the module thatâs loaded directly\nfrom the command line.  Second, it does not check the cache if there is no\nsource module.  To support a non-source (compiled only) distribution, the\ncompiled module must be in the source directory, and there must not be a source\nmodule.\nSome tips for experts:\nYou can use the -O or -OO switches on the Python command\nto reduce the size of a compiled module.  The -O switch removes assert\nstatements, the -OO switch removes both assert statements and __doc__\nstrings.  Since some programs may rely on having these available, you should\nonly use this option if you know what youâre doing.  âOptimizedâ modules have\nan opt- tag and are usually smaller.  Future releases may\nchange the effects of optimization.\nA program doesnât run any faster when it is read from a .pyc\nfile than when it is read from a .py file; the only thing thatâs faster\nabout .pyc files is the speed with which they are loaded.\nThe module compileall can create .pyc files for all modules in a\ndirectory.\nThere is more detail on this process, including a flow chart of the\ndecisions, in PEP 3147.\n6.2. Standard ModulesÂ¶\nPython comes with a library of standard modules, described in a separate\ndocument, the Python Library Reference (âLibrary Referenceâ hereafter).  Some\nmodules are built into the interpreter; these provide access to operations that\nare not part of the core of the language but are nevertheless built in, either\nfor efficiency or to provide access to operating system primitives such as\nsystem calls.  The set of such modules is a configuration option which also\ndepends on the underlying platform.  For example, the winreg module is only\nprovided on Windows systems. One particular module deserves some attention:\nsys, which is built into every Python interpreter.  The variables\nsys.ps1 and sys.ps2 define the strings used as primary and secondary\nprompts:\n>>> import sys\n>>> sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print('Yuck!')\nYuck!\nC>\nThese two variables are only defined if the interpreter is in interactive mode.\nThe variable sys.path is a list of strings that determines the interpreterâs\nsearch path for modules. It is initialized to a default path taken from the\nenvironment variable PYTHONPATH, or from a built-in default if\nPYTHONPATH is not set.  You can modify it using standard list\noperations:\n>>> import sys\n>>> sys.path.append('/ufs/guido/lib/python')\n6.3. The dir() FunctionÂ¶\nThe built-in function dir() is used to find out which names a module\ndefines.  It returns a sorted list of strings:\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)\n['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n'__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n'__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n'_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n'_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',\n'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',"
      },
      {
        "chunk_id": "python_docs_complete_chunk_25",
        "original_index": 25,
        "content": "'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n'warnoptions']\nWithout arguments, dir() lists the names you have defined currently:\n>>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir()\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']\nNote that it lists all types of names: variables, modules, functions, etc.\ndir() does not list the names of built-in functions and variables.  If you\nwant a list of those, they are defined in the standard module\nbuiltins:\n>>> import builtins\n>>> dir(builtins)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n'NotImplementedError', 'OSError', 'OverflowError',\n'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n'__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n'zip']\n6.4. PackagesÂ¶\nPackages are a way of structuring Pythonâs module namespace by using âdotted\nmodule namesâ.  For example, the module name A.B designates a submodule\nnamed B in a package named A.  Just like the use of modules saves the\nauthors of different modules from having to worry about each otherâs global\nvariable names, the use of dotted module names saves the authors of multi-module\npackages like NumPy or Pillow from having to worry about\neach otherâs module names.\nSuppose you want to design a collection of modules (a âpackageâ) for the uniform\nhandling of sound files and sound data.  There are many different sound file"
      },
      {
        "chunk_id": "python_docs_complete_chunk_26",
        "original_index": 26,
        "content": "each otherâs module names.\nSuppose you want to design a collection of modules (a âpackageâ) for the uniform\nhandling of sound files and sound data.  There are many different sound file\nformats (usually recognized by their extension, for example: .wav,\n.aiff, .au), so you may need to create and maintain a growing\ncollection of modules for the conversion between the various file formats.\nThere are also many different operations you might want to perform on sound data\n(such as mixing, adding echo, applying an equalizer function, creating an\nartificial stereo effect), so in addition you will be writing a never-ending\nstream of modules to perform these operations.  Hereâs a possible structure for\nyour package (expressed in terms of a hierarchical filesystem):\nsound/                          Top-level package\n__init__.py               Initialize the sound package\nformats/                  Subpackage for file format conversions\n__init__.py\nwavread.py\nwavwrite.py\naiffread.py\naiffwrite.py\nauread.py\nauwrite.py\n...\neffects/                  Subpackage for sound effects\n__init__.py\necho.py\nsurround.py\nreverse.py\n...\nfilters/                  Subpackage for filters\n__init__.py\nequalizer.py\nvocoder.py\nkaraoke.py\n...\nWhen importing the package, Python searches through the directories on\nsys.path looking for the package subdirectory.\nThe __init__.py files are required to make Python treat directories\ncontaining the file as packages (unless using a namespace package, a\nrelatively advanced feature). This prevents directories with a common name,\nsuch as string, from unintentionally hiding valid modules that occur later\non the module search path. In the simplest case, __init__.py can just be\nan empty file, but it can also execute initialization code for the package or\nset the __all__ variable, described later.\nUsers of the package can import individual modules from the package, for\nexample:\nimport sound.effects.echo\nThis loads the submodule sound.effects.echo.  It must be referenced with\nits full name.\nsound.effects.echo.echofilter(input, output, delay=0.7, atten=4)\nAn alternative way of importing the submodule is:\nfrom sound.effects import echo\nThis also loads the submodule echo, and makes it available without its\npackage prefix, so it can be used as follows:\necho.echofilter(input, output, delay=0.7, atten=4)\nYet another variation is to import the desired function or variable directly:\nfrom sound.effects.echo import echofilter\nAgain, this loads the submodule echo, but this makes its function\nechofilter() directly available:\nechofilter(input, output, delay=0.7, atten=4)\nNote that when using from package import item, the item can be either a\nsubmodule (or subpackage) of the package, or some  other name defined in the\npackage, like a function, class or variable.  The import statement first\ntests whether the item is defined in the package; if not, it assumes it is a\nmodule and attempts to load it.  If it fails to find it, an ImportError\nexception is raised.\nContrarily, when using syntax like import item.subitem.subsubitem, each item\nexcept for the last must be a package; the last item can be a module or a\npackage but canât be a class or function or variable defined in the previous\nitem.\n6.4.1. Importing * From a PackageÂ¶\nNow what happens when the user writes from sound.effects import *?  Ideally,\none would hope that this somehow goes out to the filesystem, finds which\nsubmodules are present in the package, and imports them all.  This could take a\nlong time and importing sub-modules might have unwanted side-effects that should\nonly happen when the sub-module is explicitly imported.\nThe only solution is for the package author to provide an explicit index of the\npackage.  The import statement uses the following convention: if a packageâs\n__init__.py code defines a list named __all__, it is taken to be the\nlist of module names that should be imported when from package import * is"
      },
      {
        "chunk_id": "python_docs_complete_chunk_27",
        "original_index": 27,
        "content": "__init__.py code defines a list named __all__, it is taken to be the\nlist of module names that should be imported when from package import * is\nencountered.  It is up to the package author to keep this list up-to-date when a\nnew version of the package is released.  Package authors may also decide not to\nsupport it, if they donât see a use for importing * from their package.  For\nexample, the file sound/effects/__init__.py could contain the following\ncode:\n__all__ = [\"echo\", \"surround\", \"reverse\"]\nThis would mean that from sound.effects import * would import the three\nnamed submodules of the sound.effects package.\nBe aware that submodules might become shadowed by locally defined names. For\nexample, if you added a reverse function to the\nsound/effects/__init__.py file, the from sound.effects import *\nwould only import the two submodules echo and surround, but not the\nreverse submodule, because it is shadowed by the locally defined\nreverse function:\n__all__ = [\n\"echo\",      # refers to the 'echo.py' file\n\"surround\",  # refers to the 'surround.py' file\n\"reverse\",   # !!! refers to the 'reverse' function now !!!\n]\ndef reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule\nreturn msg[::-1]    #     in the case of a 'from sound.effects import *'\nIf __all__ is not defined, the statement from sound.effects import *\ndoes not import all submodules from the package sound.effects into the\ncurrent namespace; it only ensures that the package sound.effects has\nbeen imported (possibly running any initialization code in __init__.py)\nand then imports whatever names are defined in the package.  This includes any\nnames defined (and submodules explicitly loaded) by __init__.py.  It\nalso includes any submodules of the package that were explicitly loaded by\nprevious import statements.  Consider this code:\nimport sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import *\nIn this example, the echo and surround modules are imported in the\ncurrent namespace because they are defined in the sound.effects package\nwhen the from...import statement is executed.  (This also works when\n__all__ is defined.)\nAlthough certain modules are designed to export only names that follow certain\npatterns when you use import *, it is still considered bad practice in\nproduction code.\nRemember, there is nothing wrong with using from package import\nspecific_submodule!  In fact, this is the recommended notation unless the\nimporting module needs to use submodules with the same name from different\npackages.\n6.4.2. Intra-package ReferencesÂ¶\nWhen packages are structured into subpackages (as with the sound package\nin the example), you can use absolute imports to refer to submodules of siblings\npackages.  For example, if the module sound.filters.vocoder needs to use\nthe echo module in the sound.effects package, it can use from\nsound.effects import echo.\nYou can also write relative imports, with the from module import name form\nof import statement.  These imports use leading dots to indicate the current and\nparent packages involved in the relative import.  From the surround\nmodule for example, you might use:\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\nNote that relative imports are based on the name of the current module.  Since\nthe name of the main module is always \"__main__\", modules intended for use\nas the main module of a Python application must always use absolute imports.\n6.4.3. Packages in Multiple DirectoriesÂ¶\nPackages support one more special attribute, __path__.  This is\ninitialized to be a sequence of strings containing the name of the\ndirectory holding the\npackageâs __init__.py before the code in that file is executed.  This\nvariable can be modified; doing so affects future searches for modules and\nsubpackages contained in the package.\nWhile this feature is not often needed, it can be used to extend the set of\nmodules found in a package.\nFootnotes\n[1]"
      },
      {
        "chunk_id": "python_docs_complete_chunk_28",
        "original_index": 28,
        "content": "subpackages contained in the package.\nWhile this feature is not often needed, it can be used to extend the set of\nmodules found in a package.\nFootnotes\n[1]\nIn fact function definitions are also âstatementsâ that are âexecutedâ; the\nexecution of a module-level function definition adds the function name to\nthe moduleâs global namespace."
      },
      {
        "chunk_id": "python_docs_complete_chunk_29",
        "original_index": 29,
        "content": "==================== CLASSES ===================="
      },
      {
        "chunk_id": "python_docs_complete_chunk_30",
        "original_index": 30,
        "content": "9. ClassesÂ¶\nClasses provide a means of bundling data and functionality together.  Creating\na new class creates a new type of object, allowing new instances of that\ntype to be made.  Each class instance can have attributes attached to it for\nmaintaining its state.  Class instances can also have methods (defined by its\nclass) for modifying its state.\nCompared with other programming languages, Pythonâs class mechanism adds classes\nwith a minimum of new syntax and semantics.  It is a mixture of the class\nmechanisms found in C++ and Modula-3.  Python classes provide all the standard\nfeatures of Object Oriented Programming: the class inheritance mechanism allows\nmultiple base classes, a derived class can override any methods of its base\nclass or classes, and a method can call the method of a base class with the same\nname.  Objects can contain arbitrary amounts and kinds of data.  As is true for\nmodules, classes partake of the dynamic nature of Python: they are created at\nruntime, and can be modified further after creation.\nIn C++ terminology, normally class members (including the data members) are\npublic (except see below Private Variables), and all member functions are\nvirtual.  As in Modula-3, there are no shorthands for referencing the objectâs\nmembers from its methods: the method function is declared with an explicit first\nargument representing the object, which is provided implicitly by the call.  As\nin Smalltalk, classes themselves are objects.  This provides semantics for\nimporting and renaming.  Unlike C++ and Modula-3, built-in types can be used as\nbase classes for extension by the user.  Also, like in C++, most built-in\noperators with special syntax (arithmetic operators, subscripting etc.) can be\nredefined for class instances.\n(Lacking universally accepted terminology to talk about classes, I will make\noccasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, since\nits object-oriented semantics are closer to those of Python than C++, but I\nexpect that few readers have heard of it.)\n9.1. A Word About Names and ObjectsÂ¶\nObjects have individuality, and multiple names (in multiple scopes) can be bound\nto the same object.  This is known as aliasing in other languages.  This is\nusually not appreciated on a first glance at Python, and can be safely ignored\nwhen dealing with immutable basic types (numbers, strings, tuples).  However,\naliasing has a possibly surprising effect on the semantics of Python code\ninvolving mutable objects such as lists, dictionaries, and most other types.\nThis is usually used to the benefit of the program, since aliases behave like\npointers in some respects.  For example, passing an object is cheap since only a\npointer is passed by the implementation; and if a function modifies an object\npassed as an argument, the caller will see the change â this eliminates the\nneed for two different argument passing mechanisms as in Pascal.\n9.2. Python Scopes and NamespacesÂ¶\nBefore introducing classes, I first have to tell you something about Pythonâs\nscope rules.  Class definitions play some neat tricks with namespaces, and you\nneed to know how scopes and namespaces work to fully understand whatâs going on.\nIncidentally, knowledge about this subject is useful for any advanced Python\nprogrammer.\nLetâs begin with some definitions.\nA namespace is a mapping from names to objects.  Most namespaces are currently\nimplemented as Python dictionaries, but thatâs normally not noticeable in any\nway (except for performance), and it may change in the future.  Examples of\nnamespaces are: the set of built-in names (containing functions such as abs(), and\nbuilt-in exception names); the global names in a module; and the local names in\na function invocation.  In a sense the set of attributes of an object also form\na namespace.  The important thing to know about namespaces is that there is\nabsolutely no relation between names in different namespaces; for instance, two"
      },
      {
        "chunk_id": "python_docs_complete_chunk_31",
        "original_index": 31,
        "content": "a namespace.  The important thing to know about namespaces is that there is\nabsolutely no relation between names in different namespaces; for instance, two\ndifferent modules may both define a function maximize without confusion â\nusers of the modules must prefix it with the module name.\nBy the way, I use the word attribute for any name following a dot â for\nexample, in the expression z.real, real is an attribute of the object\nz.  Strictly speaking, references to names in modules are attribute\nreferences: in the expression modname.funcname, modname is a module\nobject and funcname is an attribute of it.  In this case there happens to be\na straightforward mapping between the moduleâs attributes and the global names\ndefined in the module: they share the same namespace!  [1]\nAttributes may be read-only or writable.  In the latter case, assignment to\nattributes is possible.  Module attributes are writable: you can write\nmodname.the_answer = 42.  Writable attributes may also be deleted with the\ndel statement.  For example, del modname.the_answer will remove\nthe attribute the_answer from the object named by modname.\nNamespaces are created at different moments and have different lifetimes.  The\nnamespace containing the built-in names is created when the Python interpreter\nstarts up, and is never deleted.  The global namespace for a module is created\nwhen the module definition is read in; normally, module namespaces also last\nuntil the interpreter quits.  The statements executed by the top-level\ninvocation of the interpreter, either read from a script file or interactively,\nare considered part of a module called __main__, so they have their own\nglobal namespace.  (The built-in names actually also live in a module; this is\ncalled builtins.)\nThe local namespace for a function is created when the function is called, and\ndeleted when the function returns or raises an exception that is not handled\nwithin the function.  (Actually, forgetting would be a better way to describe\nwhat actually happens.)  Of course, recursive invocations each have their own\nlocal namespace.\nA scope is a textual region of a Python program where a namespace is directly\naccessible.  âDirectly accessibleâ here means that an unqualified reference to a\nname attempts to find the name in the namespace.\nAlthough scopes are determined statically, they are used dynamically. At any\ntime during execution, there are 3 or 4 nested scopes whose namespaces are\ndirectly accessible:\nthe innermost scope, which is searched first, contains the local names\nthe scopes of any enclosing functions, which are searched starting with the\nnearest enclosing scope, contain non-local, but also non-global names\nthe next-to-last scope contains the current moduleâs global names\nthe outermost scope (searched last) is the namespace containing built-in names\nIf a name is declared global, then all references and assignments go directly to\nthe next-to-last scope containing the moduleâs global names.  To rebind variables\nfound outside of the innermost scope, the nonlocal statement can be\nused; if not declared nonlocal, those variables are read-only (an attempt to\nwrite to such a variable will simply create a new local variable in the\ninnermost scope, leaving the identically named outer variable unchanged).\nUsually, the local scope references the local names of the (textually) current\nfunction.  Outside functions, the local scope references the same namespace as\nthe global scope: the moduleâs namespace. Class definitions place yet another\nnamespace in the local scope.\nIt is important to realize that scopes are determined textually: the global\nscope of a function defined in a module is that moduleâs namespace, no matter\nfrom where or by what alias the function is called.  On the other hand, the\nactual search for names is done dynamically, at run time â however, the\nlanguage definition is evolving towards static name resolution, at âcompileâ"
      },
      {
        "chunk_id": "python_docs_complete_chunk_32",
        "original_index": 32,
        "content": "actual search for names is done dynamically, at run time â however, the\nlanguage definition is evolving towards static name resolution, at âcompileâ\ntime, so donât rely on dynamic name resolution!  (In fact, local variables are\nalready determined statically.)\nA special quirk of Python is that â if no global or nonlocal\nstatement is in effect â assignments to names always go into the innermost scope.\nAssignments do not copy data â they just bind names to objects.  The same is true\nfor deletions: the statement del x removes the binding of x from the\nnamespace referenced by the local scope.  In fact, all operations that introduce\nnew names use the local scope: in particular, import statements and\nfunction definitions bind the module or function name in the local scope.\nThe global statement can be used to indicate that particular\nvariables live in the global scope and should be rebound there; the\nnonlocal statement indicates that particular variables live in\nan enclosing scope and should be rebound there.\n9.2.1. Scopes and Namespaces ExampleÂ¶\nThis is an example demonstrating how to reference the different scopes and\nnamespaces, and how global and nonlocal affect variable\nbinding:\ndef scope_test():\ndef do_local():\nspam = \"local spam\"\ndef do_nonlocal():\nnonlocal spam\nspam = \"nonlocal spam\"\ndef do_global():\nglobal spam\nspam = \"global spam\"\nspam = \"test spam\"\ndo_local()\nprint(\"After local assignment:\", spam)\ndo_nonlocal()\nprint(\"After nonlocal assignment:\", spam)\ndo_global()\nprint(\"After global assignment:\", spam)\nscope_test()\nprint(\"In global scope:\", spam)\nThe output of the example code is:\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\nNote how the local assignment (which is default) didnât change scope_test's\nbinding of spam.  The nonlocal assignment changed scope_test's\nbinding of spam, and the global assignment changed the module-level\nbinding.\nYou can also see that there was no previous binding for spam before the\nglobal assignment.\n9.3. A First Look at ClassesÂ¶\nClasses introduce a little bit of new syntax, three new object types, and some\nnew semantics.\n9.3.1. Class Definition SyntaxÂ¶\nThe simplest form of class definition looks like this:\nclass ClassName:\n<statement-1>\n.\n.\n.\n<statement-N>\nClass definitions, like function definitions (def statements) must be\nexecuted before they have any effect.  (You could conceivably place a class\ndefinition in a branch of an if statement, or inside a function.)\nIn practice, the statements inside a class definition will usually be function\ndefinitions, but other statements are allowed, and sometimes useful â weâll\ncome back to this later.  The function definitions inside a class normally have\na peculiar form of argument list, dictated by the calling conventions for\nmethods â again, this is explained later.\nWhen a class definition is entered, a new namespace is created, and used as the\nlocal scope â thus, all assignments to local variables go into this new\nnamespace.  In particular, function definitions bind the name of the new\nfunction here.\nWhen a class definition is left normally (via the end), a class object is\ncreated.  This is basically a wrapper around the contents of the namespace\ncreated by the class definition; weâll learn more about class objects in the\nnext section.  The original local scope (the one in effect just before the class\ndefinition was entered) is reinstated, and the class object is bound here to the\nclass name given in the class definition header (ClassName in the\nexample).\n9.3.2. Class ObjectsÂ¶\nClass objects support two kinds of operations: attribute references and\ninstantiation.\nAttribute references use the standard syntax used for all attribute references\nin Python: obj.name.  Valid attribute names are all the names that were in\nthe classâs namespace when the class object was created.  So, if the class\ndefinition looked like this:"
      },
      {
        "chunk_id": "python_docs_complete_chunk_33",
        "original_index": 33,
        "content": "in Python: obj.name.  Valid attribute names are all the names that were in\nthe classâs namespace when the class object was created.  So, if the class\ndefinition looked like this:\nclass MyClass:\n\"\"\"A simple example class\"\"\"\ni = 12345\ndef f(self):\nreturn 'hello world'\nthen MyClass.i and MyClass.f are valid attribute references, returning\nan integer and a function object, respectively. Class attributes can also be\nassigned to, so you can change the value of MyClass.i by assignment.\n__doc__ is also a valid attribute, returning the docstring\nbelonging to the class: \"A simple example class\".\nClass instantiation uses function notation.  Just pretend that the class\nobject is a parameterless function that returns a new instance of the class.\nFor example (assuming the above class):\nx = MyClass()\ncreates a new instance of the class and assigns this object to the local\nvariable x.\nThe instantiation operation (âcallingâ a class object) creates an empty object.\nMany classes like to create objects with instances customized to a specific\ninitial state. Therefore a class may define a special method named\n__init__(), like this:\ndef __init__(self):\nself.data = []\nWhen a class defines an __init__() method, class instantiation\nautomatically invokes __init__() for the newly created class instance.  So\nin this example, a new, initialized instance can be obtained by:\nx = MyClass()\nOf course, the __init__() method may have arguments for greater\nflexibility.  In that case, arguments given to the class instantiation operator\nare passed on to __init__().  For example,\n>>> class Complex:\n...     def __init__(self, realpart, imagpart):\n...         self.r = realpart\n...         self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n9.3.3. Instance ObjectsÂ¶\nNow what can we do with instance objects?  The only operations understood by\ninstance objects are attribute references.  There are two kinds of valid\nattribute names: data attributes and methods.\ndata attributes correspond to âinstance variablesâ in Smalltalk, and to âdata\nmembersâ in C++.  Data attributes need not be declared; like local variables,\nthey spring into existence when they are first assigned to.  For example, if\nx is the instance of MyClass created above, the following piece of\ncode will print the value 16, without leaving a trace:\nx.counter = 1\nwhile x.counter < 10:\nx.counter = x.counter * 2\nprint(x.counter)\ndel x.counter\nThe other kind of instance attribute reference is a method. A method is a\nfunction that âbelongs toâ an object.\nValid method names of an instance object depend on its class.  By definition,\nall attributes of a class that are function  objects define corresponding\nmethods of its instances.  So in our example, x.f is a valid method\nreference, since MyClass.f is a function, but x.i is not, since\nMyClass.i is not.  But x.f is not the same thing as MyClass.f â it\nis a method object, not a function object.\n9.3.4. Method ObjectsÂ¶\nUsually, a method is called right after it is bound:\nx.f()\nIn the MyClass example, this will return the string 'hello world'.\nHowever, it is not necessary to call a method right away: x.f is a method\nobject, and can be stored away and called at a later time.  For example:\nxf = x.f\nwhile True:\nprint(xf())\nwill continue to print hello world until the end of time.\nWhat exactly happens when a method is called?  You may have noticed that\nx.f() was called without an argument above, even though the function\ndefinition for f() specified an argument.  What happened to the argument?\nSurely Python raises an exception when a function that requires an argument is\ncalled without any â even if the argument isnât actually usedâ¦\nActually, you may have guessed the answer: the special thing about methods is\nthat the instance object is passed as the first argument of the function.  In our\nexample, the call x.f() is exactly equivalent to MyClass.f(x).  In"
      },
      {
        "chunk_id": "python_docs_complete_chunk_34",
        "original_index": 34,
        "content": "that the instance object is passed as the first argument of the function.  In our\nexample, the call x.f() is exactly equivalent to MyClass.f(x).  In\ngeneral, calling a method with a list of n arguments is equivalent to calling\nthe corresponding function with an argument list that is created by inserting\nthe methodâs instance object before the first argument.\nIn general, methods work as follows.  When a non-data attribute\nof an instance is referenced, the instanceâs class is searched.\nIf the name denotes a valid class attribute that is a function object,\nreferences to both the instance object and the function object\nare packed into a method object.  When the method object is called\nwith an argument list, a new argument list is constructed from the instance\nobject and the argument list, and the function object is called with this new\nargument list.\n9.3.5. Class and Instance VariablesÂ¶\nGenerally speaking, instance variables are for data unique to each instance\nand class variables are for attributes and methods shared by all instances\nof the class:\nclass Dog:\nkind = 'canine'         # class variable shared by all instances\ndef __init__(self, name):\nself.name = name    # instance variable unique to each instance\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\nAs discussed in A Word About Names and Objects, shared data can have possibly surprising\neffects with involving mutable objects such as lists and dictionaries.\nFor example, the tricks list in the following code should not be used as a\nclass variable because just a single list would be shared by all Dog\ninstances:\nclass Dog:\ntricks = []             # mistaken use of a class variable\ndef __init__(self, name):\nself.name = name\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\nCorrect design of the class should use an instance variable instead:\nclass Dog:\ndef __init__(self, name):\nself.name = name\nself.tricks = []    # creates a new empty list for each dog\ndef add_trick(self, trick):\nself.tricks.append(trick)\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n9.4. Random RemarksÂ¶\nIf the same attribute name occurs in both an instance and in a class,\nthen attribute lookup prioritizes the instance:\n>>> class Warehouse:\n...    purpose = 'storage'\n...    region = 'west'\n...\n>>> w1 = Warehouse()\n>>> print(w1.purpose, w1.region)\nstorage west\n>>> w2 = Warehouse()\n>>> w2.region = 'east'\n>>> print(w2.purpose, w2.region)\nstorage east\nData attributes may be referenced by methods as well as by ordinary users\n(âclientsâ) of an object.  In other words, classes are not usable to implement\npure abstract data types.  In fact, nothing in Python makes it possible to\nenforce data hiding â it is all based upon convention.  (On the other hand,\nthe Python implementation, written in C, can completely hide implementation\ndetails and control access to an object if necessary; this can be used by\nextensions to Python written in C.)\nClients should use data attributes with care â clients may mess up invariants\nmaintained by the methods by stamping on their data attributes.  Note that\nclients may add data attributes of their own to an instance object without\naffecting the validity of the methods, as long as name conflicts are avoided â\nagain, a naming convention can save a lot of headaches here.\nThere is no shorthand for referencing data attributes (or other methods!) from\nwithin methods.  I find that this actually increases the readability of methods:"
      },
      {
        "chunk_id": "python_docs_complete_chunk_35",
        "original_index": 35,
        "content": "There is no shorthand for referencing data attributes (or other methods!) from\nwithin methods.  I find that this actually increases the readability of methods:\nthere is no chance of confusing local variables and instance variables when\nglancing through a method.\nOften, the first argument of a method is called self.  This is nothing more\nthan a convention: the name self has absolutely no special meaning to\nPython.  Note, however, that by not following the convention your code may be\nless readable to other Python programmers, and it is also conceivable that a\nclass browser program might be written that relies upon such a convention.\nAny function object that is a class attribute defines a method for instances of\nthat class.  It is not necessary that the function definition is textually\nenclosed in the class definition: assigning a function object to a local\nvariable in the class is also ok.  For example:\n# Function defined outside the class\ndef f1(self, x, y):\nreturn min(x, x+y)\nclass C:\nf = f1\ndef g(self):\nreturn 'hello world'\nh = g\nNow f, g and h are all attributes of class C that refer to\nfunction objects, and consequently they are all methods of instances of\nC â h being exactly equivalent to g.  Note that this practice\nusually only serves to confuse the reader of a program.\nMethods may call other methods by using method attributes of the self\nargument:\nclass Bag:\ndef __init__(self):\nself.data = []\ndef add(self, x):\nself.data.append(x)\ndef addtwice(self, x):\nself.add(x)\nself.add(x)\nMethods may reference global names in the same way as ordinary functions.  The\nglobal scope associated with a method is the module containing its\ndefinition.  (A class is never used as a global scope.)  While one\nrarely encounters a good reason for using global data in a method, there are\nmany legitimate uses of the global scope: for one thing, functions and modules\nimported into the global scope can be used by methods, as well as functions and\nclasses defined in it.  Usually, the class containing the method is itself\ndefined in this global scope, and in the next section weâll find some good\nreasons why a method would want to reference its own class.\nEach value is an object, and therefore has a class (also called its type).\nIt is stored as object.__class__.\n9.5. InheritanceÂ¶\nOf course, a language feature would not be worthy of the name âclassâ without\nsupporting inheritance.  The syntax for a derived class definition looks like\nthis:\nclass DerivedClassName(BaseClassName):\n<statement-1>\n.\n.\n.\n<statement-N>\nThe name BaseClassName must be defined in a\nnamespace accessible from the scope containing the\nderived class definition.  In place of a base class name, other arbitrary\nexpressions are also allowed.  This can be useful, for example, when the base\nclass is defined in another module:\nclass DerivedClassName(modname.BaseClassName):\nExecution of a derived class definition proceeds the same as for a base class.\nWhen the class object is constructed, the base class is remembered.  This is\nused for resolving attribute references: if a requested attribute is not found\nin the class, the search proceeds to look in the base class.  This rule is\napplied recursively if the base class itself is derived from some other class.\nThereâs nothing special about instantiation of derived classes:\nDerivedClassName() creates a new instance of the class.  Method references\nare resolved as follows: the corresponding class attribute is searched,\ndescending down the chain of base classes if necessary, and the method reference\nis valid if this yields a function object.\nDerived classes may override methods of their base classes.  Because methods\nhave no special privileges when calling other methods of the same object, a\nmethod of a base class that calls another method defined in the same base class\nmay end up calling a method of a derived class that overrides it.  (For C++\nprogrammers: all methods in Python are effectively virtual.)"
      },
      {
        "chunk_id": "python_docs_complete_chunk_36",
        "original_index": 36,
        "content": "may end up calling a method of a derived class that overrides it.  (For C++\nprogrammers: all methods in Python are effectively virtual.)\nAn overriding method in a derived class may in fact want to extend rather than\nsimply replace the base class method of the same name. There is a simple way to\ncall the base class method directly: just call BaseClassName.methodname(self,\narguments).  This is occasionally useful to clients as well.  (Note that this\nonly works if the base class is accessible as BaseClassName in the global\nscope.)\nPython has two built-in functions that work with inheritance:\nUse isinstance() to check an instanceâs type: isinstance(obj, int)\nwill be True only if obj.__class__ is int or some class\nderived from int.\nUse issubclass() to check class inheritance: issubclass(bool, int)\nis True since bool is a subclass of int.  However,\nissubclass(float, int) is False since float is not a\nsubclass of int.\n9.5.1. Multiple InheritanceÂ¶\nPython supports a form of multiple inheritance as well.  A class definition with\nmultiple base classes looks like this:\nclass DerivedClassName(Base1, Base2, Base3):\n<statement-1>\n.\n.\n.\n<statement-N>\nFor most purposes, in the simplest cases, you can think of the search for\nattributes inherited from a parent class as depth-first, left-to-right, not\nsearching twice in the same class where there is an overlap in the hierarchy.\nThus, if an attribute is not found in DerivedClassName, it is searched\nfor in Base1, then (recursively) in the base classes of Base1,\nand if it was not found there, it was searched for in Base2, and so on.\nIn fact, it is slightly more complex than that; the method resolution order\nchanges dynamically to support cooperative calls to super().  This\napproach is known in some other multiple-inheritance languages as\ncall-next-method and is more powerful than the super call found in\nsingle-inheritance languages.\nDynamic ordering is necessary because all cases of multiple inheritance exhibit\none or more diamond relationships (where at least one of the parent classes\ncan be accessed through multiple paths from the bottommost class).  For example,\nall classes inherit from object, so any case of multiple inheritance\nprovides more than one path to reach object.  To keep the base classes\nfrom being accessed more than once, the dynamic algorithm linearizes the search\norder in a way that preserves the left-to-right ordering specified in each\nclass, that calls each parent only once, and that is monotonic (meaning that a\nclass can be subclassed without affecting the precedence order of its parents).\nTaken together, these properties make it possible to design reliable and\nextensible classes with multiple inheritance.  For more detail, see\nThe Python 2.3 Method Resolution Order.\n9.6. Private VariablesÂ¶\nâPrivateâ instance variables that cannot be accessed except from inside an\nobject donât exist in Python.  However, there is a convention that is followed\nby most Python code: a name prefixed with an underscore (e.g. _spam) should\nbe treated as a non-public part of the API (whether it is a function, a method\nor a data member).  It should be considered an implementation detail and subject\nto change without notice.\nSince there is a valid use-case for class-private members (namely to avoid name\nclashes of names with names defined by subclasses), there is limited support for\nsuch a mechanism, called name mangling.  Any identifier of the form\n__spam (at least two leading underscores, at most one trailing underscore)\nis textually replaced with _classname__spam, where classname is the\ncurrent class name with leading underscore(s) stripped.  This mangling is done\nwithout regard to the syntactic position of the identifier, as long as it\noccurs within the definition of a class.\nSee also\nThe private name mangling specifications\nfor details and special cases.\nName mangling is helpful for letting subclasses override methods without\nbreaking intraclass method calls.  For example:\nclass Mapping:"
      },
      {
        "chunk_id": "python_docs_complete_chunk_37",
        "original_index": 37,
        "content": "for details and special cases.\nName mangling is helpful for letting subclasses override methods without\nbreaking intraclass method calls.  For example:\nclass Mapping:\ndef __init__(self, iterable):\nself.items_list = []\nself.__update(iterable)\ndef update(self, iterable):\nfor item in iterable:\nself.items_list.append(item)\n__update = update   # private copy of original update() method\nclass MappingSubclass(Mapping):\ndef update(self, keys, values):\n# provides new signature for update()\n# but does not break __init__()\nfor item in zip(keys, values):\nself.items_list.append(item)\nThe above example would work even if MappingSubclass were to introduce a\n__update identifier since it is replaced with _Mapping__update in the\nMapping class  and _MappingSubclass__update in the MappingSubclass\nclass respectively.\nNote that the mangling rules are designed mostly to avoid accidents; it still is\npossible to access or modify a variable that is considered private.  This can\neven be useful in special circumstances, such as in the debugger.\nNotice that code passed to exec() or eval() does not consider the\nclassname of the invoking class to be the current class; this is similar to the\neffect of the global statement, the effect of which is likewise restricted\nto code that is byte-compiled together.  The same restriction applies to\ngetattr(), setattr() and delattr(), as well as when referencing\n__dict__ directly.\n9.7. Odds and EndsÂ¶\nSometimes it is useful to have a data type similar to the Pascal ârecordâ or C\nâstructâ, bundling together a few named data items. The idiomatic approach\nis to use dataclasses for this purpose:\nfrom dataclasses import dataclass\n@dataclass\nclass Employee:\nname: str\ndept: str\nsalary: int\n>>> john = Employee('john', 'computer lab', 1000)\n>>> john.dept\n'computer lab'\n>>> john.salary\n1000\nA piece of Python code that expects a particular abstract data type can often be\npassed a class that emulates the methods of that data type instead.  For\ninstance, if you have a function that formats some data from a file object, you\ncan define a class with methods read() and\nreadline() that get the\ndata from a string buffer instead, and pass it as an argument.\nInstance method objects have attributes, too:\nm.__self__ is the instance\nobject with the method m(), and m.__func__ is\nthe function object\ncorresponding to the method.\n9.8. IteratorsÂ¶\nBy now you have probably noticed that most container objects can be looped over\nusing a for statement:\nfor element in [1, 2, 3]:\nprint(element)\nfor element in (1, 2, 3):\nprint(element)\nfor key in {'one':1, 'two':2}:\nprint(key)\nfor char in \"123\":\nprint(char)\nfor line in open(\"myfile.txt\"):\nprint(line, end='')\nThis style of access is clear, concise, and convenient.  The use of iterators\npervades and unifies Python.  Behind the scenes, the for statement\ncalls iter() on the container object.  The function returns an iterator\nobject that defines the method __next__() which accesses\nelements in the container one at a time.  When there are no more elements,\n__next__() raises a StopIteration exception which tells the\nfor loop to terminate.  You can call the __next__() method\nusing the next() built-in function; this example shows how it all works:\n>>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<str_iterator object at 0x10c90e650>\n>>> next(it)\n'a'\n>>> next(it)\n'b'\n>>> next(it)\n'c'\n>>> next(it)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nnext(it)\nStopIteration\nHaving seen the mechanics behind the iterator protocol, it is easy to add\niterator behavior to your classes.  Define an __iter__() method which\nreturns an object with a __next__() method.  If the class\ndefines __next__(), then __iter__() can just return self:\nclass Reverse:\n\"\"\"Iterator for looping over a sequence backwards.\"\"\"\ndef __init__(self, data):\nself.data = data\nself.index = len(data)\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.index == 0:\nraise StopIteration\nself.index = self.index - 1"
      },
      {
        "chunk_id": "python_docs_complete_chunk_38",
        "original_index": 38,
        "content": "def __init__(self, data):\nself.data = data\nself.index = len(data)\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.index == 0:\nraise StopIteration\nself.index = self.index - 1\nreturn self.data[self.index]\n>>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n...     print(char)\n...\nm\na\np\ns\n9.9. GeneratorsÂ¶\nGenerators are a simple and powerful tool for creating iterators.  They\nare written like regular functions but use the yield statement\nwhenever they want to return data.  Each time next() is called on it, the\ngenerator resumes where it left off (it remembers all the data values and which\nstatement was last executed).  An example shows that generators can be trivially\neasy to create:\ndef reverse(data):\nfor index in range(len(data)-1, -1, -1):\nyield data[index]\n>>> for char in reverse('golf'):\n...     print(char)\n...\nf\nl\no\ng\nAnything that can be done with generators can also be done with class-based\niterators as described in the previous section.  What makes generators so\ncompact is that the __iter__() and __next__() methods\nare created automatically.\nAnother key feature is that the local variables and execution state are\nautomatically saved between calls.  This made the function easier to write and\nmuch more clear than an approach using instance variables like self.index\nand self.data.\nIn addition to automatic method creation and saving program state, when\ngenerators terminate, they automatically raise StopIteration. In\ncombination, these features make it easy to create iterators with no more effort\nthan writing a regular function.\n9.10. Generator ExpressionsÂ¶\nSome simple generators can be coded succinctly as expressions using a syntax\nsimilar to list comprehensions but with parentheses instead of square brackets.\nThese expressions are designed for situations where the generator is used right\naway by an enclosing function.  Generator expressions are more compact but less\nversatile than full generator definitions and tend to be more memory friendly\nthan equivalent list comprehensions.\nExamples:\n>>> sum(i*i for i in range(10))                 # sum of squares\n285\n>>> xvec = [10, 20, 30]\n>>> yvec = [7, 5, 3]\n>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n260\n>>> unique_words = set(word for line in page  for word in line.split())\n>>> valedictorian = max((student.gpa, student.name) for student in graduates)\n>>> data = 'golf'\n>>> list(data[i] for i in range(len(data)-1, -1, -1))\n['f', 'l', 'o', 'g']\nFootnotes\n[1]\nExcept for one thing.  Module objects have a secret read-only attribute called\n__dict__ which returns the dictionary used to implement the moduleâs\nnamespace; the name __dict__ is an attribute but not a global name.\nObviously, using this violates the abstraction of namespace implementation, and\nshould be restricted to things like post-mortem debuggers."
      },
      {
        "chunk_id": "python_docs_complete_chunk_39",
        "original_index": 39,
        "content": "==================== ERRORS ===================="
      },
      {
        "chunk_id": "python_docs_complete_chunk_40",
        "original_index": 40,
        "content": "8. Errors and ExceptionsÂ¶\nUntil now error messages havenât been more than mentioned, but if you have tried\nout the examples you have probably seen some.  There are (at least) two\ndistinguishable kinds of errors: syntax errors and exceptions.\n8.1. Syntax ErrorsÂ¶\nSyntax errors, also known as parsing errors, are perhaps the most common kind of\ncomplaint you get while you are still learning Python:\n>>> while True print('Hello world')\nFile \"<stdin>\", line 1\nwhile True print('Hello world')\n^^^^^\nSyntaxError: invalid syntax\nThe parser repeats the offending line and displays little âarrowâs pointing\nat the token in the line where the error was detected.  The error may be\ncaused by the absence of a token before the indicated token.  In the\nexample, the error is detected at the function print(), since a colon\n(':') is missing before it.  File name and line number are printed so you\nknow where to look in case the input came from a script.\n8.2. ExceptionsÂ¶\nEven if a statement or expression is syntactically correct, it may cause an\nerror when an attempt is made to execute it. Errors detected during execution\nare called exceptions and are not unconditionally fatal: you will soon learn\nhow to handle them in Python programs.  Most exceptions are not handled by\nprograms, however, and result in error messages as shown here:\n>>> 10 * (1/0)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nZeroDivisionError: division by zero\n>>> 4 + spam*3\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'spam' is not defined\n>>> '2' + 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate str (not \"int\") to str\nThe last line of the error message indicates what happened. Exceptions come in\ndifferent types, and the type is printed as part of the message: the types in\nthe example are ZeroDivisionError, NameError and TypeError.\nThe string printed as the exception type is the name of the built-in exception\nthat occurred.  This is true for all built-in exceptions, but need not be true\nfor user-defined exceptions (although it is a useful convention). Standard\nexception names are built-in identifiers (not reserved keywords).\nThe rest of the line provides detail based on the type of exception and what\ncaused it.\nThe preceding part of the error message shows the context where the exception\noccurred, in the form of a stack traceback. In general it contains a stack\ntraceback listing source lines; however, it will not display lines read from\nstandard input.\nBuilt-in Exceptions lists the built-in exceptions and their meanings.\n8.3. Handling ExceptionsÂ¶\nIt is possible to write programs that handle selected exceptions. Look at the\nfollowing example, which asks the user for input until a valid integer has been\nentered, but allows the user to interrupt the program (using Control-C or\nwhatever the operating system supports); note that a user-generated interruption\nis signalled by raising the KeyboardInterrupt exception.\n>>> while True:\n...     try:\n...         x = int(input(\"Please enter a number: \"))\n...         break\n...     except ValueError:\n...         print(\"Oops!  That was no valid number.  Try again...\")\n...\nThe try statement works as follows.\nFirst, the try clause (the statement(s) between the try and\nexcept keywords) is executed.\nIf no exception occurs, the except clause is skipped and execution of the\ntry statement is finished.\nIf an exception occurs during execution of the try clause, the rest of the\nclause is skipped.  Then, if its type matches the exception named after the\nexcept keyword, the except clause is executed, and then execution\ncontinues after the try/except block.\nIf an exception occurs which does not match the exception named in the except\nclause, it is passed on to outer try statements; if no handler is\nfound, it is an unhandled exception and execution stops with an error message."
      },
      {
        "chunk_id": "python_docs_complete_chunk_41",
        "original_index": 41,
        "content": "clause, it is passed on to outer try statements; if no handler is\nfound, it is an unhandled exception and execution stops with an error message.\nA try statement may have more than one except clause, to specify\nhandlers for different exceptions.  At most one handler will be executed.\nHandlers only handle exceptions that occur in the corresponding try clause,\nnot in other handlers of the same try statement.  An except clause\nmay name multiple exceptions as a parenthesized tuple, for example:\n... except (RuntimeError, TypeError, NameError):\n...     pass\nA class in an except clause matches exceptions which are instances of the\nclass itself or one of its derived classes (but not the other way around â an\nexcept clause listing a derived class does not match instances of its base classes).\nFor example, the following code will print B, C, D in that order:\nclass B(Exception):\npass\nclass C(B):\npass\nclass D(C):\npass\nfor cls in [B, C, D]:\ntry:\nraise cls()\nexcept D:\nprint(\"D\")\nexcept C:\nprint(\"C\")\nexcept B:\nprint(\"B\")\nNote that if the except clauses were reversed (with except B first), it\nwould have printed B, B, B â the first matching except clause is triggered.\nWhen an exception occurs, it may have associated values, also known as the\nexceptionâs arguments. The presence and types of the arguments depend on the\nexception type.\nThe except clause may specify a variable after the exception name.  The\nvariable is bound to the exception instance which typically has an args\nattribute that stores the arguments. For convenience, builtin exception\ntypes define __str__() to print all the arguments without explicitly\naccessing .args.\n>>> try:\n...     raise Exception('spam', 'eggs')\n... except Exception as inst:\n...     print(type(inst))    # the exception type\n...     print(inst.args)     # arguments stored in .args\n...     print(inst)          # __str__ allows args to be printed directly,\n...                          # but may be overridden in exception subclasses\n...     x, y = inst.args     # unpack args\n...     print('x =', x)\n...     print('y =', y)\n...\n<class 'Exception'>\n('spam', 'eggs')\n('spam', 'eggs')\nx = spam\ny = eggs\nThe exceptionâs __str__() output is printed as the last part (âdetailâ)\nof the message for unhandled exceptions.\nBaseException is the common base class of all exceptions. One of its\nsubclasses, Exception, is the base class of all the non-fatal exceptions.\nExceptions which are not subclasses of Exception are not typically\nhandled, because they are used to indicate that the program should terminate.\nThey include SystemExit which is raised by sys.exit() and\nKeyboardInterrupt which is raised when a user wishes to interrupt\nthe program.\nException can be used as a wildcard that catches (almost) everything.\nHowever, it is good practice to be as specific as possible with the types\nof exceptions that we intend to handle, and to allow any unexpected\nexceptions to propagate on.\nThe most common pattern for handling Exception is to print or log\nthe exception and then re-raise it (allowing a caller to handle the\nexception as well):\nimport sys\ntry:\nf = open('myfile.txt')\ns = f.readline()\ni = int(s.strip())\nexcept OSError as err:\nprint(\"OS error:\", err)\nexcept ValueError:\nprint(\"Could not convert data to an integer.\")\nexcept Exception as err:\nprint(f\"Unexpected {err=}, {type(err)=}\")\nraise\nThe try â¦ except statement has an optional else\nclause, which, when present, must follow all except clauses.  It is useful\nfor code that must be executed if the try clause does not raise an exception.\nFor example:\nfor arg in sys.argv[1:]:\ntry:\nf = open(arg, 'r')\nexcept OSError:\nprint('cannot open', arg)\nelse:\nprint(arg, 'has', len(f.readlines()), 'lines')\nf.close()\nThe use of the else clause is better than adding additional code to\nthe try clause because it avoids accidentally catching an exception\nthat wasnât raised by the code being protected by the try â¦\nexcept statement."
      },
      {
        "chunk_id": "python_docs_complete_chunk_42",
        "original_index": 42,
        "content": "the try clause because it avoids accidentally catching an exception\nthat wasnât raised by the code being protected by the try â¦\nexcept statement.\nException handlers do not handle only exceptions that occur immediately in the\ntry clause, but also those that occur inside functions that are called (even\nindirectly) in the try clause. For example:\n>>> def this_fails():\n...     x = 1/0\n...\n>>> try:\n...     this_fails()\n... except ZeroDivisionError as err:\n...     print('Handling run-time error:', err)\n...\nHandling run-time error: division by zero\n8.4. Raising ExceptionsÂ¶\nThe raise statement allows the programmer to force a specified\nexception to occur. For example:\n>>> raise NameError('HiThere')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: HiThere\nThe sole argument to raise indicates the exception to be raised.\nThis must be either an exception instance or an exception class (a class that\nderives from BaseException, such as Exception or one of its\nsubclasses).  If an exception class is passed, it will be implicitly\ninstantiated by calling its constructor with no arguments:\nraise ValueError  # shorthand for 'raise ValueError()'\nIf you need to determine whether an exception was raised but donât intend to\nhandle it, a simpler form of the raise statement allows you to\nre-raise the exception:\n>>> try:\n...     raise NameError('HiThere')\n... except NameError:\n...     print('An exception flew by!')\n...     raise\n...\nAn exception flew by!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nNameError: HiThere\n8.5. Exception ChainingÂ¶\nIf an unhandled exception occurs inside an except section, it will\nhave the exception being handled attached to it and included in the error\nmessage:\n>>> try:\n...     open(\"database.sqlite\")\n... except OSError:\n...     raise RuntimeError(\"unable to handle error\")\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nFileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: unable to handle error\nTo indicate that an exception is a direct consequence of another, the\nraise statement allows an optional from clause:\n# exc must be exception instance or None.\nraise RuntimeError from exc\nThis can be useful when you are transforming exceptions. For example:\n>>> def func():\n...     raise ConnectionError\n...\n>>> try:\n...     func()\n... except ConnectionError as exc:\n...     raise RuntimeError('Failed to open database') from exc\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nFile \"<stdin>\", line 2, in func\nConnectionError\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError: Failed to open database\nIt also allows disabling automatic exception chaining using the from None\nidiom:\n>>> try:\n...     open('database.sqlite')\n... except OSError:\n...     raise RuntimeError from None\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nRuntimeError\nFor more information about chaining mechanics, see Built-in Exceptions.\n8.6. User-defined ExceptionsÂ¶\nPrograms may name their own exceptions by creating a new exception class (see\nClasses for more about Python classes).  Exceptions should typically\nbe derived from the Exception class, either directly or indirectly.\nException classes can be defined which do anything any other class can do, but\nare usually kept simple, often only offering a number of attributes that allow\ninformation about the error to be extracted by handlers for the exception.\nMost exceptions are defined with names that end in âErrorâ, similar to the\nnaming of the standard exceptions.\nMany standard modules define their own exceptions to report errors that may\noccur in functions they define."
      },
      {
        "chunk_id": "python_docs_complete_chunk_43",
        "original_index": 43,
        "content": "naming of the standard exceptions.\nMany standard modules define their own exceptions to report errors that may\noccur in functions they define.\n8.7. Defining Clean-up ActionsÂ¶\nThe try statement has another optional clause which is intended to\ndefine clean-up actions that must be executed under all circumstances.  For\nexample:\n>>> try:\n...     raise KeyboardInterrupt\n... finally:\n...     print('Goodbye, world!')\n...\nGoodbye, world!\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nKeyboardInterrupt\nIf a finally clause is present, the finally\nclause will execute as the last task before the try\nstatement completes. The finally clause runs whether or\nnot the try statement produces an exception. The following\npoints discuss more complex cases when an exception occurs:\nIf an exception occurs during execution of the try\nclause, the exception may be handled by an except\nclause. If the exception is not handled by an except\nclause, the exception is re-raised after the finally\nclause has been executed.\nAn exception could occur during execution of an except\nor else clause. Again, the exception is re-raised after\nthe finally clause has been executed.\nIf the finally clause executes a break,\ncontinue or return statement, exceptions are not\nre-raised.\nIf the try statement reaches a break,\ncontinue or return statement, the\nfinally clause will execute just prior to the\nbreak, continue or return\nstatementâs execution.\nIf a finally clause includes a return\nstatement, the returned value will be the one from the\nfinally clauseâs return statement, not the\nvalue from the try clauseâs return\nstatement.\nFor example:\n>>> def bool_return():\n...     try:\n...         return True\n...     finally:\n...         return False\n...\n>>> bool_return()\nFalse\nA more complicated example:\n>>> def divide(x, y):\n...     try:\n...         result = x / y\n...     except ZeroDivisionError:\n...         print(\"division by zero!\")\n...     else:\n...         print(\"result is\", result)\n...     finally:\n...         print(\"executing finally clause\")\n...\n>>> divide(2, 1)\nresult is 2.0\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 3, in divide\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\nAs you can see, the finally clause is executed in any event.  The\nTypeError raised by dividing two strings is not handled by the\nexcept clause and therefore re-raised after the finally\nclause has been executed.\nIn real world applications, the finally clause is useful for\nreleasing external resources (such as files or network connections), regardless\nof whether the use of the resource was successful.\n8.8. Predefined Clean-up ActionsÂ¶\nSome objects define standard clean-up actions to be undertaken when the object\nis no longer needed, regardless of whether or not the operation using the object\nsucceeded or failed. Look at the following example, which tries to open a file\nand print its contents to the screen.\nfor line in open(\"myfile.txt\"):\nprint(line, end=\"\")\nThe problem with this code is that it leaves the file open for an indeterminate\namount of time after this part of the code has finished executing.\nThis is not an issue in simple scripts, but can be a problem for larger\napplications. The with statement allows objects like files to be\nused in a way that ensures they are always cleaned up promptly and correctly.\nwith open(\"myfile.txt\") as f:\nfor line in f:\nprint(line, end=\"\")\nAfter the statement is executed, the file f is always closed, even if a\nproblem was encountered while processing the lines. Objects which, like files,\nprovide predefined clean-up actions will indicate this in their documentation.\n8.9. Raising and Handling Multiple Unrelated ExceptionsÂ¶\nThere are situations where it is necessary to report several exceptions that"
      },
      {
        "chunk_id": "python_docs_complete_chunk_44",
        "original_index": 44,
        "content": "8.9. Raising and Handling Multiple Unrelated ExceptionsÂ¶\nThere are situations where it is necessary to report several exceptions that\nhave occurred. This is often the case in concurrency frameworks, when several\ntasks may have failed in parallel, but there are also other use cases where\nit is desirable to continue execution and collect multiple errors rather than\nraise the first exception.\nThe builtin ExceptionGroup wraps a list of exception instances so\nthat they can be raised together. It is an exception itself, so it can be\ncaught like any other exception.\n>>> def f():\n...     excs = [OSError('error 1'), SystemError('error 2')]\n...     raise ExceptionGroup('there were problems', excs)\n...\n>>> f()\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 1, in <module>\n|   File \"<stdin>\", line 3, in f\n| ExceptionGroup: there were problems\n+-+---------------- 1 ----------------\n| OSError: error 1\n+---------------- 2 ----------------\n| SystemError: error 2\n+------------------------------------\n>>> try:\n...     f()\n... except Exception as e:\n...     print(f'caught {type(e)}: e')\n...\ncaught <class 'ExceptionGroup'>: e\n>>>\nBy using except* instead of except, we can selectively\nhandle only the exceptions in the group that match a certain\ntype. In the following example, which shows a nested exception\ngroup, each except* clause extracts from the group exceptions\nof a certain type while letting all other exceptions propagate to\nother clauses and eventually to be reraised.\n>>> def f():\n...     raise ExceptionGroup(\n...         \"group1\",\n...         [\n...             OSError(1),\n...             SystemError(2),\n...             ExceptionGroup(\n...                 \"group2\",\n...                 [\n...                     OSError(3),\n...                     RecursionError(4)\n...                 ]\n...             )\n...         ]\n...     )\n...\n>>> try:\n...     f()\n... except* OSError as e:\n...     print(\"There were OSErrors\")\n... except* SystemError as e:\n...     print(\"There were SystemErrors\")\n...\nThere were OSErrors\nThere were SystemErrors\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 2, in <module>\n|   File \"<stdin>\", line 2, in f\n| ExceptionGroup: group1\n+-+---------------- 1 ----------------\n| ExceptionGroup: group2\n+-+---------------- 1 ----------------\n| RecursionError: 4\n+------------------------------------\n>>>\nNote that the exceptions nested in an exception group must be instances,\nnot types. This is because in practice the exceptions would typically\nbe ones that have already been raised and caught by the program, along\nthe following pattern:\n>>> excs = []\n... for test in tests:\n...     try:\n...         test.run()\n...     except Exception as e:\n...         excs.append(e)\n...\n>>> if excs:\n...    raise ExceptionGroup(\"Test Failures\", excs)\n...\n8.10. Enriching Exceptions with NotesÂ¶\nWhen an exception is created in order to be raised, it is usually initialized\nwith information that describes the error that has occurred. There are cases\nwhere it is useful to add information after the exception was caught. For this\npurpose, exceptions have a method add_note(note) that accepts a string and\nadds it to the exceptionâs notes list. The standard traceback rendering\nincludes all notes, in the order they were added, after the exception.\n>>> try:\n...     raise TypeError('bad type')\n... except Exception as e:\n...     e.add_note('Add some information')\n...     e.add_note('Add some more information')\n...     raise\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nTypeError: bad type\nAdd some information\nAdd some more information\n>>>\nFor example, when collecting exceptions into an exception group, we may want\nto add context information for the individual errors. In the following each\nexception in the group has a note indicating when this error has occurred.\n>>> def f():\n...     raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n...     try:"
      },
      {
        "chunk_id": "python_docs_complete_chunk_45",
        "original_index": 45,
        "content": "exception in the group has a note indicating when this error has occurred.\n>>> def f():\n...     raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n...     try:\n...         f()\n...     except Exception as e:\n...         e.add_note(f'Happened in Iteration {i+1}')\n...         excs.append(e)\n...\n>>> raise ExceptionGroup('We have some problems', excs)\n+ Exception Group Traceback (most recent call last):\n|   File \"<stdin>\", line 1, in <module>\n| ExceptionGroup: We have some problems (3 sub-exceptions)\n+-+---------------- 1 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 1\n+---------------- 2 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 2\n+---------------- 3 ----------------\n| Traceback (most recent call last):\n|   File \"<stdin>\", line 3, in <module>\n|   File \"<stdin>\", line 2, in f\n| OSError: operation failed\n| Happened in Iteration 3\n+------------------------------------\n>>>"
      }
    ]
  }
]