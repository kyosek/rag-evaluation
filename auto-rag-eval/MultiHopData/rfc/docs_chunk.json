[
  {
    "doc_id": "rfc_http",
    "original_uuid": "cdcf",
    "content": "\n\n\n\n\n\nNetwork Working Group                                      R. Fielding\nRequest for Comments: 2616                                   UC Irvine\nObsoletes: 2068                                              J. Gettys\nCategory: Standards Track                                   Compaq/W3C\n                                                              J. Mogul\n                                                                Compaq\n                                                            H. Frystyk\n                                                               W3C/MIT\n                                                           L. Masinter\n                                                                 Xerox\n                                                              P. Leach\n                                                             Microsoft\n                                                        T. Berners-Lee\n                                                               W3C/MIT\n                                                             June 1999\n\n\n                Hypertext Transfer Protocol -- HTTP/1.1\n\nStatus of this Memo\n\n   This document specifies an Internet standards track protocol for the\n   Internet community, and requests discussion and suggestions for\n   improvements.  Please refer to the current edition of the \"Internet\n   Official Protocol Standards\" (STD 1) for the standardization state\n   and status of this protocol.  Distribution of this memo is unlimited.\n\nCopyright Notice\n\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n\nAbstract\n\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n   protocol for distributed, collaborative, hypermedia information\n   systems. It is a generic, stateless, protocol which can be used for\n   many tasks beyond its use for hypertext, such as name servers and\n   distributed object management systems, through extension of its\n   request methods, error codes and headers [47]. A feature of HTTP is\n   the typing and negotiation of data representation, allowing systems\n   to be built independently of the data being transferred.\n\n   HTTP has been in use by the World-Wide Web global information\n   initiative since 1990. This specification defines the protocol\n   referred to as \"HTTP/1.1\", and is an update to RFC 2068 [33].\n\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 1]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\nTable of Contents\n\n   1   Introduction ...................................................7\n   1.1    Purpose......................................................7\n   1.2   Requirements .................................................8\n   1.3   Terminology ..................................................8\n   1.4   Overall Operation ...........................................12\n   2   Notational Conventions and Generic Grammar ....................14\n   2.1   Augmented BNF ...............................................14\n   2.2   Basic Rules .................................................15\n   3   Protocol Parameters ...........................................17\n   3.1   HTTP Version ................................................17\n   3.2   Uniform Resource Identifiers ................................18\n   3.2.1    General Syntax ...........................................19\n   3.2.2    http URL .................................................19\n   3.2.3    URI Comparison ...........................................20\n   3.3   Date/Time Formats ...........................................20\n   3.3.1    Full Date ................................................20\n   3.3.2    Delta Seconds ............................................21\n   3.4   Character Sets ..............................................21\n   3.4.1    Missing Charset ..........................................22\n   3.5   Content Codings .............................................23\n   3.6   Transfer Codings ............................................24\n   3.6.1    Chunked Transfer Coding ..................................25\n   3.7   Media Types .................................................26\n   3.7.1    Canonicalization and Text Defaults .......................27\n   3.7.2    Multipart Types ..........................................27\n   3.8   Product Tokens ..............................................28\n   3.9   Quality Values ..............................................29\n   3.10  Language Tags ...............................................29\n   3.11  Entity Tags .................................................30\n   3.12  Range Units .................................................30\n   4   HTTP Message ..................................................31\n   4.1   Message Types ...............................................31\n   4.2   Message Headers .............................................31\n   4.3   Message Body ................................................32\n   4.4   Message Length ..............................................33\n   4.5   General Header Fields .......................................34\n   5   Request .......................................................35\n   5.1   Request-Line ................................................35\n   5.1.1    Method ...................................................36\n   5.1.2    Request-URI ..............................................36\n   5.2   The Resource Identified by a Request ........................38\n   5.3   Request Header Fields .......................................38\n   6   Response ......................................................39\n   6.1   Status-Line .................................................39\n   6.1.1    Status Code and Reason Phrase ............................39\n   6.2   Response Header Fields ......................................41\n\n\n\nFielding, et al.            Standards Track                     [Page 2]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   7   Entity ........................................................42\n   7.1   Entity Header Fields ........................................42\n   7.2   Entity Body .................................................43\n   7.2.1    Type .....................................................43\n   7.2.2    Entity Length ............................................43\n   8   Connections ...................................................44\n   8.1   Persistent Connections ......................................44\n   8.1.1    Purpose ..................................................44\n   8.1.2    Overall Operation ........................................45\n   8.1.3    Proxy Servers ............................................46\n   8.1.4    Practical Considerations .................................46\n   8.2   Message Transmission Requirements ...........................47\n   8.2.1    Persistent Connections and Flow Control ..................47\n   8.2.2    Monitoring Connections for Error Status Messages .........48\n   8.2.3    Use of the 100 (Continue) Status .........................48\n   8.2.4    Client Behavior if Server Prematurely Closes Connection ..50\n   9   Method Definitions ............................................51\n   9.1   Safe and Idempotent Methods .................................51\n   9.1.1    Safe Methods .............................................51\n   9.1.2    Idempotent Methods .......................................51\n   9.2   OPTIONS .....................................................52\n   9.3   GET .........................................................53\n   9.4   HEAD ........................................................54\n   9.5   POST ........................................................54\n   9.6   PUT .........................................................55\n   9.7   DELETE ......................................................56\n   9.8   TRACE .......................................................56\n   9.9   CONNECT .....................................................57\n   10   Status Code Definitions ......................................57\n   10.1  Informational 1xx ...........................................57\n   10.1.1   100 Continue .............................................58\n   10.1.2   101 Switching Protocols ..................................58\n   10.2  Successful 2xx ..............................................58\n   10.2.1   200 OK ...................................................58\n   10.2.2   201 Created ..............................................59\n   10.2.3   202 Accepted .............................................59\n   10.2.4   203 Non-Authoritative Information ........................59\n   10.2.5   204 No Content ...........................................60\n   10.2.6   205 Reset Content ........................................60\n   10.2.7   206 Partial Content ......................................60\n   10.3  Redirection 3xx .............................................61\n   10.3.1   300 Multiple Choices .....................................61\n   10.3.2   301 Moved Permanently ....................................62\n   10.3.3   302 Found ................................................62\n   10.3.4   303 See Other ............................................63\n   10.3.5   304 Not Modified .........................................63\n   10.3.6   305 Use Proxy ............................................64\n   10.3.7   306 (Unused) .............................................64\n\n\n\nFielding, et al.            Standards Track                     [Page 3]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   10.3.8   307 Temporary Redirect ...................................65\n   10.4  Client Error 4xx ............................................65\n   10.4.1    400 Bad Request .........................................65\n   10.4.2    401 Unauthorized ........................................66\n   10.4.3    402 Payment Required ....................................66\n   10.4.4    403 Forbidden ...........................................66\n   10.4.5    404 Not Found ...........................................66\n   10.4.6    405 Method Not Allowed ..................................66\n   10.4.7    406 Not Acceptable ......................................67\n   10.4.8    407 Proxy Authentication Required .......................67\n   10.4.9    408 Request Timeout .....................................67\n   10.4.10   409 Conflict ............................................67\n   10.4.11   410 Gone ................................................68\n   10.4.12   411 Length Required .....................................68\n   10.4.13   412 Precondition Failed .................................68\n   10.4.14   413 Request Entity Too Large ............................69\n   10.4.15   414 Request-URI Too Long ................................69\n   10.4.16   415 Unsupported Media Type ..............................69\n   10.4.17   416 Requested Range Not Satisfiable .....................69\n   10.4.18   417 Expectation Failed ..................................70\n   10.5  Server Error 5xx ............................................70\n   10.5.1   500 Internal Server Error ................................70\n   10.5.2   501 Not Implemented ......................................70\n   10.5.3   502 Bad Gateway ..........................................70\n   10.5.4   503 Service Unavailable ..................................70\n   10.5.5   504 Gateway Timeout ......................................71\n   10.5.6   505 HTTP Version Not Supported ...........................71\n   11   Access Authentication ........................................71\n   12   Content Negotiation ..........................................71\n   12.1  Server-driven Negotiation ...................................72\n   12.2  Agent-driven Negotiation ....................................73\n   12.3  Transparent Negotiation .....................................74\n   13   Caching in HTTP ..............................................74\n   13.1.1   Cache Correctness ........................................75\n   13.1.2   Warnings .................................................76\n   13.1.3   Cache-control Mechanisms .................................77\n   13.1.4   Explicit User Agent Warnings .............................78\n   13.1.5   Exceptions to the Rules and Warnings .....................78\n   13.1.6   Client-controlled Behavior ...............................79\n   13.2  Expiration Model ............................................79\n   13.2.1   Server-Specified Expiration ..............................79\n   13.2.2   Heuristic Expiration .....................................80\n   13.2.3   Age Calculations .........................................80\n   13.2.4   Expiration Calculations ..................................83\n   13.2.5   Disambiguating Expiration Values .........................84\n   13.2.6   Disambiguating Multiple Responses ........................84\n   13.3  Validation Model ............................................85\n   13.3.1   Last-Modified Dates ......................................86\n\n\n\nFielding, et al.            Standards Track                     [Page 4]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   13.3.2   Entity Tag Cache Validators ..............................86\n   13.3.3   Weak and Strong Validators ...............................86\n   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89\n   13.3.5   Non-validating Conditionals ..............................90\n   13.4  Response Cacheability .......................................91\n   13.5  Constructing Responses From Caches ..........................92\n   13.5.1   End-to-end and Hop-by-hop Headers ........................92\n   13.5.2   Non-modifiable Headers ...................................92\n   13.5.3   Combining Headers ........................................94\n   13.5.4   Combining Byte Ranges ....................................95\n   13.6  Caching Negotiated Responses ................................95\n   13.7  Shared and Non-Shared Caches ................................96\n   13.8  Errors or Incomplete Response Cache Behavior ................97\n   13.9  Side Effects of GET and HEAD ................................97\n   13.10   Invalidation After Updates or Deletions ...................97\n   13.11   Write-Through Mandatory ...................................98\n   13.12   Cache Replacement .........................................99\n   13.13   History Lists .............................................99\n   14   Header Field Definitions ....................................100\n   14.1  Accept .....................................................100\n   14.2  Accept-Charset .............................................102\n   14.3  Accept-Encoding ............................................102\n   14.4  Accept-Language ............................................104\n   14.5  Accept-Ranges ..............................................105\n   14.6  Age ........................................................106\n   14.7  Allow ......................................................106\n   14.8  Authorization ..............................................107\n   14.9  Cache-Control ..............................................108\n   14.9.1   What is Cacheable .......................................109\n   14.9.2   What May be Stored by Caches ............................110\n   14.9.3   Modifications of the Basic Expiration Mechanism .........111\n   14.9.4   Cache Revalidation and Reload Controls ..................113\n   14.9.5   No-Transform Directive ..................................115\n   14.9.6   Cache Control Extensions ................................116\n   14.10   Connection ...............................................117\n   14.11   Content-Encoding .........................................118\n   14.12   Content-Language .........................................118\n   14.13   Content-Length ...........................................119\n   14.14   Content-Location .........................................120\n   14.15   Content-MD5 ..............................................121\n   14.16   Content-Range ............................................122\n   14.17   Content-Type .............................................124\n   14.18   Date .....................................................124\n   14.18.1   Clockless Origin Server Operation ......................125\n   14.19   ETag .....................................................126\n   14.20   Expect ...................................................126\n   14.21   Expires ..................................................127\n   14.22   From .....................................................128\n\n\n\nFielding, et al.            Standards Track                     [Page 5]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   14.23   Host .....................................................128\n   14.24   If-Match .................................................129\n   14.25   If-Modified-Since ........................................130\n   14.26   If-None-Match ............................................132\n   14.27   If-Range .................................................133\n   14.28   If-Unmodified-Since ......................................134\n   14.29   Last-Modified ............................................134\n   14.30   Location .................................................135\n   14.31   Max-Forwards .............................................136\n   14.32   Pragma ...................................................136\n   14.33   Proxy-Authenticate .......................................137\n   14.34   Proxy-Authorization ......................................137\n   14.35   Range ....................................................138\n   14.35.1    Byte Ranges ...........................................138\n   14.35.2    Range Retrieval Requests ..............................139\n   14.36   Referer ..................................................140\n   14.37   Retry-After ..............................................141\n   14.38   Server ...................................................141\n   14.39   TE .......................................................142\n   14.40   Trailer ..................................................143\n   14.41  Transfer-Encoding..........................................143\n   14.42   Upgrade ..................................................144\n   14.43   User-Agent ...............................................145\n   14.44   Vary .....................................................145\n   14.45   Via ......................................................146\n   14.46   Warning ..................................................148\n   14.47   WWW-Authenticate .........................................150\n   15 Security Considerations .......................................150\n   15.1      Personal Information....................................151\n   15.1.1   Abuse of Server Log Information .........................151\n   15.1.2   Transfer of Sensitive Information .......................151\n   15.1.3   Encoding Sensitive Information in URI's .................152\n   15.1.4   Privacy Issues Connected to Accept Headers ..............152\n   15.2  Attacks Based On File and Path Names .......................153\n   15.3  DNS Spoofing ...............................................154\n   15.4  Location Headers and Spoofing ..............................154\n   15.5  Content-Disposition Issues .................................154\n   15.6  Authentication Credentials and Idle Clients ................155\n   15.7  Proxies and Caching ........................................155\n   15.7.1    Denial of Service Attacks on Proxies....................156\n   16   Acknowledgments .............................................156\n   17   References ..................................................158\n   18   Authors' Addresses ..........................................162\n   19   Appendices ..................................................164\n   19.1  Internet Media Type message/http and application/http ......164\n   19.2  Internet Media Type multipart/byteranges ...................165\n   19.3  Tolerant Applications ......................................166\n   19.4  Differences Between HTTP Entities and RFC 2045 Entities ....167\n\n\n\nFielding, et al.            Standards Track                     [Page 6]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   19.4.1   MIME-Version ............................................167\n   19.4.2   Conversion to Canonical Form ............................167\n   19.4.3   Conversion of Date Formats ..............................168\n   19.4.4   Introduction of Content-Encoding ........................168\n   19.4.5   No Content-Transfer-Encoding ............................168\n   19.4.6   Introduction of Transfer-Encoding .......................169\n   19.4.7   MHTML and Line Length Limitations .......................169\n   19.5  Additional Features ........................................169\n   19.5.1   Content-Disposition .....................................170\n   19.6  Compatibility with Previous Versions .......................170\n   19.6.1   Changes from HTTP/1.0 ...................................171\n   19.6.2   Compatibility with HTTP/1.0 Persistent Connections ......172\n   19.6.3   Changes from RFC 2068 ...................................172\n   20   Index .......................................................175\n   21   Full Copyright Statement ....................................176\n\n1 Introduction\n\n1.1 Purpose\n\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n   protocol for distributed, collaborative, hypermedia information\n   systems. HTTP has been in use by the World-Wide Web global\n   information initiative since 1990. The first version of HTTP,\n   referred to as HTTP/0.9, was a simple protocol for raw data transfer\n   across the Internet. HTTP/1.0, as defined by RFC 1945 [6], improved\n   the protocol by allowing messages to be in the format of MIME-like\n   messages, containing metainformation about the data transferred and\n   modifiers on the request/response semantics. However, HTTP/1.0 does\n   not sufficiently take into consideration the effects of hierarchical\n   proxies, caching, the need for persistent connections, or virtual\n   hosts. In addition, the proliferation of incompletely-implemented\n   applications calling themselves \"HTTP/1.0\" has necessitated a\n   protocol version change in order for two communicating applications\n   to determine each other's true capabilities.\n\n   This specification defines the protocol referred to as \"HTTP/1.1\".\n   This protocol includes more stringent requirements than HTTP/1.0 in\n   order to ensure reliable implementation of its features.\n\n   Practical information systems require more functionality than simple\n   retrieval, including search, front-end update, and annotation. HTTP\n   allows an open-ended set of methods and headers that indicate the\n   purpose of a request [47]. It builds on the discipline of reference\n   provided by the Uniform Resource Identifier (URI) [3], as a location\n   (URL) [4] or name (URN) [20], for indicating the resource to which a\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 7]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   method is to be applied. Messages are passed in a format similar to\n   that used by Internet mail [9] as defined by the Multipurpose\n   Internet Mail Extensions (MIME) [7].\n\n   HTTP is also used as a generic protocol for communication between\n   user agents and proxies/gateways to other Internet systems, including\n   those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2],\n   and WAIS [10] protocols. In this way, HTTP allows basic hypermedia\n   access to resources available from diverse applications.\n\n1.2 Requirements\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC 2119 [34].\n\n   An implementation is not compliant if it fails to satisfy one or more\n   of the MUST or REQUIRED level requirements for the protocols it\n   implements. An implementation that satisfies all the MUST or REQUIRED\n   level and all the SHOULD level requirements for its protocols is said\n   to be \"unconditionally compliant\"; one that satisfies all the MUST\n   level requirements but not all the SHOULD level requirements for its\n   protocols is said to be \"conditionally compliant.\"\n\n1.3 Terminology\n\n   This specification uses a number of terms to refer to the roles\n   played by participants in, and objects of, the HTTP communication.\n\n   connection\n      A transport layer virtual circuit established between two programs\n      for the purpose of communication.\n\n   message\n      The basic unit of HTTP communication, consisting of a structured\n      sequence of octets matching the syntax defined in section 4 and\n      transmitted via the connection.\n\n   request\n      An HTTP request message, as defined in section 5.\n\n   response\n      An HTTP response message, as defined in section 6.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 8]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   resource\n      A network data object or service that can be identified by a URI,\n      as defined in section 3.2. Resources may be available in multiple\n      representations (e.g. multiple languages, data formats, size, and\n      resolutions) or vary in other ways.\n\n   entity\n      The information transferred as the payload of a request or\n      response. An entity consists of metainformation in the form of\n      entity-header fields and content in the form of an entity-body, as\n      described in section 7.\n\n   representation\n      An entity included with a response that is subject to content\n      negotiation, as described in section 12. There may exist multiple\n      representations associated with a particular response status.\n\n   content negotiation\n      The mechanism for selecting the appropriate representation when\n      servicing a request, as described in section 12. The\n      representation of entities in any response can be negotiated\n      (including error responses).\n\n   variant\n      A resource may have one, or more than one, representation(s)\n      associated with it at any given instant. Each of these\n      representations is termed a `varriant'.  Use of the term `variant'\n      does not necessarily imply that the resource is subject to content\n      negotiation.\n\n   client\n      A program that establishes connections for the purpose of sending\n      requests.\n\n   user agent\n      The client which initiates a request. These are often browsers,\n      editors, spiders (web-traversing robots), or other end user tools.\n\n   server\n      An application program that accepts connections in order to\n      service requests by sending back responses. Any given program may\n      be capable of being both a client and a server; our use of these\n      terms refers only to the role being performed by the program for a\n      particular connection, rather than to the program's capabilities\n      in general. Likewise, any server may act as an origin server,\n      proxy, gateway, or tunnel, switching behavior based on the nature\n      of each request.\n\n\n\n\nFielding, et al.            Standards Track                     [Page 9]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   origin server\n      The server on which a given resource resides or is to be created.\n\n   proxy\n      An intermediary program which acts as both a server and a client\n      for the purpose of making requests on behalf of other clients.\n      Requests are serviced internally or by passing them on, with\n      possible translation, to other servers. A proxy MUST implement\n      both the client and server requirements of this specification. A\n      \"transparent proxy\" is a proxy that does not modify the request or\n      response beyond what is required for proxy authentication and\n      identification. A \"non-transparent proxy\" is a proxy that modifies\n      the request or response in order to provide some added service to\n      the user agent, such as group annotation services, media type\n      transformation, protocol reduction, or anonymity filtering. Except\n      where either transparent or non-transparent behavior is explicitly\n      stated, the HTTP proxy requirements apply to both types of\n      proxies.\n\n   gateway\n      A server which acts as an intermediary for some other server.\n      Unlike a proxy, a gateway receives requests as if it were the\n      origin server for the requested resource; the requesting client\n      may not be aware that it is communicating with a gateway.\n\n   tunnel\n      An intermediary program which is acting as a blind relay between\n      two connections. Once active, a tunnel is not considered a party\n      to the HTTP communication, though the tunnel may have been\n      initiated by an HTTP request. The tunnel ceases to exist when both\n      ends of the relayed connections are closed.\n\n   cache\n      A program's local store of response messages and the subsystem\n      that controls its message storage, retrieval, and deletion. A\n      cache stores cacheable responses in order to reduce the response\n      time and network bandwidth consumption on future, equivalent\n      requests. Any client or server may include a cache, though a cache\n      cannot be used by a server that is acting as a tunnel.\n\n   cacheable\n      A response is cacheable if a cache is allowed to store a copy of\n      the response message for use in answering subsequent requests. The\n      rules for determining the cacheability of HTTP responses are\n      defined in section 13. Even if a resource is cacheable, there may\n      be additional constraints on whether a cache can use the cached\n      copy for a particular request.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 10]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   first-hand\n      A response is first-hand if it comes directly and without\n      unnecessary delay from the origin server, perhaps via one or more\n      proxies. A response is also first-hand if its validity has just\n      been checked directly with the origin server.\n\n   explicit expiration time\n      The time at which the origin server intends that an entity should\n      no longer be returned by a cache without further validation.\n\n   heuristic expiration time\n      An expiration time assigned by a cache when no explicit expiration\n      time is available.\n\n   age\n      The age of a response is the time since it was sent by, or\n      successfully validated with, the origin server.\n\n   freshness lifetime\n      The length of time between the generation of a response and its\n      expiration time.\n\n   fresh\n      A response is fresh if its age has not yet exceeded its freshness\n      lifetime.\n\n   stale\n      A response is stale if its age has passed its freshness lifetime.\n\n   semantically transparent\n      A cache behaves in a \"semantically transparent\" manner, with\n      respect to a particular response, when its use affects neither the\n      requesting client nor the origin server, except to improve\n      performance. When a cache is semantically transparent, the client\n      receives exactly the same response (except for hop-by-hop headers)\n      that it would have received had its request been handled directly\n      by the origin server.\n\n   validator\n      A protocol element (e.g., an entity tag or a Last-Modified time)\n      that is used to find out whether a cache entry is an equivalent\n      copy of an entity.\n\n   upstream/downstream\n      Upstream and downstream describe the flow of a message: all\n      messages flow from upstream to downstream.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 11]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   inbound/outbound\n      Inbound and outbound refer to the request and response paths for\n      messages: \"inbound\" means \"traveling toward the origin server\",\n      and \"outbound\" means \"traveling toward the user agent\"\n\n1.4 Overall Operation\n\n   The HTTP protocol is a request/response protocol. A client sends a\n   request to the server in the form of a request method, URI, and\n   protocol version, followed by a MIME-like message containing request\n   modifiers, client information, and possible body content over a\n   connection with a server. The server responds with a status line,\n   including the message's protocol version and a success or error code,\n   followed by a MIME-like message containing server information, entity\n   metainformation, and possible entity-body content. The relationship\n   between HTTP and MIME is described in appendix 19.4.\n\n   Most HTTP communication is initiated by a user agent and consists of\n   a request to be applied to a resource on some origin server. In the\n   simplest case, this may be accomplished via a single connection (v)\n   between the user agent (UA) and the origin server (O).\n\n          request chain ------------------------>\n       UA -------------------v------------------- O\n          <----------------------- response chain\n\n   A more complicated situation occurs when one or more intermediaries\n   are present in the request/response chain. There are three common\n   forms of intermediary: proxy, gateway, and tunnel. A proxy is a\n   forwarding agent, receiving requests for a URI in its absolute form,\n   rewriting all or part of the message, and forwarding the reformatted\n   request toward the server identified by the URI. A gateway is a\n   receiving agent, acting as a layer above some other server(s) and, if\n   necessary, translating the requests to the underlying server's\n   protocol. A tunnel acts as a relay point between two connections\n   without changing the messages; tunnels are used when the\n   communication needs to pass through an intermediary (such as a\n   firewall) even when the intermediary cannot understand the contents\n   of the messages.\n\n          request chain -------------------------------------->\n       UA -----v----- A -----v----- B -----v----- C -----v----- O\n          <------------------------------------- response chain\n\n   The figure above shows three intermediaries (A, B, and C) between the\n   user agent and origin server. A request or response message that\n   travels the whole chain will pass through four separate connections.\n   This distinction is important because some HTTP communication options\n\n\n\nFielding, et al.            Standards Track                    [Page 12]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   may apply only to the connection with the nearest, non-tunnel\n   neighbor, only to the end-points of the chain, or to all connections\n   along the chain. Although the diagram is linear, each participant may\n   be engaged in multiple, simultaneous communications. For example, B\n   may be receiving requests from many clients other than A, and/or\n   forwarding requests to servers other than C, at the same time that it\n   is handling A's request.\n\n   Any party to the communication which is not acting as a tunnel may\n   employ an internal cache for handling requests. The effect of a cache\n   is that the request/response chain is shortened if one of the\n   participants along the chain has a cached response applicable to that\n   request. The following illustrates the resulting chain if B has a\n   cached copy of an earlier response from O (via C) for a request which\n   has not been cached by UA or A.\n\n          request chain ---------->\n       UA -----v----- A -----v----- B - - - - - - C - - - - - - O\n          <--------- response chain\n\n   Not all responses are usefully cacheable, and some requests may\n   contain modifiers which place special requirements on cache behavior.\n   HTTP requirements for cache behavior and cacheable responses are\n   defined in section 13.\n\n   In fact, there are a wide variety of architectures and configurations\n   of caches and proxies currently being experimented with or deployed\n   across the World Wide Web. These systems include national hierarchies\n   of proxy caches to save transoceanic bandwidth, systems that\n   broadcast or multicast cache entries, organizations that distribute\n   subsets of cached data via CD-ROM, and so on. HTTP systems are used\n   in corporate intranets over high-bandwidth links, and for access via\n   PDAs with low-power radio links and intermittent connectivity. The\n   goal of HTTP/1.1 is to support the wide diversity of configurations\n   already deployed while introducing protocol constructs that meet the\n   needs of those who build web applications that require high\n   reliability and, failing that, at least reliable indications of\n   failure.\n\n   HTTP communication usually takes place over TCP/IP connections. The\n   default port is TCP 80 [19], but other ports can be used. This does\n   not preclude HTTP from being implemented on top of any other protocol\n   on the Internet, or on other networks. HTTP only presumes a reliable\n   transport; any protocol that provides such guarantees can be used;\n   the mapping of the HTTP/1.1 request and response structures onto the\n   transport data units of the protocol in question is outside the scope\n   of this specification.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 13]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   In HTTP/1.0, most implementations used a new connection for each\n   request/response exchange. In HTTP/1.1, a connection may be used for\n   one or more request/response exchanges, although connections may be\n   closed for a variety of reasons (see section 8.1).\n\n2 Notational Conventions and Generic Grammar\n\n2.1 Augmented BNF\n\n   All of the mechanisms specified in this document are described in\n   both prose and an augmented Backus-Naur Form (BNF) similar to that\n   used by RFC 822 [9]. Implementors will need to be familiar with the\n   notation in order to understand this specification. The augmented BNF\n   includes the following constructs:\n\n   name = definition\n      The name of a rule is simply the name itself (without any\n      enclosing \"<\" and \">\") and is separated from its definition by the\n      equal \"=\" character. White space is only significant in that\n      indentation of continuation lines is used to indicate a rule\n      definition that spans more than one line. Certain basic rules are\n      in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle\n      brackets are used within definitions whenever their presence will\n      facilitate discerning the use of rule names.\n\n   \"literal\"\n      Quotation marks surround literal text. Unless stated otherwise,\n      the text is case-insensitive.\n\n   rule1 | rule2\n      Elements separated by a bar (\"|\") are alternatives, e.g., \"yes |\n      no\" will accept yes or no.\n\n   (rule1 rule2)\n      Elements enclosed in parentheses are treated as a single element.\n      Thus, \"(elem (foo | bar) elem)\" allows the token sequences \"elem\n      foo elem\" and \"elem bar elem\".\n\n   *rule\n      The character \"*\" preceding an element indicates repetition. The\n      full form is \"<n>*<m>element\" indicating at least <n> and at most\n      <m> occurrences of element. Default values are 0 and infinity so\n      that \"*(element)\" allows any number, including zero; \"1*element\"\n      requires at least one; and \"1*2element\" allows one or two.\n\n   [rule]\n      Square brackets enclose optional elements; \"[foo bar]\" is\n      equivalent to \"*1(foo bar)\".\n\n\n\nFielding, et al.            Standards Track                    [Page 14]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   N rule\n      Specific repetition: \"<n>(element)\" is equivalent to\n      \"<n>*<n>(element)\"; that is, exactly <n> occurrences of (element).\n      Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three\n      alphabetic characters.\n\n   #rule\n      A construct \"#\" is defined, similar to \"*\", for defining lists of\n      elements. The full form is \"<n>#<m>element\" indicating at least\n      <n> and at most <m> elements, each separated by one or more commas\n      (\",\") and OPTIONAL linear white space (LWS). This makes the usual\n      form of lists very easy; a rule such as\n         ( *LWS element *( *LWS \",\" *LWS element ))\n      can be shown as\n         1#element\n      Wherever this construct is used, null elements are allowed, but do\n      not contribute to the count of elements present. That is,\n      \"(element), , (element) \" is permitted, but counts as only two\n      elements. Therefore, where at least one element is required, at\n      least one non-null element MUST be present. Default values are 0\n      and infinity so that \"#element\" allows any number, including zero;\n      \"1#element\" requires at least one; and \"1#2element\" allows one or\n      two.\n\n   ; comment\n      A semi-colon, set off some distance to the right of rule text,\n      starts a comment that continues to the end of line. This is a\n      simple way of including useful notes in parallel with the\n      specifications.\n\n   implied *LWS\n      The grammar described by this specification is word-based. Except\n      where noted otherwise, linear white space (LWS) can be included\n      between any two adjacent words (token or quoted-string), and\n      between adjacent words and separators, without changing the\n      interpretation of a field. At least one delimiter (LWS and/or\n\n      separators) MUST exist between any two tokens (for the definition\n      of \"token\" below), since they would otherwise be interpreted as a\n      single token.\n\n2.2 Basic Rules\n\n   The following rules are used throughout this specification to\n   describe basic parsing constructs. The US-ASCII coded character set\n   is defined by ANSI X3.4-1986 [21].\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 15]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       OCTET          = <any 8-bit sequence of data>\n       CHAR           = <any US-ASCII character (octets 0 - 127)>\n       UPALPHA        = <any US-ASCII uppercase letter \"A\"..\"Z\">\n       LOALPHA        = <any US-ASCII lowercase letter \"a\"..\"z\">\n       ALPHA          = UPALPHA | LOALPHA\n       DIGIT          = <any US-ASCII digit \"0\"..\"9\">\n       CTL            = <any US-ASCII control character\n                        (octets 0 - 31) and DEL (127)>\n       CR             = <US-ASCII CR, carriage return (13)>\n       LF             = <US-ASCII LF, linefeed (10)>\n       SP             = <US-ASCII SP, space (32)>\n       HT             = <US-ASCII HT, horizontal-tab (9)>\n       <\">            = <US-ASCII double-quote mark (34)>\n\n   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all\n   protocol elements except the entity-body (see appendix 19.3 for\n   tolerant applications). The end-of-line marker within an entity-body\n   is defined by its associated media type, as described in section 3.7.\n\n       CRLF           = CR LF\n\n   HTTP/1.1 header field values can be folded onto multiple lines if the\n   continuation line begins with a space or horizontal tab. All linear\n   white space, including folding, has the same semantics as SP. A\n   recipient MAY replace any linear white space with a single SP before\n   interpreting the field value or forwarding the message downstream.\n\n       LWS            = [CRLF] 1*( SP | HT )\n\n   The TEXT rule is only used for descriptive field contents and values\n   that are not intended to be interpreted by the message parser. Words\n   of *TEXT MAY contain characters from character sets other than ISO-\n   8859-1 [22] only when encoded according to the rules of RFC 2047\n   [14].\n\n       TEXT           = <any OCTET except CTLs,\n                        but including LWS>\n\n   A CRLF is allowed in the definition of TEXT only as part of a header\n   field continuation. It is expected that the folding LWS will be\n   replaced with a single SP before interpretation of the TEXT value.\n\n   Hexadecimal numeric characters are used in several protocol elements.\n\n       HEX            = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n                      | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | DIGIT\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 16]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Many HTTP/1.1 header field values consist of words separated by LWS\n   or special characters. These special characters MUST be in a quoted\n   string to be used within a parameter value (as defined in section\n   3.6).\n\n       token          = 1*<any CHAR except CTLs or separators>\n       separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                      | \"{\" | \"}\" | SP | HT\n\n   Comments can be included in some HTTP header fields by surrounding\n   the comment text with parentheses. Comments are only allowed in\n   fields containing \"comment\" as part of their field value definition.\n   In all other fields, parentheses are considered part of the field\n   value.\n\n       comment        = \"(\" *( ctext | quoted-pair | comment ) \")\"\n       ctext          = <any TEXT excluding \"(\" and \")\">\n\n   A string of text is parsed as a single word if it is quoted using\n   double-quote marks.\n\n       quoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n       qdtext         = <any TEXT except <\">>\n\n   The backslash character (\"\\\") MAY be used as a single-character\n   quoting mechanism only within quoted-string and comment constructs.\n\n       quoted-pair    = \"\\\" CHAR\n\n3 Protocol Parameters\n\n3.1 HTTP Version\n\n   HTTP uses a \"<major>.<minor>\" numbering scheme to indicate versions\n   of the protocol. The protocol versioning policy is intended to allow\n   the sender to indicate the format of a message and its capacity for\n   understanding further HTTP communication, rather than the features\n   obtained via that communication. No change is made to the version\n   number for the addition of message components which do not affect\n   communication behavior or which only add to extensible field values.\n   The <minor> number is incremented when the changes made to the\n   protocol add features which do not change the general message parsing\n   algorithm, but which may add to the message semantics and imply\n   additional capabilities of the sender. The <major> number is\n   incremented when the format of a message within the protocol is\n   changed. See RFC 2145 [36] for a fuller explanation.\n\n\n\nFielding, et al.            Standards Track                    [Page 17]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The version of an HTTP message is indicated by an HTTP-Version field\n   in the first line of the message.\n\n       HTTP-Version   = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n\n   Note that the major and minor numbers MUST be treated as separate\n   integers and that each MAY be incremented higher than a single digit.\n   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is\n   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and\n   MUST NOT be sent.\n\n   An application that sends a request or response message that includes\n   HTTP-Version of \"HTTP/1.1\" MUST be at least conditionally compliant\n   with this specification. Applications that are at least conditionally\n   compliant with this specification SHOULD use an HTTP-Version of\n   \"HTTP/1.1\" in their messages, and MUST do so for any message that is\n   not compatible with HTTP/1.0. For more details on when to send\n   specific HTTP-Version values, see RFC 2145 [36].\n\n   The HTTP version of an application is the highest HTTP version for\n   which the application is at least conditionally compliant.\n\n   Proxy and gateway applications need to be careful when forwarding\n   messages in protocol versions different from that of the application.\n   Since the protocol version indicates the protocol capability of the\n   sender, a proxy/gateway MUST NOT send a message with a version\n   indicator which is greater than its actual version. If a higher\n   version request is received, the proxy/gateway MUST either downgrade\n   the request version, or respond with an error, or switch to tunnel\n   behavior.\n\n   Due to interoperability problems with HTTP/1.0 proxies discovered\n   since the publication of RFC 2068[33], caching proxies MUST, gateways\n   MAY, and tunnels MUST NOT upgrade the request to the highest version\n   they support. The proxy/gateway's response to that request MUST be in\n   the same major version as the request.\n\n      Note: Converting between versions of HTTP may involve modification\n      of header fields required or forbidden by the versions involved.\n\n3.2 Uniform Resource Identifiers\n\n   URIs have been known by many names: WWW addresses, Universal Document\n   Identifiers, Universal Resource Identifiers [3], and finally the\n   combination of Uniform Resource Locators (URL) [4] and Names (URN)\n   [20]. As far as HTTP is concerned, Uniform Resource Identifiers are\n   simply formatted strings which identify--via name, location, or any\n   other characteristic--a resource.\n\n\n\nFielding, et al.            Standards Track                    [Page 18]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.1 General Syntax\n\n   URIs in HTTP can be represented in absolute form or relative to some\n   known base URI [11], depending upon the context of their use. The two\n   forms are differentiated by the fact that absolute URIs always begin\n   with a scheme name followed by a colon. For definitive information on\n   URL syntax and semantics, see \"Uniform Resource Identifiers (URI):\n   Generic Syntax and Semantics,\" RFC 2396 [42] (which replaces RFCs\n   1738 [4] and RFC 1808 [11]). This specification adopts the\n   definitions of \"URI-reference\", \"absoluteURI\", \"relativeURI\", \"port\",\n   \"host\",\"abs_path\", \"rel_path\", and \"authority\" from that\n   specification.\n\n   The HTTP protocol does not place any a priori limit on the length of\n   a URI. Servers MUST be able to handle the URI of any resource they\n   serve, and SHOULD be able to handle URIs of unbounded length if they\n   provide GET-based forms that could generate such URIs. A server\n   SHOULD return 414 (Request-URI Too Long) status if a URI is longer\n   than the server can handle (see section 10.4.15).\n\n      Note: Servers ought to be cautious about depending on URI lengths\n      above 255 bytes, because some older client or proxy\n      implementations might not properly support these lengths.\n\n3.2.2 http URL\n\n   The \"http\" scheme is used to locate network resources via the HTTP\n   protocol. This section defines the scheme-specific syntax and\n   semantics for http URLs.\n\n   http_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query ]]\n\n   If the port is empty or not given, port 80 is assumed. The semantics\n   are that the identified resource is located at the server listening\n   for TCP connections on that port of that host, and the Request-URI\n   for the resource is abs_path (section 5.1.2). The use of IP addresses\n   in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]). If\n   the abs_path is not present in the URL, it MUST be given as \"/\" when\n   used as a Request-URI for a resource (section 5.1.2). If a proxy\n   receives a host name which is not a fully qualified domain name, it\n   MAY add its domain to the host name it received. If a proxy receives\n   a fully qualified domain name, the proxy MUST NOT change the host\n   name.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 19]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.3 URI Comparison\n\n   When comparing two URIs to decide if they match or not, a client\n   SHOULD use a case-sensitive octet-by-octet comparison of the entire\n   URIs, with these exceptions:\n\n      - A port that is empty or not given is equivalent to the default\n        port for that URI-reference;\n\n        - Comparisons of host names MUST be case-insensitive;\n\n        - Comparisons of scheme names MUST be case-insensitive;\n\n        - An empty abs_path is equivalent to an abs_path of \"/\".\n\n   Characters other than those in the \"reserved\" and \"unsafe\" sets (see\n   RFC 2396 [42]) are equivalent to their \"\"%\" HEX HEX\" encoding.\n\n   For example, the following three URIs are equivalent:\n\n      http://abc.com:80/~smith/home.html\n      http://ABC.com/%7Esmith/home.html\n      http://ABC.com:/%7esmith/home.html\n\n3.3 Date/Time Formats\n\n3.3.1 Full Date\n\n   HTTP applications have historically allowed three different formats\n   for the representation of date/time stamps:\n\n      Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n      Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036\n      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format\n\n   The first format is preferred as an Internet standard and represents\n   a fixed-length subset of that defined by RFC 1123 [8] (an update to\n   RFC 822 [9]). The second format is in common use, but is based on the\n   obsolete RFC 850 [12] date format and lacks a four-digit year.\n   HTTP/1.1 clients and servers that parse the date value MUST accept\n   all three formats (for compatibility with HTTP/1.0), though they MUST\n   only generate the RFC 1123 format for representing HTTP-date values\n   in header fields. See section 19.3 for further information.\n\n      Note: Recipients of date values are encouraged to be robust in\n      accepting date values that may have been sent by non-HTTP\n      applications, as is sometimes the case when retrieving or posting\n      messages via proxies/gateways to SMTP or NNTP.\n\n\n\nFielding, et al.            Standards Track                    [Page 20]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   All HTTP date/time stamps MUST be represented in Greenwich Mean Time\n   (GMT), without exception. For the purposes of HTTP, GMT is exactly\n   equal to UTC (Coordinated Universal Time). This is indicated in the\n   first two formats by the inclusion of \"GMT\" as the three-letter\n   abbreviation for time zone, and MUST be assumed when reading the\n   asctime format. HTTP-date is case sensitive and MUST NOT include\n   additional LWS beyond that specifically included as SP in the\n   grammar.\n\n       HTTP-date    = rfc1123-date | rfc850-date | asctime-date\n       rfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\n       rfc850-date  = weekday \",\" SP date2 SP time SP \"GMT\"\n       asctime-date = wkday SP date3 SP time SP 4DIGIT\n       date1        = 2DIGIT SP month SP 4DIGIT\n                      ; day month year (e.g., 02 Jun 1982)\n       date2        = 2DIGIT \"-\" month \"-\" 2DIGIT\n                      ; day-month-year (e.g., 02-Jun-82)\n       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n                      ; month day (e.g., Jun  2)\n       time         = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n                      ; 00:00:00 - 23:59:59\n       wkday        = \"Mon\" | \"Tue\" | \"Wed\"\n                    | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\n       weekday      = \"Monday\" | \"Tuesday\" | \"Wednesday\"\n                    | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\"\n       month        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n                    | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n                    | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n\n      Note: HTTP requirements for the date/time stamp format apply only\n      to their usage within the protocol stream. Clients and servers are\n      not required to use these formats for user presentation, request\n      logging, etc.\n\n3.3.2 Delta Seconds\n\n   Some HTTP header fields allow a time value to be specified as an\n   integer number of seconds, represented in decimal, after the time\n   that the message was received.\n\n       delta-seconds  = 1*DIGIT\n\n3.4 Character Sets\n\n   HTTP uses the same definition of the term \"character set\" as that\n   described for MIME:\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 21]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The term \"character set\" is used in this document to refer to a\n   method used with one or more tables to convert a sequence of octets\n   into a sequence of characters. Note that unconditional conversion in\n   the other direction is not required, in that not all characters may\n   be available in a given character set and a character set may provide\n   more than one sequence of octets to represent a particular character.\n   This definition is intended to allow various kinds of character\n   encoding, from simple single-table mappings such as US-ASCII to\n   complex table switching methods such as those that use ISO-2022's\n   techniques. However, the definition associated with a MIME character\n   set name MUST fully specify the mapping to be performed from octets\n   to characters. In particular, use of external profiling information\n   to determine the exact mapping is not permitted.\n\n      Note: This use of the term \"character set\" is more commonly\n      referred to as a \"character encoding.\" However, since HTTP and\n      MIME share the same registry, it is important that the terminology\n      also be shared.\n\n   HTTP character sets are identified by case-insensitive tokens. The\n   complete set of tokens is defined by the IANA Character Set registry\n   [19].\n\n       charset = token\n\n   Although HTTP allows an arbitrary token to be used as a charset\n   value, any token that has a predefined value within the IANA\n   Character Set registry [19] MUST represent the character set defined\n   by that registry. Applications SHOULD limit their use of character\n   sets to those defined by the IANA registry.\n\n   Implementors should be aware of IETF character set requirements [38]\n   [41].\n\n3.4.1 Missing Charset\n\n   Some HTTP/1.0 software has interpreted a Content-Type header without\n   charset parameter incorrectly to mean \"recipient should guess.\"\n   Senders wishing to defeat this behavior MAY include a charset\n   parameter even when the charset is ISO-8859-1 and SHOULD do so when\n   it is known that it will not confuse the recipient.\n\n   Unfortunately, some older HTTP/1.0 clients did not deal properly with\n   an explicit charset parameter. HTTP/1.1 recipients MUST respect the\n   charset label provided by the sender; and those user agents that have\n   a provision to \"guess\" a charset MUST use the charset from the\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 22]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   content-type field if they support that charset, rather than the\n   recipient's preference, when initially displaying a document. See\n   section 3.7.1.\n\n3.5 Content Codings\n\n   Content coding values indicate an encoding transformation that has\n   been or can be applied to an entity. Content codings are primarily\n   used to allow a document to be compressed or otherwise usefully\n   transformed without losing the identity of its underlying media type\n   and without loss of information. Frequently, the entity is stored in\n   coded form, transmitted directly, and only decoded by the recipient.\n\n       content-coding   = token\n\n   All content-coding values are case-insensitive. HTTP/1.1 uses\n   content-coding values in the Accept-Encoding (section 14.3) and\n   Content-Encoding (section 14.11) header fields. Although the value\n   describes the content-coding, what is more important is that it\n   indicates what decoding mechanism will be required to remove the\n   encoding.\n\n   The Internet Assigned Numbers Authority (IANA) acts as a registry for\n   content-coding value tokens. Initially, the registry contains the\n   following tokens:\n\n   gzip An encoding format produced by the file compression program\n        \"gzip\" (GNU zip) as described in RFC 1952 [25]. This format is a\n        Lempel-Ziv coding (LZ77) with a 32 bit CRC.\n\n   compress\n        The encoding format produced by the common UNIX file compression\n        program \"compress\". This format is an adaptive Lempel-Ziv-Welch\n        coding (LZW).\n\n        Use of program names for the identification of encoding formats\n        is not desirable and is discouraged for future encodings. Their\n        use here is representative of historical practice, not good\n        design. For compatibility with previous implementations of HTTP,\n        applications SHOULD consider \"x-gzip\" and \"x-compress\" to be\n        equivalent to \"gzip\" and \"compress\" respectively.\n\n   deflate\n        The \"zlib\" format defined in RFC 1950 [31] in combination with\n        the \"deflate\" compression mechanism described in RFC 1951 [29].\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 23]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   identity\n        The default (identity) encoding; the use of no transformation\n        whatsoever. This content-coding is used only in the Accept-\n        Encoding header, and SHOULD NOT be used in the Content-Encoding\n        header.\n\n   New content-coding value tokens SHOULD be registered; to allow\n   interoperability between clients and servers, specifications of the\n   content coding algorithms needed to implement a new value SHOULD be\n   publicly available and adequate for independent implementation, and\n   conform to the purpose of content coding defined in this section.\n\n3.6 Transfer Codings\n\n   Transfer-coding values are used to indicate an encoding\n   transformation that has been, can be, or may need to be applied to an\n   entity-body in order to ensure \"safe transport\" through the network.\n   This differs from a content coding in that the transfer-coding is a\n   property of the message, not of the original entity.\n\n       transfer-coding         = \"chunked\" | transfer-extension\n       transfer-extension      = token *( \";\" parameter )\n\n   Parameters are in  the form of attribute/value pairs.\n\n       parameter               = attribute \"=\" value\n       attribute               = token\n       value                   = token | quoted-string\n\n   All transfer-coding values are case-insensitive. HTTP/1.1 uses\n   transfer-coding values in the TE header field (section 14.39) and in\n   the Transfer-Encoding header field (section 14.41).\n\n   Whenever a transfer-coding is applied to a message-body, the set of\n   transfer-codings MUST include \"chunked\", unless the message is\n   terminated by closing the connection. When the \"chunked\" transfer-\n   coding is used, it MUST be the last transfer-coding applied to the\n   message-body. The \"chunked\" transfer-coding MUST NOT be applied more\n   than once to a message-body. These rules allow the recipient to\n   determine the transfer-length of the message (section 4.4).\n\n   Transfer-codings are analogous to the Content-Transfer-Encoding\n   values of MIME [7], which were designed to enable safe transport of\n   binary data over a 7-bit transport service. However, safe transport\n   has a different focus for an 8bit-clean transfer protocol. In HTTP,\n   the only unsafe characteristic of message-bodies is the difficulty in\n   determining the exact body length (section 7.2.2), or the desire to\n   encrypt data over a shared transport.\n\n\n\nFielding, et al.            Standards Track                    [Page 24]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Internet Assigned Numbers Authority (IANA) acts as a registry for\n   transfer-coding value tokens. Initially, the registry contains the\n   following tokens: \"chunked\" (section 3.6.1), \"identity\" (section\n   3.6.2), \"gzip\" (section 3.5), \"compress\" (section 3.5), and \"deflate\"\n   (section 3.5).\n\n   New transfer-coding value tokens SHOULD be registered in the same way\n   as new content-coding value tokens (section 3.5).\n\n   A server which receives an entity-body with a transfer-coding it does\n   not understand SHOULD return 501 (Unimplemented), and close the\n   connection. A server MUST NOT send transfer-codings to an HTTP/1.0\n   client.\n\n3.6.1 Chunked Transfer Coding\n\n   The chunked encoding modifies the body of a message in order to\n   transfer it as a series of chunks, each with its own size indicator,\n   followed by an OPTIONAL trailer containing entity-header fields. This\n   allows dynamically produced content to be transferred along with the\n   information necessary for the recipient to verify that it has\n   received the full message.\n\n       Chunked-Body   = *chunk\n                        last-chunk\n                        trailer\n                        CRLF\n\n       chunk          = chunk-size [ chunk-extension ] CRLF\n                        chunk-data CRLF\n       chunk-size     = 1*HEX\n       last-chunk     = 1*(\"0\") [ chunk-extension ] CRLF\n\n       chunk-extension= *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )\n       chunk-ext-name = token\n       chunk-ext-val  = token | quoted-string\n       chunk-data     = chunk-size(OCTET)\n       trailer        = *(entity-header CRLF)\n\n   The chunk-size field is a string of hex digits indicating the size of\n   the chunk. The chunked encoding is ended by any chunk whose size is\n   zero, followed by the trailer, which is terminated by an empty line.\n\n   The trailer allows the sender to include additional HTTP header\n   fields at the end of the message. The Trailer header field can be\n   used to indicate which header fields are included in a trailer (see\n   section 14.40).\n\n\n\n\nFielding, et al.            Standards Track                    [Page 25]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A server using chunked transfer-coding in a response MUST NOT use the\n   trailer for any header fields unless at least one of the following is\n   true:\n\n   a)the request included a TE header field that indicates \"trailers\" is\n     acceptable in the transfer-coding of the  response, as described in\n     section 14.39; or,\n\n   b)the server is the origin server for the response, the trailer\n     fields consist entirely of optional metadata, and the recipient\n     could use the message (in a manner acceptable to the origin server)\n     without receiving this metadata.  In other words, the origin server\n     is willing to accept the possibility that the trailer fields might\n     be silently discarded along the path to the client.\n\n   This requirement prevents an interoperability failure when the\n   message is being received by an HTTP/1.1 (or later) proxy and\n   forwarded to an HTTP/1.0 recipient. It avoids a situation where\n   compliance with the protocol would have necessitated a possibly\n   infinite buffer on the proxy.\n\n   An example process for decoding a Chunked-Body is presented in\n   appendix 19.4.6.\n\n   All HTTP/1.1 applications MUST be able to receive and decode the\n   \"chunked\" transfer-coding, and MUST ignore chunk-extension extensions\n   they do not understand.\n\n3.7 Media Types\n\n   HTTP uses Internet Media Types [17] in the Content-Type (section\n   14.17) and Accept (section 14.1) header fields in order to provide\n   open and extensible data typing and type negotiation.\n\n       media-type     = type \"/\" subtype *( \";\" parameter )\n       type           = token\n       subtype        = token\n\n   Parameters MAY follow the type/subtype in the form of attribute/value\n   pairs (as defined in section 3.6).\n\n   The type, subtype, and parameter attribute names are case-\n   insensitive. Parameter values might or might not be case-sensitive,\n   depending on the semantics of the parameter name. Linear white space\n   (LWS) MUST NOT be used between the type and subtype, nor between an\n   attribute and its value. The presence or absence of a parameter might\n   be significant to the processing of a media-type, depending on its\n   definition within the media type registry.\n\n\n\nFielding, et al.            Standards Track                    [Page 26]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Note that some older HTTP applications do not recognize media type\n   parameters. When sending data to older HTTP applications,\n   implementations SHOULD only use media type parameters when they are\n   required by that type/subtype definition.\n\n   Media-type values are registered with the Internet Assigned Number\n   Authority (IANA [19]). The media type registration process is\n   outlined in RFC 1590 [17]. Use of non-registered media types is\n   discouraged.\n\n3.7.1 Canonicalization and Text Defaults\n\n   Internet media types are registered with a canonical form. An\n   entity-body transferred via HTTP messages MUST be represented in the\n   appropriate canonical form prior to its transmission except for\n   \"text\" types, as defined in the next paragraph.\n\n   When in canonical form, media subtypes of the \"text\" type use CRLF as\n   the text line break. HTTP relaxes this requirement and allows the\n   transport of text media with plain CR or LF alone representing a line\n   break when it is done consistently for an entire entity-body. HTTP\n   applications MUST accept CRLF, bare CR, and bare LF as being\n   representative of a line break in text media received via HTTP. In\n   addition, if the text is represented in a character set that does not\n   use octets 13 and 10 for CR and LF respectively, as is the case for\n   some multi-byte character sets, HTTP allows the use of whatever octet\n   sequences are defined by that character set to represent the\n   equivalent of CR and LF for line breaks. This flexibility regarding\n   line breaks applies only to text media in the entity-body; a bare CR\n   or LF MUST NOT be substituted for CRLF within any of the HTTP control\n   structures (such as header fields and multipart boundaries).\n\n   If an entity-body is encoded with a content-coding, the underlying\n   data MUST be in a form defined above prior to being encoded.\n\n   The \"charset\" parameter is used with some media types to define the\n   character set (section 3.4) of the data. When no explicit charset\n   parameter is provided by the sender, media subtypes of the \"text\"\n   type are defined to have a default charset value of \"ISO-8859-1\" when\n   received via HTTP. Data in character sets other than \"ISO-8859-1\" or\n   its subsets MUST be labeled with an appropriate charset value. See\n   section 3.4.1 for compatibility problems.\n\n3.7.2 Multipart Types\n\n   MIME provides for a number of \"multipart\" types -- encapsulations of\n   one or more entities within a single message-body. All multipart\n   types share a common syntax, as defined in section 5.1.1 of RFC 2046\n\n\n\nFielding, et al.            Standards Track                    [Page 27]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [40], and MUST include a boundary parameter as part of the media type\n   value. The message body is itself a protocol element and MUST\n   therefore use only CRLF to represent line breaks between body-parts.\n   Unlike in RFC 2046, the epilogue of any multipart message MUST be\n   empty; HTTP applications MUST NOT transmit the epilogue (even if the\n   original multipart contains an epilogue). These restrictions exist in\n   order to preserve the self-delimiting nature of a multipart message-\n   body, wherein the \"end\" of the message-body is indicated by the\n   ending multipart boundary.\n\n   In general, HTTP treats a multipart message-body no differently than\n   any other media type: strictly as payload. The one exception is the\n   \"multipart/byteranges\" type (appendix 19.2) when it appears in a 206\n   (Partial Content) response, which will be interpreted by some HTTP\n   caching mechanisms as described in sections 13.5.4 and 14.16. In all\n   other cases, an HTTP user agent SHOULD follow the same or similar\n   behavior as a MIME user agent would upon receipt of a multipart type.\n   The MIME header fields within each body-part of a multipart message-\n   body do not have any significance to HTTP beyond that defined by\n   their MIME semantics.\n\n   In general, an HTTP user agent SHOULD follow the same or similar\n   behavior as a MIME user agent would upon receipt of a multipart type.\n   If an application receives an unrecognized multipart subtype, the\n   application MUST treat it as being equivalent to \"multipart/mixed\".\n\n      Note: The \"multipart/form-data\" type has been specifically defined\n      for carrying form data suitable for processing via the POST\n      request method, as described in RFC 1867 [15].\n\n3.8 Product Tokens\n\n   Product tokens are used to allow communicating applications to\n   identify themselves by software name and version. Most fields using\n   product tokens also allow sub-products which form a significant part\n   of the application to be listed, separated by white space. By\n   convention, the products are listed in order of their significance\n   for identifying the application.\n\n       product         = token [\"/\" product-version]\n       product-version = token\n\n   Examples:\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n       Server: Apache/0.8.4\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 28]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Product tokens SHOULD be short and to the point. They MUST NOT be\n   used for advertising or other non-essential information. Although any\n   token character MAY appear in a product-version, this token SHOULD\n   only be used for a version identifier (i.e., successive versions of\n   the same product SHOULD only differ in the product-version portion of\n   the product value).\n\n3.9 Quality Values\n\n   HTTP content negotiation (section 12) uses short \"floating point\"\n   numbers to indicate the relative importance (\"weight\") of various\n   negotiable parameters.  A weight is normalized to a real number in\n   the range 0 through 1, where 0 is the minimum and 1 the maximum\n   value. If a parameter has a quality value of 0, then content with\n   this parameter is `not acceptable' for the client. HTTP/1.1\n   applications MUST NOT generate more than three digits after the\n   decimal point. User configuration of these values SHOULD also be\n   limited in this fashion.\n\n       qvalue         = ( \"0\" [ \".\" 0*3DIGIT ] )\n                      | ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n   \"Quality values\" is a misnomer, since these values merely represent\n   relative degradation in desired quality.\n\n3.10 Language Tags\n\n   A language tag identifies a natural language spoken, written, or\n   otherwise conveyed by human beings for communication of information\n   to other human beings. Computer languages are explicitly excluded.\n   HTTP uses language tags within the Accept-Language and Content-\n   Language fields.\n\n   The syntax and registry of HTTP language tags is the same as that\n   defined by RFC 1766 [1]. In summary, a language tag is composed of 1\n   or more parts: A primary language tag and a possibly empty series of\n   subtags:\n\n        language-tag  = primary-tag *( \"-\" subtag )\n        primary-tag   = 1*8ALPHA\n        subtag        = 1*8ALPHA\n\n   White space is not allowed within the tag and all tags are case-\n   insensitive. The name space of language tags is administered by the\n   IANA. Example tags include:\n\n       en, en-US, en-cockney, i-cherokee, x-pig-latin\n\n\n\n\nFielding, et al.            Standards Track                    [Page 29]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   where any two-letter primary-tag is an ISO-639 language abbreviation\n   and any two-letter initial subtag is an ISO-3166 country code. (The\n   last three tags above are not registered tags; all but the last are\n   examples of tags which could be registered in future.)\n\n3.11 Entity Tags\n\n   Entity tags are used for comparing two or more entities from the same\n   requested resource. HTTP/1.1 uses entity tags in the ETag (section\n   14.19), If-Match (section 14.24), If-None-Match (section 14.26), and\n   If-Range (section 14.27) header fields. The definition of how they\n   are used and compared as cache validators is in section 13.3.3. An\n   entity tag consists of an opaque quoted string, possibly prefixed by\n   a weakness indicator.\n\n      entity-tag = [ weak ] opaque-tag\n      weak       = \"W/\"\n      opaque-tag = quoted-string\n\n   A \"strong entity tag\" MAY be shared by two entities of a resource\n   only if they are equivalent by octet equality.\n\n   A \"weak entity tag,\" indicated by the \"W/\" prefix, MAY be shared by\n   two entities of a resource only if the entities are equivalent and\n   could be substituted for each other with no significant change in\n   semantics. A weak entity tag can only be used for weak comparison.\n\n   An entity tag MUST be unique across all versions of all entities\n   associated with a particular resource. A given entity tag value MAY\n   be used for entities obtained by requests on different URIs. The use\n   of the same entity tag value in conjunction with entities obtained by\n   requests on different URIs does not imply the equivalence of those\n   entities.\n\n3.12 Range Units\n\n   HTTP/1.1 allows a client to request that only part (a range of) the\n   response entity be included within the response. HTTP/1.1 uses range\n   units in the Range (section 14.35) and Content-Range (section 14.16)\n   header fields. An entity can be broken down into subranges according\n   to various structural units.\n\n      range-unit       = bytes-unit | other-range-unit\n      bytes-unit       = \"bytes\"\n      other-range-unit = token\n\n   The only range unit defined by HTTP/1.1 is \"bytes\". HTTP/1.1\n   implementations MAY ignore ranges specified using other units.\n\n\n\nFielding, et al.            Standards Track                    [Page 30]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 has been designed to allow implementations of applications\n   that do not depend on knowledge of ranges.\n\n4 HTTP Message\n\n4.1 Message Types\n\n   HTTP messages consist of requests from client to server and responses\n   from server to client.\n\n       HTTP-message   = Request | Response     ; HTTP/1.1 messages\n\n   Request (section 5) and Response (section 6) messages use the generic\n   message format of RFC 822 [9] for transferring entities (the payload\n   of the message). Both types of message consist of a start-line, zero\n   or more header fields (also known as \"headers\"), an empty line (i.e.,\n   a line with nothing preceding the CRLF) indicating the end of the\n   header fields, and possibly a message-body.\n\n        generic-message = start-line\n                          *(message-header CRLF)\n                          CRLF\n                          [ message-body ]\n        start-line      = Request-Line | Status-Line\n\n   In the interest of robustness, servers SHOULD ignore any empty\n   line(s) received where a Request-Line is expected. In other words, if\n   the server is reading the protocol stream at the beginning of a\n   message and receives a CRLF first, it should ignore the CRLF.\n\n   Certain buggy HTTP/1.0 client implementations generate extra CRLF's\n   after a POST request. To restate what is explicitly forbidden by the\n   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an\n   extra CRLF.\n\n4.2 Message Headers\n\n   HTTP header fields, which include general-header (section 4.5),\n   request-header (section 5.3), response-header (section 6.2), and\n   entity-header (section 7.1) fields, follow the same generic format as\n   that given in Section 3.1 of RFC 822 [9]. Each header field consists\n   of a name followed by a colon (\":\") and the field value. Field names\n   are case-insensitive. The field value MAY be preceded by any amount\n   of LWS, though a single SP is preferred. Header fields can be\n   extended over multiple lines by preceding each extra line with at\n   least one SP or HT. Applications ought to follow \"common form\", where\n   one is known or indicated, when generating HTTP constructs, since\n   there might exist some implementations that fail to accept anything\n\n\n\nFielding, et al.            Standards Track                    [Page 31]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   beyond the common forms.\n\n       message-header = field-name \":\" [ field-value ]\n       field-name     = token\n       field-value    = *( field-content | LWS )\n       field-content  = <the OCTETs making up the field-value\n                        and consisting of either *TEXT or combinations\n                        of token, separators, and quoted-string>\n\n   The field-content does not include any leading or trailing LWS:\n   linear white space occurring before the first non-whitespace\n   character of the field-value or after the last non-whitespace\n   character of the field-value. Such leading or trailing LWS MAY be\n   removed without changing the semantics of the field value. Any LWS\n   that occurs between field-content MAY be replaced with a single SP\n   before interpreting the field value or forwarding the message\n   downstream.\n\n   The order in which header fields with differing field names are\n   received is not significant. However, it is \"good practice\" to send\n   general-header fields first, followed by request-header or response-\n   header fields, and ending with the entity-header fields.\n\n   Multiple message-header fields with the same field-name MAY be\n   present in a message if and only if the entire field-value for that\n   header field is defined as a comma-separated list [i.e., #(values)].\n   It MUST be possible to combine the multiple header fields into one\n   \"field-name: field-value\" pair, without changing the semantics of the\n   message, by appending each subsequent field-value to the first, each\n   separated by a comma. The order in which header fields with the same\n   field-name are received is therefore significant to the\n   interpretation of the combined field value, and thus a proxy MUST NOT\n   change the order of these field values when a message is forwarded.\n\n4.3 Message Body\n\n   The message-body (if any) of an HTTP message is used to carry the\n   entity-body associated with the request or response. The message-body\n   differs from the entity-body only when a transfer-coding has been\n   applied, as indicated by the Transfer-Encoding header field (section\n   14.41).\n\n       message-body = entity-body\n                    | <entity-body encoded as per Transfer-Encoding>\n\n   Transfer-Encoding MUST be used to indicate any transfer-codings\n   applied by an application to ensure safe and proper transfer of the\n   message. Transfer-Encoding is a property of the message, not of the\n\n\n\nFielding, et al.            Standards Track                    [Page 32]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   entity, and thus MAY be added or removed by any application along the\n   request/response chain. (However, section 3.6 places restrictions on\n   when certain transfer-codings may be used.)\n\n   The rules for when a message-body is allowed in a message differ for\n   requests and responses.\n\n   The presence of a message-body in a request is signaled by the\n   inclusion of a Content-Length or Transfer-Encoding header field in\n   the request's message-headers. A message-body MUST NOT be included in\n   a request if the specification of the request method (section 5.1.1)\n   does not allow sending an entity-body in requests. A server SHOULD\n   read and forward a message-body on any request; if the request method\n   does not include defined semantics for an entity-body, then the\n   message-body SHOULD be ignored when handling the request.\n\n   For response messages, whether or not a message-body is included with\n   a message is dependent on both the request method and the response\n   status code (section 6.1.1). All responses to the HEAD request method\n   MUST NOT include a message-body, even though the presence of entity-\n   header fields might lead one to believe they do. All 1xx\n   (informational), 204 (no content), and 304 (not modified) responses\n   MUST NOT include a message-body. All other responses do include a\n   message-body, although it MAY be of zero length.\n\n4.4 Message Length\n\n   The transfer-length of a message is the length of the message-body as\n   it appears in the message; that is, after any transfer-codings have\n   been applied. When a message-body is included with a message, the\n   transfer-length of that body is determined by one of the following\n   (in order of precedence):\n\n   1.Any response message which \"MUST NOT\" include a message-body (such\n     as the 1xx, 204, and 304 responses and any response to a HEAD\n     request) is always terminated by the first empty line after the\n     header fields, regardless of the entity-header fields present in\n     the message.\n\n   2.If a Transfer-Encoding header field (section 14.41) is present and\n     has any value other than \"identity\", then the transfer-length is\n     defined by use of the \"chunked\" transfer-coding (section 3.6),\n     unless the message is terminated by closing the connection.\n\n   3.If a Content-Length header field (section 14.13) is present, its\n     decimal value in OCTETs represents both the entity-length and the\n     transfer-length. The Content-Length header field MUST NOT be sent\n     if these two lengths are different (i.e., if a Transfer-Encoding\n\n\n\nFielding, et al.            Standards Track                    [Page 33]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n     header field is present). If a message is received with both a\n     Transfer-Encoding header field and a Content-Length header field,\n     the latter MUST be ignored.\n\n   4.If the message uses the media type \"multipart/byteranges\", and the\n     ransfer-length is not otherwise specified, then this self-\n     elimiting media type defines the transfer-length. This media type\n     UST NOT be used unless the sender knows that the recipient can arse\n     it; the presence in a request of a Range header with ultiple byte-\n     range specifiers from a 1.1 client implies that the lient can parse\n     multipart/byteranges responses.\n\n       A range header might be forwarded by a 1.0 proxy that does not\n       understand multipart/byteranges; in this case the server MUST\n       delimit the message using methods defined in items 1,3 or 5 of\n       this section.\n\n   5.By the server closing the connection. (Closing the connection\n     cannot be used to indicate the end of a request body, since that\n     would leave no possibility for the server to send back a response.)\n\n   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests\n   containing a message-body MUST include a valid Content-Length header\n   field unless the server is known to be HTTP/1.1 compliant. If a\n   request contains a message-body and a Content-Length is not given,\n   the server SHOULD respond with 400 (bad request) if it cannot\n   determine the length of the message, or with 411 (length required) if\n   it wishes to insist on receiving a valid Content-Length.\n\n   All HTTP/1.1 applications that receive entities MUST accept the\n   \"chunked\" transfer-coding (section 3.6), thus allowing this mechanism\n   to be used for messages when the message length cannot be determined\n   in advance.\n\n   Messages MUST NOT include both a Content-Length header field and a\n   non-identity transfer-coding. If the message does include a non-\n   identity transfer-coding, the Content-Length MUST be ignored.\n\n   When a Content-Length is given in a message where a message-body is\n   allowed, its field value MUST exactly match the number of OCTETs in\n   the message-body. HTTP/1.1 user agents MUST notify the user when an\n   invalid length is received and detected.\n\n4.5 General Header Fields\n\n   There are a few header fields which have general applicability for\n   both request and response messages, but which do not apply to the\n   entity being transferred. These header fields apply only to the\n\n\n\nFielding, et al.            Standards Track                    [Page 34]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   message being transmitted.\n\n       general-header = Cache-Control            ; Section 14.9\n                      | Connection               ; Section 14.10\n                      | Date                     ; Section 14.18\n                      | Pragma                   ; Section 14.32\n                      | Trailer                  ; Section 14.40\n                      | Transfer-Encoding        ; Section 14.41\n                      | Upgrade                  ; Section 14.42\n                      | Via                      ; Section 14.45\n                      | Warning                  ; Section 14.46\n\n   General-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields may be given the semantics of general\n   header fields if all parties in the communication recognize them to\n   be general-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n5 Request\n\n   A request message from a client to a server includes, within the\n   first line of that message, the method to be applied to the resource,\n   the identifier of the resource, and the protocol version in use.\n\n        Request       = Request-Line              ; Section 5.1\n                        *(( general-header        ; Section 4.5\n                         | request-header         ; Section 5.3\n                         | entity-header ) CRLF)  ; Section 7.1\n                        CRLF\n                        [ message-body ]          ; Section 4.3\n\n5.1 Request-Line\n\n   The Request-Line begins with a method token, followed by the\n   Request-URI and the protocol version, and ending with CRLF. The\n   elements are separated by SP characters. No CR or LF is allowed\n   except in the final CRLF sequence.\n\n        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 35]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n5.1.1 Method\n\n   The Method  token indicates the method to be performed on the\n   resource identified by the Request-URI. The method is case-sensitive.\n\n       Method         = \"OPTIONS\"                ; Section 9.2\n                      | \"GET\"                    ; Section 9.3\n                      | \"HEAD\"                   ; Section 9.4\n                      | \"POST\"                   ; Section 9.5\n                      | \"PUT\"                    ; Section 9.6\n                      | \"DELETE\"                 ; Section 9.7\n                      | \"TRACE\"                  ; Section 9.8\n                      | \"CONNECT\"                ; Section 9.9\n                      | extension-method\n       extension-method = token\n\n   The list of methods allowed by a resource can be specified in an\n   Allow header field (section 14.7). The return code of the response\n   always notifies the client whether a method is currently allowed on a\n   resource, since the set of allowed methods can change dynamically. An\n   origin server SHOULD return the status code 405 (Method Not Allowed)\n   if the method is known by the origin server but not allowed for the\n   requested resource, and 501 (Not Implemented) if the method is\n   unrecognized or not implemented by the origin server. The methods GET\n   and HEAD MUST be supported by all general-purpose servers. All other\n   methods are OPTIONAL; however, if the above methods are implemented,\n   they MUST be implemented with the same semantics as those specified\n   in section 9.\n\n5.1.2 Request-URI\n\n   The Request-URI is a Uniform Resource Identifier (section 3.2) and\n   identifies the resource upon which to apply the request.\n\n       Request-URI    = \"*\" | absoluteURI | abs_path | authority\n\n   The four options for Request-URI are dependent on the nature of the\n   request. The asterisk \"*\" means that the request does not apply to a\n   particular resource, but to the server itself, and is only allowed\n   when the method used does not necessarily apply to a resource. One\n   example would be\n\n       OPTIONS * HTTP/1.1\n\n   The absoluteURI form is REQUIRED when the request is being made to a\n   proxy. The proxy is requested to forward the request or service it\n   from a valid cache, and return the response. Note that the proxy MAY\n   forward the request on to another proxy or directly to the server\n\n\n\nFielding, et al.            Standards Track                    [Page 36]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   specified by the absoluteURI. In order to avoid request loops, a\n   proxy MUST be able to recognize all of its server names, including\n   any aliases, local variations, and the numeric IP address. An example\n   Request-Line would be:\n\n       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1\n\n   To allow for transition to absoluteURIs in all requests in future\n   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI\n   form in requests, even though HTTP/1.1 clients will only generate\n   them in requests to proxies.\n\n   The authority form is only used by the CONNECT method (section 9.9).\n\n   The most common form of Request-URI is that used to identify a\n   resource on an origin server or gateway. In this case the absolute\n   path of the URI MUST be transmitted (see section 3.2.1, abs_path) as\n   the Request-URI, and the network location of the URI (authority) MUST\n   be transmitted in a Host header field. For example, a client wishing\n   to retrieve the resource above directly from the origin server would\n   create a TCP connection to port 80 of the host \"www.w3.org\" and send\n   the lines:\n\n       GET /pub/WWW/TheProject.html HTTP/1.1\n       Host: www.w3.org\n\n   followed by the remainder of the Request. Note that the absolute path\n   cannot be empty; if none is present in the original URI, it MUST be\n   given as \"/\" (the server root).\n\n   The Request-URI is transmitted in the format specified in section\n   3.2.1. If the Request-URI is encoded using the \"% HEX HEX\" encoding\n   [42], the origin server MUST decode the Request-URI in order to\n   properly interpret the request. Servers SHOULD respond to invalid\n   Request-URIs with an appropriate status code.\n\n   A transparent proxy MUST NOT rewrite the \"abs_path\" part of the\n   received Request-URI when forwarding it to the next inbound server,\n   except as noted above to replace a null abs_path with \"/\".\n\n      Note: The \"no rewrite\" rule prevents the proxy from changing the\n      meaning of the request when the origin server is improperly using\n      a non-reserved URI character for a reserved purpose.  Implementors\n      should be aware that some pre-HTTP/1.1 proxies have been known to\n      rewrite the Request-URI.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 37]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n5.2 The Resource Identified by a Request\n\n   The exact resource identified by an Internet request is determined by\n   examining both the Request-URI and the Host header field.\n\n   An origin server that does not allow resources to differ by the\n   requested host MAY ignore the Host header field value when\n   determining the resource identified by an HTTP/1.1 request. (But see\n   section 19.6.1.1 for other requirements on Host support in HTTP/1.1.)\n\n   An origin server that does differentiate resources based on the host\n   requested (sometimes referred to as virtual hosts or vanity host\n   names) MUST use the following rules for determining the requested\n   resource on an HTTP/1.1 request:\n\n   1. If Request-URI is an absoluteURI, the host is part of the\n     Request-URI. Any Host header field value in the request MUST be\n     ignored.\n\n   2. If the Request-URI is not an absoluteURI, and the request includes\n     a Host header field, the host is determined by the Host header\n     field value.\n\n   3. If the host as determined by rule 1 or 2 is not a valid host on\n     the server, the response MUST be a 400 (Bad Request) error message.\n\n   Recipients of an HTTP/1.0 request that lacks a Host header field MAY\n   attempt to use heuristics (e.g., examination of the URI path for\n   something unique to a particular host) in order to determine what\n   exact resource is being requested.\n\n5.3 Request Header Fields\n\n   The request-header fields allow the client to pass additional\n   information about the request, and about the client itself, to the\n   server. These fields act as request modifiers, with semantics\n   equivalent to the parameters on a programming language method\n   invocation.\n\n       request-header = Accept                   ; Section 14.1\n                      | Accept-Charset           ; Section 14.2\n                      | Accept-Encoding          ; Section 14.3\n                      | Accept-Language          ; Section 14.4\n                      | Authorization            ; Section 14.8\n                      | Expect                   ; Section 14.20\n                      | From                     ; Section 14.22\n                      | Host                     ; Section 14.23\n                      | If-Match                 ; Section 14.24\n\n\n\nFielding, et al.            Standards Track                    [Page 38]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                      | If-Modified-Since        ; Section 14.25\n                      | If-None-Match            ; Section 14.26\n                      | If-Range                 ; Section 14.27\n                      | If-Unmodified-Since      ; Section 14.28\n                      | Max-Forwards             ; Section 14.31\n                      | Proxy-Authorization      ; Section 14.34\n                      | Range                    ; Section 14.35\n                      | Referer                  ; Section 14.36\n                      | TE                       ; Section 14.39\n                      | User-Agent               ; Section 14.43\n\n   Request-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields MAY be given the semantics of request-\n   header fields if all parties in the communication recognize them to\n   be request-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n6 Response\n\n   After receiving and interpreting a request message, a server responds\n   with an HTTP response message.\n\n       Response      = Status-Line               ; Section 6.1\n                       *(( general-header        ; Section 4.5\n                        | response-header        ; Section 6.2\n                        | entity-header ) CRLF)  ; Section 7.1\n                       CRLF\n                       [ message-body ]          ; Section 7.2\n\n6.1 Status-Line\n\n   The first line of a Response message is the Status-Line, consisting\n   of the protocol version followed by a numeric status code and its\n   associated textual phrase, with each element separated by SP\n   characters. No CR or LF is allowed except in the final CRLF sequence.\n\n       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n\n6.1.1 Status Code and Reason Phrase\n\n   The Status-Code element is a 3-digit integer result code of the\n   attempt to understand and satisfy the request. These codes are fully\n   defined in section 10. The Reason-Phrase is intended to give a short\n   textual description of the Status-Code. The Status-Code is intended\n   for use by automata and the Reason-Phrase is intended for the human\n   user. The client is not required to examine or display the Reason-\n   Phrase.\n\n\n\nFielding, et al.            Standards Track                    [Page 39]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The first digit of the Status-Code defines the class of response. The\n   last two digits do not have any categorization role. There are 5\n   values for the first digit:\n\n      - 1xx: Informational - Request received, continuing process\n\n      - 2xx: Success - The action was successfully received,\n        understood, and accepted\n\n      - 3xx: Redirection - Further action must be taken in order to\n        complete the request\n\n      - 4xx: Client Error - The request contains bad syntax or cannot\n        be fulfilled\n\n      - 5xx: Server Error - The server failed to fulfill an apparently\n        valid request\n\n   The individual values of the numeric status codes defined for\n   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are\n   presented below. The reason phrases listed here are only\n   recommendations -- they MAY be replaced by local equivalents without\n   affecting the protocol.\n\n      Status-Code    =\n            \"100\"  ; Section 10.1.1: Continue\n          | \"101\"  ; Section 10.1.2: Switching Protocols\n          | \"200\"  ; Section 10.2.1: OK\n          | \"201\"  ; Section 10.2.2: Created\n          | \"202\"  ; Section 10.2.3: Accepted\n          | \"203\"  ; Section 10.2.4: Non-Authoritative Information\n          | \"204\"  ; Section 10.2.5: No Content\n          | \"205\"  ; Section 10.2.6: Reset Content\n          | \"206\"  ; Section 10.2.7: Partial Content\n          | \"300\"  ; Section 10.3.1: Multiple Choices\n          | \"301\"  ; Section 10.3.2: Moved Permanently\n          | \"302\"  ; Section 10.3.3: Found\n          | \"303\"  ; Section 10.3.4: See Other\n          | \"304\"  ; Section 10.3.5: Not Modified\n          | \"305\"  ; Section 10.3.6: Use Proxy\n          | \"307\"  ; Section 10.3.8: Temporary Redirect\n          | \"400\"  ; Section 10.4.1: Bad Request\n          | \"401\"  ; Section 10.4.2: Unauthorized\n          | \"402\"  ; Section 10.4.3: Payment Required\n          | \"403\"  ; Section 10.4.4: Forbidden\n          | \"404\"  ; Section 10.4.5: Not Found\n          | \"405\"  ; Section 10.4.6: Method Not Allowed\n          | \"406\"  ; Section 10.4.7: Not Acceptable\n\n\n\nFielding, et al.            Standards Track                    [Page 40]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n          | \"407\"  ; Section 10.4.8: Proxy Authentication Required\n          | \"408\"  ; Section 10.4.9: Request Time-out\n          | \"409\"  ; Section 10.4.10: Conflict\n          | \"410\"  ; Section 10.4.11: Gone\n          | \"411\"  ; Section 10.4.12: Length Required\n          | \"412\"  ; Section 10.4.13: Precondition Failed\n          | \"413\"  ; Section 10.4.14: Request Entity Too Large\n          | \"414\"  ; Section 10.4.15: Request-URI Too Large\n          | \"415\"  ; Section 10.4.16: Unsupported Media Type\n          | \"416\"  ; Section 10.4.17: Requested range not satisfiable\n          | \"417\"  ; Section 10.4.18: Expectation Failed\n          | \"500\"  ; Section 10.5.1: Internal Server Error\n          | \"501\"  ; Section 10.5.2: Not Implemented\n          | \"502\"  ; Section 10.5.3: Bad Gateway\n          | \"503\"  ; Section 10.5.4: Service Unavailable\n          | \"504\"  ; Section 10.5.5: Gateway Time-out\n          | \"505\"  ; Section 10.5.6: HTTP Version not supported\n          | extension-code\n\n      extension-code = 3DIGIT\n      Reason-Phrase  = *<TEXT, excluding CR, LF>\n\n   HTTP status codes are extensible. HTTP applications are not required\n   to understand the meaning of all registered status codes, though such\n   understanding is obviously desirable. However, applications MUST\n   understand the class of any status code, as indicated by the first\n   digit, and treat any unrecognized response as being equivalent to the\n   x00 status code of that class, with the exception that an\n   unrecognized response MUST NOT be cached. For example, if an\n   unrecognized status code of 431 is received by the client, it can\n   safely assume that there was something wrong with its request and\n   treat the response as if it had received a 400 status code. In such\n   cases, user agents SHOULD present to the user the entity returned\n   with the response, since that entity is likely to include human-\n   readable information which will explain the unusual status.\n\n6.2 Response Header Fields\n\n   The response-header fields allow the server to pass additional\n   information about the response which cannot be placed in the Status-\n   Line. These header fields give information about the server and about\n   further access to the resource identified by the Request-URI.\n\n       response-header = Accept-Ranges           ; Section 14.5\n                       | Age                     ; Section 14.6\n                       | ETag                    ; Section 14.19\n                       | Location                ; Section 14.30\n                       | Proxy-Authenticate      ; Section 14.33\n\n\n\nFielding, et al.            Standards Track                    [Page 41]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                       | Retry-After             ; Section 14.37\n                       | Server                  ; Section 14.38\n                       | Vary                    ; Section 14.44\n                       | WWW-Authenticate        ; Section 14.47\n\n   Response-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields MAY be given the semantics of response-\n   header fields if all parties in the communication recognize them to\n   be response-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n7 Entity\n\n   Request and Response messages MAY transfer an entity if not otherwise\n   restricted by the request method or response status code. An entity\n   consists of entity-header fields and an entity-body, although some\n   responses will only include the entity-headers.\n\n   In this section, both sender and recipient refer to either the client\n   or the server, depending on who sends and who receives the entity.\n\n7.1 Entity Header Fields\n\n   Entity-header fields define metainformation about the entity-body or,\n   if no body is present, about the resource identified by the request.\n   Some of this metainformation is OPTIONAL; some might be REQUIRED by\n   portions of this specification.\n\n       entity-header  = Allow                    ; Section 14.7\n                      | Content-Encoding         ; Section 14.11\n                      | Content-Language         ; Section 14.12\n                      | Content-Length           ; Section 14.13\n                      | Content-Location         ; Section 14.14\n                      | Content-MD5              ; Section 14.15\n                      | Content-Range            ; Section 14.16\n                      | Content-Type             ; Section 14.17\n                      | Expires                  ; Section 14.21\n                      | Last-Modified            ; Section 14.29\n                      | extension-header\n\n       extension-header = message-header\n\n   The extension-header mechanism allows additional entity-header fields\n   to be defined without changing the protocol, but these fields cannot\n   be assumed to be recognizable by the recipient. Unrecognized header\n   fields SHOULD be ignored by the recipient and MUST be forwarded by\n   transparent proxies.\n\n\n\nFielding, et al.            Standards Track                    [Page 42]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n7.2 Entity Body\n\n   The entity-body (if any) sent with an HTTP request or response is in\n   a format and encoding defined by the entity-header fields.\n\n       entity-body    = *OCTET\n\n   An entity-body is only present in a message when a message-body is\n   present, as described in section 4.3. The entity-body is obtained\n   from the message-body by decoding any Transfer-Encoding that might\n   have been applied to ensure safe and proper transfer of the message.\n\n7.2.1 Type\n\n   When an entity-body is included with a message, the data type of that\n   body is determined via the header fields Content-Type and Content-\n   Encoding. These define a two-layer, ordered encoding model:\n\n       entity-body := Content-Encoding( Content-Type( data ) )\n\n   Content-Type specifies the media type of the underlying data.\n   Content-Encoding may be used to indicate any additional content\n   codings applied to the data, usually for the purpose of data\n   compression, that are a property of the requested resource. There is\n   no default encoding.\n\n   Any HTTP/1.1 message containing an entity-body SHOULD include a\n   Content-Type header field defining the media type of that body. If\n   and only if the media type is not given by a Content-Type field, the\n   recipient MAY attempt to guess the media type via inspection of its\n   content and/or the name extension(s) of the URI used to identify the\n   resource. If the media type remains unknown, the recipient SHOULD\n   treat it as type \"application/octet-stream\".\n\n7.2.2 Entity Length\n\n   The entity-length of a message is the length of the message-body\n   before any transfer-codings have been applied. Section 4.4 defines\n   how the transfer-length of a message-body is determined.\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 43]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8 Connections\n\n8.1 Persistent Connections\n\n8.1.1 Purpose\n\n   Prior to persistent connections, a separate TCP connection was\n   established to fetch each URL, increasing the load on HTTP servers\n   and causing congestion on the Internet. The use of inline images and\n   other associated data often require a client to make multiple\n   requests of the same server in a short amount of time. Analysis of\n   these performance problems and results from a prototype\n   implementation are available [26] [30]. Implementation experience and\n   measurements of actual HTTP/1.1 (RFC 2068) implementations show good\n   results [39]. Alternatives have also been explored, for example,\n   T/TCP [27].\n\n   Persistent HTTP connections have a number of advantages:\n\n      - By opening and closing fewer TCP connections, CPU time is saved\n        in routers and hosts (clients, servers, proxies, gateways,\n        tunnels, or caches), and memory used for TCP protocol control\n        blocks can be saved in hosts.\n\n      - HTTP requests and responses can be pipelined on a connection.\n        Pipelining allows a client to make multiple requests without\n        waiting for each response, allowing a single TCP connection to\n        be used much more efficiently, with much lower elapsed time.\n\n      - Network congestion is reduced by reducing the number of packets\n        caused by TCP opens, and by allowing TCP sufficient time to\n        determine the congestion state of the network.\n\n      - Latency on subsequent requests is reduced since there is no time\n        spent in TCP's connection opening handshake.\n\n      - HTTP can evolve more gracefully, since errors can be reported\n        without the penalty of closing the TCP connection. Clients using\n        future versions of HTTP might optimistically try a new feature,\n        but if communicating with an older server, retry with old\n        semantics after an error is reported.\n\n   HTTP implementations SHOULD implement persistent connections.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 44]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.1.2 Overall Operation\n\n   A significant difference between HTTP/1.1 and earlier versions of\n   HTTP is that persistent connections are the default behavior of any\n   HTTP connection. That is, unless otherwise indicated, the client\n   SHOULD assume that the server will maintain a persistent connection,\n   even after error responses from the server.\n\n   Persistent connections provide a mechanism by which a client and a\n   server can signal the close of a TCP connection. This signaling takes\n   place using the Connection header field (section 14.10). Once a close\n   has been signaled, the client MUST NOT send any more requests on that\n   connection.\n\n8.1.2.1 Negotiation\n\n   An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to\n   maintain a persistent connection unless a Connection header including\n   the connection-token \"close\" was sent in the request. If the server\n   chooses to close the connection immediately after sending the\n   response, it SHOULD send a Connection header including the\n   connection-token close.\n\n   An HTTP/1.1 client MAY expect a connection to remain open, but would\n   decide to keep it open based on whether the response from a server\n   contains a Connection header with the connection-token close. In case\n   the client does not want to maintain a connection for more than that\n   request, it SHOULD send a Connection header including the\n   connection-token close.\n\n   If either the client or the server sends the close token in the\n   Connection header, that request becomes the last one for the\n   connection.\n\n   Clients and servers SHOULD NOT assume that a persistent connection is\n   maintained for HTTP versions less than 1.1 unless it is explicitly\n   signaled. See section 19.6.2 for more information on backward\n   compatibility with HTTP/1.0 clients.\n\n   In order to remain persistent, all messages on the connection MUST\n   have a self-defined message length (i.e., one not defined by closure\n   of the connection), as described in section 4.4.\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 45]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.1.2.2 Pipelining\n\n   A client that supports persistent connections MAY \"pipeline\" its\n   requests (i.e., send multiple requests without waiting for each\n   response). A server MUST send its responses to those requests in the\n   same order that the requests were received.\n\n   Clients which assume persistent connections and pipeline immediately\n   after connection establishment SHOULD be prepared to retry their\n   connection if the first pipelined attempt fails. If a client does\n   such a retry, it MUST NOT pipeline before it knows the connection is\n   persistent. Clients MUST also be prepared to resend their requests if\n   the server closes the connection before sending all of the\n   corresponding responses.\n\n   Clients SHOULD NOT pipeline requests using non-idempotent methods or\n   non-idempotent sequences of methods (see section 9.1.2). Otherwise, a\n   premature termination of the transport connection could lead to\n   indeterminate results. A client wishing to send a non-idempotent\n   request SHOULD wait to send that request until it has received the\n   response status for the previous request.\n\n8.1.3 Proxy Servers\n\n   It is especially important that proxies correctly implement the\n   properties of the Connection header field as specified in section\n   14.10.\n\n   The proxy server MUST signal persistent connections separately with\n   its clients and the origin servers (or other proxy servers) that it\n   connects to. Each persistent connection applies to only one transport\n   link.\n\n   A proxy server MUST NOT establish a HTTP/1.1 persistent connection\n   with an HTTP/1.0 client (but see RFC 2068 [33] for information and\n   discussion of the problems with the Keep-Alive header implemented by\n   many HTTP/1.0 clients).\n\n8.1.4 Practical Considerations\n\n   Servers will usually have some time-out value beyond which they will\n   no longer maintain an inactive connection. Proxy servers might make\n   this a higher value since it is likely that the client will be making\n   more connections through the same server. The use of persistent\n   connections places no requirements on the length (or existence) of\n   this time-out for either the client or the server.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 46]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   When a client or server wishes to time-out it SHOULD issue a graceful\n   close on the transport connection. Clients and servers SHOULD both\n   constantly watch for the other side of the transport close, and\n   respond to it as appropriate. If a client or server does not detect\n   the other side's close promptly it could cause unnecessary resource\n   drain on the network.\n\n   A client, server, or proxy MAY close the transport connection at any\n   time. For example, a client might have started to send a new request\n   at the same time that the server has decided to close the \"idle\"\n   connection. From the server's point of view, the connection is being\n   closed while it was idle, but from the client's point of view, a\n   request is in progress.\n\n   This means that clients, servers, and proxies MUST be able to recover\n   from asynchronous close events. Client software SHOULD reopen the\n   transport connection and retransmit the aborted sequence of requests\n   without user interaction so long as the request sequence is\n   idempotent (see section 9.1.2). Non-idempotent methods or sequences\n   MUST NOT be automatically retried, although user agents MAY offer a\n   human operator the choice of retrying the request(s). Confirmation by\n   user-agent software with semantic understanding of the application\n   MAY substitute for user confirmation. The automatic retry SHOULD NOT\n   be repeated if the second sequence of requests fails.\n\n   Servers SHOULD always respond to at least one request per connection,\n   if at all possible. Servers SHOULD NOT close a connection in the\n   middle of transmitting a response, unless a network or client failure\n   is suspected.\n\n   Clients that use persistent connections SHOULD limit the number of\n   simultaneous connections that they maintain to a given server. A\n   single-user client SHOULD NOT maintain more than 2 connections with\n   any server or proxy. A proxy SHOULD use up to 2*N connections to\n   another server or proxy, where N is the number of simultaneously\n   active users. These guidelines are intended to improve HTTP response\n   times and avoid congestion.\n\n8.2 Message Transmission Requirements\n\n8.2.1 Persistent Connections and Flow Control\n\n   HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's\n   flow control mechanisms to resolve temporary overloads, rather than\n   terminating connections with the expectation that clients will retry.\n   The latter technique can exacerbate network congestion.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 47]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.2.2 Monitoring Connections for Error Status Messages\n\n   An HTTP/1.1 (or later) client sending a message-body SHOULD monitor\n   the network connection for an error status while it is transmitting\n   the request. If the client sees an error status, it SHOULD\n   immediately cease transmitting the body. If the body is being sent\n   using a \"chunked\" encoding (section 3.6), a zero length chunk and\n   empty trailer MAY be used to prematurely mark the end of the message.\n   If the body was preceded by a Content-Length header, the client MUST\n   close the connection.\n\n8.2.3 Use of the 100 (Continue) Status\n\n   The purpose of the 100 (Continue) status (see section 10.1.1) is to\n   allow a client that is sending a request message with a request body\n   to determine if the origin server is willing to accept the request\n   (based on the request headers) before the client sends the request\n   body. In some cases, it might either be inappropriate or highly\n   inefficient for the client to send the body if the server will reject\n   the message without looking at the body.\n\n   Requirements for HTTP/1.1 clients:\n\n      - If a client will wait for a 100 (Continue) response before\n        sending the request body, it MUST send an Expect request-header\n        field (section 14.20) with the \"100-continue\" expectation.\n\n      - A client MUST NOT send an Expect request-header field (section\n        14.20) with the \"100-continue\" expectation if it does not intend\n        to send a request body.\n\n   Because of the presence of older implementations, the protocol allows\n   ambiguous situations in which a client may send \"Expect: 100-\n   continue\" without receiving either a 417 (Expectation Failed) status\n   or a 100 (Continue) status. Therefore, when a client sends this\n   header field to an origin server (possibly via a proxy) from which it\n   has never seen a 100 (Continue) status, the client SHOULD NOT wait\n   for an indefinite period before sending the request body.\n\n   Requirements for HTTP/1.1 origin servers:\n\n      - Upon receiving a request which includes an Expect request-header\n        field with the \"100-continue\" expectation, an origin server MUST\n        either respond with 100 (Continue) status and continue to read\n        from the input stream, or respond with a final status code. The\n        origin server MUST NOT wait for the request body before sending\n        the 100 (Continue) response. If it responds with a final status\n        code, it MAY close the transport connection or it MAY continue\n\n\n\nFielding, et al.            Standards Track                    [Page 48]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n        to read and discard the rest of the request.  It MUST NOT\n        perform the requested method if it returns a final status code.\n\n      - An origin server SHOULD NOT send a 100 (Continue) response if\n        the request message does not include an Expect request-header\n        field with the \"100-continue\" expectation, and MUST NOT send a\n        100 (Continue) response if such a request comes from an HTTP/1.0\n        (or earlier) client. There is an exception to this rule: for\n        compatibility with RFC 2068, a server MAY send a 100 (Continue)\n        status in response to an HTTP/1.1 PUT or POST request that does\n        not include an Expect request-header field with the \"100-\n        continue\" expectation. This exception, the purpose of which is\n        to minimize any client processing delays associated with an\n        undeclared wait for 100 (Continue) status, applies only to\n        HTTP/1.1 requests, and not to requests with any other HTTP-\n        version value.\n\n      - An origin server MAY omit a 100 (Continue) response if it has\n        already received some or all of the request body for the\n        corresponding request.\n\n      - An origin server that sends a 100 (Continue) response MUST\n        ultimately send a final status code, once the request body is\n        received and processed, unless it terminates the transport\n        connection prematurely.\n\n      - If an origin server receives a request that does not include an\n        Expect request-header field with the \"100-continue\" expectation,\n        the request includes a request body, and the server responds\n        with a final status code before reading the entire request body\n        from the transport connection, then the server SHOULD NOT close\n        the transport connection until it has read the entire request,\n        or until the client closes the connection. Otherwise, the client\n        might not reliably receive the response message. However, this\n        requirement is not be construed as preventing a server from\n        defending itself against denial-of-service attacks, or from\n        badly broken client implementations.\n\n   Requirements for HTTP/1.1 proxies:\n\n      - If a proxy receives a request that includes an Expect request-\n        header field with the \"100-continue\" expectation, and the proxy\n        either knows that the next-hop server complies with HTTP/1.1 or\n        higher, or does not know the HTTP version of the next-hop\n        server, it MUST forward the request, including the Expect header\n        field.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 49]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If the proxy knows that the version of the next-hop server is\n        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST\n        respond with a 417 (Expectation Failed) status.\n\n      - Proxies SHOULD maintain a cache recording the HTTP version\n        numbers received from recently-referenced next-hop servers.\n\n      - A proxy MUST NOT forward a 100 (Continue) response if the\n        request message was received from an HTTP/1.0 (or earlier)\n        client and did not include an Expect request-header field with\n        the \"100-continue\" expectation. This requirement overrides the\n        general rule for forwarding of 1xx responses (see section 10.1).\n\n8.2.4 Client Behavior if Server Prematurely Closes Connection\n\n   If an HTTP/1.1 client sends a request which includes a request body,\n   but which does not include an Expect request-header field with the\n   \"100-continue\" expectation, and if the client is not directly\n   connected to an HTTP/1.1 origin server, and if the client sees the\n   connection close before receiving any status from the server, the\n   client SHOULD retry the request.  If the client does retry this\n   request, it MAY use the following \"binary exponential backoff\"\n   algorithm to be assured of obtaining a reliable response:\n\n      1. Initiate a new connection to the server\n\n      2. Transmit the request-headers\n\n      3. Initialize a variable R to the estimated round-trip time to the\n         server (e.g., based on the time it took to establish the\n         connection), or to a constant value of 5 seconds if the round-\n         trip time is not available.\n\n      4. Compute T = R * (2**N), where N is the number of previous\n         retries of this request.\n\n      5. Wait either for an error response from the server, or for T\n         seconds (whichever comes first)\n\n      6. If no error response is received, after T seconds transmit the\n         body of the request.\n\n      7. If client sees that the connection is closed prematurely,\n         repeat from step 1 until the request is accepted, an error\n         response is received, or the user becomes impatient and\n         terminates the retry process.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 50]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If at any point an error status is received, the client\n\n      - SHOULD NOT continue and\n\n      - SHOULD close the connection if it has not completed sending the\n        request message.\n\n9 Method Definitions\n\n   The set of common methods for HTTP/1.1 is defined below. Although\n   this set can be expanded, additional methods cannot be assumed to\n   share the same semantics for separately extended clients and servers.\n\n   The Host request-header field (section 14.23) MUST accompany all\n   HTTP/1.1 requests.\n\n9.1 Safe and Idempotent Methods\n\n9.1.1 Safe Methods\n\n   Implementors should be aware that the software represents the user in\n   their interactions over the Internet, and should be careful to allow\n   the user to be aware of any actions they might take which may have an\n   unexpected significance to themselves or others.\n\n   In particular, the convention has been established that the GET and\n   HEAD methods SHOULD NOT have the significance of taking an action\n   other than retrieval. These methods ought to be considered \"safe\".\n   This allows user agents to represent other methods, such as POST, PUT\n   and DELETE, in a special way, so that the user is made aware of the\n   fact that a possibly unsafe action is being requested.\n\n   Naturally, it is not possible to ensure that the server does not\n   generate side-effects as a result of performing a GET request; in\n   fact, some dynamic resources consider that a feature. The important\n   distinction here is that the user did not request the side-effects,\n   so therefore cannot be held accountable for them.\n\n9.1.2 Idempotent Methods\n\n   Methods can also have the property of \"idempotence\" in that (aside\n   from error or expiration issues) the side-effects of N > 0 identical\n   requests is the same as for a single request. The methods GET, HEAD,\n   PUT and DELETE share this property. Also, the methods OPTIONS and\n   TRACE SHOULD NOT have side effects, and so are inherently idempotent.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 51]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   However, it is possible that a sequence of several requests is non-\n   idempotent, even if all of the methods executed in that sequence are\n   idempotent. (A sequence is idempotent if a single execution of the\n   entire sequence always yields a result that is not changed by a\n   reexecution of all, or part, of that sequence.) For example, a\n   sequence is non-idempotent if its result depends on a value that is\n   later modified in the same sequence.\n\n   A sequence that never has side effects is idempotent, by definition\n   (provided that no concurrent operations are being executed on the\n   same set of resources).\n\n9.2 OPTIONS\n\n   The OPTIONS method represents a request for information about the\n   communication options available on the request/response chain\n   identified by the Request-URI. This method allows the client to\n   determine the options and/or requirements associated with a resource,\n   or the capabilities of a server, without implying a resource action\n   or initiating a resource retrieval.\n\n   Responses to this method are not cacheable.\n\n   If the OPTIONS request includes an entity-body (as indicated by the\n   presence of Content-Length or Transfer-Encoding), then the media type\n   MUST be indicated by a Content-Type field. Although this\n   specification does not define any use for such a body, future\n   extensions to HTTP might use the OPTIONS body to make more detailed\n   queries on the server. A server that does not support such an\n   extension MAY discard the request body.\n\n   If the Request-URI is an asterisk (\"*\"), the OPTIONS request is\n   intended to apply to the server in general rather than to a specific\n   resource. Since a server's communication options typically depend on\n   the resource, the \"*\" request is only useful as a \"ping\" or \"no-op\"\n   type of method; it does nothing beyond allowing the client to test\n   the capabilities of the server. For example, this can be used to test\n   a proxy for HTTP/1.1 compliance (or lack thereof).\n\n   If the Request-URI is not an asterisk, the OPTIONS request applies\n   only to the options that are available when communicating with that\n   resource.\n\n   A 200 response SHOULD include any header fields that indicate\n   optional features implemented by the server and applicable to that\n   resource (e.g., Allow), possibly including extensions not defined by\n   this specification. The response body, if any, SHOULD also include\n   information about the communication options. The format for such a\n\n\n\nFielding, et al.            Standards Track                    [Page 52]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   body is not defined by this specification, but might be defined by\n   future extensions to HTTP. Content negotiation MAY be used to select\n   the appropriate response format. If no response body is included, the\n   response MUST include a Content-Length field with a field-value of\n   \"0\".\n\n   The Max-Forwards request-header field MAY be used to target a\n   specific proxy in the request chain. When a proxy receives an OPTIONS\n   request on an absoluteURI for which request forwarding is permitted,\n   the proxy MUST check for a Max-Forwards field. If the Max-Forwards\n   field-value is zero (\"0\"), the proxy MUST NOT forward the message;\n   instead, the proxy SHOULD respond with its own communication options.\n   If the Max-Forwards field-value is an integer greater than zero, the\n   proxy MUST decrement the field-value when it forwards the request. If\n   no Max-Forwards field is present in the request, then the forwarded\n   request MUST NOT include a Max-Forwards field.\n\n9.3 GET\n\n   The GET method means retrieve whatever information (in the form of an\n   entity) is identified by the Request-URI. If the Request-URI refers\n   to a data-producing process, it is the produced data which shall be\n   returned as the entity in the response and not the source text of the\n   process, unless that text happens to be the output of the process.\n\n   The semantics of the GET method change to a \"conditional GET\" if the\n   request message includes an If-Modified-Since, If-Unmodified-Since,\n   If-Match, If-None-Match, or If-Range header field. A conditional GET\n   method requests that the entity be transferred only under the\n   circumstances described by the conditional header field(s). The\n   conditional GET method is intended to reduce unnecessary network\n   usage by allowing cached entities to be refreshed without requiring\n   multiple requests or transferring data already held by the client.\n\n   The semantics of the GET method change to a \"partial GET\" if the\n   request message includes a Range header field. A partial GET requests\n   that only part of the entity be transferred, as described in section\n   14.35. The partial GET method is intended to reduce unnecessary\n   network usage by allowing partially-retrieved entities to be\n   completed without transferring data already held by the client.\n\n   The response to a GET request is cacheable if and only if it meets\n   the requirements for HTTP caching described in section 13.\n\n   See section 15.1.3 for security considerations when used for forms.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 53]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n9.4 HEAD\n\n   The HEAD method is identical to GET except that the server MUST NOT\n   return a message-body in the response. The metainformation contained\n   in the HTTP headers in response to a HEAD request SHOULD be identical\n   to the information sent in response to a GET request. This method can\n   be used for obtaining metainformation about the entity implied by the\n   request without transferring the entity-body itself. This method is\n   often used for testing hypertext links for validity, accessibility,\n   and recent modification.\n\n   The response to a HEAD request MAY be cacheable in the sense that the\n   information contained in the response MAY be used to update a\n   previously cached entity from that resource. If the new field values\n   indicate that the cached entity differs from the current entity (as\n   would be indicated by a change in Content-Length, Content-MD5, ETag\n   or Last-Modified), then the cache MUST treat the cache entry as\n   stale.\n\n9.5 POST\n\n   The POST method is used to request that the origin server accept the\n   entity enclosed in the request as a new subordinate of the resource\n   identified by the Request-URI in the Request-Line. POST is designed\n   to allow a uniform method to cover the following functions:\n\n      - Annotation of existing resources;\n\n      - Posting a message to a bulletin board, newsgroup, mailing list,\n        or similar group of articles;\n\n      - Providing a block of data, such as the result of submitting a\n        form, to a data-handling process;\n\n      - Extending a database through an append operation.\n\n   The actual function performed by the POST method is determined by the\n   server and is usually dependent on the Request-URI. The posted entity\n   is subordinate to that URI in the same way that a file is subordinate\n   to a directory containing it, a news article is subordinate to a\n   newsgroup to which it is posted, or a record is subordinate to a\n   database.\n\n   The action performed by the POST method might not result in a\n   resource that can be identified by a URI. In this case, either 200\n   (OK) or 204 (No Content) is the appropriate response status,\n   depending on whether or not the response includes an entity that\n   describes the result.\n\n\n\nFielding, et al.            Standards Track                    [Page 54]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If a resource has been created on the origin server, the response\n   SHOULD be 201 (Created) and contain an entity which describes the\n   status of the request and refers to the new resource, and a Location\n   header (see section 14.30).\n\n   Responses to this method are not cacheable, unless the response\n   includes appropriate Cache-Control or Expires header fields. However,\n   the 303 (See Other) response can be used to direct the user agent to\n   retrieve a cacheable resource.\n\n   POST requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   See section 15.1.3 for security considerations.\n\n9.6 PUT\n\n   The PUT method requests that the enclosed entity be stored under the\n   supplied Request-URI. If the Request-URI refers to an already\n   existing resource, the enclosed entity SHOULD be considered as a\n   modified version of the one residing on the origin server. If the\n   Request-URI does not point to an existing resource, and that URI is\n   capable of being defined as a new resource by the requesting user\n   agent, the origin server can create the resource with that URI. If a\n   new resource is created, the origin server MUST inform the user agent\n   via the 201 (Created) response. If an existing resource is modified,\n   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent\n   to indicate successful completion of the request. If the resource\n   could not be created or modified with the Request-URI, an appropriate\n   error response SHOULD be given that reflects the nature of the\n   problem. The recipient of the entity MUST NOT ignore any Content-*\n   (e.g. Content-Range) headers that it does not understand or implement\n   and MUST return a 501 (Not Implemented) response in such cases.\n\n   If the request passes through a cache and the Request-URI identifies\n   one or more currently cached entities, those entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\n   The fundamental difference between the POST and PUT requests is\n   reflected in the different meaning of the Request-URI. The URI in a\n   POST request identifies the resource that will handle the enclosed\n   entity. That resource might be a data-accepting process, a gateway to\n   some other protocol, or a separate entity that accepts annotations.\n   In contrast, the URI in a PUT request identifies the entity enclosed\n   with the request -- the user agent knows what URI is intended and the\n   server MUST NOT attempt to apply the request to some other resource.\n   If the server desires that the request be applied to a different URI,\n\n\n\n\nFielding, et al.            Standards Track                    [Page 55]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   it MUST send a 301 (Moved Permanently) response; the user agent MAY\n   then make its own decision regarding whether or not to redirect the\n   request.\n\n   A single resource MAY be identified by many different URIs. For\n   example, an article might have a URI for identifying \"the current\n   version\" which is separate from the URI identifying each particular\n   version. In this case, a PUT request on a general URI might result in\n   several other URIs being defined by the origin server.\n\n   HTTP/1.1 does not define how a PUT method affects the state of an\n   origin server.\n\n   PUT requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   Unless otherwise specified for a particular entity-header, the\n   entity-headers in the PUT request SHOULD be applied to the resource\n   created or modified by the PUT.\n\n9.7 DELETE\n\n   The DELETE method requests that the origin server delete the resource\n   identified by the Request-URI. This method MAY be overridden by human\n   intervention (or other means) on the origin server. The client cannot\n   be guaranteed that the operation has been carried out, even if the\n   status code returned from the origin server indicates that the action\n   has been completed successfully. However, the server SHOULD NOT\n   indicate success unless, at the time the response is given, it\n   intends to delete the resource or move it to an inaccessible\n   location.\n\n   A successful response SHOULD be 200 (OK) if the response includes an\n   entity describing the status, 202 (Accepted) if the action has not\n   yet been enacted, or 204 (No Content) if the action has been enacted\n   but the response does not include an entity.\n\n   If the request passes through a cache and the Request-URI identifies\n   one or more currently cached entities, those entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\n9.8 TRACE\n\n   The TRACE method is used to invoke a remote, application-layer loop-\n   back of the request message. The final recipient of the request\n   SHOULD reflect the message received back to the client as the\n   entity-body of a 200 (OK) response. The final recipient is either the\n\n\n\n\nFielding, et al.            Standards Track                    [Page 56]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   origin server or the first proxy or gateway to receive a Max-Forwards\n   value of zero (0) in the request (see section 14.31). A TRACE request\n   MUST NOT include an entity.\n\n   TRACE allows the client to see what is being received at the other\n   end of the request chain and use that data for testing or diagnostic\n   information. The value of the Via header field (section 14.45) is of\n   particular interest, since it acts as a trace of the request chain.\n   Use of the Max-Forwards header field allows the client to limit the\n   length of the request chain, which is useful for testing a chain of\n   proxies forwarding messages in an infinite loop.\n\n   If the request is valid, the response SHOULD contain the entire\n   request message in the entity-body, with a Content-Type of\n   \"message/http\". Responses to this method MUST NOT be cached.\n\n9.9 CONNECT\n\n   This specification reserves the method name CONNECT for use with a\n   proxy that can dynamically switch to being a tunnel (e.g. SSL\n   tunneling [44]).\n\n10 Status Code Definitions\n\n   Each Status-Code is described below, including a description of which\n   method(s) it can follow and any metainformation required in the\n   response.\n\n10.1 Informational 1xx\n\n   This class of status code indicates a provisional response,\n   consisting only of the Status-Line and optional headers, and is\n   terminated by an empty line. There are no required headers for this\n   class of status code. Since HTTP/1.0 did not define any 1xx status\n   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client\n   except under experimental conditions.\n\n   A client MUST be prepared to accept one or more 1xx status responses\n   prior to a regular response, even if the client does not expect a 100\n   (Continue) status message. Unexpected 1xx status responses MAY be\n   ignored by a user agent.\n\n   Proxies MUST forward 1xx responses, unless the connection between the\n   proxy and its client has been closed, or unless the proxy itself\n   requested the generation of the 1xx response. (For example, if a\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 57]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   proxy adds a \"Expect: 100-continue\" field when it forwards a request,\n   then it need not forward the corresponding 100 (Continue)\n   response(s).)\n\n10.1.1 100 Continue\n\n   The client SHOULD continue with its request. This interim response is\n   used to inform the client that the initial part of the request has\n   been received and has not yet been rejected by the server. The client\n   SHOULD continue by sending the remainder of the request or, if the\n   request has already been completed, ignore this response. The server\n   MUST send a final response after the request has been completed. See\n   section 8.2.3 for detailed discussion of the use and handling of this\n   status code.\n\n10.1.2 101 Switching Protocols\n\n   The server understands and is willing to comply with the client's\n   request, via the Upgrade message header field (section 14.42), for a\n   change in the application protocol being used on this connection. The\n   server will switch protocols to those defined by the response's\n   Upgrade header field immediately after the empty line which\n   terminates the 101 response.\n\n   The protocol SHOULD be switched only when it is advantageous to do\n   so. For example, switching to a newer version of HTTP is advantageous\n   over older versions, and switching to a real-time, synchronous\n   protocol might be advantageous when delivering resources that use\n   such features.\n\n10.2 Successful 2xx\n\n   This class of status code indicates that the client's request was\n   successfully received, understood, and accepted.\n\n10.2.1 200 OK\n\n   The request has succeeded. The information returned with the response\n   is dependent on the method used in the request, for example:\n\n   GET    an entity corresponding to the requested resource is sent in\n          the response;\n\n   HEAD   the entity-header fields corresponding to the requested\n          resource are sent in the response without any message-body;\n\n   POST   an entity describing or containing the result of the action;\n\n\n\n\nFielding, et al.            Standards Track                    [Page 58]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   TRACE  an entity containing the request message as received by the\n          end server.\n\n10.2.2 201 Created\n\n   The request has been fulfilled and resulted in a new resource being\n   created. The newly created resource can be referenced by the URI(s)\n   returned in the entity of the response, with the most specific URI\n   for the resource given by a Location header field. The response\n   SHOULD include an entity containing a list of resource\n   characteristics and location(s) from which the user or user agent can\n   choose the one most appropriate. The entity format is specified by\n   the media type given in the Content-Type header field. The origin\n   server MUST create the resource before returning the 201 status code.\n   If the action cannot be carried out immediately, the server SHOULD\n   respond with 202 (Accepted) response instead.\n\n   A 201 response MAY contain an ETag response header field indicating\n   the current value of the entity tag for the requested variant just\n   created, see section 14.19.\n\n10.2.3 202 Accepted\n\n   The request has been accepted for processing, but the processing has\n   not been completed.  The request might or might not eventually be\n   acted upon, as it might be disallowed when processing actually takes\n   place. There is no facility for re-sending a status code from an\n   asynchronous operation such as this.\n\n   The 202 response is intentionally non-committal. Its purpose is to\n   allow a server to accept a request for some other process (perhaps a\n   batch-oriented process that is only run once per day) without\n   requiring that the user agent's connection to the server persist\n   until the process is completed. The entity returned with this\n   response SHOULD include an indication of the request's current status\n   and either a pointer to a status monitor or some estimate of when the\n   user can expect the request to be fulfilled.\n\n10.2.4 203 Non-Authoritative Information\n\n   The returned metainformation in the entity-header is not the\n   definitive set as available from the origin server, but is gathered\n   from a local or a third-party copy. The set presented MAY be a subset\n   or superset of the original version. For example, including local\n   annotation information about the resource might result in a superset\n   of the metainformation known by the origin server. Use of this\n   response code is not required and is only appropriate when the\n   response would otherwise be 200 (OK).\n\n\n\nFielding, et al.            Standards Track                    [Page 59]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.2.5 204 No Content\n\n   The server has fulfilled the request but does not need to return an\n   entity-body, and might want to return updated metainformation. The\n   response MAY include new or updated metainformation in the form of\n   entity-headers, which if present SHOULD be associated with the\n   requested variant.\n\n   If the client is a user agent, it SHOULD NOT change its document view\n   from that which caused the request to be sent. This response is\n   primarily intended to allow input for actions to take place without\n   causing a change to the user agent's active document view, although\n   any new or updated metainformation SHOULD be applied to the document\n   currently in the user agent's active view.\n\n   The 204 response MUST NOT include a message-body, and thus is always\n   terminated by the first empty line after the header fields.\n\n10.2.6 205 Reset Content\n\n   The server has fulfilled the request and the user agent SHOULD reset\n   the document view which caused the request to be sent. This response\n   is primarily intended to allow input for actions to take place via\n   user input, followed by a clearing of the form in which the input is\n   given so that the user can easily initiate another input action. The\n   response MUST NOT include an entity.\n\n10.2.7 206 Partial Content\n\n   The server has fulfilled the partial GET request for the resource.\n   The request MUST have included a Range header field (section 14.35)\n   indicating the desired range, and MAY have included an If-Range\n   header field (section 14.27) to make the request conditional.\n\n   The response MUST include the following header fields:\n\n      - Either a Content-Range header field (section 14.16) indicating\n        the range included with this response, or a multipart/byteranges\n        Content-Type including Content-Range fields for each part. If a\n        Content-Length header field is present in the response, its\n        value MUST match the actual number of OCTETs transmitted in the\n        message-body.\n\n      - Date\n\n      - ETag and/or Content-Location, if the header would have been sent\n        in a 200 response to the same request\n\n\n\n\nFielding, et al.            Standards Track                    [Page 60]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - Expires, Cache-Control, and/or Vary, if the field-value might\n        differ from that sent in any previous response for the same\n        variant\n\n   If the 206 response is the result of an If-Range request that used a\n   strong cache validator (see section 13.3.3), the response SHOULD NOT\n   include other entity-headers. If the response is the result of an\n   If-Range request that used a weak validator, the response MUST NOT\n   include other entity-headers; this prevents inconsistencies between\n   cached entity-bodies and updated headers. Otherwise, the response\n   MUST include all of the entity-headers that would have been returned\n   with a 200 (OK) response to the same request.\n\n   A cache MUST NOT combine a 206 response with other previously cached\n   content if the ETag or Last-Modified headers do not match exactly,\n   see 13.5.4.\n\n   A cache that does not support the Range and Content-Range headers\n   MUST NOT cache 206 (Partial) responses.\n\n10.3 Redirection 3xx\n\n   This class of status code indicates that further action needs to be\n   taken by the user agent in order to fulfill the request.  The action\n   required MAY be carried out by the user agent without interaction\n   with the user if and only if the method used in the second request is\n   GET or HEAD. A client SHOULD detect infinite redirection loops, since\n   such loops generate network traffic for each redirection.\n\n      Note: previous versions of this specification recommended a\n      maximum of five redirections. Content developers should be aware\n      that there might be clients that implement such a fixed\n      limitation.\n\n10.3.1 300 Multiple Choices\n\n   The requested resource corresponds to any one of a set of\n   representations, each with its own specific location, and agent-\n   driven negotiation information (section 12) is being provided so that\n   the user (or user agent) can select a preferred representation and\n   redirect its request to that location.\n\n   Unless it was a HEAD request, the response SHOULD include an entity\n   containing a list of resource characteristics and location(s) from\n   which the user or user agent can choose the one most appropriate. The\n   entity format is specified by the media type given in the Content-\n   Type header field. Depending upon the format and the capabilities of\n\n\n\n\nFielding, et al.            Standards Track                    [Page 61]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the user agent, selection of the most appropriate choice MAY be\n   performed automatically. However, this specification does not define\n   any standard for such automatic selection.\n\n   If the server has a preferred choice of representation, it SHOULD\n   include the specific URI for that representation in the Location\n   field; user agents MAY use the Location field value for automatic\n   redirection. This response is cacheable unless indicated otherwise.\n\n10.3.2 301 Moved Permanently\n\n   The requested resource has been assigned a new permanent URI and any\n   future references to this resource SHOULD use one of the returned\n   URIs.  Clients with link editing capabilities ought to automatically\n   re-link references to the Request-URI to one or more of the new\n   references returned by the server, where possible. This response is\n   cacheable unless indicated otherwise.\n\n   The new permanent URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n   If the 301 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n      Note: When automatically redirecting a POST request after\n      receiving a 301 status code, some existing HTTP/1.0 user agents\n      will erroneously change it into a GET request.\n\n10.3.3 302 Found\n\n   The requested resource resides temporarily under a different URI.\n   Since the redirection might be altered on occasion, the client SHOULD\n   continue to use the Request-URI for future requests.  This response\n   is only cacheable if indicated by a Cache-Control or Expires header\n   field.\n\n   The temporary URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 62]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the 302 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n      Note: RFC 1945 and RFC 2068 specify that the client is not allowed\n      to change the method on the redirected request.  However, most\n      existing user agent implementations treat 302 as if it were a 303\n      response, performing a GET on the Location field-value regardless\n      of the original request method. The status codes 303 and 307 have\n      been added for servers that wish to make unambiguously clear which\n      kind of reaction is expected of the client.\n\n10.3.4 303 See Other\n\n   The response to the request can be found under a different URI and\n   SHOULD be retrieved using a GET method on that resource. This method\n   exists primarily to allow the output of a POST-activated script to\n   redirect the user agent to a selected resource. The new URI is not a\n   substitute reference for the originally requested resource. The 303\n   response MUST NOT be cached, but the response to the second\n   (redirected) request might be cacheable.\n\n   The different URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n      Note: Many pre-HTTP/1.1 user agents do not understand the 303\n      status. When interoperability with such clients is a concern, the\n      302 status code may be used instead, since most user agents react\n      to a 302 response as described here for 303.\n\n10.3.5 304 Not Modified\n\n   If the client has performed a conditional GET request and access is\n   allowed, but the document has not been modified, the server SHOULD\n   respond with this status code. The 304 response MUST NOT contain a\n   message-body, and thus is always terminated by the first empty line\n   after the header fields.\n\n   The response MUST include the following header fields:\n\n      - Date, unless its omission is required by section 14.18.1\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 63]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If a clockless origin server obeys these rules, and proxies and\n   clients add their own Date to any response received without one (as\n   already specified by [RFC 2068], section 14.19), caches will operate\n   correctly.\n\n      - ETag and/or Content-Location, if the header would have been sent\n        in a 200 response to the same request\n\n      - Expires, Cache-Control, and/or Vary, if the field-value might\n        differ from that sent in any previous response for the same\n        variant\n\n   If the conditional GET used a strong cache validator (see section\n   13.3.3), the response SHOULD NOT include other entity-headers.\n   Otherwise (i.e., the conditional GET used a weak validator), the\n   response MUST NOT include other entity-headers; this prevents\n   inconsistencies between cached entity-bodies and updated headers.\n\n   If a 304 response indicates an entity not currently cached, then the\n   cache MUST disregard the response and repeat the request without the\n   conditional.\n\n   If a cache uses a received 304 response to update a cache entry, the\n   cache MUST update the entry to reflect any new field values given in\n   the response.\n\n10.3.6 305 Use Proxy\n\n   The requested resource MUST be accessed through the proxy given by\n   the Location field. The Location field gives the URI of the proxy.\n   The recipient is expected to repeat this single request via the\n   proxy. 305 responses MUST only be generated by origin servers.\n\n      Note: RFC 2068 was not clear that 305 was intended to redirect a\n      single request, and to be generated by origin servers only.  Not\n      observing these limitations has significant security consequences.\n\n10.3.7 306 (Unused)\n\n   The 306 status code was used in a previous version of the\n   specification, is no longer used, and the code is reserved.\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 64]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.3.8 307 Temporary Redirect\n\n   The requested resource resides temporarily under a different URI.\n   Since the redirection MAY be altered on occasion, the client SHOULD\n   continue to use the Request-URI for future requests.  This response\n   is only cacheable if indicated by a Cache-Control or Expires header\n   field.\n\n   The temporary URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s) , since many pre-HTTP/1.1 user agents do not\n   understand the 307 status. Therefore, the note SHOULD contain the\n   information necessary for a user to repeat the original request on\n   the new URI.\n\n   If the 307 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n10.4 Client Error 4xx\n\n   The 4xx class of status code is intended for cases in which the\n   client seems to have erred. Except when responding to a HEAD request,\n   the server SHOULD include an entity containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n   condition. These status codes are applicable to any request method.\n   User agents SHOULD display any included entity to the user.\n\n   If the client is sending data, a server implementation using TCP\n   SHOULD be careful to ensure that the client acknowledges receipt of\n   the packet(s) containing the response, before the server closes the\n   input connection. If the client continues sending data to the server\n   after the close, the server's TCP stack will send a reset packet to\n   the client, which may erase the client's unacknowledged input buffers\n   before they can be read and interpreted by the HTTP application.\n\n10.4.1 400 Bad Request\n\n   The request could not be understood by the server due to malformed\n   syntax. The client SHOULD NOT repeat the request without\n   modifications.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 65]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.2 401 Unauthorized\n\n   The request requires user authentication. The response MUST include a\n   WWW-Authenticate header field (section 14.47) containing a challenge\n   applicable to the requested resource. The client MAY repeat the\n   request with a suitable Authorization header field (section 14.8). If\n   the request already included Authorization credentials, then the 401\n   response indicates that authorization has been refused for those\n   credentials. If the 401 response contains the same challenge as the\n   prior response, and the user agent has already attempted\n   authentication at least once, then the user SHOULD be presented the\n   entity that was given in the response, since that entity might\n   include relevant diagnostic information. HTTP access authentication\n   is explained in \"HTTP Authentication: Basic and Digest Access\n   Authentication\" [43].\n\n10.4.3 402 Payment Required\n\n   This code is reserved for future use.\n\n10.4.4 403 Forbidden\n\n   The server understood the request, but is refusing to fulfill it.\n   Authorization will not help and the request SHOULD NOT be repeated.\n   If the request method was not HEAD and the server wishes to make\n   public why the request has not been fulfilled, it SHOULD describe the\n   reason for the refusal in the entity.  If the server does not wish to\n   make this information available to the client, the status code 404\n   (Not Found) can be used instead.\n\n10.4.5 404 Not Found\n\n   The server has not found anything matching the Request-URI. No\n   indication is given of whether the condition is temporary or\n   permanent. The 410 (Gone) status code SHOULD be used if the server\n   knows, through some internally configurable mechanism, that an old\n   resource is permanently unavailable and has no forwarding address.\n   This status code is commonly used when the server does not wish to\n   reveal exactly why the request has been refused, or when no other\n   response is applicable.\n\n10.4.6 405 Method Not Allowed\n\n   The method specified in the Request-Line is not allowed for the\n   resource identified by the Request-URI. The response MUST include an\n   Allow header containing a list of valid methods for the requested\n   resource.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 66]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.7 406 Not Acceptable\n\n   The resource identified by the request is only capable of generating\n   response entities which have content characteristics not acceptable\n   according to the accept headers sent in the request.\n\n   Unless it was a HEAD request, the response SHOULD include an entity\n   containing a list of available entity characteristics and location(s)\n   from which the user or user agent can choose the one most\n   appropriate. The entity format is specified by the media type given\n   in the Content-Type header field. Depending upon the format and the\n   capabilities of the user agent, selection of the most appropriate\n   choice MAY be performed automatically. However, this specification\n   does not define any standard for such automatic selection.\n\n      Note: HTTP/1.1 servers are allowed to return responses which are\n      not acceptable according to the accept headers sent in the\n      request. In some cases, this may even be preferable to sending a\n      406 response. User agents are encouraged to inspect the headers of\n      an incoming response to determine if it is acceptable.\n\n   If the response could be unacceptable, a user agent SHOULD\n   temporarily stop receipt of more data and query the user for a\n   decision on further actions.\n\n10.4.8 407 Proxy Authentication Required\n\n   This code is similar to 401 (Unauthorized), but indicates that the\n   client must first authenticate itself with the proxy. The proxy MUST\n   return a Proxy-Authenticate header field (section 14.33) containing a\n   challenge applicable to the proxy for the requested resource. The\n   client MAY repeat the request with a suitable Proxy-Authorization\n   header field (section 14.34). HTTP access authentication is explained\n   in \"HTTP Authentication: Basic and Digest Access Authentication\"\n   [43].\n\n10.4.9 408 Request Timeout\n\n   The client did not produce a request within the time that the server\n   was prepared to wait. The client MAY repeat the request without\n   modifications at any later time.\n\n10.4.10 409 Conflict\n\n   The request could not be completed due to a conflict with the current\n   state of the resource. This code is only allowed in situations where\n   it is expected that the user might be able to resolve the conflict\n   and resubmit the request. The response body SHOULD include enough\n\n\n\nFielding, et al.            Standards Track                    [Page 67]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   information for the user to recognize the source of the conflict.\n   Ideally, the response entity would include enough information for the\n   user or user agent to fix the problem; however, that might not be\n   possible and is not required.\n\n   Conflicts are most likely to occur in response to a PUT request. For\n   example, if versioning were being used and the entity being PUT\n   included changes to a resource which conflict with those made by an\n   earlier (third-party) request, the server might use the 409 response\n   to indicate that it can't complete the request. In this case, the\n   response entity would likely contain a list of the differences\n   between the two versions in a format defined by the response\n   Content-Type.\n\n10.4.11 410 Gone\n\n   The requested resource is no longer available at the server and no\n   forwarding address is known. This condition is expected to be\n   considered permanent. Clients with link editing capabilities SHOULD\n   delete references to the Request-URI after user approval. If the\n   server does not know, or has no facility to determine, whether or not\n   the condition is permanent, the status code 404 (Not Found) SHOULD be\n   used instead. This response is cacheable unless indicated otherwise.\n\n   The 410 response is primarily intended to assist the task of web\n   maintenance by notifying the recipient that the resource is\n   intentionally unavailable and that the server owners desire that\n   remote links to that resource be removed. Such an event is common for\n   limited-time, promotional services and for resources belonging to\n   individuals no longer working at the server's site. It is not\n   necessary to mark all permanently unavailable resources as \"gone\" or\n   to keep the mark for any length of time -- that is left to the\n   discretion of the server owner.\n\n10.4.12 411 Length Required\n\n   The server refuses to accept the request without a defined Content-\n   Length. The client MAY repeat the request if it adds a valid\n   Content-Length header field containing the length of the message-body\n   in the request message.\n\n10.4.13 412 Precondition Failed\n\n   The precondition given in one or more of the request-header fields\n   evaluated to false when it was tested on the server. This response\n   code allows the client to place preconditions on the current resource\n   metainformation (header field data) and thus prevent the requested\n   method from being applied to a resource other than the one intended.\n\n\n\nFielding, et al.            Standards Track                    [Page 68]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.14 413 Request Entity Too Large\n\n   The server is refusing to process a request because the request\n   entity is larger than the server is willing or able to process. The\n   server MAY close the connection to prevent the client from continuing\n   the request.\n\n   If the condition is temporary, the server SHOULD include a Retry-\n   After header field to indicate that it is temporary and after what\n   time the client MAY try again.\n\n10.4.15 414 Request-URI Too Long\n\n   The server is refusing to service the request because the Request-URI\n   is longer than the server is willing to interpret. This rare\n   condition is only likely to occur when a client has improperly\n   converted a POST request to a GET request with long query\n   information, when the client has descended into a URI \"black hole\" of\n   redirection (e.g., a redirected URI prefix that points to a suffix of\n   itself), or when the server is under attack by a client attempting to\n   exploit security holes present in some servers using fixed-length\n   buffers for reading or manipulating the Request-URI.\n\n10.4.16 415 Unsupported Media Type\n\n   The server is refusing to service the request because the entity of\n   the request is in a format not supported by the requested resource\n   for the requested method.\n\n10.4.17 416 Requested Range Not Satisfiable\n\n   A server SHOULD return a response with this status code if a request\n   included a Range request-header field (section 14.35), and none of\n   the range-specifier values in this field overlap the current extent\n   of the selected resource, and the request did not include an If-Range\n   request-header field. (For byte-ranges, this means that the first-\n   byte-pos of all of the byte-range-spec values were greater than the\n   current length of the selected resource.)\n\n   When this status code is returned for a byte-range request, the\n   response SHOULD include a Content-Range entity-header field\n   specifying the current length of the selected resource (see section\n   14.16). This response MUST NOT use the multipart/byteranges content-\n   type.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 69]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.18 417 Expectation Failed\n\n   The expectation given in an Expect request-header field (see section\n   14.20) could not be met by this server, or, if the server is a proxy,\n   the server has unambiguous evidence that the request could not be met\n   by the next-hop server.\n\n10.5 Server Error 5xx\n\n   Response status codes beginning with the digit \"5\" indicate cases in\n   which the server is aware that it has erred or is incapable of\n   performing the request. Except when responding to a HEAD request, the\n   server SHOULD include an entity containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n   condition. User agents SHOULD display any included entity to the\n   user. These response codes are applicable to any request method.\n\n10.5.1 500 Internal Server Error\n\n   The server encountered an unexpected condition which prevented it\n   from fulfilling the request.\n\n10.5.2 501 Not Implemented\n\n   The server does not support the functionality required to fulfill the\n   request. This is the appropriate response when the server does not\n   recognize the request method and is not capable of supporting it for\n   any resource.\n\n10.5.3 502 Bad Gateway\n\n   The server, while acting as a gateway or proxy, received an invalid\n   response from the upstream server it accessed in attempting to\n   fulfill the request.\n\n10.5.4 503 Service Unavailable\n\n   The server is currently unable to handle the request due to a\n   temporary overloading or maintenance of the server. The implication\n   is that this is a temporary condition which will be alleviated after\n   some delay. If known, the length of the delay MAY be indicated in a\n   Retry-After header. If no Retry-After is given, the client SHOULD\n   handle the response as it would for a 500 response.\n\n      Note: The existence of the 503 status code does not imply that a\n      server must use it when becoming overloaded. Some servers may wish\n      to simply refuse the connection.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 70]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.5.5 504 Gateway Timeout\n\n   The server, while acting as a gateway or proxy, did not receive a\n   timely response from the upstream server specified by the URI (e.g.\n   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed\n   to access in attempting to complete the request.\n\n      Note: Note to implementors: some deployed proxies are known to\n      return 400 or 500 when DNS lookups time out.\n\n10.5.6 505 HTTP Version Not Supported\n\n   The server does not support, or refuses to support, the HTTP protocol\n   version that was used in the request message. The server is\n   indicating that it is unable or unwilling to complete the request\n   using the same major version as the client, as described in section\n   3.1, other than with this error message. The response SHOULD contain\n   an entity describing why that version is not supported and what other\n   protocols are supported by that server.\n\n11 Access Authentication\n\n   HTTP provides several OPTIONAL challenge-response authentication\n   mechanisms which can be used by a server to challenge a client\n   request and by a client to provide authentication information. The\n   general framework for access authentication, and the specification of\n   \"basic\" and \"digest\" authentication, are specified in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. This\n   specification adopts the definitions of \"challenge\" and \"credentials\"\n   from that specification.\n\n12 Content Negotiation\n\n   Most HTTP responses include an entity which contains information for\n   interpretation by a human user. Naturally, it is desirable to supply\n   the user with the \"best available\" entity corresponding to the\n   request. Unfortunately for servers and caches, not all users have the\n   same preferences for what is \"best,\" and not all user agents are\n   equally capable of rendering all entity types. For that reason, HTTP\n   has provisions for several mechanisms for \"content negotiation\" --\n   the process of selecting the best representation for a given response\n   when there are multiple representations available.\n\n      Note: This is not called \"format negotiation\" because the\n      alternate representations may be of the same media type, but use\n      different capabilities of that type, be in different languages,\n      etc.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 71]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Any response containing an entity-body MAY be subject to negotiation,\n   including error responses.\n\n   There are two kinds of content negotiation which are possible in\n   HTTP: server-driven and agent-driven negotiation. These two kinds of\n   negotiation are orthogonal and thus may be used separately or in\n   combination. One method of combination, referred to as transparent\n   negotiation, occurs when a cache uses the agent-driven negotiation\n   information provided by the origin server in order to provide\n   server-driven negotiation for subsequent requests.\n\n12.1 Server-driven Negotiation\n\n   If the selection of the best representation for a response is made by\n   an algorithm located at the server, it is called server-driven\n   negotiation. Selection is based on the available representations of\n   the response (the dimensions over which it can vary; e.g. language,\n   content-coding, etc.) and the contents of particular header fields in\n   the request message or on other information pertaining to the request\n   (such as the network address of the client).\n\n   Server-driven negotiation is advantageous when the algorithm for\n   selecting from among the available representations is difficult to\n   describe to the user agent, or when the server desires to send its\n   \"best guess\" to the client along with the first response (hoping to\n   avoid the round-trip delay of a subsequent request if the \"best\n   guess\" is good enough for the user). In order to improve the server's\n   guess, the user agent MAY include request header fields (Accept,\n   Accept-Language, Accept-Encoding, etc.) which describe its\n   preferences for such a response.\n\n   Server-driven negotiation has disadvantages:\n\n      1. It is impossible for the server to accurately determine what\n         might be \"best\" for any given user, since that would require\n         complete knowledge of both the capabilities of the user agent\n         and the intended use for the response (e.g., does the user want\n         to view it on screen or print it on paper?).\n\n      2. Having the user agent describe its capabilities in every\n         request can be both very inefficient (given that only a small\n         percentage of responses have multiple representations) and a\n         potential violation of the user's privacy.\n\n      3. It complicates the implementation of an origin server and the\n         algorithms for generating responses to a request.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 72]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      4. It may limit a public cache's ability to use the same response\n         for multiple user's requests.\n\n   HTTP/1.1 includes the following request-header fields for enabling\n   server-driven negotiation through description of user agent\n   capabilities and user preferences: Accept (section 14.1), Accept-\n   Charset (section 14.2), Accept-Encoding (section 14.3), Accept-\n   Language (section 14.4), and User-Agent (section 14.43). However, an\n   origin server is not limited to these dimensions and MAY vary the\n   response based on any aspect of the request, including information\n   outside the request-header fields or within extension header fields\n   not defined by this specification.\n\n   The Vary  header field can be used to express the parameters the\n   server uses to select a representation that is subject to server-\n   driven negotiation. See section 13.6 for use of the Vary header field\n   by caches and section 14.44 for use of the Vary header field by\n   servers.\n\n12.2 Agent-driven Negotiation\n\n   With agent-driven negotiation, selection of the best representation\n   for a response is performed by the user agent after receiving an\n   initial response from the origin server. Selection is based on a list\n   of the available representations of the response included within the\n   header fields or entity-body of the initial response, with each\n   representation identified by its own URI. Selection from among the\n   representations may be performed automatically (if the user agent is\n   capable of doing so) or manually by the user selecting from a\n   generated (possibly hypertext) menu.\n\n   Agent-driven negotiation is advantageous when the response would vary\n   over commonly-used dimensions (such as type, language, or encoding),\n   when the origin server is unable to determine a user agent's\n   capabilities from examining the request, and generally when public\n   caches are used to distribute server load and reduce network usage.\n\n   Agent-driven negotiation suffers from the disadvantage of needing a\n   second request to obtain the best alternate representation. This\n   second request is only efficient when caching is used. In addition,\n   this specification does not define any mechanism for supporting\n   automatic selection, though it also does not prevent any such\n   mechanism from being developed as an extension and used within\n   HTTP/1.1.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 73]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)\n   status codes for enabling agent-driven negotiation when the server is\n   unwilling or unable to provide a varying response using server-driven\n   negotiation.\n\n12.3 Transparent Negotiation\n\n   Transparent negotiation is a combination of both server-driven and\n   agent-driven negotiation. When a cache is supplied with a form of the\n   list of available representations of the response (as in agent-driven\n   negotiation) and the dimensions of variance are completely understood\n   by the cache, then the cache becomes capable of performing server-\n   driven negotiation on behalf of the origin server for subsequent\n   requests on that resource.\n\n   Transparent negotiation has the advantage of distributing the\n   negotiation work that would otherwise be required of the origin\n   server and also removing the second request delay of agent-driven\n   negotiation when the cache is able to correctly guess the right\n   response.\n\n   This specification does not define any mechanism for transparent\n   negotiation, though it also does not prevent any such mechanism from\n   being developed as an extension that could be used within HTTP/1.1.\n\n13 Caching in HTTP\n\n   HTTP is typically used for distributed information systems, where\n   performance can be improved by the use of response caches. The\n   HTTP/1.1 protocol includes a number of elements intended to make\n   caching work as well as possible. Because these elements are\n   inextricable from other aspects of the protocol, and because they\n   interact with each other, it is useful to describe the basic caching\n   design of HTTP separately from the detailed descriptions of methods,\n   headers, response codes, etc.\n\n   Caching would be useless if it did not significantly improve\n   performance. The goal of caching in HTTP/1.1 is to eliminate the need\n   to send requests in many cases, and to eliminate the need to send\n   full responses in many other cases. The former reduces the number of\n   network round-trips required for many operations; we use an\n   \"expiration\" mechanism for this purpose (see section 13.2). The\n   latter reduces network bandwidth requirements; we use a \"validation\"\n   mechanism for this purpose (see section 13.3).\n\n   Requirements for performance, availability, and disconnected\n   operation require us to be able to relax the goal of semantic\n   transparency. The HTTP/1.1 protocol allows origin servers, caches,\n\n\n\nFielding, et al.            Standards Track                    [Page 74]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   and clients to explicitly reduce transparency when necessary.\n   However, because non-transparent operation may confuse non-expert\n   users, and might be incompatible with certain server applications\n   (such as those for ordering merchandise), the protocol requires that\n   transparency be relaxed\n\n      - only by an explicit protocol-level request when relaxed by\n        client or origin server\n\n      - only with an explicit warning to the end user when relaxed by\n        cache or client\n\n   Therefore, the HTTP/1.1 protocol provides these important elements:\n\n      1. Protocol features that provide full semantic transparency when\n         this is required by all parties.\n\n      2. Protocol features that allow an origin server or user agent to\n         explicitly request and control non-transparent operation.\n\n      3. Protocol features that allow a cache to attach warnings to\n         responses that do not preserve the requested approximation of\n         semantic transparency.\n\n   A basic principle is that it must be possible for the clients to\n   detect any potential relaxation of semantic transparency.\n\n      Note: The server, cache, or client implementor might be faced with\n      design decisions not explicitly discussed in this specification.\n      If a decision might affect semantic transparency, the implementor\n      ought to err on the side of maintaining transparency unless a\n      careful and complete analysis shows significant benefits in\n      breaking transparency.\n\n13.1.1 Cache Correctness\n\n   A correct cache MUST respond to a request with the most up-to-date\n   response held by the cache that is appropriate to the request (see\n   sections 13.2.5, 13.2.6, and 13.12) which meets one of the following\n   conditions:\n\n      1. It has been checked for equivalence with what the origin server\n         would have returned by revalidating the response with the\n         origin server (section 13.3);\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 75]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      2. It is \"fresh enough\" (see section 13.2). In the default case,\n         this means it meets the least restrictive freshness requirement\n         of the client, origin server, and cache (see section 14.9); if\n         the origin server so specifies, it is the freshness requirement\n         of the origin server alone.\n\n         If a stored response is not \"fresh enough\" by the most\n         restrictive freshness requirement of both the client and the\n         origin server, in carefully considered circumstances the cache\n         MAY still return the response with the appropriate Warning\n         header (see section 13.1.5 and 14.46), unless such a response\n         is prohibited (e.g., by a \"no-store\" cache-directive, or by a\n         \"no-cache\" cache-request-directive; see section 14.9).\n\n      3. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect),\n         or error (4xx or 5xx) response message.\n\n   If the cache can not communicate with the origin server, then a\n   correct cache SHOULD respond as above if the response can be\n   correctly served from the cache; if not it MUST return an error or\n   warning indicating that there was a communication failure.\n\n   If a cache receives a response (either an entire response, or a 304\n   (Not Modified) response) that it would normally forward to the\n   requesting client, and the received response is no longer fresh, the\n   cache SHOULD forward it to the requesting client without adding a new\n   Warning (but without removing any existing Warning headers). A cache\n   SHOULD NOT attempt to revalidate a response simply because that\n   response became stale in transit; this might lead to an infinite\n   loop. A user agent that receives a stale response without a Warning\n   MAY display a warning indication to the user.\n\n13.1.2 Warnings\n\n   Whenever a cache returns a response that is neither first-hand nor\n   \"fresh enough\" (in the sense of condition 2 in section 13.1.1), it\n   MUST attach a warning to that effect, using a Warning general-header.\n   The Warning header and the currently defined warnings are described\n   in section 14.46. The warning allows clients to take appropriate\n   action.\n\n   Warnings MAY be used for other purposes, both cache-related and\n   otherwise. The use of a warning, rather than an error status code,\n   distinguish these responses from true failures.\n\n   Warnings are assigned three digit warn-codes. The first digit\n   indicates whether the Warning MUST or MUST NOT be deleted from a\n   stored cache entry after a successful revalidation:\n\n\n\nFielding, et al.            Standards Track                    [Page 76]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   1xx  Warnings that describe the freshness or revalidation status of\n     the response, and so MUST be deleted after a successful\n     revalidation. 1XX warn-codes MAY be generated by a cache only when\n     validating a cached entry. It MUST NOT be generated by clients.\n\n   2xx  Warnings that describe some aspect of the entity body or entity\n     headers that is not rectified by a revalidation (for example, a\n     lossy compression of the entity bodies) and which MUST NOT be\n     deleted after a successful revalidation.\n\n   See section 14.46 for the definitions of the codes themselves.\n\n   HTTP/1.0 caches will cache all Warnings in responses, without\n   deleting the ones in the first category. Warnings in responses that\n   are passed to HTTP/1.0 caches carry an extra warning-date field,\n   which prevents a future HTTP/1.1 recipient from believing an\n   erroneously cached Warning.\n\n   Warnings also carry a warning text. The text MAY be in any\n   appropriate natural language (perhaps based on the client's Accept\n   headers), and include an OPTIONAL indication of what character set is\n   used.\n\n   Multiple warnings MAY be attached to a response (either by the origin\n   server or by a cache), including multiple warnings with the same code\n   number. For example, a server might provide the same warning with\n   texts in both English and Basque.\n\n   When multiple warnings are attached to a response, it might not be\n   practical or reasonable to display all of them to the user. This\n   version of HTTP does not specify strict priority rules for deciding\n   which warnings to display and in what order, but does suggest some\n   heuristics.\n\n13.1.3 Cache-control Mechanisms\n\n   The basic cache mechanisms in HTTP/1.1 (server-specified expiration\n   times and validators) are implicit directives to caches. In some\n   cases, a server or client might need to provide explicit directives\n   to the HTTP caches. We use the Cache-Control header for this purpose.\n\n   The Cache-Control header allows a client or server to transmit a\n   variety of directives in either requests or responses. These\n   directives typically override the default caching algorithms. As a\n   general rule, if there is any apparent conflict between header\n   values, the most restrictive interpretation is applied (that is, the\n   one that is most likely to preserve semantic transparency). However,\n\n\n\n\nFielding, et al.            Standards Track                    [Page 77]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   in some cases, cache-control directives are explicitly specified as\n   weakening the approximation of semantic transparency (for example,\n   \"max-stale\" or \"public\").\n\n   The cache-control directives are described in detail in section 14.9.\n\n13.1.4 Explicit User Agent Warnings\n\n   Many user agents make it possible for users to override the basic\n   caching mechanisms. For example, the user agent might allow the user\n   to specify that cached entities (even explicitly stale ones) are\n   never validated. Or the user agent might habitually add \"Cache-\n   Control: max-stale=3600\" to every request. The user agent SHOULD NOT\n   default to either non-transparent behavior, or behavior that results\n   in abnormally ineffective caching, but MAY be explicitly configured\n   to do so by an explicit action of the user.\n\n   If the user has overridden the basic caching mechanisms, the user\n   agent SHOULD explicitly indicate to the user whenever this results in\n   the display of information that might not meet the server's\n   transparency requirements (in particular, if the displayed entity is\n   known to be stale). Since the protocol normally allows the user agent\n   to determine if responses are stale or not, this indication need only\n   be displayed when this actually happens. The indication need not be a\n   dialog box; it could be an icon (for example, a picture of a rotting\n   fish) or some other indicator.\n\n   If the user has overridden the caching mechanisms in a way that would\n   abnormally reduce the effectiveness of caches, the user agent SHOULD\n   continually indicate this state to the user (for example, by a\n   display of a picture of currency in flames) so that the user does not\n   inadvertently consume excess resources or suffer from excessive\n   latency.\n\n13.1.5 Exceptions to the Rules and Warnings\n\n   In some cases, the operator of a cache MAY choose to configure it to\n   return stale responses even when not requested by clients. This\n   decision ought not be made lightly, but may be necessary for reasons\n   of availability or performance, especially when the cache is poorly\n   connected to the origin server. Whenever a cache returns a stale\n   response, it MUST mark it as such (using a Warning header) enabling\n   the client software to alert the user that there might be a potential\n   problem.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 78]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   It also allows the user agent to take steps to obtain a first-hand or\n   fresh response. For this reason, a cache SHOULD NOT return a stale\n   response if the client explicitly requests a first-hand or fresh one,\n   unless it is impossible to comply for technical or policy reasons.\n\n13.1.6 Client-controlled Behavior\n\n   While the origin server (and to a lesser extent, intermediate caches,\n   by their contribution to the age of a response) are the primary\n   source of expiration information, in some cases the client might need\n   to control a cache's decision about whether to return a cached\n   response without validating it. Clients do this using several\n   directives of the Cache-Control header.\n\n   A client's request MAY specify the maximum age it is willing to\n   accept of an unvalidated response; specifying a value of zero forces\n   the cache(s) to revalidate all responses. A client MAY also specify\n   the minimum time remaining before a response expires. Both of these\n   options increase constraints on the behavior of caches, and so cannot\n   further relax the cache's approximation of semantic transparency.\n\n   A client MAY also specify that it will accept stale responses, up to\n   some maximum amount of staleness. This loosens the constraints on the\n   caches, and so might violate the origin server's specified\n   constraints on semantic transparency, but might be necessary to\n   support disconnected operation, or high availability in the face of\n   poor connectivity.\n\n13.2 Expiration Model\n\n13.2.1 Server-Specified Expiration\n\n   HTTP caching works best when caches can entirely avoid making\n   requests to the origin server. The primary mechanism for avoiding\n   requests is for an origin server to provide an explicit expiration\n   time in the future, indicating that a response MAY be used to satisfy\n   subsequent requests. In other words, a cache can return a fresh\n   response without first contacting the server.\n\n   Our expectation is that servers will assign future explicit\n   expiration times to responses in the belief that the entity is not\n   likely to change, in a semantically significant way, before the\n   expiration time is reached. This normally preserves semantic\n   transparency, as long as the server's expiration times are carefully\n   chosen.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 79]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The expiration mechanism applies only to responses taken from a cache\n   and not to first-hand responses forwarded immediately to the\n   requesting client.\n\n   If an origin server wishes to force a semantically transparent cache\n   to validate every request, it MAY assign an explicit expiration time\n   in the past. This means that the response is always stale, and so the\n   cache SHOULD validate it before using it for subsequent requests. See\n   section 14.9.4 for a more restrictive way to force revalidation.\n\n   If an origin server wishes to force any HTTP/1.1 cache, no matter how\n   it is configured, to validate every request, it SHOULD use the \"must-\n   revalidate\" cache-control directive (see section 14.9).\n\n   Servers specify explicit expiration times using either the Expires\n   header, or the max-age directive of the Cache-Control header.\n\n   An expiration time cannot be used to force a user agent to refresh\n   its display or reload a resource; its semantics apply only to caching\n   mechanisms, and such mechanisms need only check a resource's\n   expiration status when a new request for that resource is initiated.\n   See section 13.13 for an explanation of the difference between caches\n   and history mechanisms.\n\n13.2.2 Heuristic Expiration\n\n   Since origin servers do not always provide explicit expiration times,\n   HTTP caches typically assign heuristic expiration times, employing\n   algorithms that use other header values (such as the Last-Modified\n   time) to estimate a plausible expiration time. The HTTP/1.1\n   specification does not provide specific algorithms, but does impose\n   worst-case constraints on their results. Since heuristic expiration\n   times might compromise semantic transparency, they ought to used\n   cautiously, and we encourage origin servers to provide explicit\n   expiration times as much as possible.\n\n13.2.3 Age Calculations\n\n   In order to know if a cached entry is fresh, a cache needs to know if\n   its age exceeds its freshness lifetime. We discuss how to calculate\n   the latter in section 13.2.4; this section describes how to calculate\n   the age of a response or cache entry.\n\n   In this discussion, we use the term \"now\" to mean \"the current value\n   of the clock at the host performing the calculation.\" Hosts that use\n   HTTP, but especially hosts running origin servers and caches, SHOULD\n   use NTP [28] or some similar protocol to synchronize their clocks to\n   a globally accurate time standard.\n\n\n\nFielding, et al.            Standards Track                    [Page 80]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 requires origin servers to send a Date header, if possible,\n   with every response, giving the time at which the response was\n   generated (see section 14.18). We use the term \"date_value\" to denote\n   the value of the Date header, in a form appropriate for arithmetic\n   operations.\n\n   HTTP/1.1 uses the Age response-header to convey the estimated age of\n   the response message when obtained from a cache. The Age field value\n   is the cache's estimate of the amount of time since the response was\n   generated or revalidated by the origin server.\n\n   In essence, the Age value is the sum of the time that the response\n   has been resident in each of the caches along the path from the\n   origin server, plus the amount of time it has been in transit along\n   network paths.\n\n   We use the term \"age_value\" to denote the value of the Age header, in\n   a form appropriate for arithmetic operations.\n\n   A response's age can be calculated in two entirely independent ways:\n\n      1. now minus date_value, if the local clock is reasonably well\n         synchronized to the origin server's clock. If the result is\n         negative, the result is replaced by zero.\n\n      2. age_value, if all of the caches along the response path\n         implement HTTP/1.1.\n\n   Given that we have two independent ways to compute the age of a\n   response when it is received, we can combine these as\n\n       corrected_received_age = max(now - date_value, age_value)\n\n   and as long as we have either nearly synchronized clocks or all-\n   HTTP/1.1 paths, one gets a reliable (conservative) result.\n\n   Because of network-imposed delays, some significant interval might\n   pass between the time that a server generates a response and the time\n   it is received at the next outbound cache or client. If uncorrected,\n   this delay could result in improperly low ages.\n\n   Because the request that resulted in the returned Age value must have\n   been initiated prior to that Age value's generation, we can correct\n   for delays imposed by the network by recording the time at which the\n   request was initiated. Then, when an Age value is received, it MUST\n   be interpreted relative to the time the request was initiated, not\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 81]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the time that the response was received. This algorithm results in\n   conservative behavior no matter how much delay is experienced. So, we\n   compute:\n\n      corrected_initial_age = corrected_received_age\n                            + (now - request_time)\n\n   where \"request_time\" is the time (according to the local clock) when\n   the request that elicited this response was sent.\n\n   Summary of age calculation algorithm, when a cache receives a\n   response:\n\n      /*\n       * age_value\n       *      is the value of Age: header received by the cache with\n       *              this response.\n       * date_value\n       *      is the value of the origin server's Date: header\n       * request_time\n       *      is the (local) time when the cache made the request\n       *              that resulted in this cached response\n       * response_time\n       *      is the (local) time when the cache received the\n       *              response\n       * now\n       *      is the current (local) time\n       */\n\n      apparent_age = max(0, response_time - date_value);\n      corrected_received_age = max(apparent_age, age_value);\n      response_delay = response_time - request_time;\n      corrected_initial_age = corrected_received_age + response_delay;\n      resident_time = now - response_time;\n      current_age   = corrected_initial_age + resident_time;\n\n   The current_age of a cache entry is calculated by adding the amount\n   of time (in seconds) since the cache entry was last validated by the\n   origin server to the corrected_initial_age. When a response is\n   generated from a cache entry, the cache MUST include a single Age\n   header field in the response with a value equal to the cache entry's\n   current_age.\n\n   The presence of an Age header field in a response implies that a\n   response is not first-hand. However, the converse is not true, since\n   the lack of an Age header field in a response does not imply that the\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 82]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   response is first-hand unless all caches along the request path are\n   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement\n   the Age header field).\n\n13.2.4 Expiration Calculations\n\n   In order to decide whether a response is fresh or stale, we need to\n   compare its freshness lifetime to its age. The age is calculated as\n   described in section 13.2.3; this section describes how to calculate\n   the freshness lifetime, and to determine if a response has expired.\n   In the discussion below, the values can be represented in any form\n   appropriate for arithmetic operations.\n\n   We use the term \"expires_value\" to denote the value of the Expires\n   header. We use the term \"max_age_value\" to denote an appropriate\n   value of the number of seconds carried by the \"max-age\" directive of\n   the Cache-Control header in a response (see section 14.9.3).\n\n   The max-age directive takes priority over Expires, so if max-age is\n   present in a response, the calculation is simply:\n\n      freshness_lifetime = max_age_value\n\n   Otherwise, if Expires is present in the response, the calculation is:\n\n      freshness_lifetime = expires_value - date_value\n\n   Note that neither of these calculations is vulnerable to clock skew,\n   since all of the information comes from the origin server.\n\n   If none of Expires, Cache-Control: max-age, or Cache-Control: s-\n   maxage (see section 14.9.3) appears in the response, and the response\n   does not include other restrictions on caching, the cache MAY compute\n   a freshness lifetime using a heuristic. The cache MUST attach Warning\n   113 to any response whose age is more than 24 hours if such warning\n   has not already been added.\n\n   Also, if the response does have a Last-Modified time, the heuristic\n   expiration value SHOULD be no more than some fraction of the interval\n   since that time. A typical setting of this fraction might be 10%.\n\n   The calculation to determine if a response has expired is quite\n   simple:\n\n      response_is_fresh = (freshness_lifetime > current_age)\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 83]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.2.5 Disambiguating Expiration Values\n\n   Because expiration values are assigned optimistically, it is possible\n   for two caches to contain fresh values for the same resource that are\n   different.\n\n   If a client performing a retrieval receives a non-first-hand response\n   for a request that was already fresh in its own cache, and the Date\n   header in its existing cache entry is newer than the Date on the new\n   response, then the client MAY ignore the response. If so, it MAY\n   retry the request with a \"Cache-Control: max-age=0\" directive (see\n   section 14.9), to force a check with the origin server.\n\n   If a cache has two fresh responses for the same representation with\n   different validators, it MUST use the one with the more recent Date\n   header. This situation might arise because the cache is pooling\n   responses from other caches, or because a client has asked for a\n   reload or a revalidation of an apparently fresh cache entry.\n\n13.2.6 Disambiguating Multiple Responses\n\n   Because a client might be receiving responses via multiple paths, so\n   that some responses flow through one set of caches and other\n   responses flow through a different set of caches, a client might\n   receive responses in an order different from that in which the origin\n   server sent them. We would like the client to use the most recently\n   generated response, even if older responses are still apparently\n   fresh.\n\n   Neither the entity tag nor the expiration value can impose an\n   ordering on responses, since it is possible that a later response\n   intentionally carries an earlier expiration time. The Date values are\n   ordered to a granularity of one second.\n\n   When a client tries to revalidate a cache entry, and the response it\n   receives contains a Date header that appears to be older than the one\n   for the existing entry, then the client SHOULD repeat the request\n   unconditionally, and include\n\n       Cache-Control: max-age=0\n\n   to force any intermediate caches to validate their copies directly\n   with the origin server, or\n\n       Cache-Control: no-cache\n\n   to force any intermediate caches to obtain a new copy from the origin\n   server.\n\n\n\nFielding, et al.            Standards Track                    [Page 84]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the Date values are equal, then the client MAY use either response\n   (or MAY, if it is being extremely prudent, request a new response).\n   Servers MUST NOT depend on clients being able to choose\n   deterministically between responses generated during the same second,\n   if their expiration times overlap.\n\n13.3 Validation Model\n\n   When a cache has a stale entry that it would like to use as a\n   response to a client's request, it first has to check with the origin\n   server (or possibly an intermediate cache with a fresh response) to\n   see if its cached entry is still usable. We call this \"validating\"\n   the cache entry. Since we do not want to have to pay the overhead of\n   retransmitting the full response if the cached entry is good, and we\n   do not want to pay the overhead of an extra round trip if the cached\n   entry is invalid, the HTTP/1.1 protocol supports the use of\n   conditional methods.\n\n   The key protocol features for supporting conditional methods are\n   those concerned with \"cache validators.\" When an origin server\n   generates a full response, it attaches some sort of validator to it,\n   which is kept with the cache entry. When a client (user agent or\n   proxy cache) makes a conditional request for a resource for which it\n   has a cache entry, it includes the associated validator in the\n   request.\n\n   The server then checks that validator against the current validator\n   for the entity, and, if they match (see section 13.3.3), it responds\n   with a special status code (usually, 304 (Not Modified)) and no\n   entity-body. Otherwise, it returns a full response (including\n   entity-body). Thus, we avoid transmitting the full response if the\n   validator matches, and we avoid an extra round trip if it does not\n   match.\n\n   In HTTP/1.1, a conditional request looks exactly the same as a normal\n   request for the same resource, except that it carries a special\n   header (which includes the validator) that implicitly turns the\n   method (usually, GET) into a conditional.\n\n   The protocol includes both positive and negative senses of cache-\n   validating conditions. That is, it is possible to request either that\n   a method be performed if and only if a validator matches or if and\n   only if no validators match.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 85]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      Note: a response that lacks a validator may still be cached, and\n      served from cache until it expires, unless this is explicitly\n      prohibited by a cache-control directive. However, a cache cannot\n      do a conditional retrieval if it does not have a validator for the\n      entity, which means it will not be refreshable after it expires.\n\n13.3.1 Last-Modified Dates\n\n   The Last-Modified entity-header field value is often used as a cache\n   validator. In simple terms, a cache entry is considered to be valid\n   if the entity has not been modified since the Last-Modified value.\n\n13.3.2 Entity Tag Cache Validators\n\n   The ETag response-header field value, an entity tag, provides for an\n   \"opaque\" cache validator. This might allow more reliable validation\n   in situations where it is inconvenient to store modification dates,\n   where the one-second resolution of HTTP date values is not\n   sufficient, or where the origin server wishes to avoid certain\n   paradoxes that might arise from the use of modification dates.\n\n   Entity Tags are described in section 3.11. The headers used with\n   entity tags are described in sections 14.19, 14.24, 14.26 and 14.44.\n\n13.3.3 Weak and Strong Validators\n\n   Since both origin servers and caches will compare two validators to\n   decide if they represent the same or different entities, one normally\n   would expect that if the entity (the entity-body or any entity-\n   headers) changes in any way, then the associated validator would\n   change as well. If this is true, then we call this validator a\n   \"strong validator.\"\n\n   However, there might be cases when a server prefers to change the\n   validator only on semantically significant changes, and not when\n   insignificant aspects of the entity change. A validator that does not\n   always change when the resource changes is a \"weak validator.\"\n\n   Entity tags are normally \"strong validators,\" but the protocol\n   provides a mechanism to tag an entity tag as \"weak.\" One can think of\n   a strong validator as one that changes whenever the bits of an entity\n   changes, while a weak value changes whenever the meaning of an entity\n   changes. Alternatively, one can think of a strong validator as part\n   of an identifier for a specific entity, while a weak validator is\n   part of an identifier for a set of semantically equivalent entities.\n\n      Note: One example of a strong validator is an integer that is\n      incremented in stable storage every time an entity is changed.\n\n\n\nFielding, et al.            Standards Track                    [Page 86]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      An entity's modification time, if represented with one-second\n      resolution, could be a weak validator, since it is possible that\n      the resource might be modified twice during a single second.\n\n      Support for weak validators is optional. However, weak validators\n      allow for more efficient caching of equivalent objects; for\n      example, a hit counter on a site is probably good enough if it is\n      updated every few days or weeks, and any value during that period\n      is likely \"good enough\" to be equivalent.\n\n   A \"use\" of a validator is either when a client generates a request\n   and includes the validator in a validating header field, or when a\n   server compares two validators.\n\n   Strong validators are usable in any context. Weak validators are only\n   usable in contexts that do not depend on exact equality of an entity.\n   For example, either kind is usable for a conditional GET of a full\n   entity. However, only a strong validator is usable for a sub-range\n   retrieval, since otherwise the client might end up with an internally\n   inconsistent entity.\n\n   Clients MAY issue simple (non-subrange) GET requests with either weak\n   validators or strong validators. Clients MUST NOT use weak validators\n   in other forms of request.\n\n   The only function that the HTTP/1.1 protocol defines on validators is\n   comparison. There are two validator comparison functions, depending\n   on whether the comparison context allows the use of weak validators\n   or not:\n\n      - The strong comparison function: in order to be considered equal,\n        both validators MUST be identical in every way, and both MUST\n        NOT be weak.\n\n      - The weak comparison function: in order to be considered equal,\n        both validators MUST be identical in every way, but either or\n        both of them MAY be tagged as \"weak\" without affecting the\n        result.\n\n   An entity tag is strong unless it is explicitly tagged as weak.\n   Section 3.11 gives the syntax for entity tags.\n\n   A Last-Modified time, when used as a validator in a request, is\n   implicitly weak unless it is possible to deduce that it is strong,\n   using the following rules:\n\n      - The validator is being compared by an origin server to the\n        actual current validator for the entity and,\n\n\n\nFielding, et al.            Standards Track                    [Page 87]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - That origin server reliably knows that the associated entity did\n        not change twice during the second covered by the presented\n        validator.\n\n   or\n\n      - The validator is about to be used by a client in an If-\n        Modified-Since or If-Unmodified-Since header, because the client\n        has a cache entry for the associated entity, and\n\n      - That cache entry includes a Date value, which gives the time\n        when the origin server sent the original response, and\n\n      - The presented Last-Modified time is at least 60 seconds before\n        the Date value.\n\n   or\n\n      - The validator is being compared by an intermediate cache to the\n        validator stored in its cache entry for the entity, and\n\n      - That cache entry includes a Date value, which gives the time\n        when the origin server sent the original response, and\n\n      - The presented Last-Modified time is at least 60 seconds before\n        the Date value.\n\n   This method relies on the fact that if two different responses were\n   sent by the origin server during the same second, but both had the\n   same Last-Modified time, then at least one of those responses would\n   have a Date value equal to its Last-Modified time. The arbitrary 60-\n   second limit guards against the possibility that the Date and Last-\n   Modified values are generated from different clocks, or at somewhat\n   different times during the preparation of the response. An\n   implementation MAY use a value larger than 60 seconds, if it is\n   believed that 60 seconds is too short.\n\n   If a client wishes to perform a sub-range retrieval on a value for\n   which it has only a Last-Modified time and no opaque validator, it\n   MAY do this only if the Last-Modified time is strong in the sense\n   described here.\n\n   A cache or origin server receiving a conditional request, other than\n   a full-body GET request, MUST use the strong comparison function to\n   evaluate the condition.\n\n   These rules allow HTTP/1.1 caches and clients to safely perform sub-\n   range retrievals on values that have been obtained from HTTP/1.0\n\n\n\nFielding, et al.            Standards Track                    [Page 88]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   servers.\n\n13.3.4 Rules for When to Use Entity Tags and Last-Modified Dates\n\n   We adopt a set of rules and recommendations for origin servers,\n   clients, and caches regarding when various validator types ought to\n   be used, and for what purposes.\n\n   HTTP/1.1 origin servers:\n\n      - SHOULD send an entity tag validator unless it is not feasible to\n        generate one.\n\n      - MAY send a weak entity tag instead of a strong entity tag, if\n        performance considerations support the use of weak entity tags,\n        or if it is unfeasible to send a strong entity tag.\n\n      - SHOULD send a Last-Modified value if it is feasible to send one,\n        unless the risk of a breakdown in semantic transparency that\n        could result from using this date in an If-Modified-Since header\n        would lead to serious problems.\n\n   In other words, the preferred behavior for an HTTP/1.1 origin server\n   is to send both a strong entity tag and a Last-Modified value.\n\n   In order to be legal, a strong entity tag MUST change whenever the\n   associated entity value changes in any way. A weak entity tag SHOULD\n   change whenever the associated entity changes in a semantically\n   significant way.\n\n      Note: in order to provide semantically transparent caching, an\n      origin server must avoid reusing a specific strong entity tag\n      value for two different entities, or reusing a specific weak\n      entity tag value for two semantically different entities. Cache\n      entries might persist for arbitrarily long periods, regardless of\n      expiration times, so it might be inappropriate to expect that a\n      cache will never again attempt to validate an entry using a\n      validator that it obtained at some point in the past.\n\n   HTTP/1.1 clients:\n\n      - If an entity tag has been provided by the origin server, MUST\n        use that entity tag in any cache-conditional request (using If-\n        Match or If-None-Match).\n\n      - If only a Last-Modified value has been provided by the origin\n        server, SHOULD use that value in non-subrange cache-conditional\n        requests (using If-Modified-Since).\n\n\n\nFielding, et al.            Standards Track                    [Page 89]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If only a Last-Modified value has been provided by an HTTP/1.0\n        origin server, MAY use that value in subrange cache-conditional\n        requests (using If-Unmodified-Since:). The user agent SHOULD\n        provide a way to disable this, in case of difficulty.\n\n      - If both an entity tag and a Last-Modified value have been\n        provided by the origin server, SHOULD use both validators in\n        cache-conditional requests. This allows both HTTP/1.0 and\n        HTTP/1.1 caches to respond appropriately.\n\n   An HTTP/1.1 origin server, upon receiving a conditional request that\n   includes both a Last-Modified date (e.g., in an If-Modified-Since or\n   If-Unmodified-Since header field) and one or more entity tags (e.g.,\n   in an If-Match, If-None-Match, or If-Range header field) as cache\n   validators, MUST NOT return a response status of 304 (Not Modified)\n   unless doing so is consistent with all of the conditional header\n   fields in the request.\n\n   An HTTP/1.1 caching proxy, upon receiving a conditional request that\n   includes both a Last-Modified date and one or more entity tags as\n   cache validators, MUST NOT return a locally cached response to the\n   client unless that cached response is consistent with all of the\n   conditional header fields in the request.\n\n      Note: The general principle behind these rules is that HTTP/1.1\n      servers and clients should transmit as much non-redundant\n      information as is available in their responses and requests.\n      HTTP/1.1 systems receiving this information will make the most\n      conservative assumptions about the validators they receive.\n\n      HTTP/1.0 clients and caches will ignore entity tags. Generally,\n      last-modified values received or used by these systems will\n      support transparent and efficient caching, and so HTTP/1.1 origin\n      servers should provide Last-Modified values. In those rare cases\n      where the use of a Last-Modified value as a validator by an\n      HTTP/1.0 system could result in a serious problem, then HTTP/1.1\n      origin servers should not provide one.\n\n13.3.5 Non-validating Conditionals\n\n   The principle behind entity tags is that only the service author\n   knows the semantics of a resource well enough to select an\n   appropriate cache validation mechanism, and the specification of any\n   validator comparison function more complex than byte-equality would\n   open up a can of worms. Thus, comparisons of any other headers\n   (except Last-Modified, for compatibility with HTTP/1.0) are never\n   used for purposes of validating a cache entry.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 90]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.4 Response Cacheability\n\n   Unless specifically constrained by a cache-control (section 14.9)\n   directive, a caching system MAY always store a successful response\n   (see section 13.8) as a cache entry, MAY return it without validation\n   if it is fresh, and MAY return it after successful validation. If\n   there is neither a cache validator nor an explicit expiration time\n   associated with a response, we do not expect it to be cached, but\n   certain caches MAY violate this expectation (for example, when little\n   or no network connectivity is available). A client can usually detect\n   that such a response was taken from a cache by comparing the Date\n   header to the current time.\n\n      Note: some HTTP/1.0 caches are known to violate this expectation\n      without providing any Warning.\n\n   However, in some cases it might be inappropriate for a cache to\n   retain an entity, or to return it in response to a subsequent\n   request. This might be because absolute semantic transparency is\n   deemed necessary by the service author, or because of security or\n   privacy considerations. Certain cache-control directives are\n   therefore provided so that the server can indicate that certain\n   resource entities, or portions thereof, are not to be cached\n   regardless of other considerations.\n\n   Note that section 14.8 normally prevents a shared cache from saving\n   and returning a response to a previous request if that request\n   included an Authorization header.\n\n   A response received with a status code of 200, 203, 206, 300, 301 or\n   410 MAY be stored by a cache and used in reply to a subsequent\n   request, subject to the expiration mechanism, unless a cache-control\n   directive prohibits caching. However, a cache that does not support\n   the Range and Content-Range headers MUST NOT cache 206 (Partial\n   Content) responses.\n\n   A response received with any other status code (e.g. status codes 302\n   and 307) MUST NOT be returned in a reply to a subsequent request\n   unless there are cache-control directives or another header(s) that\n   explicitly allow it. For example, these include the following: an\n   Expires header (section 14.21); a \"max-age\", \"s-maxage\",  \"must-\n   revalidate\", \"proxy-revalidate\", \"public\" or \"private\" cache-control\n   directive (section 14.9).\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 91]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5 Constructing Responses From Caches\n\n   The purpose of an HTTP cache is to store information received in\n   response to requests for use in responding to future requests. In\n   many cases, a cache simply returns the appropriate parts of a\n   response to the requester. However, if the cache holds a cache entry\n   based on a previous response, it might have to combine parts of a new\n   response with what is held in the cache entry.\n\n13.5.1 End-to-end and Hop-by-hop Headers\n\n   For the purpose of defining the behavior of caches and non-caching\n   proxies, we divide HTTP headers into two categories:\n\n      - End-to-end headers, which are  transmitted to the ultimate\n        recipient of a request or response. End-to-end headers in\n        responses MUST be stored as part of a cache entry and MUST be\n        transmitted in any response formed from a cache entry.\n\n      - Hop-by-hop headers, which are meaningful only for a single\n        transport-level connection, and are not stored by caches or\n        forwarded by proxies.\n\n   The following HTTP/1.1 headers are hop-by-hop headers:\n\n      - Connection\n      - Keep-Alive\n      - Proxy-Authenticate\n      - Proxy-Authorization\n      - TE\n      - Trailers\n      - Transfer-Encoding\n      - Upgrade\n\n   All other headers defined by HTTP/1.1 are end-to-end headers.\n\n   Other hop-by-hop headers MUST be listed in a Connection header,\n   (section 14.10) to be introduced into HTTP/1.1 (or later).\n\n13.5.2 Non-modifiable Headers\n\n   Some features of the HTTP/1.1 protocol, such as Digest\n   Authentication, depend on the value of certain end-to-end headers. A\n   transparent proxy SHOULD NOT modify an end-to-end header unless the\n   definition of that header requires or specifically allows that.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 92]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A transparent proxy MUST NOT modify any of the following fields in a\n   request or response, and it MUST NOT add any of these fields if not\n   already present:\n\n      - Content-Location\n\n      - Content-MD5\n\n      - ETag\n\n      - Last-Modified\n\n   A transparent proxy MUST NOT modify any of the following fields in a\n   response:\n\n      - Expires\n\n   but it MAY add any of these fields if not already present. If an\n   Expires header is added, it MUST be given a field-value identical to\n   that of the Date header in that response.\n\n   A  proxy MUST NOT modify or add any of the following fields in a\n   message that contains the no-transform cache-control directive, or in\n   any request:\n\n      - Content-Encoding\n\n      - Content-Range\n\n      - Content-Type\n\n   A non-transparent proxy MAY modify or add these fields to a message\n   that does not include no-transform, but if it does so, it MUST add a\n   Warning 214 (Transformation applied) if one does not already appear\n   in the message (see section 14.46).\n\n      Warning: unnecessary modification of end-to-end headers might\n      cause authentication failures if stronger authentication\n      mechanisms are introduced in later versions of HTTP. Such\n      authentication mechanisms MAY rely on the values of header fields\n      not listed here.\n\n   The Content-Length field of a request or response is added or deleted\n   according to the rules in section 4.4. A transparent proxy MUST\n   preserve the entity-length (section 7.2.2) of the entity-body,\n   although it MAY change the transfer-length (section 4.4).\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 93]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5.3 Combining Headers\n\n   When a cache makes a validating request to a server, and the server\n   provides a 304 (Not Modified) response or a 206 (Partial Content)\n   response, the cache then constructs a response to send to the\n   requesting client.\n\n   If the status code is 304 (Not Modified), the cache uses the entity-\n   body stored in the cache entry as the entity-body of this outgoing\n   response. If the status code is 206 (Partial Content) and the ETag or\n   Last-Modified headers match exactly, the cache MAY combine the\n   contents stored in the cache entry with the new contents received in\n   the response and use the result as the entity-body of this outgoing\n   response, (see 13.5.4).\n\n   The end-to-end headers stored in the cache entry are used for the\n   constructed response, except that\n\n      - any stored Warning headers with warn-code 1xx (see section\n        14.46) MUST be deleted from the cache entry and the forwarded\n        response.\n\n      - any stored Warning headers with warn-code 2xx MUST be retained\n        in the cache entry and the forwarded response.\n\n      - any end-to-end headers provided in the 304 or 206 response MUST\n        replace the corresponding headers from the cache entry.\n\n   Unless the cache decides to remove the cache entry, it MUST also\n   replace the end-to-end headers stored with the cache entry with\n   corresponding headers received in the incoming response, except for\n   Warning headers as described immediately above. If a header field-\n   name in the incoming response matches more than one header in the\n   cache entry, all such old headers MUST be replaced.\n\n   In other words, the set of end-to-end headers received in the\n   incoming response overrides all corresponding end-to-end headers\n   stored with the cache entry (except for stored Warning headers with\n   warn-code 1xx, which are deleted even if not overridden).\n\n      Note: this rule allows an origin server to use a 304 (Not\n      Modified) or a 206 (Partial Content) response to update any header\n      associated with a previous response for the same entity or sub-\n      ranges thereof, although it might not always be meaningful or\n      correct to do so. This rule does not allow an origin server to use\n      a 304 (Not Modified) or a 206 (Partial Content) response to\n      entirely delete a header that it had provided with a previous\n      response.\n\n\n\nFielding, et al.            Standards Track                    [Page 94]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5.4 Combining Byte Ranges\n\n   A response might transfer only a subrange of the bytes of an entity-\n   body, either because the request included one or more Range\n   specifications, or because a connection was broken prematurely. After\n   several such transfers, a cache might have received several ranges of\n   the same entity-body.\n\n   If a cache has a stored non-empty set of subranges for an entity, and\n   an incoming response transfers another subrange, the cache MAY\n   combine the new subrange with the existing set if both the following\n   conditions are met:\n\n      - Both the incoming response and the cache entry have a cache\n        validator.\n\n      - The two cache validators match using the strong comparison\n        function (see section 13.3.3).\n\n   If either requirement is not met, the cache MUST use only the most\n   recent partial response (based on the Date values transmitted with\n   every response, and using the incoming response if these values are\n   equal or missing), and MUST discard the other partial information.\n\n13.6 Caching Negotiated Responses\n\n   Use of server-driven content negotiation (section 12.1), as indicated\n   by the presence of a Vary header field in a response, alters the\n   conditions and procedure by which a cache can use the response for\n   subsequent requests. See section 14.44 for use of the Vary header\n   field by servers.\n\n   A server SHOULD use the Vary header field to inform a cache of what\n   request-header fields were used to select among multiple\n   representations of a cacheable response subject to server-driven\n   negotiation. The set of header fields named by the Vary field value\n   is known as the \"selecting\" request-headers.\n\n   When the cache receives a subsequent request whose Request-URI\n   specifies one or more cache entries including a Vary header field,\n   the cache MUST NOT use such a cache entry to construct a response to\n   the new request unless all of the selecting request-headers present\n   in the new request match the corresponding stored request-headers in\n   the original request.\n\n   The selecting request-headers from two requests are defined to match\n   if and only if the selecting request-headers in the first request can\n   be transformed to the selecting request-headers in the second request\n\n\n\nFielding, et al.            Standards Track                    [Page 95]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   by adding or removing linear white space (LWS) at places where this\n   is allowed by the corresponding BNF, and/or combining multiple\n   message-header fields with the same field name following the rules\n   about message headers in section 4.2.\n\n   A Vary header field-value of \"*\" always fails to match and subsequent\n   requests on that resource can only be properly interpreted by the\n   origin server.\n\n   If the selecting request header fields for the cached entry do not\n   match the selecting request header fields of the new request, then\n   the cache MUST NOT use a cached entry to satisfy the request unless\n   it first relays the new request to the origin server in a conditional\n   request and the server responds with 304 (Not Modified), including an\n   entity tag or Content-Location that indicates the entity to be used.\n\n   If an entity tag was assigned to a cached representation, the\n   forwarded request SHOULD be conditional and include the entity tags\n   in an If-None-Match header field from all its cache entries for the\n   resource. This conveys to the server the set of entities currently\n   held by the cache, so that if any one of these entities matches the\n   requested entity, the server can use the ETag header field in its 304\n   (Not Modified) response to tell the cache which entry is appropriate.\n   If the entity-tag of the new response matches that of an existing\n   entry, the new response SHOULD be used to update the header fields of\n   the existing entry, and the result MUST be returned to the client.\n\n   If any of the existing cache entries contains only partial content\n   for the associated entity, its entity-tag SHOULD NOT be included in\n   the If-None-Match header field unless the request is for a range that\n   would be fully satisfied by that entry.\n\n   If a cache receives a successful response whose Content-Location\n   field matches that of an existing cache entry for the same Request-\n   ]URI, whose entity-tag differs from that of the existing entry, and\n   whose Date is more recent than that of the existing entry, the\n   existing entry SHOULD NOT be returned in response to future requests\n   and SHOULD be deleted from the cache.\n\n13.7 Shared and Non-Shared Caches\n\n   For reasons of security and privacy, it is necessary to make a\n   distinction between \"shared\" and \"non-shared\" caches. A non-shared\n   cache is one that is accessible only to a single user. Accessibility\n   in this case SHOULD be enforced by appropriate security mechanisms.\n   All other caches are considered to be \"shared.\" Other sections of\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 96]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   this specification place certain constraints on the operation of\n   shared caches in order to prevent loss of privacy or failure of\n   access controls.\n\n13.8 Errors or Incomplete Response Cache Behavior\n\n   A cache that receives an incomplete response (for example, with fewer\n   bytes of data than specified in a Content-Length header) MAY store\n   the response. However, the cache MUST treat this as a partial\n   response. Partial responses MAY be combined as described in section\n   13.5.4; the result might be a full response or might still be\n   partial. A cache MUST NOT return a partial response to a client\n   without explicitly marking it as such, using the 206 (Partial\n   Content) status code. A cache MUST NOT return a partial response\n   using a status code of 200 (OK).\n\n   If a cache receives a 5xx response while attempting to revalidate an\n   entry, it MAY either forward this response to the requesting client,\n   or act as if the server failed to respond. In the latter case, it MAY\n   return a previously received response unless the cached entry\n   includes the \"must-revalidate\" cache-control directive (see section\n   14.9).\n\n13.9 Side Effects of GET and HEAD\n\n   Unless the origin server explicitly prohibits the caching of their\n   responses, the application of GET and HEAD methods to any resources\n   SHOULD NOT have side effects that would lead to erroneous behavior if\n   these responses are taken from a cache. They MAY still have side\n   effects, but a cache is not required to consider such side effects in\n   its caching decisions. Caches are always expected to observe an\n   origin server's explicit restrictions on caching.\n\n   We note one exception to this rule: since some applications have\n   traditionally used GETs and HEADs with query URLs (those containing a\n   \"?\" in the rel_path part) to perform operations with significant side\n   effects, caches MUST NOT treat responses to such URIs as fresh unless\n   the server provides an explicit expiration time. This specifically\n   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT\n   be taken from a cache. See section 9.1.1 for related information.\n\n13.10 Invalidation After Updates or Deletions\n\n   The effect of certain methods performed on a resource at the origin\n   server might cause one or more existing cache entries to become non-\n   transparently invalid. That is, although they might continue to be\n   \"fresh,\" they do not accurately reflect what the origin server would\n   return for a new request on that resource.\n\n\n\nFielding, et al.            Standards Track                    [Page 97]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   There is no way for the HTTP protocol to guarantee that all such\n   cache entries are marked invalid. For example, the request that\n   caused the change at the origin server might not have gone through\n   the proxy where a cache entry is stored. However, several rules help\n   reduce the likelihood of erroneous behavior.\n\n   In this section, the phrase \"invalidate an entity\" means that the\n   cache will either remove all instances of that entity from its\n   storage, or will mark these as \"invalid\" and in need of a mandatory\n   revalidation before they can be returned in response to a subsequent\n   request.\n\n   Some HTTP methods MUST cause a cache to invalidate an entity. This is\n   either the entity referred to by the Request-URI, or by the Location\n   or Content-Location headers (if present). These methods are:\n\n      - PUT\n\n      - DELETE\n\n      - POST\n\n   In order to prevent denial of service attacks, an invalidation based\n   on the URI in a Location or Content-Location header MUST only be\n   performed if the host part is the same as in the Request-URI.\n\n   A cache that passes through requests for methods it does not\n   understand SHOULD invalidate any entities referred to by the\n   Request-URI.\n\n13.11 Write-Through Mandatory\n\n   All methods that might be expected to cause modifications to the\n   origin server's resources MUST be written through to the origin\n   server. This currently includes all methods except for GET and HEAD.\n   A cache MUST NOT reply to such a request from a client before having\n   transmitted the request to the inbound server, and having received a\n   corresponding response from the inbound server. This does not prevent\n   a proxy cache from sending a 100 (Continue) response before the\n   inbound server has sent its final reply.\n\n   The alternative (known as \"write-back\" or \"copy-back\" caching) is not\n   allowed in HTTP/1.1, due to the difficulty of providing consistent\n   updates and the problems arising from server, cache, or network\n   failure prior to write-back.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 98]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.12 Cache Replacement\n\n   If a new cacheable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8)\n   response is received from a resource while any existing responses for\n   the same resource are cached, the cache SHOULD use the new response\n   to reply to the current request. It MAY insert it into cache storage\n   and MAY, if it meets all other requirements, use it to respond to any\n   future requests that would previously have caused the old response to\n   be returned. If it inserts the new response into cache storage  the\n   rules in section 13.5.3 apply.\n\n      Note: a new response that has an older Date header value than\n      existing cached responses is not cacheable.\n\n13.13 History Lists\n\n   User agents often have history mechanisms, such as \"Back\" buttons and\n   history lists, which can be used to redisplay an entity retrieved\n   earlier in a session.\n\n   History mechanisms and caches are different. In particular history\n   mechanisms SHOULD NOT try to show a semantically transparent view of\n   the current state of a resource. Rather, a history mechanism is meant\n   to show exactly what the user saw at the time when the resource was\n   retrieved.\n\n   By default, an expiration time does not apply to history mechanisms.\n   If the entity is still in storage, a history mechanism SHOULD display\n   it even if the entity has expired, unless the user has specifically\n   configured the agent to refresh expired history documents.\n\n   This is not to be construed to prohibit the history mechanism from\n   telling the user that a view might be stale.\n\n      Note: if history list mechanisms unnecessarily prevent users from\n      viewing stale resources, this will tend to force service authors\n      to avoid using HTTP expiration controls and cache controls when\n      they would otherwise like to. Service authors may consider it\n      important that users not be presented with error messages or\n      warning messages when they use navigation controls (such as BACK)\n      to view previously fetched resources. Even though sometimes such\n      resources ought not to cached, or ought to expire quickly, user\n      interface considerations may force service authors to resort to\n      other means of preventing caching (e.g. \"once-only\" URLs) in order\n      not to suffer the effects of improperly functioning history\n      mechanisms.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 99]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14 Header Field Definitions\n\n   This section defines the syntax and semantics of all standard\n   HTTP/1.1 header fields. For entity-header fields, both sender and\n   recipient refer to either the client or the server, depending on who\n   sends and who receives the entity.\n\n14.1 Accept\n\n   The Accept request-header field can be used to specify certain media\n   types which are acceptable for the response. Accept headers can be\n   used to indicate that the request is specifically limited to a small\n   set of desired types, as in the case of a request for an in-line\n   image.\n\n       Accept         = \"Accept\" \":\"\n                        #( media-range [ accept-params ] )\n\n       media-range    = ( \"*/*\"\n                        | ( type \"/\" \"*\" )\n                        | ( type \"/\" subtype )\n                        ) *( \";\" parameter )\n       accept-params  = \";\" \"q\" \"=\" qvalue *( accept-extension )\n       accept-extension = \";\" token [ \"=\" ( token | quoted-string ) ]\n\n   The asterisk \"*\" character is used to group media types into ranges,\n   with \"*/*\" indicating all media types and \"type/*\" indicating all\n   subtypes of that type. The media-range MAY include media type\n   parameters that are applicable to that range.\n\n   Each media-range MAY be followed by one or more accept-params,\n   beginning with the \"q\" parameter for indicating a relative quality\n   factor. The first \"q\" parameter (if any) separates the media-range\n   parameter(s) from the accept-params. Quality factors allow the user\n   or user agent to indicate the relative degree of preference for that\n   media-range, using the qvalue scale from 0 to 1 (section 3.9). The\n   default value is q=1.\n\n      Note: Use of the \"q\" parameter name to separate media type\n      parameters from Accept extension parameters is due to historical\n      practice. Although this prevents any media type parameter named\n      \"q\" from being used with a media range, such an event is believed\n      to be unlikely given the lack of any \"q\" parameters in the IANA\n      media type registry and the rare usage of any media type\n      parameters in Accept. Future media types are discouraged from\n      registering any parameter named \"q\".\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 100]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The example\n\n       Accept: audio/*; q=0.2, audio/basic\n\n   SHOULD be interpreted as \"I prefer audio/basic, but send me any audio\n   type if it is the best available after an 80% mark-down in quality.\"\n\n   If no Accept header field is present, then it is assumed that the\n   client accepts all media types. If an Accept header field is present,\n   and if the server cannot send a response which is acceptable\n   according to the combined Accept field value, then the server SHOULD\n   send a 406 (not acceptable) response.\n\n   A more elaborate example is\n\n       Accept: text/plain; q=0.5, text/html,\n               text/x-dvi; q=0.8, text/x-c\n\n   Verbally, this would be interpreted as \"text/html and text/x-c are\n   the preferred media types, but if they do not exist, then send the\n   text/x-dvi entity, and if that does not exist, send the text/plain\n   entity.\"\n\n   Media ranges can be overridden by more specific media ranges or\n   specific media types. If more than one media range applies to a given\n   type, the most specific reference has precedence. For example,\n\n       Accept: text/*, text/html, text/html;level=1, */*\n\n   have the following precedence:\n\n       1) text/html;level=1\n       2) text/html\n       3) text/*\n       4) */*\n\n   The media type quality factor associated with a given type is\n   determined by finding the media range with the highest precedence\n   which matches that type. For example,\n\n       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,\n               text/html;level=2;q=0.4, */*;q=0.5\n\n   would cause the following values to be associated:\n\n       text/html;level=1         = 1\n       text/html                 = 0.7\n       text/plain                = 0.3\n\n\n\nFielding, et al.            Standards Track                   [Page 101]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       image/jpeg                = 0.5\n       text/html;level=2         = 0.4\n       text/html;level=3         = 0.7\n\n      Note: A user agent might be provided with a default set of quality\n      values for certain media ranges. However, unless the user agent is\n      a closed system which cannot interact with other rendering agents,\n      this default set ought to be configurable by the user.\n\n14.2 Accept-Charset\n\n   The Accept-Charset request-header field can be used to indicate what\n   character sets are acceptable for the response. This field allows\n   clients capable of understanding more comprehensive or special-\n   purpose character sets to signal that capability to a server which is\n   capable of representing documents in those character sets.\n\n      Accept-Charset = \"Accept-Charset\" \":\"\n              1#( ( charset | \"*\" )[ \";\" \"q\" \"=\" qvalue ] )\n\n\n   Character set values are described in section 3.4. Each charset MAY\n   be given an associated quality value which represents the user's\n   preference for that charset. The default value is q=1. An example is\n\n      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n\n   The special value \"*\", if present in the Accept-Charset field,\n   matches every character set (including ISO-8859-1) which is not\n   mentioned elsewhere in the Accept-Charset field. If no \"*\" is present\n   in an Accept-Charset field, then all character sets not explicitly\n   mentioned get a quality value of 0, except for ISO-8859-1, which gets\n   a quality value of 1 if not explicitly mentioned.\n\n   If no Accept-Charset header is present, the default is that any\n   character set is acceptable. If an Accept-Charset header is present,\n   and if the server cannot send a response which is acceptable\n   according to the Accept-Charset header, then the server SHOULD send\n   an error response with the 406 (not acceptable) status code, though\n   the sending of an unacceptable response is also allowed.\n\n14.3 Accept-Encoding\n\n   The Accept-Encoding request-header field is similar to Accept, but\n   restricts the content-codings (section 3.5) that are acceptable in\n   the response.\n\n       Accept-Encoding  = \"Accept-Encoding\" \":\"\n\n\n\nFielding, et al.            Standards Track                   [Page 102]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                          1#( codings [ \";\" \"q\" \"=\" qvalue ] )\n       codings          = ( content-coding | \"*\" )\n\n   Examples of its use are:\n\n       Accept-Encoding: compress, gzip\n       Accept-Encoding:\n       Accept-Encoding: *\n       Accept-Encoding: compress;q=0.5, gzip;q=1.0\n       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n\n   A server tests whether a content-coding is acceptable, according to\n   an Accept-Encoding field, using these rules:\n\n      1. If the content-coding is one of the content-codings listed in\n         the Accept-Encoding field, then it is acceptable, unless it is\n         accompanied by a qvalue of 0. (As defined in section 3.9, a\n         qvalue of 0 means \"not acceptable.\")\n\n      2. The special \"*\" symbol in an Accept-Encoding field matches any\n         available content-coding not explicitly listed in the header\n         field.\n\n      3. If multiple content-codings are acceptable, then the acceptable\n         content-coding with the highest non-zero qvalue is preferred.\n\n      4. The \"identity\" content-coding is always acceptable, unless\n         specifically refused because the Accept-Encoding field includes\n         \"identity;q=0\", or because the field includes \"*;q=0\" and does\n         not explicitly include the \"identity\" content-coding. If the\n         Accept-Encoding field-value is empty, then only the \"identity\"\n         encoding is acceptable.\n\n   If an Accept-Encoding field is present in a request, and if the\n   server cannot send a response which is acceptable according to the\n   Accept-Encoding header, then the server SHOULD send an error response\n   with the 406 (Not Acceptable) status code.\n\n   If no Accept-Encoding field is present in a request, the server MAY\n   assume that the client will accept any content coding. In this case,\n   if \"identity\" is one of the available content-codings, then the\n   server SHOULD use the \"identity\" content-coding, unless it has\n   additional information that a different content-coding is meaningful\n   to the client.\n\n      Note: If the request does not include an Accept-Encoding field,\n      and if the \"identity\" content-coding is unavailable, then\n      content-codings commonly understood by HTTP/1.0 clients (i.e.,\n\n\n\nFielding, et al.            Standards Track                   [Page 103]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      \"gzip\" and \"compress\") are preferred; some older clients\n      improperly display messages sent with other content-codings.  The\n      server might also make this decision based on information about\n      the particular user-agent or client.\n\n      Note: Most HTTP/1.0 applications do not recognize or obey qvalues\n      associated with content-codings. This means that qvalues will not\n      work and are not permitted with x-gzip or x-compress.\n\n14.4 Accept-Language\n\n   The Accept-Language request-header field is similar to Accept, but\n   restricts the set of natural languages that are preferred as a\n   response to the request. Language tags are defined in section 3.10.\n\n       Accept-Language = \"Accept-Language\" \":\"\n                         1#( language-range [ \";\" \"q\" \"=\" qvalue ] )\n       language-range  = ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) | \"*\" )\n\n   Each language-range MAY be given an associated quality value which\n   represents an estimate of the user's preference for the languages\n   specified by that range. The quality value defaults to \"q=1\". For\n   example,\n\n       Accept-Language: da, en-gb;q=0.8, en;q=0.7\n\n   would mean: \"I prefer Danish, but will accept British English and\n   other types of English.\" A language-range matches a language-tag if\n   it exactly equals the tag, or if it exactly equals a prefix of the\n   tag such that the first tag character following the prefix is \"-\".\n   The special range \"*\", if present in the Accept-Language field,\n   matches every tag not matched by any other range present in the\n   Accept-Language field.\n\n      Note: This use of a prefix matching rule does not imply that\n      language tags are assigned to languages in such a way that it is\n      always true that if a user understands a language with a certain\n      tag, then this user will also understand all languages with tags\n      for which this tag is a prefix. The prefix rule simply allows the\n      use of prefix tags if this is the case.\n\n   The language quality factor assigned to a language-tag by the\n   Accept-Language field is the quality value of the longest language-\n   range in the field that matches the language-tag. If no language-\n   range in the field matches the tag, the language quality factor\n   assigned is 0. If no Accept-Language header is present in the\n   request, the server\n\n\n\n\nFielding, et al.            Standards Track                   [Page 104]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   SHOULD assume that all languages are equally acceptable. If an\n   Accept-Language header is present, then all languages which are\n   assigned a quality factor greater than 0 are acceptable.\n\n   It might be contrary to the privacy expectations of the user to send\n   an Accept-Language header with the complete linguistic preferences of\n   the user in every request. For a discussion of this issue, see\n   section 15.1.4.\n\n   As intelligibility is highly dependent on the individual user, it is\n   recommended that client applications make the choice of linguistic\n   preference available to the user. If the choice is not made\n   available, then the Accept-Language header field MUST NOT be given in\n   the request.\n\n      Note: When making the choice of linguistic preference available to\n      the user, we remind implementors of  the fact that users are not\n      familiar with the details of language matching as described above,\n      and should provide appropriate guidance. As an example, users\n      might assume that on selecting \"en-gb\", they will be served any\n      kind of English document if British English is not available. A\n      user agent might suggest in such a case to add \"en\" to get the\n      best matching behavior.\n\n14.5 Accept-Ranges\n\n      The Accept-Ranges response-header field allows the server to\n      indicate its acceptance of range requests for a resource:\n\n          Accept-Ranges     = \"Accept-Ranges\" \":\" acceptable-ranges\n          acceptable-ranges = 1#range-unit | \"none\"\n\n      Origin servers that accept byte-range requests MAY send\n\n          Accept-Ranges: bytes\n\n      but are not required to do so. Clients MAY generate byte-range\n      requests without having received this header for the resource\n      involved. Range units are defined in section 3.12.\n\n      Servers that do not accept any kind of range request for a\n      resource MAY send\n\n          Accept-Ranges: none\n\n      to advise the client not to attempt a range request.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 105]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.6 Age\n\n      The Age response-header field conveys the sender's estimate of the\n      amount of time since the response (or its revalidation) was\n      generated at the origin server. A cached response is \"fresh\" if\n      its age does not exceed its freshness lifetime. Age values are\n      calculated as specified in section 13.2.3.\n\n           Age = \"Age\" \":\" age-value\n           age-value = delta-seconds\n\n      Age values are non-negative decimal integers, representing time in\n      seconds.\n\n      If a cache receives a value larger than the largest positive\n      integer it can represent, or if any of its age calculations\n      overflows, it MUST transmit an Age header with a value of\n      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST\n      include an Age header field in every response generated from its\n      own cache. Caches SHOULD use an arithmetic type of at least 31\n      bits of range.\n\n14.7 Allow\n\n      The Allow entity-header field lists the set of methods supported\n      by the resource identified by the Request-URI. The purpose of this\n      field is strictly to inform the recipient of valid methods\n      associated with the resource. An Allow header field MUST be\n      present in a 405 (Method Not Allowed) response.\n\n          Allow   = \"Allow\" \":\" #Method\n\n      Example of use:\n\n          Allow: GET, HEAD, PUT\n\n      This field cannot prevent a client from trying other methods.\n      However, the indications given by the Allow header field value\n      SHOULD be followed. The actual set of allowed methods is defined\n      by the origin server at the time of each request.\n\n      The Allow header field MAY be provided with a PUT request to\n      recommend the methods to be supported by the new or modified\n      resource. The server is not required to support these methods and\n      SHOULD include an Allow header in the response giving the actual\n      supported methods.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 106]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      A proxy MUST NOT modify the Allow header field even if it does not\n      understand all the methods specified, since the user agent might\n      have other means of communicating with the origin server.\n\n14.8 Authorization\n\n      A user agent that wishes to authenticate itself with a server--\n      usually, but not necessarily, after receiving a 401 response--does\n      so by including an Authorization request-header field with the\n      request.  The Authorization field value consists of credentials\n      containing the authentication information of the user agent for\n      the realm of the resource being requested.\n\n          Authorization  = \"Authorization\" \":\" credentials\n\n      HTTP access authentication is described in \"HTTP Authentication:\n      Basic and Digest Access Authentication\" [43]. If a request is\n      authenticated and a realm specified, the same credentials SHOULD\n      be valid for all other requests within this realm (assuming that\n      the authentication scheme itself does not require otherwise, such\n      as credentials that vary according to a challenge value or using\n      synchronized clocks).\n\n      When a shared cache (see section 13.7) receives a request\n      containing an Authorization field, it MUST NOT return the\n      corresponding response as a reply to any other request, unless one\n      of the following specific exceptions holds:\n\n      1. If the response includes the \"s-maxage\" cache-control\n         directive, the cache MAY use that response in replying to a\n         subsequent request. But (if the specified maximum age has\n         passed) a proxy cache MUST first revalidate it with the origin\n         server, using the request-headers from the new request to allow\n         the origin server to authenticate the new request. (This is the\n         defined behavior for s-maxage.) If the response includes \"s-\n         maxage=0\", the proxy MUST always revalidate it before re-using\n         it.\n\n      2. If the response includes the \"must-revalidate\" cache-control\n         directive, the cache MAY use that response in replying to a\n         subsequent request. But if the response is stale, all caches\n         MUST first revalidate it with the origin server, using the\n         request-headers from the new request to allow the origin server\n         to authenticate the new request.\n\n      3. If the response includes the \"public\" cache-control directive,\n         it MAY be returned in reply to any subsequent request.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 107]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.9 Cache-Control\n\n   The Cache-Control general-header field is used to specify directives\n   that MUST be obeyed by all caching mechanisms along the\n   request/response chain. The directives specify behavior intended to\n   prevent caches from adversely interfering with the request or\n   response. These directives typically override the default caching\n   algorithms. Cache directives are unidirectional in that the presence\n   of a directive in a request does not imply that the same directive is\n   to be given in the response.\n\n      Note that HTTP/1.0 caches might not implement Cache-Control and\n      might only implement Pragma: no-cache (see section 14.32).\n\n   Cache directives MUST be passed through by a proxy or gateway\n   application, regardless of their significance to that application,\n   since the directives might be applicable to all recipients along the\n   request/response chain. It is not possible to specify a cache-\n   directive for a specific cache.\n\n    Cache-Control   = \"Cache-Control\" \":\" 1#cache-directive\n\n    cache-directive = cache-request-directive\n         | cache-response-directive\n\n    cache-request-directive =\n           \"no-cache\"                          ; Section 14.9.1\n         | \"no-store\"                          ; Section 14.9.2\n         | \"max-age\" \"=\" delta-seconds         ; Section 14.9.3, 14.9.4\n         | \"max-stale\" [ \"=\" delta-seconds ]   ; Section 14.9.3\n         | \"min-fresh\" \"=\" delta-seconds       ; Section 14.9.3\n         | \"no-transform\"                      ; Section 14.9.5\n         | \"only-if-cached\"                    ; Section 14.9.4\n         | cache-extension                     ; Section 14.9.6\n\n     cache-response-directive =\n           \"public\"                               ; Section 14.9.1\n         | \"private\" [ \"=\" <\"> 1#field-name <\"> ] ; Section 14.9.1\n         | \"no-cache\" [ \"=\" <\"> 1#field-name <\"> ]; Section 14.9.1\n         | \"no-store\"                             ; Section 14.9.2\n         | \"no-transform\"                         ; Section 14.9.5\n         | \"must-revalidate\"                      ; Section 14.9.4\n         | \"proxy-revalidate\"                     ; Section 14.9.4\n         | \"max-age\" \"=\" delta-seconds            ; Section 14.9.3\n         | \"s-maxage\" \"=\" delta-seconds           ; Section 14.9.3\n         | cache-extension                        ; Section 14.9.6\n\n    cache-extension = token [ \"=\" ( token | quoted-string ) ]\n\n\n\nFielding, et al.            Standards Track                   [Page 108]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   When a directive appears without any 1#field-name parameter, the\n   directive applies to the entire request or response. When such a\n   directive appears with a 1#field-name parameter, it applies only to\n   the named field or fields, and not to the rest of the request or\n   response. This mechanism supports extensibility; implementations of\n   future versions of the HTTP protocol might apply these directives to\n   header fields not defined in HTTP/1.1.\n\n   The cache-control directives can be broken down into these general\n   categories:\n\n      - Restrictions on what are cacheable; these may only be imposed by\n        the origin server.\n\n      - Restrictions on what may be stored by a cache; these may be\n        imposed by either the origin server or the user agent.\n\n      - Modifications of the basic expiration mechanism; these may be\n        imposed by either the origin server or the user agent.\n\n      - Controls over cache revalidation and reload; these may only be\n        imposed by a user agent.\n\n      - Control over transformation of entities.\n\n      - Extensions to the caching system.\n\n14.9.1 What is Cacheable\n\n   By default, a response is cacheable if the requirements of the\n   request method, request header fields, and the response status\n   indicate that it is cacheable. Section 13.4 summarizes these defaults\n   for cacheability. The following Cache-Control response directives\n   allow an origin server to override the default cacheability of a\n   response:\n\n   public\n      Indicates that the response MAY be cached by any cache, even if it\n      would normally be non-cacheable or cacheable only within a non-\n      shared cache. (See also Authorization, section 14.8, for\n      additional details.)\n\n   private\n      Indicates that all or part of the response message is intended for\n      a single user and MUST NOT be cached by a shared cache. This\n      allows an origin server to state that the specified parts of the\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 109]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      response are intended for only one user and are not a valid\n      response for requests by other users. A private (non-shared) cache\n      MAY cache the response.\n\n       Note: This usage of the word private only controls where the\n       response may be cached, and cannot ensure the privacy of the\n       message content.\n\n   no-cache\n       If the no-cache directive does not specify a field-name, then a\n      cache MUST NOT use the response to satisfy a subsequent request\n      without successful revalidation with the origin server. This\n      allows an origin server to prevent caching even by caches that\n      have been configured to return stale responses to client requests.\n\n      If the no-cache directive does specify one or more field-names,\n      then a cache MAY use the response to satisfy a subsequent request,\n      subject to any other restrictions on caching. However, the\n      specified field-name(s) MUST NOT be sent in the response to a\n      subsequent request without successful revalidation with the origin\n      server. This allows an origin server to prevent the re-use of\n      certain header fields in a response, while still allowing caching\n      of the rest of the response.\n\n       Note: Most HTTP/1.0 caches will not recognize or obey this\n       directive.\n\n14.9.2 What May be Stored by Caches\n\n   no-store\n      The purpose of the no-store directive is to prevent the\n      inadvertent release or retention of sensitive information (for\n      example, on backup tapes). The no-store directive applies to the\n      entire message, and MAY be sent either in a response or in a\n      request. If sent in a request, a cache MUST NOT store any part of\n      either this request or any response to it. If sent in a response,\n      a cache MUST NOT store any part of either this response or the\n      request that elicited it. This directive applies to both non-\n      shared and shared caches. \"MUST NOT store\" in this context means\n      that the cache MUST NOT intentionally store the information in\n      non-volatile storage, and MUST make a best-effort attempt to\n      remove the information from volatile storage as promptly as\n      possible after forwarding it.\n\n      Even when this directive is associated with a response, users\n      might explicitly store such a response outside of the caching\n      system (e.g., with a \"Save As\" dialog). History buffers MAY store\n      such responses as part of their normal operation.\n\n\n\nFielding, et al.            Standards Track                   [Page 110]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      The purpose of this directive is to meet the stated requirements\n      of certain users and service authors who are concerned about\n      accidental releases of information via unanticipated accesses to\n      cache data structures. While the use of this directive might\n      improve privacy in some cases, we caution that it is NOT in any\n      way a reliable or sufficient mechanism for ensuring privacy. In\n      particular, malicious or compromised caches might not recognize or\n      obey this directive, and communications networks might be\n      vulnerable to eavesdropping.\n\n14.9.3 Modifications of the Basic Expiration Mechanism\n\n   The expiration time of an entity MAY be specified by the origin\n   server using the Expires header (see section 14.21). Alternatively,\n   it MAY be specified using the max-age directive in a response. When\n   the max-age cache-control directive is present in a cached response,\n   the response is stale if its current age is greater than the age\n   value given (in seconds) at the time of a new request for that\n   resource. The max-age directive on a response implies that the\n   response is cacheable (i.e., \"public\") unless some other, more\n   restrictive cache directive is also present.\n\n   If a response includes both an Expires header and a max-age\n   directive, the max-age directive overrides the Expires header, even\n   if the Expires header is more restrictive. This rule allows an origin\n   server to provide, for a given response, a longer expiration time to\n   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be\n   useful if certain HTTP/1.0 caches improperly calculate ages or\n   expiration times, perhaps due to desynchronized clocks.\n\n   Many HTTP/1.0 cache implementations will treat an Expires value that\n   is less than or equal to the response Date value as being equivalent\n   to the Cache-Control response directive \"no-cache\". If an HTTP/1.1\n   cache receives such a response, and the response does not include a\n   Cache-Control header field, it SHOULD consider the response to be\n   non-cacheable in order to retain compatibility with HTTP/1.0 servers.\n\n       Note: An origin server might wish to use a relatively new HTTP\n       cache control feature, such as the \"private\" directive, on a\n       network including older caches that do not understand that\n       feature. The origin server will need to combine the new feature\n       with an Expires field whose value is less than or equal to the\n       Date value. This will prevent older caches from improperly\n       caching the response.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 111]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   s-maxage\n       If a response includes an s-maxage directive, then for a shared\n       cache (but not for a private cache), the maximum age specified by\n       this directive overrides the maximum age specified by either the\n       max-age directive or the Expires header. The s-maxage directive\n       also implies the semantics of the proxy-revalidate directive (see\n       section 14.9.4), i.e., that the shared cache must not use the\n       entry after it becomes stale to respond to a subsequent request\n       without first revalidating it with the origin server. The s-\n       maxage directive is always ignored by a private cache.\n\n   Note that most older caches, not compliant with this specification,\n   do not implement any cache-control directives. An origin server\n   wishing to use a cache-control directive that restricts, but does not\n   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the\n   requirement that the max-age directive overrides the Expires header,\n   and the fact that pre-HTTP/1.1-compliant caches do not observe the\n   max-age directive.\n\n   Other directives allow a user agent to modify the basic expiration\n   mechanism. These directives MAY be specified on a request:\n\n   max-age\n      Indicates that the client is willing to accept a response whose\n      age is no greater than the specified time in seconds. Unless max-\n      stale directive is also included, the client is not willing to\n      accept a stale response.\n\n   min-fresh\n      Indicates that the client is willing to accept a response whose\n      freshness lifetime is no less than its current age plus the\n      specified time in seconds. That is, the client wants a response\n      that will still be fresh for at least the specified number of\n      seconds.\n\n   max-stale\n      Indicates that the client is willing to accept a response that has\n      exceeded its expiration time. If max-stale is assigned a value,\n      then the client is willing to accept a response that has exceeded\n      its expiration time by no more than the specified number of\n      seconds. If no value is assigned to max-stale, then the client is\n      willing to accept a stale response of any age.\n\n   If a cache returns a stale response, either because of a max-stale\n   directive on a request, or because the cache is configured to\n   override the expiration time of a response, the cache MUST attach a\n   Warning header to the stale response, using Warning 110 (Response is\n   stale).\n\n\n\nFielding, et al.            Standards Track                   [Page 112]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A cache MAY be configured to return stale responses without\n   validation, but only if this does not conflict with any \"MUST\"-level\n   requirements concerning cache validation (e.g., a \"must-revalidate\"\n   cache-control directive).\n\n   If both the new request and the cached entry include \"max-age\"\n   directives, then the lesser of the two values is used for determining\n   the freshness of the cached entry for that request.\n\n14.9.4 Cache Revalidation and Reload Controls\n\n   Sometimes a user agent might want or need to insist that a cache\n   revalidate its cache entry with the origin server (and not just with\n   the next cache along the path to the origin server), or to reload its\n   cache entry from the origin server. End-to-end revalidation might be\n   necessary if either the cache or the origin server has overestimated\n   the expiration time of the cached response. End-to-end reload may be\n   necessary if the cache entry has become corrupted for some reason.\n\n   End-to-end revalidation may be requested either when the client does\n   not have its own local cached copy, in which case we call it\n   \"unspecified end-to-end revalidation\", or when the client does have a\n   local cached copy, in which case we call it \"specific end-to-end\n   revalidation.\"\n\n   The client can specify these three kinds of action using Cache-\n   Control request directives:\n\n   End-to-end reload\n      The request includes a \"no-cache\" cache-control directive or, for\n      compatibility with HTTP/1.0 clients, \"Pragma: no-cache\". Field\n      names MUST NOT be included with the no-cache directive in a\n      request. The server MUST NOT use a cached copy when responding to\n      such a request.\n\n   Specific end-to-end revalidation\n      The request includes a \"max-age=0\" cache-control directive, which\n      forces each cache along the path to the origin server to\n      revalidate its own entry, if any, with the next cache or server.\n      The initial request includes a cache-validating conditional with\n      the client's current validator.\n\n   Unspecified end-to-end revalidation\n      The request includes \"max-age=0\" cache-control directive, which\n      forces each cache along the path to the origin server to\n      revalidate its own entry, if any, with the next cache or server.\n      The initial request does not include a cache-validating\n\n\n\n\nFielding, et al.            Standards Track                   [Page 113]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      conditional; the first cache along the path (if any) that holds a\n      cache entry for this resource includes a cache-validating\n      conditional with its current validator.\n\n   max-age\n      When an intermediate cache is forced, by means of a max-age=0\n      directive, to revalidate its own cache entry, and the client has\n      supplied its own validator in the request, the supplied validator\n      might differ from the validator currently stored with the cache\n      entry. In this case, the cache MAY use either validator in making\n      its own request without affecting semantic transparency.\n\n      However, the choice of validator might affect performance. The\n      best approach is for the intermediate cache to use its own\n      validator when making its request. If the server replies with 304\n      (Not Modified), then the cache can return its now validated copy\n      to the client with a 200 (OK) response. If the server replies with\n      a new entity and cache validator, however, the intermediate cache\n      can compare the returned validator with the one provided in the\n      client's request, using the strong comparison function. If the\n      client's validator is equal to the origin server's, then the\n      intermediate cache simply returns 304 (Not Modified). Otherwise,\n      it returns the new entity with a 200 (OK) response.\n\n      If a request includes the no-cache directive, it SHOULD NOT\n      include min-fresh, max-stale, or max-age.\n\n   only-if-cached\n      In some cases, such as times of extremely poor network\n      connectivity, a client may want a cache to return only those\n      responses that it currently has stored, and not to reload or\n      revalidate with the origin server. To do this, the client may\n      include the only-if-cached directive in a request. If it receives\n      this directive, a cache SHOULD either respond using a cached entry\n      that is consistent with the other constraints of the request, or\n      respond with a 504 (Gateway Timeout) status. However, if a group\n      of caches is being operated as a unified system with good internal\n      connectivity, such a request MAY be forwarded within that group of\n      caches.\n\n   must-revalidate\n      Because a cache MAY be configured to ignore a server's specified\n      expiration time, and because a client request MAY include a max-\n      stale directive (which has a similar effect), the protocol also\n      includes a mechanism for the origin server to require revalidation\n      of a cache entry on any subsequent use. When the must-revalidate\n      directive is present in a response received by a cache, that cache\n      MUST NOT use the entry after it becomes stale to respond to a\n\n\n\nFielding, et al.            Standards Track                   [Page 114]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      subsequent request without first revalidating it with the origin\n      server. (I.e., the cache MUST do an end-to-end revalidation every\n      time, if, based solely on the origin server's Expires or max-age\n      value, the cached response is stale.)\n\n      The must-revalidate directive is necessary to support reliable\n      operation for certain protocol features. In all circumstances an\n      HTTP/1.1 cache MUST obey the must-revalidate directive; in\n      particular, if the cache cannot reach the origin server for any\n      reason, it MUST generate a 504 (Gateway Timeout) response.\n\n      Servers SHOULD send the must-revalidate directive if and only if\n      failure to revalidate a request on the entity could result in\n      incorrect operation, such as a silently unexecuted financial\n      transaction. Recipients MUST NOT take any automated action that\n      violates this directive, and MUST NOT automatically provide an\n      unvalidated copy of the entity if revalidation fails.\n\n      Although this is not recommended, user agents operating under\n      severe connectivity constraints MAY violate this directive but, if\n      so, MUST explicitly warn the user that an unvalidated response has\n      been provided. The warning MUST be provided on each unvalidated\n      access, and SHOULD require explicit user confirmation.\n\n   proxy-revalidate\n      The proxy-revalidate directive has the same meaning as the must-\n      revalidate directive, except that it does not apply to non-shared\n      user agent caches. It can be used on a response to an\n      authenticated request to permit the user's cache to store and\n      later return the response without needing to revalidate it (since\n      it has already been authenticated once by that user), while still\n      requiring proxies that service many users to revalidate each time\n      (in order to make sure that each user has been authenticated).\n      Note that such authenticated responses also need the public cache\n      control directive in order to allow them to be cached at all.\n\n14.9.5 No-Transform Directive\n\n   no-transform\n      Implementors of intermediate caches (proxies) have found it useful\n      to convert the media type of certain entity bodies. A non-\n      transparent proxy might, for example, convert between image\n      formats in order to save cache space or to reduce the amount of\n      traffic on a slow link.\n\n      Serious operational problems occur, however, when these\n      transformations are applied to entity bodies intended for certain\n      kinds of applications. For example, applications for medical\n\n\n\nFielding, et al.            Standards Track                   [Page 115]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      imaging, scientific data analysis and those using end-to-end\n      authentication, all depend on receiving an entity body that is bit\n      for bit identical to the original entity-body.\n\n      Therefore, if a message includes the no-transform directive, an\n      intermediate cache or proxy MUST NOT change those headers that are\n      listed in section 13.5.2 as being subject to the no-transform\n      directive. This implies that the cache or proxy MUST NOT change\n      any aspect of the entity-body that is specified by these headers,\n      including the value of the entity-body itself.\n\n14.9.6 Cache Control Extensions\n\n   The Cache-Control header field can be extended through the use of one\n   or more cache-extension tokens, each with an optional assigned value.\n   Informational extensions (those which do not require a change in\n   cache behavior) MAY be added without changing the semantics of other\n   directives. Behavioral extensions are designed to work by acting as\n   modifiers to the existing base of cache directives. Both the new\n   directive and the standard directive are supplied, such that\n   applications which do not understand the new directive will default\n   to the behavior specified by the standard directive, and those that\n   understand the new directive will recognize it as modifying the\n   requirements associated with the standard directive. In this way,\n   extensions to the cache-control directives can be made without\n   requiring changes to the base protocol.\n\n   This extension mechanism depends on an HTTP cache obeying all of the\n   cache-control directives defined for its native HTTP-version, obeying\n   certain extensions, and ignoring all directives that it does not\n   understand.\n\n   For example, consider a hypothetical new response directive called\n   community which acts as a modifier to the private directive. We\n   define this new directive to mean that, in addition to any non-shared\n   cache, any cache which is shared only by members of the community\n   named within its value may cache the response. An origin server\n   wishing to allow the UCI community to use an otherwise private\n   response in their shared cache(s) could do so by including\n\n       Cache-Control: private, community=\"UCI\"\n\n   A cache seeing this header field will act correctly even if the cache\n   does not understand the community cache-extension, since it will also\n   see and understand the private directive and thus default to the safe\n   behavior.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 116]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Unrecognized cache-directives MUST be ignored; it is assumed that any\n   cache-directive likely to be unrecognized by an HTTP/1.1 cache will\n   be combined with standard directives (or the response's default\n   cacheability) such that the cache behavior will remain minimally\n   correct even if the cache does not understand the extension(s).\n\n14.10 Connection\n\n   The Connection general-header field allows the sender to specify\n   options that are desired for that particular connection and MUST NOT\n   be communicated by proxies over further connections.\n\n   The Connection header has the following grammar:\n\n       Connection = \"Connection\" \":\" 1#(connection-token)\n       connection-token  = token\n\n   HTTP/1.1 proxies MUST parse the Connection header field before a\n   message is forwarded and, for each connection-token in this field,\n   remove any header field(s) from the message with the same name as the\n   connection-token. Connection options are signaled by the presence of\n   a connection-token in the Connection header field, not by any\n   corresponding additional header field(s), since the additional header\n   field may not be sent if there are no parameters associated with that\n   connection option.\n\n   Message headers listed in the Connection header MUST NOT include\n   end-to-end headers, such as Cache-Control.\n\n   HTTP/1.1 defines the \"close\" connection option for the sender to\n   signal that the connection will be closed after completion of the\n   response. For example,\n\n       Connection: close\n\n   in either the request or the response header fields indicates that\n   the connection SHOULD NOT be considered `persistent' (section 8.1)\n   after the current request/response is complete.\n\n   HTTP/1.1 applications that do not support persistent connections MUST\n   include the \"close\" connection option in every message.\n\n   A system receiving an HTTP/1.0 (or lower-version) message that\n   includes a Connection header MUST, for each connection-token in this\n   field, remove and ignore any header field(s) from the message with\n   the same name as the connection-token. This protects against mistaken\n   forwarding of such header fields by pre-HTTP/1.1 proxies. See section\n   19.6.2.\n\n\n\nFielding, et al.            Standards Track                   [Page 117]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.11 Content-Encoding\n\n   The Content-Encoding entity-header field is used as a modifier to the\n   media-type. When present, its value indicates what additional content\n   codings have been applied to the entity-body, and thus what decoding\n   mechanisms must be applied in order to obtain the media-type\n   referenced by the Content-Type header field. Content-Encoding is\n   primarily used to allow a document to be compressed without losing\n   the identity of its underlying media type.\n\n       Content-Encoding  = \"Content-Encoding\" \":\" 1#content-coding\n\n   Content codings are defined in section 3.5. An example of its use is\n\n       Content-Encoding: gzip\n\n   The content-coding is a characteristic of the entity identified by\n   the Request-URI. Typically, the entity-body is stored with this\n   encoding and is only decoded before rendering or analogous usage.\n   However, a non-transparent proxy MAY modify the content-coding if the\n   new coding is known to be acceptable to the recipient, unless the\n   \"no-transform\" cache-control directive is present in the message.\n\n   If the content-coding of an entity is not \"identity\", then the\n   response MUST include a Content-Encoding entity-header (section\n   14.11) that lists the non-identity content-coding(s) used.\n\n   If the content-coding of an entity in a request message is not\n   acceptable to the origin server, the server SHOULD respond with a\n   status code of 415 (Unsupported Media Type).\n\n   If multiple encodings have been applied to an entity, the content\n   codings MUST be listed in the order in which they were applied.\n   Additional information about the encoding parameters MAY be provided\n   by other entity-header fields not defined by this specification.\n\n14.12 Content-Language\n\n   The Content-Language entity-header field describes the natural\n   language(s) of the intended audience for the enclosed entity. Note\n   that this might not be equivalent to all the languages used within\n   the entity-body.\n\n       Content-Language  = \"Content-Language\" \":\" 1#language-tag\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 118]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Language tags are defined in section 3.10. The primary purpose of\n   Content-Language is to allow a user to identify and differentiate\n   entities according to the user's own preferred language. Thus, if the\n   body content is intended only for a Danish-literate audience, the\n   appropriate field is\n\n       Content-Language: da\n\n   If no Content-Language is specified, the default is that the content\n   is intended for all language audiences. This might mean that the\n   sender does not consider it to be specific to any natural language,\n   or that the sender does not know for which language it is intended.\n\n   Multiple languages MAY be listed for content that is intended for\n   multiple audiences. For example, a rendition of the \"Treaty of\n   Waitangi,\" presented simultaneously in the original Maori and English\n   versions, would call for\n\n       Content-Language: mi, en\n\n   However, just because multiple languages are present within an entity\n   does not mean that it is intended for multiple linguistic audiences.\n   An example would be a beginner's language primer, such as \"A First\n   Lesson in Latin,\" which is clearly intended to be used by an\n   English-literate audience. In this case, the Content-Language would\n   properly only include \"en\".\n\n   Content-Language MAY be applied to any media type -- it is not\n   limited to textual documents.\n\n14.13 Content-Length\n\n   The Content-Length entity-header field indicates the size of the\n   entity-body, in decimal number of OCTETs, sent to the recipient or,\n   in the case of the HEAD method, the size of the entity-body that\n   would have been sent had the request been a GET.\n\n       Content-Length    = \"Content-Length\" \":\" 1*DIGIT\n\n   An example is\n\n       Content-Length: 3495\n\n   Applications SHOULD use this field to indicate the transfer-length of\n   the message-body, unless this is prohibited by the rules in section\n   4.4.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 119]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Any Content-Length greater than or equal to zero is a valid value.\n   Section 4.4 describes how to determine the length of a message-body\n   if a Content-Length is not given.\n\n   Note that the meaning of this field is significantly different from\n   the corresponding definition in MIME, where it is an optional field\n   used within the \"message/external-body\" content-type. In HTTP, it\n   SHOULD be sent whenever the message's length can be determined prior\n   to being transferred, unless this is prohibited by the rules in\n   section 4.4.\n\n14.14 Content-Location\n\n   The Content-Location entity-header field MAY be used to supply the\n   resource location for the entity enclosed in the message when that\n   entity is accessible from a location separate from the requested\n   resource's URI. A server SHOULD provide a Content-Location for the\n   variant corresponding to the response entity; especially in the case\n   where a resource has multiple entities associated with it, and those\n   entities actually have separate locations by which they might be\n   individually accessed, the server SHOULD provide a Content-Location\n   for the particular variant which is returned.\n\n       Content-Location = \"Content-Location\" \":\"\n                         ( absoluteURI | relativeURI )\n\n   The value of Content-Location also defines the base URI for the\n   entity.\n\n   The Content-Location value is not a replacement for the original\n   requested URI; it is only a statement of the location of the resource\n   corresponding to this particular entity at the time of the request.\n   Future requests MAY specify the Content-Location URI as the request-\n   URI if the desire is to identify the source of that particular\n   entity.\n\n   A cache cannot assume that an entity with a Content-Location\n   different from the URI used to retrieve it can be used to respond to\n   later requests on that Content-Location URI. However, the Content-\n   Location can be used to differentiate between multiple entities\n   retrieved from a single requested resource, as described in section\n   13.6.\n\n   If the Content-Location is a relative URI, the relative URI is\n   interpreted relative to the Request-URI.\n\n   The meaning of the Content-Location header in PUT or POST requests is\n   undefined; servers are free to ignore it in those cases.\n\n\n\nFielding, et al.            Standards Track                   [Page 120]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.15 Content-MD5\n\n   The Content-MD5 entity-header field, as defined in RFC 1864 [23], is\n   an MD5 digest of the entity-body for the purpose of providing an\n   end-to-end message integrity check (MIC) of the entity-body. (Note: a\n   MIC is good for detecting accidental modification of the entity-body\n   in transit, but is not proof against malicious attacks.)\n\n        Content-MD5   = \"Content-MD5\" \":\" md5-digest\n        md5-digest   = <base64 of 128 bit MD5 digest as per RFC 1864>\n\n   The Content-MD5 header field MAY be generated by an origin server or\n   client to function as an integrity check of the entity-body. Only\n   origin servers or clients MAY generate the Content-MD5 header field;\n   proxies and gateways MUST NOT generate it, as this would defeat its\n   value as an end-to-end integrity check. Any recipient of the entity-\n   body, including gateways and proxies, MAY check that the digest value\n   in this header field matches that of the entity-body as received.\n\n   The MD5 digest is computed based on the content of the entity-body,\n   including any content-coding that has been applied, but not including\n   any transfer-encoding applied to the message-body. If the message is\n   received with a transfer-encoding, that encoding MUST be removed\n   prior to checking the Content-MD5 value against the received entity.\n\n   This has the result that the digest is computed on the octets of the\n   entity-body exactly as, and in the order that, they would be sent if\n   no transfer-encoding were being applied.\n\n   HTTP extends RFC 1864 to permit the digest to be computed for MIME\n   composite media-types (e.g., multipart/* and message/rfc822), but\n   this does not change how the digest is computed as defined in the\n   preceding paragraph.\n\n   There are several consequences of this. The entity-body for composite\n   types MAY contain many body-parts, each with its own MIME and HTTP\n   headers (including Content-MD5, Content-Transfer-Encoding, and\n   Content-Encoding headers). If a body-part has a Content-Transfer-\n   Encoding or Content-Encoding header, it is assumed that the content\n   of the body-part has had the encoding applied, and the body-part is\n   included in the Content-MD5 digest as is -- i.e., after the\n   application. The Transfer-Encoding header field is not allowed within\n   body-parts.\n\n   Conversion of all line breaks to CRLF MUST NOT be done before\n   computing or checking the digest: the line break convention used in\n   the text actually transmitted MUST be left unaltered when computing\n   the digest.\n\n\n\nFielding, et al.            Standards Track                   [Page 121]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      Note: while the definition of Content-MD5 is exactly the same for\n      HTTP as in RFC 1864 for MIME entity-bodies, there are several ways\n      in which the application of Content-MD5 to HTTP entity-bodies\n      differs from its application to MIME entity-bodies. One is that\n      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and\n      does use Transfer-Encoding and Content-Encoding. Another is that\n      HTTP more frequently uses binary content types than MIME, so it is\n      worth noting that, in such cases, the byte order used to compute\n      the digest is the transmission byte order defined for the type.\n      Lastly, HTTP allows transmission of text types with any of several\n      line break conventions and not just the canonical form using CRLF.\n\n14.16 Content-Range\n\n   The Content-Range entity-header is sent with a partial entity-body to\n   specify where in the full entity-body the partial body should be\n   applied. Range units are defined in section 3.12.\n\n       Content-Range = \"Content-Range\" \":\" content-range-spec\n\n       content-range-spec      = byte-content-range-spec\n       byte-content-range-spec = bytes-unit SP\n                                 byte-range-resp-spec \"/\"\n                                 ( instance-length | \"*\" )\n\n       byte-range-resp-spec = (first-byte-pos \"-\" last-byte-pos)\n                                      | \"*\"\n       instance-length           = 1*DIGIT\n\n   The header SHOULD indicate the total length of the full entity-body,\n   unless this length is unknown or difficult to determine. The asterisk\n   \"*\" character means that the instance-length is unknown at the time\n   when the response was generated.\n\n   Unlike byte-ranges-specifier values (see section 14.35.1), a byte-\n   range-resp-spec MUST only specify one range, and MUST contain\n   absolute byte positions for both the first and last byte of the\n   range.\n\n   A byte-content-range-spec with a byte-range-resp-spec whose last-\n   byte-pos value is less than its first-byte-pos value, or whose\n   instance-length value is less than or equal to its last-byte-pos\n   value, is invalid. The recipient of an invalid byte-content-range-\n   spec MUST ignore it and any content transferred along with it.\n\n   A server sending a response with status code 416 (Requested range not\n   satisfiable) SHOULD include a Content-Range field with a byte-range-\n   resp-spec of \"*\". The instance-length specifies the current length of\n\n\n\nFielding, et al.            Standards Track                   [Page 122]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the selected resource. A response with status code 206 (Partial\n   Content) MUST NOT include a Content-Range field with a byte-range-\n   resp-spec of \"*\".\n\n   Examples of byte-content-range-spec values, assuming that the entity\n   contains a total of 1234 bytes:\n\n      . The first 500 bytes:\n       bytes 0-499/1234\n\n      . The second 500 bytes:\n       bytes 500-999/1234\n\n      . All except for the first 500 bytes:\n       bytes 500-1233/1234\n\n      . The last 500 bytes:\n       bytes 734-1233/1234\n\n   When an HTTP message includes the content of a single range (for\n   example, a response to a request for a single range, or to a request\n   for a set of ranges that overlap without any holes), this content is\n   transmitted with a Content-Range header, and a Content-Length header\n   showing the number of bytes actually transferred. For example,\n\n       HTTP/1.1 206 Partial content\n       Date: Wed, 15 Nov 1995 06:25:24 GMT\n       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n       Content-Range: bytes 21010-47021/47022\n       Content-Length: 26012\n       Content-Type: image/gif\n\n   When an HTTP message includes the content of multiple ranges (for\n   example, a response to a request for multiple non-overlapping\n   ranges), these are transmitted as a multipart message. The multipart\n   media type used for this purpose is \"multipart/byteranges\" as defined\n   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.\n\n   A response to a request for a single range MUST NOT be sent using the\n   multipart/byteranges media type.  A response to a request for\n   multiple ranges, whose result is a single range, MAY be sent as a\n   multipart/byteranges media type with one part. A client that cannot\n   decode a multipart/byteranges message MUST NOT ask for multiple\n   byte-ranges in a single request.\n\n   When a client requests multiple byte-ranges in one request, the\n   server SHOULD return them in the order that they appeared in the\n   request.\n\n\n\nFielding, et al.            Standards Track                   [Page 123]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the server ignores a byte-range-spec because it is syntactically\n   invalid, the server SHOULD treat the request as if the invalid Range\n   header field did not exist. (Normally, this means return a 200\n   response containing the full entity).\n\n   If the server receives a request (other than one including an If-\n   Range request-header field) with an unsatisfiable Range request-\n   header field (that is, all of whose byte-range-spec values have a\n   first-byte-pos value greater than the current length of the selected\n   resource), it SHOULD return a response code of 416 (Requested range\n   not satisfiable) (section 10.4.17).\n\n      Note: clients cannot depend on servers to send a 416 (Requested\n      range not satisfiable) response instead of a 200 (OK) response for\n      an unsatisfiable Range request-header, since not all servers\n      implement this request-header.\n\n14.17 Content-Type\n\n   The Content-Type entity-header field indicates the media type of the\n   entity-body sent to the recipient or, in the case of the HEAD method,\n   the media type that would have been sent had the request been a GET.\n\n       Content-Type   = \"Content-Type\" \":\" media-type\n\n   Media types are defined in section 3.7. An example of the field is\n\n       Content-Type: text/html; charset=ISO-8859-4\n\n   Further discussion of methods for identifying the media type of an\n   entity is provided in section 7.2.1.\n\n14.18 Date\n\n   The Date general-header field represents the date and time at which\n   the message was originated, having the same semantics as orig-date in\n   RFC 822. The field value is an HTTP-date, as described in section\n   3.3.1; it MUST be sent in RFC 1123 [8]-date format.\n\n       Date  = \"Date\" \":\" HTTP-date\n\n   An example is\n\n       Date: Tue, 15 Nov 1994 08:12:31 GMT\n\n   Origin servers MUST include a Date header field in all responses,\n   except in these cases:\n\n\n\n\nFielding, et al.            Standards Track                   [Page 124]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      1. If the response status code is 100 (Continue) or 101 (Switching\n         Protocols), the response MAY include a Date header field, at\n         the server's option.\n\n      2. If the response status code conveys a server error, e.g. 500\n         (Internal Server Error) or 503 (Service Unavailable), and it is\n         inconvenient or impossible to generate a valid Date.\n\n      3. If the server does not have a clock that can provide a\n         reasonable approximation of the current time, its responses\n         MUST NOT include a Date header field. In this case, the rules\n         in section 14.18.1 MUST be followed.\n\n   A received message that does not have a Date header field MUST be\n   assigned one by the recipient if the message will be cached by that\n   recipient or gatewayed via a protocol which requires a Date. An HTTP\n   implementation without a clock MUST NOT cache responses without\n   revalidating them on every use. An HTTP cache, especially a shared\n   cache, SHOULD use a mechanism, such as NTP [28], to synchronize its\n   clock with a reliable external standard.\n\n   Clients SHOULD only send a Date header field in messages that include\n   an entity-body, as in the case of the PUT and POST requests, and even\n   then it is optional. A client without a clock MUST NOT send a Date\n   header field in a request.\n\n   The HTTP-date sent in a Date header SHOULD NOT represent a date and\n   time subsequent to the generation of the message. It SHOULD represent\n   the best available approximation of the date and time of message\n   generation, unless the implementation has no means of generating a\n   reasonably accurate date and time. In theory, the date ought to\n   represent the moment just before the entity is generated. In\n   practice, the date can be generated at any time during the message\n   origination without affecting its semantic value.\n\n14.18.1 Clockless Origin Server Operation\n\n   Some origin server implementations might not have a clock available.\n   An origin server without a clock MUST NOT assign Expires or Last-\n   Modified values to a response, unless these values were associated\n   with the resource by a system or user with a reliable clock. It MAY\n   assign an Expires value that is known, at or before server\n   configuration time, to be in the past (this allows \"pre-expiration\"\n   of responses without storing separate Expires values for each\n   resource).\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 125]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.19 ETag\n\n   The ETag response-header field provides the current value of the\n   entity tag for the requested variant. The headers used with entity\n   tags are described in sections 14.24, 14.26 and 14.44. The entity tag\n   MAY be used for comparison with other entities from the same resource\n   (see section 13.3.3).\n\n      ETag = \"ETag\" \":\" entity-tag\n\n   Examples:\n\n      ETag: \"xyzzy\"\n      ETag: W/\"xyzzy\"\n      ETag: \"\"\n\n14.20 Expect\n\n   The Expect request-header field is used to indicate that particular\n   server behaviors are required by the client.\n\n      Expect       =  \"Expect\" \":\" 1#expectation\n\n      expectation  =  \"100-continue\" | expectation-extension\n      expectation-extension =  token [ \"=\" ( token | quoted-string )\n                               *expect-params ]\n      expect-params =  \";\" token [ \"=\" ( token | quoted-string ) ]\n\n\n   A server that does not understand or is unable to comply with any of\n   the expectation values in the Expect field of a request MUST respond\n   with appropriate error status. The server MUST respond with a 417\n   (Expectation Failed) status if any of the expectations cannot be met\n   or, if there are other problems with the request, some other 4xx\n   status.\n\n   This header field is defined with extensible syntax to allow for\n   future extensions. If a server receives a request containing an\n   Expect field that includes an expectation-extension that it does not\n   support, it MUST respond with a 417 (Expectation Failed) status.\n\n   Comparison of expectation values is case-insensitive for unquoted\n   tokens (including the 100-continue token), and is case-sensitive for\n   quoted-string expectation-extensions.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 126]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST\n   return a 417 (Expectation Failed) status if it receives a request\n   with an expectation that it cannot meet. However, the Expect\n   request-header itself is end-to-end; it MUST be forwarded if the\n   request is forwarded.\n\n   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the\n   Expect header.\n\n   See section 8.2.3 for the use of the 100 (continue) status.\n\n14.21 Expires\n\n   The Expires entity-header field gives the date/time after which the\n   response is considered stale. A stale cache entry may not normally be\n   returned by a cache (either a proxy cache or a user agent cache)\n   unless it is first validated with the origin server (or with an\n   intermediate cache that has a fresh copy of the entity). See section\n   13.2 for further discussion of the expiration model.\n\n   The presence of an Expires field does not imply that the original\n   resource will change or cease to exist at, before, or after that\n   time.\n\n   The format is an absolute date and time as defined by HTTP-date in\n   section 3.3.1; it MUST be in RFC 1123 date format:\n\n      Expires = \"Expires\" \":\" HTTP-date\n\n   An example of its use is\n\n      Expires: Thu, 01 Dec 1994 16:00:00 GMT\n\n      Note: if a response includes a Cache-Control field with the max-\n      age directive (see section 14.9.3), that directive overrides the\n      Expires field.\n\n   HTTP/1.1 clients and caches MUST treat other invalid date formats,\n   especially including the value \"0\", as in the past (i.e., \"already\n   expired\").\n\n   To mark a response as \"already expired,\" an origin server sends an\n   Expires date that is equal to the Date header value. (See the rules\n   for expiration calculations in section 13.2.4.)\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 127]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   To mark a response as \"never expires,\" an origin server sends an\n   Expires date approximately one year from the time the response is\n   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one\n   year in the future.\n\n   The presence of an Expires header field with a date value of some\n   time in the future on a response that otherwise would by default be\n   non-cacheable indicates that the response is cacheable, unless\n   indicated otherwise by a Cache-Control header field (section 14.9).\n\n14.22 From\n\n   The From request-header field, if given, SHOULD contain an Internet\n   e-mail address for the human user who controls the requesting user\n   agent. The address SHOULD be machine-usable, as defined by \"mailbox\"\n   in RFC 822 [9] as updated by RFC 1123 [8]:\n\n       From   = \"From\" \":\" mailbox\n\n   An example is:\n\n       From: webmaster@w3.org\n\n   This header field MAY be used for logging purposes and as a means for\n   identifying the source of invalid or unwanted requests. It SHOULD NOT\n   be used as an insecure form of access protection. The interpretation\n   of this field is that the request is being performed on behalf of the\n   person given, who accepts responsibility for the method performed. In\n   particular, robot agents SHOULD include this header so that the\n   person responsible for running the robot can be contacted if problems\n   occur on the receiving end.\n\n   The Internet e-mail address in this field MAY be separate from the\n   Internet host which issued the request. For example, when a request\n   is passed through a proxy the original issuer's address SHOULD be\n   used.\n\n   The client SHOULD NOT send the From header field without the user's\n   approval, as it might conflict with the user's privacy interests or\n   their site's security policy. It is strongly recommended that the\n   user be able to disable, enable, and modify the value of this field\n   at any time prior to a request.\n\n14.23 Host\n\n   The Host request-header field specifies the Internet host and port\n   number of the resource being requested, as obtained from the original\n   URI given by the user or referring resource (generally an HTTP URL,\n\n\n\nFielding, et al.            Standards Track                   [Page 128]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   as described in section 3.2.2). The Host field value MUST represent\n   the naming authority of the origin server or gateway given by the\n   original URL. This allows the origin server or gateway to\n   differentiate between internally-ambiguous URLs, such as the root \"/\"\n   URL of a server for multiple host names on a single IP address.\n\n       Host = \"Host\" \":\" host [ \":\" port ] ; Section 3.2.2\n\n   A \"host\" without any trailing port information implies the default\n   port for the service requested (e.g., \"80\" for an HTTP URL). For\n   example, a request on the origin server for\n   <http://www.w3.org/pub/WWW/> would properly include:\n\n       GET /pub/WWW/ HTTP/1.1\n       Host: www.w3.org\n\n   A client MUST include a Host header field in all HTTP/1.1 request\n   messages . If the requested URI does not include an Internet host\n   name for the service being requested, then the Host header field MUST\n   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any\n   request message it forwards does contain an appropriate Host header\n   field that identifies the service being requested by the proxy. All\n   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)\n   status code to any HTTP/1.1 request message which lacks a Host header\n   field.\n\n   See sections 5.2 and 19.6.1.1 for other requirements relating to\n   Host.\n\n14.24 If-Match\n\n   The If-Match request-header field is used with a method to make it\n   conditional. A client that has one or more entities previously\n   obtained from the resource can verify that one of those entities is\n   current by including a list of their associated entity tags in the\n   If-Match header field. Entity tags are defined in section 3.11. The\n   purpose of this feature is to allow efficient updates of cached\n   information with a minimum amount of transaction overhead. It is also\n   used, on updating requests, to prevent inadvertent modification of\n   the wrong version of a resource. As a special case, the value \"*\"\n   matches any current entity of the resource.\n\n       If-Match = \"If-Match\" \":\" ( \"*\" | 1#entity-tag )\n\n   If any of the entity tags match the entity tag of the entity that\n   would have been returned in the response to a similar GET request\n   (without the If-Match header) on that resource, or if \"*\" is given\n\n\n\n\nFielding, et al.            Standards Track                   [Page 129]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   and any current entity exists for that resource, then the server MAY\n   perform the requested method as if the If-Match header field did not\n   exist.\n\n   A server MUST use the strong comparison function (see section 13.3.3)\n   to compare the entity tags in If-Match.\n\n   If none of the entity tags match, or if \"*\" is given and no current\n   entity exists, the server MUST NOT perform the requested method, and\n   MUST return a 412 (Precondition Failed) response. This behavior is\n   most useful when the client wants to prevent an updating method, such\n   as PUT, from modifying a resource that has changed since the client\n   last retrieved it.\n\n   If the request would, without the If-Match header field, result in\n   anything other than a 2xx or 412 status, then the If-Match header\n   MUST be ignored.\n\n   The meaning of \"If-Match: *\" is that the method SHOULD be performed\n   if the representation selected by the origin server (or by a cache,\n   possibly using the Vary mechanism, see section 14.44) exists, and\n   MUST NOT be performed if the representation does not exist.\n\n   A request intended to update a resource (e.g., a PUT) MAY include an\n   If-Match header field to signal that the request method MUST NOT be\n   applied if the entity corresponding to the If-Match value (a single\n   entity tag) is no longer a representation of that resource. This\n   allows the user to indicate that they do not wish the request to be\n   successful if the resource has been changed without their knowledge.\n   Examples:\n\n       If-Match: \"xyzzy\"\n       If-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n       If-Match: *\n\n   The result of a request having both an If-Match header field and\n   either an If-None-Match or an If-Modified-Since header fields is\n   undefined by this specification.\n\n14.25 If-Modified-Since\n\n   The If-Modified-Since request-header field is used with a method to\n   make it conditional: if the requested variant has not been modified\n   since the time specified in this field, an entity will not be\n   returned from the server; instead, a 304 (not modified) response will\n   be returned without any message-body.\n\n       If-Modified-Since = \"If-Modified-Since\" \":\" HTTP-date\n\n\n\nFielding, et al.            Standards Track                   [Page 130]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   An example of the field is:\n\n       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n   A GET method with an If-Modified-Since header and no Range header\n   requests that the identified entity be transferred only if it has\n   been modified since the date given by the If-Modified-Since header.\n   The algorithm for determining this includes the following cases:\n\n      a) If the request would normally result in anything other than a\n         200 (OK) status, or if the passed If-Modified-Since date is\n         invalid, the response is exactly the same as for a normal GET.\n         A date which is later than the server's current time is\n         invalid.\n\n      b) If the variant has been modified since the If-Modified-Since\n         date, the response is exactly the same as for a normal GET.\n\n      c) If the variant has not been modified since a valid If-\n         Modified-Since date, the server SHOULD return a 304 (Not\n         Modified) response.\n\n   The purpose of this feature is to allow efficient updates of cached\n   information with a minimum amount of transaction overhead.\n\n      Note: The Range request-header field modifies the meaning of If-\n      Modified-Since; see section 14.35 for full details.\n\n      Note: If-Modified-Since times are interpreted by the server, whose\n      clock might not be synchronized with the client.\n\n      Note: When handling an If-Modified-Since header field, some\n      servers will use an exact date comparison function, rather than a\n      less-than function, for deciding whether to send a 304 (Not\n      Modified) response. To get best results when sending an If-\n      Modified-Since header field for cache validation, clients are\n      advised to use the exact date string received in a previous Last-\n      Modified header field whenever possible.\n\n      Note: If a client uses an arbitrary date in the If-Modified-Since\n      header instead of a date taken from the Last-Modified header for\n      the same request, the client should be aware of the fact that this\n      date is interpreted in the server's understanding of time. The\n      client should consider unsynchronized clocks and rounding problems\n      due to the different encodings of time between the client and\n      server. This includes the possibility of race conditions if the\n      document has changed between the time it was first requested and\n      the If-Modified-Since date of a subsequent request, and the\n\n\n\nFielding, et al.            Standards Track                   [Page 131]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      possibility of clock-skew-related problems if the If-Modified-\n      Since date is derived from the client's clock without correction\n      to the server's clock. Corrections for different time bases\n      between client and server are at best approximate due to network\n      latency.\n\n   The result of a request having both an If-Modified-Since header field\n   and either an If-Match or an If-Unmodified-Since header fields is\n   undefined by this specification.\n\n14.26 If-None-Match\n\n   The If-None-Match request-header field is used with a method to make\n   it conditional. A client that has one or more entities previously\n   obtained from the resource can verify that none of those entities is\n   current by including a list of their associated entity tags in the\n   If-None-Match header field. The purpose of this feature is to allow\n   efficient updates of cached information with a minimum amount of\n   transaction overhead. It is also used to prevent a method (e.g. PUT)\n   from inadvertently modifying an existing resource when the client\n   believes that the resource does not exist.\n\n   As a special case, the value \"*\" matches any current entity of the\n   resource.\n\n       If-None-Match = \"If-None-Match\" \":\" ( \"*\" | 1#entity-tag )\n\n   If any of the entity tags match the entity tag of the entity that\n   would have been returned in the response to a similar GET request\n   (without the If-None-Match header) on that resource, or if \"*\" is\n   given and any current entity exists for that resource, then the\n   server MUST NOT perform the requested method, unless required to do\n   so because the resource's modification date fails to match that\n   supplied in an If-Modified-Since header field in the request.\n   Instead, if the request method was GET or HEAD, the server SHOULD\n   respond with a 304 (Not Modified) response, including the cache-\n   related header fields (particularly ETag) of one of the entities that\n   matched. For all other request methods, the server MUST respond with\n   a status of 412 (Precondition Failed).\n\n   See section 13.3.3 for rules on how to determine if two entities tags\n   match. The weak comparison function can only be used with GET or HEAD\n   requests.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 132]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If none of the entity tags match, then the server MAY perform the\n   requested method as if the If-None-Match header field did not exist,\n   but MUST also ignore any If-Modified-Since header field(s) in the\n   request. That is, if no entity tags match, then the server MUST NOT\n   return a 304 (Not Modified) response.\n\n   If the request would, without the If-None-Match header field, result\n   in anything other than a 2xx or 304 status, then the If-None-Match\n   header MUST be ignored. (See section 13.3.4 for a discussion of\n   server behavior when both If-Modified-Since and If-None-Match appear\n   in the same request.)\n\n   The meaning of \"If-None-Match: *\" is that the method MUST NOT be\n   performed if the representation selected by the origin server (or by\n   a cache, possibly using the Vary mechanism, see section 14.44)\n   exists, and SHOULD be performed if the representation does not exist.\n   This feature is intended to be useful in preventing races between PUT\n   operations.\n\n   Examples:\n\n       If-None-Match: \"xyzzy\"\n       If-None-Match: W/\"xyzzy\"\n       If-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n       If-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"\n       If-None-Match: *\n\n   The result of a request having both an If-None-Match header field and\n   either an If-Match or an If-Unmodified-Since header fields is\n   undefined by this specification.\n\n14.27 If-Range\n\n   If a client has a partial copy of an entity in its cache, and wishes\n   to have an up-to-date copy of the entire entity in its cache, it\n   could use the Range request-header with a conditional GET (using\n   either or both of If-Unmodified-Since and If-Match.) However, if the\n   condition fails because the entity has been modified, the client\n   would then have to make a second request to obtain the entire current\n   entity-body.\n\n   The If-Range header allows a client to \"short-circuit\" the second\n   request. Informally, its meaning is `if the entity is unchanged, send\n   me the part(s) that I am missing; otherwise, send me the entire new\n   entity'.\n\n        If-Range = \"If-Range\" \":\" ( entity-tag | HTTP-date )\n\n\n\n\nFielding, et al.            Standards Track                   [Page 133]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the client has no entity tag for an entity, but does have a Last-\n   Modified date, it MAY use that date in an If-Range header. (The\n   server can distinguish between a valid HTTP-date and any form of\n   entity-tag by examining no more than two characters.) The If-Range\n   header SHOULD only be used together with a Range header, and MUST be\n   ignored if the request does not include a Range header, or if the\n   server does not support the sub-range operation.\n\n   If the entity tag given in the If-Range header matches the current\n   entity tag for the entity, then the server SHOULD provide the\n   specified sub-range of the entity using a 206 (Partial content)\n   response. If the entity tag does not match, then the server SHOULD\n   return the entire entity using a 200 (OK) response.\n\n14.28 If-Unmodified-Since\n\n   The If-Unmodified-Since request-header field is used with a method to\n   make it conditional. If the requested resource has not been modified\n   since the time specified in this field, the server SHOULD perform the\n   requested operation as if the If-Unmodified-Since header were not\n   present.\n\n   If the requested variant has been modified since the specified time,\n   the server MUST NOT perform the requested operation, and MUST return\n   a 412 (Precondition Failed).\n\n      If-Unmodified-Since = \"If-Unmodified-Since\" \":\" HTTP-date\n\n   An example of the field is:\n\n       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n   If the request normally (i.e., without the If-Unmodified-Since\n   header) would result in anything other than a 2xx or 412 status, the\n   If-Unmodified-Since header SHOULD be ignored.\n\n   If the specified date is invalid, the header is ignored.\n\n   The result of a request having both an If-Unmodified-Since header\n   field and either an If-None-Match or an If-Modified-Since header\n   fields is undefined by this specification.\n\n14.29 Last-Modified\n\n   The Last-Modified entity-header field indicates the date and time at\n   which the origin server believes the variant was last modified.\n\n       Last-Modified  = \"Last-Modified\" \":\" HTTP-date\n\n\n\nFielding, et al.            Standards Track                   [Page 134]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   An example of its use is\n\n       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n\n   The exact meaning of this header field depends on the implementation\n   of the origin server and the nature of the original resource. For\n   files, it may be just the file system last-modified time. For\n   entities with dynamically included parts, it may be the most recent\n   of the set of last-modify times for its component parts. For database\n   gateways, it may be the last-update time stamp of the record. For\n   virtual objects, it may be the last time the internal state changed.\n\n   An origin server MUST NOT send a Last-Modified date which is later\n   than the server's time of message origination. In such cases, where\n   the resource's last modification would indicate some time in the\n   future, the server MUST replace that date with the message\n   origination date.\n\n   An origin server SHOULD obtain the Last-Modified value of the entity\n   as close as possible to the time that it generates the Date value of\n   its response. This allows a recipient to make an accurate assessment\n   of the entity's modification time, especially if the entity changes\n   near the time that the response is generated.\n\n   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.\n\n14.30 Location\n\n   The Location response-header field is used to redirect the recipient\n   to a location other than the Request-URI for completion of the\n   request or identification of a new resource. For 201 (Created)\n   responses, the Location is that of the new resource which was created\n   by the request. For 3xx responses, the location SHOULD indicate the\n   server's preferred URI for automatic redirection to the resource. The\n   field value consists of a single absolute URI.\n\n       Location       = \"Location\" \":\" absoluteURI\n\n   An example is:\n\n       Location: http://www.w3.org/pub/WWW/People.html\n\n      Note: The Content-Location header field (section 14.14) differs\n      from Location in that the Content-Location identifies the original\n      location of the entity enclosed in the request. It is therefore\n      possible for a response to contain header fields for both Location\n      and Content-Location. Also see section 13.10 for cache\n      requirements of some methods.\n\n\n\nFielding, et al.            Standards Track                   [Page 135]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.31 Max-Forwards\n\n   The Max-Forwards request-header field provides a mechanism with the\n   TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit the\n   number of proxies or gateways that can forward the request to the\n   next inbound server. This can be useful when the client is attempting\n   to trace a request chain which appears to be failing or looping in\n   mid-chain.\n\n       Max-Forwards   = \"Max-Forwards\" \":\" 1*DIGIT\n\n   The Max-Forwards value is a decimal integer indicating the remaining\n   number of times this request message may be forwarded.\n\n   Each proxy or gateway recipient of a TRACE or OPTIONS request\n   containing a Max-Forwards header field MUST check and update its\n   value prior to forwarding the request. If the received value is zero\n   (0), the recipient MUST NOT forward the request; instead, it MUST\n   respond as the final recipient. If the received Max-Forwards value is\n   greater than zero, then the forwarded message MUST contain an updated\n   Max-Forwards field with a value decremented by one (1).\n\n   The Max-Forwards header field MAY be ignored for all other methods\n   defined by this specification and for any extension methods for which\n   it is not explicitly referred to as part of that method definition.\n\n14.32 Pragma\n\n   The Pragma general-header field is used to include implementation-\n   specific directives that might apply to any recipient along the\n   request/response chain. All pragma directives specify optional\n   behavior from the viewpoint of the protocol; however, some systems\n   MAY require that behavior be consistent with the directives.\n\n       Pragma            = \"Pragma\" \":\" 1#pragma-directive\n       pragma-directive  = \"no-cache\" | extension-pragma\n       extension-pragma  = token [ \"=\" ( token | quoted-string ) ]\n\n   When the no-cache directive is present in a request message, an\n   application SHOULD forward the request toward the origin server even\n   if it has a cached copy of what is being requested. This pragma\n   directive has the same semantics as the no-cache cache-directive (see\n   section 14.9) and is defined here for backward compatibility with\n   HTTP/1.0. Clients SHOULD include both header fields when a no-cache\n   request is sent to a server not known to be HTTP/1.1 compliant.\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 136]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Pragma directives MUST be passed through by a proxy or gateway\n   application, regardless of their significance to that application,\n   since the directives might be applicable to all recipients along the\n   request/response chain. It is not possible to specify a pragma for a\n   specific recipient; however, any pragma directive not relevant to a\n   recipient SHOULD be ignored by that recipient.\n\n   HTTP/1.1 caches SHOULD treat \"Pragma: no-cache\" as if the client had\n   sent \"Cache-Control: no-cache\". No new Pragma directives will be\n   defined in HTTP.\n\n      Note: because the meaning of \"Pragma: no-cache as a response\n      header field is not actually specified, it does not provide a\n      reliable replacement for \"Cache-Control: no-cache\" in a response\n\n14.33 Proxy-Authenticate\n\n   The Proxy-Authenticate response-header field MUST be included as part\n   of a 407 (Proxy Authentication Required) response. The field value\n   consists of a challenge that indicates the authentication scheme and\n   parameters applicable to the proxy for this Request-URI.\n\n       Proxy-Authenticate  = \"Proxy-Authenticate\" \":\" 1#challenge\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. Unlike\n   WWW-Authenticate, the Proxy-Authenticate header field applies only to\n   the current connection and SHOULD NOT be passed on to downstream\n   clients. However, an intermediate proxy might need to obtain its own\n   credentials by requesting them from the downstream client, which in\n   some circumstances will appear as if the proxy is forwarding the\n   Proxy-Authenticate header field.\n\n14.34 Proxy-Authorization\n\n   The Proxy-Authorization request-header field allows the client to\n   identify itself (or its user) to a proxy which requires\n   authentication. The Proxy-Authorization field value consists of\n   credentials containing the authentication information of the user\n   agent for the proxy and/or realm of the resource being requested.\n\n       Proxy-Authorization     = \"Proxy-Authorization\" \":\" credentials\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43] . Unlike\n   Authorization, the Proxy-Authorization header field applies only to\n   the next outbound proxy that demanded authentication using the Proxy-\n   Authenticate field. When multiple proxies are used in a chain, the\n\n\n\nFielding, et al.            Standards Track                   [Page 137]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Proxy-Authorization header field is consumed by the first outbound\n   proxy that was expecting to receive credentials. A proxy MAY relay\n   the credentials from the client request to the next proxy if that is\n   the mechanism by which the proxies cooperatively authenticate a given\n   request.\n\n14.35 Range\n\n14.35.1 Byte Ranges\n\n   Since all HTTP entities are represented in HTTP messages as sequences\n   of bytes, the concept of a byte range is meaningful for any HTTP\n   entity. (However, not all clients and servers need to support byte-\n   range operations.)\n\n   Byte range specifications in HTTP apply to the sequence of bytes in\n   the entity-body (not necessarily the same as the message-body).\n\n   A byte range operation MAY specify a single range of bytes, or a set\n   of ranges within a single entity.\n\n       ranges-specifier = byte-ranges-specifier\n       byte-ranges-specifier = bytes-unit \"=\" byte-range-set\n       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )\n       byte-range-spec = first-byte-pos \"-\" [last-byte-pos]\n       first-byte-pos  = 1*DIGIT\n       last-byte-pos   = 1*DIGIT\n\n   The first-byte-pos value in a byte-range-spec gives the byte-offset\n   of the first byte in a range. The last-byte-pos value gives the\n   byte-offset of the last byte in the range; that is, the byte\n   positions specified are inclusive. Byte offsets start at zero.\n\n   If the last-byte-pos value is present, it MUST be greater than or\n   equal to the first-byte-pos in that byte-range-spec, or the byte-\n   range-spec is syntactically invalid. The recipient of a byte-range-\n   set that includes one or more syntactically invalid byte-range-spec\n   values MUST ignore the header field that includes that byte-range-\n   set.\n\n   If the last-byte-pos value is absent, or if the value is greater than\n   or equal to the current length of the entity-body, last-byte-pos is\n   taken to be equal to one less than the current length of the entity-\n   body in bytes.\n\n   By its choice of last-byte-pos, a client can limit the number of\n   bytes retrieved without knowing the size of the entity.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 138]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       suffix-byte-range-spec = \"-\" suffix-length\n       suffix-length = 1*DIGIT\n\n   A suffix-byte-range-spec is used to specify the suffix of the\n   entity-body, of a length given by the suffix-length value. (That is,\n   this form specifies the last N bytes of an entity-body.) If the\n   entity is shorter than the specified suffix-length, the entire\n   entity-body is used.\n\n   If a syntactically valid byte-range-set includes at least one byte-\n   range-spec whose first-byte-pos is less than the current length of\n   the entity-body, or at least one suffix-byte-range-spec with a non-\n   zero suffix-length, then the byte-range-set is satisfiable.\n   Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set\n   is unsatisfiable, the server SHOULD return a response with a status\n   of 416 (Requested range not satisfiable). Otherwise, the server\n   SHOULD return a response with a status of 206 (Partial Content)\n   containing the satisfiable ranges of the entity-body.\n\n   Examples of byte-ranges-specifier values (assuming an entity-body of\n   length 10000):\n\n      - The first 500 bytes (byte offsets 0-499, inclusive):  bytes=0-\n        499\n\n      - The second 500 bytes (byte offsets 500-999, inclusive):\n        bytes=500-999\n\n      - The final 500 bytes (byte offsets 9500-9999, inclusive):\n        bytes=-500\n\n      - Or bytes=9500-\n\n      - The first and last bytes only (bytes 0 and 9999):  bytes=0-0,-1\n\n      - Several legal but not canonical specifications of the second 500\n        bytes (byte offsets 500-999, inclusive):\n         bytes=500-600,601-999\n         bytes=500-700,601-999\n\n14.35.2 Range Retrieval Requests\n\n   HTTP retrieval requests using conditional or unconditional GET\n   methods MAY request one or more sub-ranges of the entity, instead of\n   the entire entity, using the Range request header, which applies to\n   the entity returned as the result of the request:\n\n      Range = \"Range\" \":\" ranges-specifier\n\n\n\nFielding, et al.            Standards Track                   [Page 139]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A server MAY ignore the Range header. However, HTTP/1.1 origin\n   servers and intermediate caches ought to support byte ranges when\n   possible, since Range supports efficient recovery from partially\n   failed transfers, and supports efficient partial retrieval of large\n   entities.\n\n   If the server supports the Range header and the specified range or\n   ranges are appropriate for the entity:\n\n      - The presence of a Range header in an unconditional GET modifies\n        what is returned if the GET is otherwise successful. In other\n        words, the response carries a status code of 206 (Partial\n        Content) instead of 200 (OK).\n\n      - The presence of a Range header in a conditional GET (a request\n        using one or both of If-Modified-Since and If-None-Match, or\n        one or both of If-Unmodified-Since and If-Match) modifies what\n        is returned if the GET is otherwise successful and the\n        condition is true. It does not affect the 304 (Not Modified)\n        response returned if the conditional is false.\n\n   In some cases, it might be more appropriate to use the If-Range\n   header (see section 14.27) in addition to the Range header.\n\n   If a proxy that supports ranges receives a Range request, forwards\n   the request to an inbound server, and receives an entire entity in\n   reply, it SHOULD only return the requested range to its client. It\n   SHOULD store the entire received response in its cache if that is\n   consistent with its cache allocation policies.\n\n14.36 Referer\n\n   The Referer[sic] request-header field allows the client to specify,\n   for the server's benefit, the address (URI) of the resource from\n   which the Request-URI was obtained (the \"referrer\", although the\n   header field is misspelled.) The Referer request-header allows a\n   server to generate lists of back-links to resources for interest,\n   logging, optimized caching, etc. It also allows obsolete or mistyped\n   links to be traced for maintenance. The Referer field MUST NOT be\n   sent if the Request-URI was obtained from a source that does not have\n   its own URI, such as input from the user keyboard.\n\n       Referer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\n\n   Example:\n\n       Referer: http://www.w3.org/hypertext/DataSources/Overview.html\n\n\n\n\nFielding, et al.            Standards Track                   [Page 140]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the field value is a relative URI, it SHOULD be interpreted\n   relative to the Request-URI. The URI MUST NOT include a fragment. See\n   section 15.1.3 for security considerations.\n\n14.37 Retry-After\n\n   The Retry-After response-header field can be used with a 503 (Service\n   Unavailable) response to indicate how long the service is expected to\n   be unavailable to the requesting client. This field MAY also be used\n   with any 3xx (Redirection) response to indicate the minimum time the\n   user-agent is asked wait before issuing the redirected request. The\n   value of this field can be either an HTTP-date or an integer number\n   of seconds (in decimal) after the time of the response.\n\n       Retry-After  = \"Retry-After\" \":\" ( HTTP-date | delta-seconds )\n\n   Two examples of its use are\n\n       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT\n       Retry-After: 120\n\n   In the latter example, the delay is 2 minutes.\n\n14.38 Server\n\n   The Server response-header field contains information about the\n   software used by the origin server to handle the request. The field\n   can contain multiple product tokens (section 3.8) and comments\n   identifying the server and any significant subproducts. The product\n   tokens are listed in order of their significance for identifying the\n   application.\n\n       Server         = \"Server\" \":\" 1*( product | comment )\n\n   Example:\n\n       Server: CERN/3.0 libwww/2.17\n\n   If the response is being forwarded through a proxy, the proxy\n   application MUST NOT modify the Server response-header. Instead, it\n   SHOULD include a Via field (as described in section 14.45).\n\n      Note: Revealing the specific software version of the server might\n      allow the server machine to become more vulnerable to attacks\n      against software that is known to contain security holes. Server\n      implementors are encouraged to make this field a configurable\n      option.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 141]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.39 TE\n\n   The TE request-header field indicates what extension transfer-codings\n   it is willing to accept in the response and whether or not it is\n   willing to accept trailer fields in a chunked transfer-coding. Its\n   value may consist of the keyword \"trailers\" and/or a comma-separated\n   list of extension transfer-coding names with optional accept\n   parameters (as described in section 3.6).\n\n       TE        = \"TE\" \":\" #( t-codings )\n       t-codings = \"trailers\" | ( transfer-extension [ accept-params ] )\n\n   The presence of the keyword \"trailers\" indicates that the client is\n   willing to accept trailer fields in a chunked transfer-coding, as\n   defined in section 3.6.1. This keyword is reserved for use with\n   transfer-coding values even though it does not itself represent a\n   transfer-coding.\n\n   Examples of its use are:\n\n       TE: deflate\n       TE:\n       TE: trailers, deflate;q=0.5\n\n   The TE header field only applies to the immediate connection.\n   Therefore, the keyword MUST be supplied within a Connection header\n   field (section 14.10) whenever TE is present in an HTTP/1.1 message.\n\n   A server tests whether a transfer-coding is acceptable, according to\n   a TE field, using these rules:\n\n      1. The \"chunked\" transfer-coding is always acceptable. If the\n         keyword \"trailers\" is listed, the client indicates that it is\n         willing to accept trailer fields in the chunked response on\n         behalf of itself and any downstream clients. The implication is\n         that, if given, the client is stating that either all\n         downstream clients are willing to accept trailer fields in the\n         forwarded response, or that it will attempt to buffer the\n         response on behalf of downstream recipients.\n\n         Note: HTTP/1.1 does not define any means to limit the size of a\n         chunked response such that a client can be assured of buffering\n         the entire response.\n\n      2. If the transfer-coding being tested is one of the transfer-\n         codings listed in the TE field, then it is acceptable unless it\n         is accompanied by a qvalue of 0. (As defined in section 3.9, a\n         qvalue of 0 means \"not acceptable.\")\n\n\n\nFielding, et al.            Standards Track                   [Page 142]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      3. If multiple transfer-codings are acceptable, then the\n         acceptable transfer-coding with the highest non-zero qvalue is\n         preferred.  The \"chunked\" transfer-coding always has a qvalue\n         of 1.\n\n   If the TE field-value is empty or if no TE field is present, the only\n   transfer-coding  is \"chunked\". A message with no transfer-coding is\n   always acceptable.\n\n14.40 Trailer\n\n   The Trailer general field value indicates that the given set of\n   header fields is present in the trailer of a message encoded with\n   chunked transfer-coding.\n\n       Trailer  = \"Trailer\" \":\" 1#field-name\n\n   An HTTP/1.1 message SHOULD include a Trailer header field in a\n   message using chunked transfer-coding with a non-empty trailer. Doing\n   so allows the recipient to know which header fields to expect in the\n   trailer.\n\n   If no Trailer header field is present, the trailer SHOULD NOT include\n   any header fields. See section 3.6.1 for restrictions on the use of\n   trailer fields in a \"chunked\" transfer-coding.\n\n   Message header fields listed in the Trailer header field MUST NOT\n   include the following header fields:\n\n      . Transfer-Encoding\n\n      . Content-Length\n\n      . Trailer\n\n14.41 Transfer-Encoding\n\n   The Transfer-Encoding general-header field indicates what (if any)\n   type of transformation has been applied to the message body in order\n   to safely transfer it between the sender and the recipient. This\n   differs from the content-coding in that the transfer-coding is a\n   property of the message, not of the entity.\n\n     Transfer-Encoding       = \"Transfer-Encoding\" \":\" 1#transfer-coding\n\n   Transfer-codings are defined in section 3.6. An example is:\n\n     Transfer-Encoding: chunked\n\n\n\nFielding, et al.            Standards Track                   [Page 143]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If multiple encodings have been applied to an entity, the transfer-\n   codings MUST be listed in the order in which they were applied.\n   Additional information about the encoding parameters MAY be provided\n   by other entity-header fields not defined by this specification.\n\n   Many older HTTP/1.0 applications do not understand the Transfer-\n   Encoding header.\n\n14.42 Upgrade\n\n   The Upgrade general-header allows the client to specify what\n   additional communication protocols it supports and would like to use\n   if the server finds it appropriate to switch protocols. The server\n   MUST use the Upgrade header field within a 101 (Switching Protocols)\n   response to indicate which protocol(s) are being switched.\n\n       Upgrade        = \"Upgrade\" \":\" 1#product\n\n   For example,\n\n       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\n\n   The Upgrade header field is intended to provide a simple mechanism\n   for transition from HTTP/1.1 to some other, incompatible protocol. It\n   does so by allowing the client to advertise its desire to use another\n   protocol, such as a later version of HTTP with a higher major version\n   number, even though the current request has been made using HTTP/1.1.\n   This eases the difficult transition between incompatible protocols by\n   allowing the client to initiate a request in the more commonly\n   supported protocol while indicating to the server that it would like\n   to use a \"better\" protocol if available (where \"better\" is determined\n   by the server, possibly according to the nature of the method and/or\n   resource being requested).\n\n   The Upgrade header field only applies to switching application-layer\n   protocols upon the existing transport-layer connection. Upgrade\n   cannot be used to insist on a protocol change; its acceptance and use\n   by the server is optional. The capabilities and nature of the\n   application-layer communication after the protocol change is entirely\n   dependent upon the new protocol chosen, although the first action\n   after changing the protocol MUST be a response to the initial HTTP\n   request containing the Upgrade header field.\n\n   The Upgrade header field only applies to the immediate connection.\n   Therefore, the upgrade keyword MUST be supplied within a Connection\n   header field (section 14.10) whenever Upgrade is present in an\n   HTTP/1.1 message.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 144]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Upgrade header field cannot be used to indicate a switch to a\n   protocol on a different connection. For that purpose, it is more\n   appropriate to use a 301, 302, 303, or 305 redirection response.\n\n   This specification only defines the protocol name \"HTTP\" for use by\n   the family of Hypertext Transfer Protocols, as defined by the HTTP\n   version rules of section 3.1 and future updates to this\n   specification. Any token can be used as a protocol name; however, it\n   will only be useful if both the client and server associate the name\n   with the same protocol.\n\n14.43 User-Agent\n\n   The User-Agent request-header field contains information about the\n   user agent originating the request. This is for statistical purposes,\n   the tracing of protocol violations, and automated recognition of user\n   agents for the sake of tailoring responses to avoid particular user\n   agent limitations. User agents SHOULD include this field with\n   requests. The field can contain multiple product tokens (section 3.8)\n   and comments identifying the agent and any subproducts which form a\n   significant part of the user agent. By convention, the product tokens\n   are listed in order of their significance for identifying the\n   application.\n\n       User-Agent     = \"User-Agent\" \":\" 1*( product | comment )\n\n   Example:\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n\n14.44 Vary\n\n   The Vary field value indicates the set of request-header fields that\n   fully determines, while the response is fresh, whether a cache is\n   permitted to use the response to reply to a subsequent request\n   without revalidation. For uncacheable or stale responses, the Vary\n   field value advises the user agent about the criteria that were used\n   to select the representation. A Vary field value of \"*\" implies that\n   a cache cannot determine from the request headers of a subsequent\n   request whether this response is the appropriate representation. See\n   section 13.6 for use of the Vary header field by caches.\n\n       Vary  = \"Vary\" \":\" ( \"*\" | 1#field-name )\n\n   An HTTP/1.1 server SHOULD include a Vary header field with any\n   cacheable response that is subject to server-driven negotiation.\n   Doing so allows a cache to properly interpret future requests on that\n   resource and informs the user agent about the presence of negotiation\n\n\n\nFielding, et al.            Standards Track                   [Page 145]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   on that resource. A server MAY include a Vary header field with a\n   non-cacheable response that is subject to server-driven negotiation,\n   since this might provide the user agent with useful information about\n   the dimensions over which the response varies at the time of the\n   response.\n\n   A Vary field value consisting of a list of field-names signals that\n   the representation selected for the response is based on a selection\n   algorithm which considers ONLY the listed request-header field values\n   in selecting the most appropriate representation. A cache MAY assume\n   that the same selection will be made for future requests with the\n   same values for the listed field names, for the duration of time for\n   which the response is fresh.\n\n   The field-names given are not limited to the set of standard\n   request-header fields defined by this specification. Field names are\n   case-insensitive.\n\n   A Vary field value of \"*\" signals that unspecified parameters not\n   limited to the request-headers (e.g., the network address of the\n   client), play a role in the selection of the response representation.\n   The \"*\" value MUST NOT be generated by a proxy server; it may only be\n   generated by an origin server.\n\n14.45  Via\n\n   The Via general-header field MUST be used by gateways and proxies to\n   indicate the intermediate protocols and recipients between the user\n   agent and the server on requests, and between the origin server and\n   the client on responses. It is analogous to the \"Received\" field of\n   RFC 822 [9] and is intended to be used for tracking message forwards,\n   avoiding request loops, and identifying the protocol capabilities of\n   all senders along the request/response chain.\n\n      Via =  \"Via\" \":\" 1#( received-protocol received-by [ comment ] )\n      received-protocol = [ protocol-name \"/\" ] protocol-version\n      protocol-name     = token\n      protocol-version  = token\n      received-by       = ( host [ \":\" port ] ) | pseudonym\n      pseudonym         = token\n\n   The received-protocol indicates the protocol version of the message\n   received by the server or client along each segment of the\n   request/response chain. The received-protocol version is appended to\n   the Via field value when the message is forwarded so that information\n   about the protocol capabilities of upstream applications remains\n   visible to all recipients.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 146]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The protocol-name is optional if and only if it would be \"HTTP\". The\n   received-by field is normally the host and optional port number of a\n   recipient server or client that subsequently forwarded the message.\n   However, if the real host is considered to be sensitive information,\n   it MAY be replaced by a pseudonym. If the port is not given, it MAY\n   be assumed to be the default port of the received-protocol.\n\n   Multiple Via field values represents each proxy or gateway that has\n   forwarded the message. Each recipient MUST append its information\n   such that the end result is ordered according to the sequence of\n   forwarding applications.\n\n   Comments MAY be used in the Via header field to identify the software\n   of the recipient proxy or gateway, analogous to the User-Agent and\n   Server header fields. However, all comments in the Via field are\n   optional and MAY be removed by any recipient prior to forwarding the\n   message.\n\n   For example, a request message could be sent from an HTTP/1.0 user\n   agent to an internal proxy code-named \"fred\", which uses HTTP/1.1 to\n   forward the request to a public proxy at nowhere.com, which completes\n   the request by forwarding it to the origin server at www.ics.uci.edu.\n   The request received by www.ics.uci.edu would then have the following\n   Via header field:\n\n       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\n\n   Proxies and gateways used as a portal through a network firewall\n   SHOULD NOT, by default, forward the names and ports of hosts within\n   the firewall region. This information SHOULD only be propagated if\n   explicitly enabled. If not enabled, the received-by host of any host\n   behind the firewall SHOULD be replaced by an appropriate pseudonym\n   for that host.\n\n   For organizations that have strong privacy requirements for hiding\n   internal structures, a proxy MAY combine an ordered subsequence of\n   Via header field entries with identical received-protocol values into\n   a single such entry. For example,\n\n       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy\n\n        could be collapsed to\n\n       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 147]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Applications SHOULD NOT combine multiple entries unless they are all\n   under the same organizational control and the hosts have already been\n   replaced by pseudonyms. Applications MUST NOT combine entries which\n   have different received-protocol values.\n\n14.46 Warning\n\n   The Warning general-header field is used to carry additional\n   information about the status or transformation of a message which\n   might not be reflected in the message. This information is typically\n   used to warn about a possible lack of semantic transparency from\n   caching operations or transformations applied to the entity body of\n   the message.\n\n   Warning headers are sent with responses using:\n\n       Warning    = \"Warning\" \":\" 1#warning-value\n\n       warning-value = warn-code SP warn-agent SP warn-text\n                                             [SP warn-date]\n\n       warn-code  = 3DIGIT\n       warn-agent = ( host [ \":\" port ] ) | pseudonym\n                       ; the name or pseudonym of the server adding\n                       ; the Warning header, for use in debugging\n       warn-text  = quoted-string\n       warn-date  = <\"> HTTP-date <\">\n\n   A response MAY carry more than one Warning header.\n\n   The warn-text SHOULD be in a natural language and character set that\n   is most likely to be intelligible to the human user receiving the\n   response. This decision MAY be based on any available knowledge, such\n   as the location of the cache or user, the Accept-Language field in a\n   request, the Content-Language field in a response, etc. The default\n   language is English and the default character set is ISO-8859-1.\n\n   If a character set other than ISO-8859-1 is used, it MUST be encoded\n   in the warn-text using the method described in RFC 2047 [14].\n\n   Warning headers can in general be applied to any message, however\n   some specific warn-codes are specific to caches and can only be\n   applied to response messages. New Warning headers SHOULD be added\n   after any existing Warning headers. A cache MUST NOT delete any\n   Warning header that it received with a message. However, if a cache\n   successfully validates a cache entry, it SHOULD remove any Warning\n   headers previously attached to that entry except as specified for\n\n\n\n\nFielding, et al.            Standards Track                   [Page 148]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   specific Warning codes. It MUST then add any Warning headers received\n   in the validating response. In other words, Warning headers are those\n   that would be attached to the most recent relevant response.\n\n   When multiple Warning headers are attached to a response, the user\n   agent ought to inform the user of as many of them as possible, in the\n   order that they appear in the response. If it is not possible to\n   inform the user of all of the warnings, the user agent SHOULD follow\n   these heuristics:\n\n      - Warnings that appear early in the response take priority over\n        those appearing later in the response.\n\n      - Warnings in the user's preferred character set take priority\n        over warnings in other character sets but with identical warn-\n        codes and warn-agents.\n\n   Systems that generate multiple Warning headers SHOULD order them with\n   this user agent behavior in mind.\n\n   Requirements for the behavior of caches with respect to Warnings are\n   stated in section 13.1.2.\n\n   This is a list of the currently-defined warn-codes, each with a\n   recommended warn-text in English, and a description of its meaning.\n\n   110 Response is stale\n     MUST be included whenever the returned response is stale.\n\n   111 Revalidation failed\n     MUST be included if a cache returns a stale response because an\n     attempt to revalidate the response failed, due to an inability to\n     reach the server.\n\n   112 Disconnected operation\n     SHOULD be included if the cache is intentionally disconnected from\n     the rest of the network for a period of time.\n\n   113 Heuristic expiration\n     MUST be included if the cache heuristically chose a freshness\n     lifetime greater than 24 hours and the response's age is greater\n     than 24 hours.\n\n   199 Miscellaneous warning\n     The warning text MAY include arbitrary information to be presented\n     to a human user, or logged. A system receiving this warning MUST\n     NOT take any automated action, besides presenting the warning to\n     the user.\n\n\n\nFielding, et al.            Standards Track                   [Page 149]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   214 Transformation applied\n     MUST be added by an intermediate cache or proxy if it applies any\n     transformation changing the content-coding (as specified in the\n     Content-Encoding header) or media-type (as specified in the\n     Content-Type header) of the response, or the entity-body of the\n     response, unless this Warning code already appears in the response.\n\n   299 Miscellaneous persistent warning\n     The warning text MAY include arbitrary information to be presented\n     to a human user, or logged. A system receiving this warning MUST\n     NOT take any automated action.\n\n   If an implementation sends a message with one or more Warning headers\n   whose version is HTTP/1.0 or lower, then the sender MUST include in\n   each warning-value a warn-date that matches the date in the response.\n\n   If an implementation receives a message with a warning-value that\n   includes a warn-date, and that warn-date is different from the Date\n   value in the response, then that warning-value MUST be deleted from\n   the message before storing, forwarding, or using it. (This prevents\n   bad consequences of naive caching of Warning header fields.) If all\n   of the warning-values are deleted for this reason, the Warning header\n   MUST be deleted as well.\n\n14.47 WWW-Authenticate\n\n   The WWW-Authenticate response-header field MUST be included in 401\n   (Unauthorized) response messages. The field value consists of at\n   least one challenge that indicates the authentication scheme(s) and\n   parameters applicable to the Request-URI.\n\n       WWW-Authenticate  = \"WWW-Authenticate\" \":\" 1#challenge\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. User\n   agents are advised to take special care in parsing the WWW-\n   Authenticate field value as it might contain more than one challenge,\n   or if more than one WWW-Authenticate header field is provided, the\n   contents of a challenge itself can contain a comma-separated list of\n   authentication parameters.\n\n15 Security Considerations\n\n   This section is meant to inform application developers, information\n   providers, and users of the security limitations in HTTP/1.1 as\n   described by this document. The discussion does not include\n   definitive solutions to the problems revealed, though it does make\n   some suggestions for reducing security risks.\n\n\n\nFielding, et al.            Standards Track                   [Page 150]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.1 Personal Information\n\n   HTTP clients are often privy to large amounts of personal information\n   (e.g. the user's name, location, mail address, passwords, encryption\n   keys, etc.), and SHOULD be very careful to prevent unintentional\n   leakage of this information via the HTTP protocol to other sources.\n   We very strongly recommend that a convenient interface be provided\n   for the user to control dissemination of such information, and that\n   designers and implementors be particularly careful in this area.\n   History shows that errors in this area often create serious security\n   and/or privacy problems and generate highly adverse publicity for the\n   implementor's company.\n\n15.1.1 Abuse of Server Log Information\n\n   A server is in the position to save personal data about a user's\n   requests which might identify their reading patterns or subjects of\n   interest. This information is clearly confidential in nature and its\n   handling can be constrained by law in certain countries. People using\n   the HTTP protocol to provide data are responsible for ensuring that\n   such material is not distributed without the permission of any\n   individuals that are identifiable by the published results.\n\n15.1.2 Transfer of Sensitive Information\n\n   Like any generic data transfer protocol, HTTP cannot regulate the\n   content of the data that is transferred, nor is there any a priori\n   method of determining the sensitivity of any particular piece of\n   information within the context of any given request. Therefore,\n   applications SHOULD supply as much control over this information as\n   possible to the provider of that information. Four header fields are\n   worth special mention in this context: Server, Via, Referer and From.\n\n   Revealing the specific software version of the server might allow the\n   server machine to become more vulnerable to attacks against software\n   that is known to contain security holes. Implementors SHOULD make the\n   Server header field a configurable option.\n\n   Proxies which serve as a portal through a network firewall SHOULD\n   take special precautions regarding the transfer of header information\n   that identifies the hosts behind the firewall. In particular, they\n   SHOULD remove, or replace with sanitized versions, any Via fields\n   generated behind the firewall.\n\n   The Referer header allows reading patterns to be studied and reverse\n   links drawn. Although it can be very useful, its power can be abused\n   if user details are not separated from the information contained in\n\n\n\n\nFielding, et al.            Standards Track                   [Page 151]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the Referer. Even when the personal information has been removed, the\n   Referer header might indicate a private document's URI whose\n   publication would be inappropriate.\n\n   The information sent in the From field might conflict with the user's\n   privacy interests or their site's security policy, and hence it\n   SHOULD NOT be transmitted without the user being able to disable,\n   enable, and modify the contents of the field. The user MUST be able\n   to set the contents of this field within a user preference or\n   application defaults configuration.\n\n   We suggest, though do not require, that a convenient toggle interface\n   be provided for the user to enable or disable the sending of From and\n   Referer information.\n\n   The User-Agent (section 14.43) or Server (section 14.38) header\n   fields can sometimes be used to determine that a specific client or\n   server have a particular security hole which might be exploited.\n   Unfortunately, this same information is often used for other valuable\n   purposes for which HTTP currently has no better mechanism.\n\n15.1.3 Encoding Sensitive Information in URI's\n\n   Because the source of a link might be private information or might\n   reveal an otherwise private information source, it is strongly\n   recommended that the user be able to select whether or not the\n   Referer field is sent. For example, a browser client could have a\n   toggle switch for browsing openly/anonymously, which would\n   respectively enable/disable the sending of Referer and From\n   information.\n\n   Clients SHOULD NOT include a Referer header field in a (non-secure)\n   HTTP request if the referring page was transferred with a secure\n   protocol.\n\n   Authors of services which use the HTTP protocol SHOULD NOT use GET\n   based forms for the submission of sensitive data, because this will\n   cause this data to be encoded in the Request-URI. Many existing\n   servers, proxies, and user agents will log the request URI in some\n   place where it might be visible to third parties. Servers can use\n   POST-based form submission instead\n\n15.1.4 Privacy Issues Connected to Accept Headers\n\n   Accept request-headers can reveal information about the user to all\n   servers which are accessed. The Accept-Language header in particular\n   can reveal information the user would consider to be of a private\n   nature, because the understanding of particular languages is often\n\n\n\nFielding, et al.            Standards Track                   [Page 152]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   strongly correlated to the membership of a particular ethnic group.\n   User agents which offer the option to configure the contents of an\n   Accept-Language header to be sent in every request are strongly\n   encouraged to let the configuration process include a message which\n   makes the user aware of the loss of privacy involved.\n\n   An approach that limits the loss of privacy would be for a user agent\n   to omit the sending of Accept-Language headers by default, and to ask\n   the user whether or not to start sending Accept-Language headers to a\n   server if it detects, by looking for any Vary response-header fields\n   generated by the server, that such sending could improve the quality\n   of service.\n\n   Elaborate user-customized accept header fields sent in every request,\n   in particular if these include quality values, can be used by servers\n   as relatively reliable and long-lived user identifiers. Such user\n   identifiers would allow content providers to do click-trail tracking,\n   and would allow collaborating content providers to match cross-server\n   click-trails or form submissions of individual users. Note that for\n   many users not behind a proxy, the network address of the host\n   running the user agent will also serve as a long-lived user\n   identifier. In environments where proxies are used to enhance\n   privacy, user agents ought to be conservative in offering accept\n   header configuration options to end users. As an extreme privacy\n   measure, proxies could filter the accept headers in relayed requests.\n   General purpose user agents which provide a high degree of header\n   configurability SHOULD warn users about the loss of privacy which can\n   be involved.\n\n15.2 Attacks Based On File and Path Names\n\n   Implementations of HTTP origin servers SHOULD be careful to restrict\n   the documents returned by HTTP requests to be only those that were\n   intended by the server administrators. If an HTTP server translates\n   HTTP URIs directly into file system calls, the server MUST take\n   special care not to serve files that were not intended to be\n   delivered to HTTP clients. For example, UNIX, Microsoft Windows, and\n   other operating systems use \"..\" as a path component to indicate a\n   directory level above the current one. On such a system, an HTTP\n   server MUST disallow any such construct in the Request-URI if it\n   would otherwise allow access to a resource outside those intended to\n   be accessible via the HTTP server. Similarly, files intended for\n   reference only internally to the server (such as access control\n   files, configuration files, and script code) MUST be protected from\n   inappropriate retrieval, since they might contain sensitive\n   information. Experience has shown that minor bugs in such HTTP server\n   implementations have turned into security risks.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 153]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.3 DNS Spoofing\n\n   Clients using HTTP rely heavily on the Domain Name Service, and are\n   thus generally prone to security attacks based on the deliberate\n   mis-association of IP addresses and DNS names. Clients need to be\n   cautious in assuming the continuing validity of an IP number/DNS name\n   association.\n\n   In particular, HTTP clients SHOULD rely on their name resolver for\n   confirmation of an IP number/DNS name association, rather than\n   caching the result of previous host name lookups. Many platforms\n   already can cache host name lookups locally when appropriate, and\n   they SHOULD be configured to do so. It is proper for these lookups to\n   be cached, however, only when the TTL (Time To Live) information\n   reported by the name server makes it likely that the cached\n   information will remain useful.\n\n   If HTTP clients cache the results of host name lookups in order to\n   achieve a performance improvement, they MUST observe the TTL\n   information reported by DNS.\n\n   If HTTP clients do not observe this rule, they could be spoofed when\n   a previously-accessed server's IP address changes. As network\n   renumbering is expected to become increasingly common [24], the\n   possibility of this form of attack will grow. Observing this\n   requirement thus reduces this potential security vulnerability.\n\n   This requirement also improves the load-balancing behavior of clients\n   for replicated servers using the same DNS name and reduces the\n   likelihood of a user's experiencing failure in accessing sites which\n   use that strategy.\n\n15.4 Location Headers and Spoofing\n\n   If a single server supports multiple organizations that do not trust\n   one another, then it MUST check the values of Location and Content-\n   Location headers in responses that are generated under control of\n   said organizations to make sure that they do not attempt to\n   invalidate resources over which they have no authority.\n\n15.5 Content-Disposition Issues\n\n   RFC 1806 [35], from which the often implemented Content-Disposition\n   (see section 19.5.1) header in HTTP is derived, has a number of very\n   serious security considerations. Content-Disposition is not part of\n   the HTTP standard, but since it is widely implemented, we are\n   documenting its use and risks for implementors. See RFC 2183 [49]\n   (which updates RFC 1806) for details.\n\n\n\nFielding, et al.            Standards Track                   [Page 154]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.6 Authentication Credentials and Idle Clients\n\n   Existing HTTP clients and user agents typically retain authentication\n   information indefinitely. HTTP/1.1. does not provide a method for a\n   server to direct clients to discard these cached credentials. This is\n   a significant defect that requires further extensions to HTTP.\n   Circumstances under which credential caching can interfere with the\n   application's security model include but are not limited to:\n\n      - Clients which have been idle for an extended period following\n        which the server might wish to cause the client to reprompt the\n        user for credentials.\n\n      - Applications which include a session termination indication\n        (such as a `logout' or `commit' button on a page) after which\n        the server side of the application `knows' that there is no\n        further reason for the client to retain the credentials.\n\n   This is currently under separate study. There are a number of work-\n   arounds to parts of this problem, and we encourage the use of\n   password protection in screen savers, idle time-outs, and other\n   methods which mitigate the security problems inherent in this\n   problem. In particular, user agents which cache credentials are\n   encouraged to provide a readily accessible mechanism for discarding\n   cached credentials under user control.\n\n15.7 Proxies and Caching\n\n   By their very nature, HTTP proxies are men-in-the-middle, and\n   represent an opportunity for man-in-the-middle attacks. Compromise of\n   the systems on which the proxies run can result in serious security\n   and privacy problems. Proxies have access to security-related\n   information, personal information about individual users and\n   organizations, and proprietary information belonging to users and\n   content providers. A compromised proxy, or a proxy implemented or\n   configured without regard to security and privacy considerations,\n   might be used in the commission of a wide range of potential attacks.\n\n   Proxy operators should protect the systems on which proxies run as\n   they would protect any system that contains or transports sensitive\n   information. In particular, log information gathered at proxies often\n   contains highly sensitive personal information, and/or information\n   about organizations. Log information should be carefully guarded, and\n   appropriate guidelines for use developed and followed. (Section\n   15.1.1).\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 155]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Caching proxies provide additional potential vulnerabilities, since\n   the contents of the cache represent an attractive target for\n   malicious exploitation. Because cache contents persist after an HTTP\n   request is complete, an attack on the cache can reveal information\n   long after a user believes that the information has been removed from\n   the network. Therefore, cache contents should be protected as\n   sensitive information.\n\n   Proxy implementors should consider the privacy and security\n   implications of their design and coding decisions, and of the\n   configuration options they provide to proxy operators (especially the\n   default configuration).\n\n   Users of a proxy need to be aware that they are no trustworthier than\n   the people who run the proxy; HTTP itself cannot solve this problem.\n\n   The judicious use of cryptography, when appropriate, may suffice to\n   protect against a broad range of security and privacy attacks. Such\n   cryptography is beyond the scope of the HTTP/1.1 specification.\n\n15.7.1 Denial of Service Attacks on Proxies\n\n   They exist. They are hard to defend against. Research continues.\n   Beware.\n\n16 Acknowledgments\n\n   This specification makes heavy use of the augmented BNF and generic\n   constructs defined by David H. Crocker for RFC 822 [9]. Similarly, it\n   reuses many of the definitions provided by Nathaniel Borenstein and\n   Ned Freed for MIME [7]. We hope that their inclusion in this\n   specification will help reduce past confusion over the relationship\n   between HTTP and Internet mail message formats.\n\n   The HTTP protocol has evolved considerably over the years. It has\n   benefited from a large and active developer community--the many\n   people who have participated on the www-talk mailing list--and it is\n   that community which has been most responsible for the success of\n   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert\n   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois\n   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob\n   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc\n   VanHeyningen deserve special recognition for their efforts in\n   defining early aspects of the protocol.\n\n   This document has benefited greatly from the comments of all those\n   participating in the HTTP-WG. In addition to those already mentioned,\n   the following individuals have contributed to this specification:\n\n\n\nFielding, et al.            Standards Track                   [Page 156]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       Gary Adams                  Ross Patterson\n       Harald Tveit Alvestrand     Albert Lunde\n       Keith Ball                  John C. Mallery\n       Brian Behlendorf            Jean-Philippe Martin-Flatin\n       Paul Burchard               Mitra\n       Maurizio Codogno            David Morris\n       Mike Cowlishaw              Gavin Nicol\n       Roman Czyborra              Bill Perry\n       Michael A. Dolan            Jeffrey Perry\n       David J. Fiander            Scott Powers\n       Alan Freier                 Owen Rees\n       Marc Hedlund                Luigi Rizzo\n       Greg Herlihy                David Robinson\n       Koen Holtman                Marc Salomon\n       Alex Hopmann                Rich Salz\n       Bob Jernigan                Allan M. Schiffman\n       Shel Kaphan                 Jim Seidman\n       Rohit Khare                 Chuck Shotton\n       John Klensin                Eric W. Sink\n       Martijn Koster              Simon E. Spero\n       Alexei Kosut                Richard N. Taylor\n       David M. Kristol            Robert S. Thau\n       Daniel LaLiberte            Bill (BearHeart) Weinman\n       Ben Laurie                  Francois Yergeau\n       Paul J. Leach               Mary Ellen Zurko\n       Daniel DuBois               Josh Cohen\n\n\n   Much of the content and presentation of the caching design is due to\n   suggestions and comments from individuals including: Shel Kaphan,\n   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.\n\n   Most of the specification of ranges is based on work originally done\n   by Ari Luotonen and John Franks, with additional input from Steve\n   Zilles.\n\n   Thanks to the \"cave men\" of Palo Alto. You know who you are.\n\n   Jim Gettys (the current editor of this document) wishes particularly\n   to thank Roy Fielding, the previous editor of this document, along\n   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen\n   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and\n   Larry Masinter for their help. And thanks go particularly to Jeff\n   Mogul and Scott Lawrence for performing the \"MUST/MAY/SHOULD\" audit.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 157]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik\n   Frystyk implemented RFC 2068 early, and we wish to thank them for the\n   discovery of many of the problems that this document attempts to\n   rectify.\n\n17 References\n\n   [1] Alvestrand, H., \"Tags for the Identification of Languages\", RFC\n       1766, March 1995.\n\n   [2] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,\n       D. and B. Alberti, \"The Internet Gopher Protocol (a distributed\n       document search and retrieval protocol)\", RFC 1436, March 1993.\n\n   [3] Berners-Lee, T., \"Universal Resource Identifiers in WWW\", RFC\n       1630, June 1994.\n\n   [4] Berners-Lee, T., Masinter, L. and M. McCahill, \"Uniform Resource\n       Locators (URL)\", RFC 1738, December 1994.\n\n   [5] Berners-Lee, T. and D. Connolly, \"Hypertext Markup Language -\n       2.0\", RFC 1866, November 1995.\n\n   [6] Berners-Lee, T., Fielding, R. and H. Frystyk, \"Hypertext Transfer\n       Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n\n   [7] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n       Extensions (MIME) Part One: Format of Internet Message Bodies\",\n       RFC 2045, November 1996.\n\n   [8] Braden, R., \"Requirements for Internet Hosts -- Communication\n       Layers\", STD 3, RFC 1123, October 1989.\n\n   [9] Crocker, D., \"Standard for The Format of ARPA Internet Text\n       Messages\", STD 11, RFC 822, August 1982.\n\n   [10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,\n        Sui, J., and M. Grinbaum, \"WAIS Interface Protocol Prototype\n        Functional Specification,\" (v1.5), Thinking Machines\n        Corporation, April 1990.\n\n   [11] Fielding, R., \"Relative Uniform Resource Locators\", RFC 1808,\n        June 1995.\n\n   [12] Horton, M. and R. Adams, \"Standard for Interchange of USENET\n        Messages\", RFC 1036, December 1987.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 158]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [13] Kantor, B. and P. Lapsley, \"Network News Transfer Protocol\", RFC\n        977, February 1986.\n\n   [14] Moore, K., \"MIME (Multipurpose Internet Mail Extensions) Part\n        Three: Message Header Extensions for Non-ASCII Text\", RFC 2047,\n        November 1996.\n\n   [15] Nebel, E. and L. Masinter, \"Form-based File Upload in HTML\", RFC\n        1867, November 1995.\n\n   [16] Postel, J., \"Simple Mail Transfer Protocol\", STD 10, RFC 821,\n        August 1982.\n\n   [17] Postel, J., \"Media Type Registration Procedure\", RFC 1590,\n        November 1996.\n\n   [18] Postel, J. and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC\n        959, October 1985.\n\n   [19] Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700,\n        October 1994.\n\n   [20] Sollins, K. and L. Masinter, \"Functional Requirements for\n        Uniform Resource Names\", RFC 1737, December 1994.\n\n   [21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for\n        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.\n\n   [22] ISO-8859. International Standard -- Information Processing --\n        8-bit Single-Byte Coded Graphic Character Sets --\n        Part 1: Latin alphabet No. 1, ISO-8859-1:1987.\n        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.\n        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.\n        Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.\n        Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.\n        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.\n        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.\n        Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.\n        Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.\n\n   [23] Meyers, J. and M. Rose, \"The Content-MD5 Header Field\", RFC\n        1864, October 1995.\n\n   [24] Carpenter, B. and Y. Rekhter, \"Renumbering Needs Work\", RFC\n        1900, February 1996.\n\n   [25] Deutsch, P., \"GZIP file format specification version 4.3\", RFC\n        1952, May 1996.\n\n\n\nFielding, et al.            Standards Track                   [Page 159]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [26] Venkata N. Padmanabhan, and Jeffrey C. Mogul. \"Improving HTTP\n        Latency\", Computer Networks and ISDN Systems, v. 28, pp. 25-35,\n        Dec. 1995. Slightly revised version of paper in Proc. 2nd\n        International WWW Conference '94: Mosaic and the Web, Oct. 1994,\n        which is available at\n        http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat\n        ency.html.\n\n   [27] Joe Touch, John Heidemann, and Katia Obraczka. \"Analysis of HTTP\n        Performance\", <URL: http://www.isi.edu/touch/pubs/http-perf96/>,\n        ISI Research Report ISI/RR-98-463, (original report dated Aug.\n        1996), USC/Information Sciences Institute, August 1998.\n\n   [28] Mills, D., \"Network Time Protocol (Version 3) Specification,\n        Implementation and Analysis\", RFC 1305, March 1992.\n\n   [29] Deutsch, P., \"DEFLATE Compressed Data Format Specification\n        version 1.3\", RFC 1951, May 1996.\n\n   [30] S. Spero, \"Analysis of HTTP Performance Problems,\"\n        http://sunsite.unc.edu/mdma-release/http-prob.html.\n\n   [31] Deutsch, P. and J. Gailly, \"ZLIB Compressed Data Format\n        Specification version 3.3\", RFC 1950, May 1996.\n\n   [32] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,\n        Luotonen, A., Sink, E. and L. Stewart, \"An Extension to HTTP:\n        Digest Access Authentication\", RFC 2069, January 1997.\n\n   [33] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T.\n        Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC\n        2068, January 1997.\n\n   [34] Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n\n   [35] Troost, R. and Dorner, S., \"Communicating Presentation\n        Information in Internet Messages: The Content-Disposition\n        Header\", RFC 1806, June 1995.\n\n   [36] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, \"Use and\n        Interpretation of HTTP Version Numbers\", RFC 2145, May 1997.\n        [jg639]\n\n   [37] Palme, J., \"Common Internet Message Headers\", RFC 2076, February\n        1997. [jg640]\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 160]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [38] Yergeau, F., \"UTF-8, a transformation format of Unicode and\n        ISO-10646\", RFC 2279, January 1998. [jg641]\n\n   [39] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E.,\n        Lie, H., and C. Lilley. \"Network Performance Effects of\n        HTTP/1.1, CSS1, and PNG,\" Proceedings of ACM SIGCOMM '97, Cannes\n        France, September 1997.[jg642]\n\n   [40] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Two: Media Types\", RFC 2046, November\n        1996. [jg643]\n\n   [41] Alvestrand, H., \"IETF Policy on Character Sets and Languages\",\n        BCP 18, RFC 2277, January 1998. [jg644]\n\n   [42] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource\n        Identifiers (URI): Generic Syntax and Semantics\", RFC 2396,\n        August 1998. [jg645]\n\n   [43] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n        Leach, P., Luotonen, A., Sink, E. and L. Stewart, \"HTTP\n        Authentication: Basic and Digest Access Authentication\", RFC\n        2617, June 1999. [jg646]\n\n   [44] Luotonen, A., \"Tunneling TCP based protocols through Web proxy\n        servers,\" Work in Progress. [jg647]\n\n   [45] Palme, J. and A. Hopmann, \"MIME E-mail Encapsulation of\n        Aggregate Documents, such as HTML (MHTML)\", RFC 2110, March\n        1997.\n\n   [46] Bradner, S., \"The Internet Standards Process -- Revision 3\", BCP\n        9, RFC 2026, October 1996.\n\n   [47] Masinter, L., \"Hyper Text Coffee Pot Control Protocol\n        (HTCPCP/1.0)\", RFC 2324, 1 April 1998.\n\n   [48] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Five: Conformance Criteria and Examples\",\n        RFC 2049, November 1996.\n\n   [49] Troost, R., Dorner, S. and K. Moore, \"Communicating Presentation\n        Information in Internet Messages: The Content-Disposition Header\n        Field\", RFC 2183, August 1997.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 161]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n18 Authors' Addresses\n\n   Roy T. Fielding\n   Information and Computer Science\n   University of California, Irvine\n   Irvine, CA 92697-3425, USA\n\n   Fax: +1 (949) 824-1715\n   EMail: fielding@ics.uci.edu\n\n\n   James Gettys\n   World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: jg@w3.org\n\n\n   Jeffrey C. Mogul\n   Western Research Laboratory\n   Compaq Computer Corporation\n   250 University Avenue\n   Palo Alto, California, 94305, USA\n\n   EMail: mogul@wrl.dec.com\n\n\n   Henrik Frystyk Nielsen\n   World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: frystyk@w3.org\n\n\n   Larry Masinter\n   Xerox Corporation\n   3333 Coyote Hill Road\n   Palo Alto, CA 94034, USA\n\n   EMail: masinter@parc.xerox.com\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 162]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Paul J. Leach\n   Microsoft Corporation\n   1 Microsoft Way\n   Redmond, WA 98052, USA\n\n   EMail: paulle@microsoft.com\n\n\n   Tim Berners-Lee\n   Director, World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: timbl@w3.org\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 163]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n19 Appendices\n\n19.1 Internet Media Type message/http and application/http\n\n   In addition to defining the HTTP/1.1 protocol, this document serves\n   as the specification for the Internet media type \"message/http\" and\n   \"application/http\". The message/http type can be used to enclose a\n   single HTTP request or response message, provided that it obeys the\n   MIME restrictions for all \"message\" types regarding line length and\n   encodings. The application/http type can be used to enclose a\n   pipeline of one or more HTTP request or response messages (not\n   intermixed). The following is to be registered with IANA [17].\n\n       Media Type name:         message\n       Media subtype name:      http\n       Required parameters:     none\n       Optional parameters:     version, msgtype\n        version: The HTTP-Version number of the enclosed message\n                 (e.g., \"1.1\"). If not present, the version can be\n                 determined from the first line of the body.\n        msgtype: The message type -- \"request\" or \"response\". If not\n                 present, the type can be determined from the first\n                 line of the body.\n       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                                permitted\n       Security considerations: none\n\n       Media Type name:         application\n       Media subtype name:      http\n       Required parameters:     none\n       Optional parameters:     version, msgtype\n        version: The HTTP-Version number of the enclosed messages\n                 (e.g., \"1.1\"). If not present, the version can be\n                 determined from the first line of the body.\n        msgtype: The message type -- \"request\" or \"response\". If not\n                 present, the type can be determined from the first\n                 line of the body.\n       Encoding considerations: HTTP messages enclosed by this type\n                 are in \"binary\" format; use of an appropriate\n                 Content-Transfer-Encoding is required when\n                 transmitted via E-mail.\n       Security considerations: none\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 164]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n19.2 Internet Media Type multipart/byteranges\n\n   When an HTTP 206 (Partial Content) response message includes the\n   content of multiple ranges (a response to a request for multiple\n   non-overlapping ranges), these are transmitted as a multipart\n   message-body. The media type for this purpose is called\n   \"multipart/byteranges\".\n\n   The multipart/byteranges media type includes two or more parts, each\n   with its own Content-Type and Content-Range fields. The required\n   boundary parameter specifies the boundary string used to separate\n   each body-part.\n\n       Media Type name:         multipart\n       Media subtype name:      byteranges\n       Required parameters:     boundary\n       Optional parameters:     none\n       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                                permitted\n       Security considerations: none\n\n\n   For example:\n\n   HTTP/1.1 206 Partial Content\n   Date: Wed, 15 Nov 1995 06:25:24 GMT\n   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n\n   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n   Content-range: bytes 500-999/8000\n\n   ...the first range...\n   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n   Content-range: bytes 7000-7999/8000\n\n   ...the second range\n   --THIS_STRING_SEPARATES--\n\n      Notes:\n\n      1) Additional CRLFs may precede the first boundary string in the\n         entity.\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 165]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      2) Although RFC 2046 [40] permits the boundary string to be\n         quoted, some existing implementations handle a quoted boundary\n         string incorrectly.\n\n      3) A number of browsers and servers were coded to an early draft\n         of the byteranges specification to use a media type of\n         multipart/x-byteranges, which is almost, but not quite\n         compatible with the version documented in HTTP/1.1.\n\n19.3 Tolerant Applications\n\n   Although this document specifies the requirements for the generation\n   of HTTP/1.1 messages, not all applications will be correct in their\n   implementation. We therefore recommend that operational applications\n   be tolerant of deviations whenever those deviations can be\n   interpreted unambiguously.\n\n   Clients SHOULD be tolerant in parsing the Status-Line and servers\n   tolerant when parsing the Request-Line. In particular, they SHOULD\n   accept any amount of SP or HT characters between fields, even though\n   only a single SP is required.\n\n   The line terminator for message-header fields is the sequence CRLF.\n   However, we recommend that applications, when parsing such headers,\n   recognize a single LF as a line terminator and ignore the leading CR.\n\n   The character set of an entity-body SHOULD be labeled as the lowest\n   common denominator of the character codes used within that body, with\n   the exception that not labeling the entity is preferred over labeling\n   the entity with the labels US-ASCII or ISO-8859-1. See section 3.7.1\n   and 3.4.1.\n\n   Additional rules for requirements on parsing and encoding of dates\n   and other potential problems with date encodings include:\n\n      - HTTP/1.1 clients and caches SHOULD assume that an RFC-850 date\n        which appears to be more than 50 years in the future is in fact\n        in the past (this helps solve the \"year 2000\" problem).\n\n      - An HTTP/1.1 implementation MAY internally represent a parsed\n        Expires date as earlier than the proper value, but MUST NOT\n        internally represent a parsed Expires date as later than the\n        proper value.\n\n      - All expiration-related calculations MUST be done in GMT. The\n        local time zone MUST NOT influence the calculation or comparison\n        of an age or expiration time.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 166]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If an HTTP header incorrectly carries a date value with a time\n        zone other than GMT, it MUST be converted into GMT using the\n        most conservative possible conversion.\n\n19.4 Differences Between HTTP Entities and RFC 2045 Entities\n\n   HTTP/1.1 uses many of the constructs defined for Internet Mail (RFC\n   822 [9]) and the Multipurpose Internet Mail Extensions (MIME [7]) to\n   allow entities to be transmitted in an open variety of\n   representations and with extensible mechanisms. However, RFC 2045\n   discusses mail, and HTTP has a few features that are different from\n   those described in RFC 2045. These differences were carefully chosen\n   to optimize performance over binary connections, to allow greater\n   freedom in the use of new media types, to make date comparisons\n   easier, and to acknowledge the practice of some early HTTP servers\n   and clients.\n\n   This appendix describes specific areas where HTTP differs from RFC\n   2045. Proxies and gateways to strict MIME environments SHOULD be\n   aware of these differences and provide the appropriate conversions\n   where necessary. Proxies and gateways from MIME environments to HTTP\n   also need to be aware of the differences because some conversions\n   might be required.\n\n19.4.1 MIME-Version\n\n   HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY\n   include a single MIME-Version general-header field to indicate what\n   version of the MIME protocol was used to construct the message. Use\n   of the MIME-Version header field indicates that the message is in\n   full compliance with the MIME protocol (as defined in RFC 2045[7]).\n   Proxies/gateways are responsible for ensuring full compliance (where\n   possible) when exporting HTTP messages to strict MIME environments.\n\n       MIME-Version   = \"MIME-Version\" \":\" 1*DIGIT \".\" 1*DIGIT\n\n   MIME version \"1.0\" is the default for use in HTTP/1.1. However,\n   HTTP/1.1 message parsing and semantics are defined by this document\n   and not the MIME specification.\n\n19.4.2 Conversion to Canonical Form\n\n   RFC 2045 [7] requires that an Internet mail entity be converted to\n   canonical form prior to being transferred, as described in section 4\n   of RFC 2049 [48]. Section 3.7.1 of this document describes the forms\n   allowed for subtypes of the \"text\" media type when transmitted over\n   HTTP. RFC 2046 requires that content with a type of \"text\" represent\n   line breaks as CRLF and forbids the use of CR or LF outside of line\n\n\n\nFielding, et al.            Standards Track                   [Page 167]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a\n   line break within text content when a message is transmitted over\n   HTTP.\n\n   Where it is possible, a proxy or gateway from HTTP to a strict MIME\n   environment SHOULD translate all line breaks within the text media\n   types described in section 3.7.1 of this document to the RFC 2049\n   canonical form of CRLF. Note, however, that this might be complicated\n   by the presence of a Content-Encoding and by the fact that HTTP\n   allows the use of some character sets which do not use octets 13 and\n   10 to represent CR and LF, as is the case for some multi-byte\n   character sets.\n\n   Implementors should note that conversion will break any cryptographic\n   checksums applied to the original content unless the original content\n   is already in canonical form. Therefore, the canonical form is\n   recommended for any content that uses such checksums in HTTP.\n\n19.4.3 Conversion of Date Formats\n\n   HTTP/1.1 uses a restricted set of date formats (section 3.3.1) to\n   simplify the process of date comparison. Proxies and gateways from\n   other protocols SHOULD ensure that any Date header field present in a\n   message conforms to one of the HTTP/1.1 formats and rewrite the date\n   if necessary.\n\n19.4.4 Introduction of Content-Encoding\n\n   RFC 2045 does not include any concept equivalent to HTTP/1.1's\n   Content-Encoding header field. Since this acts as a modifier on the\n   media type, proxies and gateways from HTTP to MIME-compliant\n   protocols MUST either change the value of the Content-Type header\n   field or decode the entity-body before forwarding the message. (Some\n   experimental applications of Content-Type for Internet mail have used\n   a media-type parameter of \";conversions=<content-coding>\" to perform\n   a function equivalent to Content-Encoding. However, this parameter is\n   not part of RFC 2045.)\n\n19.4.5 No Content-Transfer-Encoding\n\n   HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC\n   2045. Proxies and gateways from MIME-compliant protocols to HTTP MUST\n   remove any non-identity CTE (\"quoted-printable\" or \"base64\") encoding\n   prior to delivering the response message to an HTTP client.\n\n   Proxies and gateways from HTTP to MIME-compliant protocols are\n   responsible for ensuring that the message is in the correct format\n   and encoding for safe transport on that protocol, where \"safe\n\n\n\nFielding, et al.            Standards Track                   [Page 168]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   transport\" is defined by the limitations of the protocol being used.\n   Such a proxy or gateway SHOULD label the data with an appropriate\n   Content-Transfer-Encoding if doing so will improve the likelihood of\n   safe transport over the destination protocol.\n\n19.4.6 Introduction of Transfer-Encoding\n\n   HTTP/1.1 introduces the Transfer-Encoding header field (section\n   14.41). Proxies/gateways MUST remove any transfer-coding prior to\n   forwarding a message via a MIME-compliant protocol.\n\n   A process for decoding the \"chunked\" transfer-coding (section 3.6)\n   can be represented in pseudo-code as:\n\n       length := 0\n       read chunk-size, chunk-extension (if any) and CRLF\n       while (chunk-size > 0) {\n          read chunk-data and CRLF\n          append chunk-data to entity-body\n          length := length + chunk-size\n          read chunk-size and CRLF\n       }\n       read entity-header\n       while (entity-header not empty) {\n          append entity-header to existing header fields\n          read entity-header\n       }\n       Content-Length := length\n       Remove \"chunked\" from Transfer-Encoding\n\n19.4.7 MHTML and Line Length Limitations\n\n   HTTP implementations which share code with MHTML [45] implementations\n   need to be aware of MIME line length limitations. Since HTTP does not\n   have this limitation, HTTP does not fold long lines. MHTML messages\n   being transported by HTTP follow all conventions of MHTML, including\n   line length limitations and folding, canonicalization, etc., since\n   HTTP transports all message-bodies as payload (see section 3.7.2) and\n   does not interpret the content or any MIME header lines that might be\n   contained therein.\n\n19.5 Additional Features\n\n   RFC 1945 and RFC 2068 document protocol elements used by some\n   existing HTTP implementations, but not consistently and correctly\n   across most HTTP/1.1 applications. Implementors are advised to be\n   aware of these features, but cannot rely upon their presence in, or\n   interoperability with, other HTTP/1.1 applications. Some of these\n\n\n\nFielding, et al.            Standards Track                   [Page 169]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   describe proposed experimental features, and some describe features\n   that experimental deployment found lacking that are now addressed in\n   the base HTTP/1.1 specification.\n\n   A number of other headers, such as Content-Disposition and Title,\n   from SMTP and MIME are also often implemented (see RFC 2076 [37]).\n\n19.5.1 Content-Disposition\n\n   The Content-Disposition response-header field has been proposed as a\n   means for the origin server to suggest a default filename if the user\n   requests that the content is saved to a file. This usage is derived\n   from the definition of Content-Disposition in RFC 1806 [35].\n\n        content-disposition = \"Content-Disposition\" \":\"\n                              disposition-type *( \";\" disposition-parm )\n        disposition-type = \"attachment\" | disp-extension-token\n        disposition-parm = filename-parm | disp-extension-parm\n        filename-parm = \"filename\" \"=\" quoted-string\n        disp-extension-token = token\n        disp-extension-parm = token \"=\" ( token | quoted-string )\n\n   An example is\n\n        Content-Disposition: attachment; filename=\"fname.ext\"\n\n   The receiving user agent SHOULD NOT respect any directory path\n   information present in the filename-parm parameter, which is the only\n   parameter believed to apply to HTTP implementations at this time. The\n   filename SHOULD be treated as a terminal component only.\n\n   If this header is used in a response with the application/octet-\n   stream content-type, the implied suggestion is that the user agent\n   should not display the response, but directly enter a `save response\n   as...' dialog.\n\n   See section 15.5 for Content-Disposition security issues.\n\n19.6 Compatibility with Previous Versions\n\n   It is beyond the scope of a protocol specification to mandate\n   compliance with previous versions. HTTP/1.1 was deliberately\n   designed, however, to make supporting previous versions easy. It is\n   worth noting that, at the time of composing this specification\n   (1996), we would expect commercial HTTP/1.1 servers to:\n\n      - recognize the format of the Request-Line for HTTP/0.9, 1.0, and\n        1.1 requests;\n\n\n\nFielding, et al.            Standards Track                   [Page 170]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - understand any valid request in the format of HTTP/0.9, 1.0, or\n        1.1;\n\n      - respond appropriately with a message in the same major version\n        used by the client.\n\n   And we would expect HTTP/1.1 clients to:\n\n      - recognize the format of the Status-Line for HTTP/1.0 and 1.1\n        responses;\n\n      - understand any valid response in the format of HTTP/0.9, 1.0, or\n        1.1.\n\n   For most implementations of HTTP/1.0, each connection is established\n   by the client prior to the request and closed by the server after\n   sending the response. Some implementations implement the Keep-Alive\n   version of persistent connections described in section 19.7.1 of RFC\n   2068 [33].\n\n19.6.1 Changes from HTTP/1.0\n\n   This section summarizes major differences between versions HTTP/1.0\n   and HTTP/1.1.\n\n19.6.1.1 Changes to Simplify Multi-homed Web Servers and Conserve IP\n         Addresses\n\n   The requirements that clients and servers support the Host request-\n   header, report an error if the Host request-header (section 14.23) is\n   missing from an HTTP/1.1 request, and accept absolute URIs (section\n   5.1.2) are among the most important changes defined by this\n   specification.\n\n   Older HTTP/1.0 clients assumed a one-to-one relationship of IP\n   addresses and servers; there was no other established mechanism for\n   distinguishing the intended server of a request than the IP address\n   to which that request was directed. The changes outlined above will\n   allow the Internet, once older HTTP clients are no longer common, to\n   support multiple Web sites from a single IP address, greatly\n   simplifying large operational Web servers, where allocation of many\n   IP addresses to a single host has created serious problems. The\n   Internet will also be able to recover the IP addresses that have been\n   allocated for the sole purpose of allowing special-purpose domain\n   names to be used in root-level HTTP URLs. Given the rate of growth of\n   the Web, and the number of servers already deployed, it is extremely\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 171]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   important that all implementations of HTTP (including updates to\n   existing HTTP/1.0 applications) correctly implement these\n   requirements:\n\n      - Both clients and servers MUST support the Host request-header.\n\n      - A client that sends an HTTP/1.1 request MUST send a Host header.\n\n      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1\n        request does not include a Host request-header.\n\n      - Servers MUST accept absolute URIs.\n\n19.6.2 Compatibility with HTTP/1.0 Persistent Connections\n\n   Some clients and servers might wish to be compatible with some\n   previous implementations of persistent connections in HTTP/1.0\n   clients and servers. Persistent connections in HTTP/1.0 are\n   explicitly negotiated as they are not the default behavior. HTTP/1.0\n   experimental implementations of persistent connections are faulty,\n   and the new facilities in HTTP/1.1 are designed to rectify these\n   problems. The problem was that some existing 1.0 clients may be\n   sending Keep-Alive to a proxy server that doesn't understand\n   Connection, which would then erroneously forward it to the next\n   inbound server, which would establish the Keep-Alive connection and\n   result in a hung HTTP/1.0 proxy waiting for the close on the\n   response. The result is that HTTP/1.0 clients must be prevented from\n   using Keep-Alive when talking to proxies.\n\n   However, talking to proxies is the most important use of persistent\n   connections, so that prohibition is clearly unacceptable. Therefore,\n   we need some other mechanism for indicating a persistent connection\n   is desired, which is safe to use even when talking to an old proxy\n   that ignores Connection. Persistent connections are the default for\n   HTTP/1.1 messages; we introduce a new keyword (Connection: close) for\n   declaring non-persistence. See section 14.10.\n\n   The original HTTP/1.0 form of persistent connections (the Connection:\n   Keep-Alive and Keep-Alive header) is documented in RFC 2068. [33]\n\n19.6.3 Changes from RFC 2068\n\n   This specification has been carefully audited to correct and\n   disambiguate key word usage; RFC 2068 had many problems in respect to\n   the conventions laid out in RFC 2119 [34].\n\n   Clarified which error code should be used for inbound server failures\n   (e.g. DNS failures). (Section 10.5.5).\n\n\n\nFielding, et al.            Standards Track                   [Page 172]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   CREATE had a race that required an Etag be sent when a resource is\n   first created. (Section 10.2.2).\n\n   Content-Base was deleted from the specification: it was not\n   implemented widely, and there is no simple, safe way to introduce it\n   without a robust extension mechanism. In addition, it is used in a\n   similar, but not identical fashion in MHTML [45].\n\n   Transfer-coding and message lengths all interact in ways that\n   required fixing exactly when chunked encoding is used (to allow for\n   transfer encoding that may not be self delimiting); it was important\n   to straighten out exactly how message lengths are computed. (Sections\n   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)\n\n   A content-coding of \"identity\" was introduced, to solve problems\n   discovered in caching. (section 3.5)\n\n   Quality Values of zero should indicate that \"I don't want something\"\n   to allow clients to refuse a representation. (Section 3.9)\n\n   The use and interpretation of HTTP version numbers has been clarified\n   by RFC 2145. Require proxies to upgrade requests to highest protocol\n   version they support to deal with problems discovered in HTTP/1.0\n   implementations (Section 3.1)\n\n   Charset wildcarding is introduced to avoid explosion of character set\n   names in accept headers. (Section 14.2)\n\n   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage\n   was introduced to add this missing case. (Sections 13.4, 14.8, 14.9,\n   14.9.3)\n\n   The Cache-Control: max-age directive was not properly defined for\n   responses. (Section 14.9.3)\n\n   There are situations where a server (especially a proxy) does not\n   know the full length of a response but is capable of serving a\n   byterange request. We therefore need a mechanism to allow byteranges\n   with a content-range not indicating the full length of the message.\n   (Section 14.16)\n\n   Range request responses would become very verbose if all meta-data\n   were always returned; by allowing the server to only send needed\n   headers in a 206 response, this problem can be avoided. (Section\n   10.2.7, 13.5.3, and 14.27)\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 173]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Fix problem with unsatisfiable range requests; there are two cases:\n   syntactic problems, and range doesn't exist in the document. The 416\n   status code was needed to resolve this ambiguity needed to indicate\n   an error for a byte range request that falls outside of the actual\n   contents of a document. (Section 10.4.17, 14.16)\n\n   Rewrite of message transmission requirements to make it much harder\n   for implementors to get it wrong, as the consequences of errors here\n   can have significant impact on the Internet, and to deal with the\n   following problems:\n\n      1. Changing \"HTTP/1.1 or later\" to \"HTTP/1.1\", in contexts where\n         this was incorrectly placing a requirement on the behavior of\n         an implementation of a future version of HTTP/1.x\n\n      2. Made it clear that user-agents should retry requests, not\n         \"clients\" in general.\n\n      3. Converted requirements for clients to ignore unexpected 100\n         (Continue) responses, and for proxies to forward 100 responses,\n         into a general requirement for 1xx responses.\n\n      4. Modified some TCP-specific language, to make it clearer that\n         non-TCP transports are possible for HTTP.\n\n      5. Require that the origin server MUST NOT wait for the request\n         body before it sends a required 100 (Continue) response.\n\n      6. Allow, rather than require, a server to omit 100 (Continue) if\n         it has already seen some of the request body.\n\n      7. Allow servers to defend against denial-of-service attacks and\n         broken clients.\n\n   This change adds the Expect header and 417 status code. The message\n   transmission requirements fixes are in sections 8.2, 10.4.18,\n   8.1.2.2, 13.11, and 14.20.\n\n   Proxies should be able to add Content-Length when appropriate.\n   (Section 13.5.2)\n\n   Clean up confusion between 403 and 404 responses. (Section 10.4.4,\n   10.4.5, and 10.4.11)\n\n   Warnings could be cached incorrectly, or not updated appropriately.\n   (Section 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning\n   also needed to be a general header, as PUT or other methods may have\n   need for it in requests.\n\n\n\nFielding, et al.            Standards Track                   [Page 174]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Transfer-coding had significant problems, particularly with\n   interactions with chunked encoding. The solution is that transfer-\n   codings become as full fledged as content-codings. This involves\n   adding an IANA registry for transfer-codings (separate from content\n   codings), a new header field (TE) and enabling trailer headers in the\n   future. Transfer encoding is a major performance benefit, so it was\n   worth fixing [39]. TE also solves another, obscure, downward\n   interoperability problem that could have occurred due to interactions\n   between authentication trailers, chunked encoding and HTTP/1.0\n   clients.(Section 3.6, 3.6.1, and 14.39)\n\n   The PATCH, LINK, UNLINK methods were defined but not commonly\n   implemented in previous versions of this specification. See RFC 2068\n   [33].\n\n   The Alternates, Content-Version, Derived-From, Link, URI, Public and\n   Content-Base header fields were defined in previous versions of this\n   specification, but not commonly implemented. See RFC 2068 [33].\n\n20 Index\n\n   Please see the PostScript version of this RFC for the INDEX.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 175]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n21.  Full Copyright Statement\n\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n\n   This document and translations of it may be copied and furnished to\n   others, and derivative works that comment on or otherwise explain it\n   or assist in its implementation may be prepared, copied, published\n   and distributed, in whole or in part, without restriction of any\n   kind, provided that the above copyright notice and this paragraph are\n   included on all such copies and derivative works.  However, this\n   document itself may not be modified in any way, such as by removing\n   the copyright notice or references to the Internet Society or other\n   Internet organizations, except as needed for the purpose of\n   developing Internet standards in which case the procedures for\n   copyrights defined in the Internet Standards process must be\n   followed, or as required to translate it into languages other than\n   English.\n\n   The limited permissions granted above are perpetual and will not be\n   revoked by the Internet Society or its successors or assigns.\n\n   This document and the information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\nAcknowledgement\n\n   Funding for the RFC Editor function is currently provided by the\n   Internet Society.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 176]\n\f\n",
    "chunks": [
      {
        "chunk_id": "rfc_http_chunk_0",
        "original_index": 0,
        "content": "Network Working Group                                      R. Fielding\nRequest for Comments: 2616                                   UC Irvine\nObsoletes: 2068                                              J. Gettys\nCategory: Standards Track                                   Compaq/W3C\n                                                              J. Mogul\n                                                                Compaq\n                                                            H. Frystyk\n                                                               W3C/MIT\n                                                           L. Masinter\n                                                                 Xerox\n                                                              P. Leach\n                                                             Microsoft\n                                                        T. Berners-Lee\n                                                               W3C/MIT\n                                                             June 1999\n\n\n                Hypertext Transfer Protocol -- HTTP/1.1\n\nStatus of this Memo\n\n   This document specifies an Internet standards track protocol for the\n   Internet community, and requests discussion and suggestions for\n   improvements.  Please refer to the current edition of the \"Internet\n   Official Protocol Standards\" (STD 1) for the standardization state\n   and status of this protocol.  Distribution of this memo is unlimited.\n\nCopyright Notice\n\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n\nAbstract\n\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n   protocol for distributed, collaborative, hypermedia information\n   systems. It is a generic, stateless, protocol which can be used for\n   many tasks beyond its use for hypertext, such as name servers and\n   distributed object management systems, through extension of its\n   request methods, error codes and headers [47]. A feature of HTTP is\n   the typing and negotiation of data representation, allowing systems\n   to be built independently of the data being transferred.\n\n   HTTP has been in use by the World-Wide Web global information\n   initiative since 1990. This specification defines the protocol\n   referred to as \"HTTP/1.1\", and is an update to RFC 2068 [33].\n\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 1]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\nTable of Contents"
      },
      {
        "chunk_id": "rfc_http_chunk_1",
        "original_index": 1,
        "content": "Fielding, et al.            Standards Track                     [Page 1]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\nTable of Contents\n\n   1   Introduction ...................................................7\n   1.1    Purpose......................................................7\n   1.2   Requirements .................................................8\n   1.3   Terminology ..................................................8\n   1.4   Overall Operation ...........................................12\n   2   Notational Conventions and Generic Grammar ....................14\n   2.1   Augmented BNF ...............................................14\n   2.2   Basic Rules .................................................15\n   3   Protocol Parameters ...........................................17\n   3.1   HTTP Version ................................................17\n   3.2   Uniform Resource Identifiers ................................18\n   3.2.1    General Syntax ...........................................19\n   3.2.2    http URL .................................................19\n   3.2.3    URI Comparison ...........................................20\n   3.3   Date/Time Formats ...........................................20\n   3.3.1    Full Date ................................................20\n   3.3.2    Delta Seconds ............................................21\n   3.4   Character Sets ..............................................21\n   3.4.1    Missing Charset ..........................................22\n   3.5   Content Codings .............................................23\n   3.6   Transfer Codings ............................................24\n   3.6.1    Chunked Transfer Coding ..................................25\n   3.7   Media Types .................................................26\n   3.7.1    Canonicalization and Text Defaults .......................27\n   3.7.2    Multipart Types ..........................................27\n   3.8   Product Tokens ..............................................28\n   3.9   Quality Values ..............................................29\n   3.10  Language Tags ...............................................29\n   3.11  Entity Tags .................................................30\n   3.12  Range Units .................................................30\n   4   HTTP Message ..................................................31\n   4.1   Message Types ...............................................31\n   4.2   Message Headers .............................................31\n   4.3   Message Body ................................................32\n   4.4   Message Length ..............................................33\n   4.5   General Header Fields .......................................34\n   5   Request .......................................................35\n   5.1   Request-Line ................................................35\n   5.1.1    Method ...................................................36\n   5.1.2    Request-URI ..............................................36\n   5.2   The Resource Identified by a Request ........................38\n   5.3   Request Header Fields .......................................38\n   6   Response ......................................................39\n   6.1   Status-Line .................................................39\n   6.1.1    Status Code and Reason Phrase ............................39\n   6.2   Response Header Fields ......................................41\n\n\n\nFielding, et al.            Standards Track                     [Page 2]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_2",
        "original_index": 2,
        "content": "Fielding, et al.            Standards Track                     [Page 2]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   7   Entity ........................................................42\n   7.1   Entity Header Fields ........................................42\n   7.2   Entity Body .................................................43\n   7.2.1    Type .....................................................43\n   7.2.2    Entity Length ............................................43\n   8   Connections ...................................................44\n   8.1   Persistent Connections ......................................44\n   8.1.1    Purpose ..................................................44\n   8.1.2    Overall Operation ........................................45\n   8.1.3    Proxy Servers ............................................46\n   8.1.4    Practical Considerations .................................46\n   8.2   Message Transmission Requirements ...........................47\n   8.2.1    Persistent Connections and Flow Control ..................47\n   8.2.2    Monitoring Connections for Error Status Messages .........48\n   8.2.3    Use of the 100 (Continue) Status .........................48\n   8.2.4    Client Behavior if Server Prematurely Closes Connection ..50\n   9   Method Definitions ............................................51\n   9.1   Safe and Idempotent Methods .................................51\n   9.1.1    Safe Methods .............................................51\n   9.1.2    Idempotent Methods .......................................51\n   9.2   OPTIONS .....................................................52\n   9.3   GET .........................................................53\n   9.4   HEAD ........................................................54\n   9.5   POST ........................................................54\n   9.6   PUT .........................................................55\n   9.7   DELETE ......................................................56\n   9.8   TRACE .......................................................56\n   9.9   CONNECT .....................................................57\n   10   Status Code Definitions ......................................57\n   10.1  Informational 1xx ...........................................57\n   10.1.1   100 Continue .............................................58\n   10.1.2   101 Switching Protocols ..................................58\n   10.2  Successful 2xx ..............................................58\n   10.2.1   200 OK ...................................................58\n   10.2.2   201 Created ..............................................59\n   10.2.3   202 Accepted .............................................59\n   10.2.4   203 Non-Authoritative Information ........................59\n   10.2.5   204 No Content ...........................................60\n   10.2.6   205 Reset Content ........................................60\n   10.2.7   206 Partial Content ......................................60\n   10.3  Redirection 3xx .............................................61\n   10.3.1   300 Multiple Choices .....................................61\n   10.3.2   301 Moved Permanently ....................................62\n   10.3.3   302 Found ................................................62\n   10.3.4   303 See Other ............................................63\n   10.3.5   304 Not Modified .........................................63\n   10.3.6   305 Use Proxy ............................................64\n   10.3.7   306 (Unused) .............................................64\n\n\n\nFielding, et al.            Standards Track                     [Page 3]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_3",
        "original_index": 3,
        "content": "Fielding, et al.            Standards Track                     [Page 3]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   10.3.8   307 Temporary Redirect ...................................65\n   10.4  Client Error 4xx ............................................65\n   10.4.1    400 Bad Request .........................................65\n   10.4.2    401 Unauthorized ........................................66\n   10.4.3    402 Payment Required ....................................66\n   10.4.4    403 Forbidden ...........................................66\n   10.4.5    404 Not Found ...........................................66\n   10.4.6    405 Method Not Allowed ..................................66\n   10.4.7    406 Not Acceptable ......................................67\n   10.4.8    407 Proxy Authentication Required .......................67\n   10.4.9    408 Request Timeout .....................................67\n   10.4.10   409 Conflict ............................................67\n   10.4.11   410 Gone ................................................68\n   10.4.12   411 Length Required .....................................68\n   10.4.13   412 Precondition Failed .................................68\n   10.4.14   413 Request Entity Too Large ............................69\n   10.4.15   414 Request-URI Too Long ................................69\n   10.4.16   415 Unsupported Media Type ..............................69\n   10.4.17   416 Requested Range Not Satisfiable .....................69\n   10.4.18   417 Expectation Failed ..................................70\n   10.5  Server Error 5xx ............................................70\n   10.5.1   500 Internal Server Error ................................70\n   10.5.2   501 Not Implemented ......................................70\n   10.5.3   502 Bad Gateway ..........................................70\n   10.5.4   503 Service Unavailable ..................................70\n   10.5.5   504 Gateway Timeout ......................................71\n   10.5.6   505 HTTP Version Not Supported ...........................71\n   11   Access Authentication ........................................71\n   12   Content Negotiation ..........................................71\n   12.1  Server-driven Negotiation ...................................72\n   12.2  Agent-driven Negotiation ....................................73\n   12.3  Transparent Negotiation .....................................74\n   13   Caching in HTTP ..............................................74\n   13.1.1   Cache Correctness ........................................75\n   13.1.2   Warnings .................................................76\n   13.1.3   Cache-control Mechanisms .................................77\n   13.1.4   Explicit User Agent Warnings .............................78\n   13.1.5   Exceptions to the Rules and Warnings .....................78\n   13.1.6   Client-controlled Behavior ...............................79\n   13.2  Expiration Model ............................................79\n   13.2.1   Server-Specified Expiration ..............................79\n   13.2.2   Heuristic Expiration .....................................80\n   13.2.3   Age Calculations .........................................80\n   13.2.4   Expiration Calculations ..................................83\n   13.2.5   Disambiguating Expiration Values .........................84\n   13.2.6   Disambiguating Multiple Responses ........................84\n   13.3  Validation Model ............................................85\n   13.3.1   Last-Modified Dates ......................................86\n\n\n\nFielding, et al.            Standards Track                     [Page 4]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_4",
        "original_index": 4,
        "content": "Fielding, et al.            Standards Track                     [Page 4]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   13.3.2   Entity Tag Cache Validators ..............................86\n   13.3.3   Weak and Strong Validators ...............................86\n   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89\n   13.3.5   Non-validating Conditionals ..............................90\n   13.4  Response Cacheability .......................................91\n   13.5  Constructing Responses From Caches ..........................92\n   13.5.1   End-to-end and Hop-by-hop Headers ........................92\n   13.5.2   Non-modifiable Headers ...................................92\n   13.5.3   Combining Headers ........................................94\n   13.5.4   Combining Byte Ranges ....................................95\n   13.6  Caching Negotiated Responses ................................95\n   13.7  Shared and Non-Shared Caches ................................96\n   13.8  Errors or Incomplete Response Cache Behavior ................97\n   13.9  Side Effects of GET and HEAD ................................97\n   13.10   Invalidation After Updates or Deletions ...................97\n   13.11   Write-Through Mandatory ...................................98\n   13.12   Cache Replacement .........................................99\n   13.13   History Lists .............................................99\n   14   Header Field Definitions ....................................100\n   14.1  Accept .....................................................100\n   14.2  Accept-Charset .............................................102\n   14.3  Accept-Encoding ............................................102\n   14.4  Accept-Language ............................................104\n   14.5  Accept-Ranges ..............................................105\n   14.6  Age ........................................................106\n   14.7  Allow ......................................................106\n   14.8  Authorization ..............................................107\n   14.9  Cache-Control ..............................................108\n   14.9.1   What is Cacheable .......................................109\n   14.9.2   What May be Stored by Caches ............................110\n   14.9.3   Modifications of the Basic Expiration Mechanism .........111\n   14.9.4   Cache Revalidation and Reload Controls ..................113\n   14.9.5   No-Transform Directive ..................................115\n   14.9.6   Cache Control Extensions ................................116\n   14.10   Connection ...............................................117\n   14.11   Content-Encoding .........................................118\n   14.12   Content-Language .........................................118\n   14.13   Content-Length ...........................................119\n   14.14   Content-Location .........................................120\n   14.15   Content-MD5 ..............................................121\n   14.16   Content-Range ............................................122\n   14.17   Content-Type .............................................124\n   14.18   Date .....................................................124\n   14.18.1   Clockless Origin Server Operation ......................125\n   14.19   ETag .....................................................126\n   14.20   Expect ...................................................126\n   14.21   Expires ..................................................127\n   14.22   From .....................................................128\n\n\n\nFielding, et al.            Standards Track                     [Page 5]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_5",
        "original_index": 5,
        "content": "Fielding, et al.            Standards Track                     [Page 5]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   14.23   Host .....................................................128\n   14.24   If-Match .................................................129\n   14.25   If-Modified-Since ........................................130\n   14.26   If-None-Match ............................................132\n   14.27   If-Range .................................................133\n   14.28   If-Unmodified-Since ......................................134\n   14.29   Last-Modified ............................................134\n   14.30   Location .................................................135\n   14.31   Max-Forwards .............................................136\n   14.32   Pragma ...................................................136\n   14.33   Proxy-Authenticate .......................................137\n   14.34   Proxy-Authorization ......................................137\n   14.35   Range ....................................................138\n   14.35.1    Byte Ranges ...........................................138\n   14.35.2    Range Retrieval Requests ..............................139\n   14.36   Referer ..................................................140\n   14.37   Retry-After ..............................................141\n   14.38   Server ...................................................141\n   14.39   TE .......................................................142\n   14.40   Trailer ..................................................143\n   14.41  Transfer-Encoding..........................................143\n   14.42   Upgrade ..................................................144\n   14.43   User-Agent ...............................................145\n   14.44   Vary .....................................................145\n   14.45   Via ......................................................146\n   14.46   Warning ..................................................148\n   14.47   WWW-Authenticate .........................................150\n   15 Security Considerations .......................................150\n   15.1      Personal Information....................................151\n   15.1.1   Abuse of Server Log Information .........................151\n   15.1.2   Transfer of Sensitive Information .......................151\n   15.1.3   Encoding Sensitive Information in URI's .................152\n   15.1.4   Privacy Issues Connected to Accept Headers ..............152\n   15.2  Attacks Based On File and Path Names .......................153\n   15.3  DNS Spoofing ...............................................154\n   15.4  Location Headers and Spoofing ..............................154\n   15.5  Content-Disposition Issues .................................154\n   15.6  Authentication Credentials and Idle Clients ................155\n   15.7  Proxies and Caching ........................................155\n   15.7.1    Denial of Service Attacks on Proxies....................156\n   16   Acknowledgments .............................................156\n   17   References ..................................................158\n   18   Authors' Addresses ..........................................162\n   19   Appendices ..................................................164\n   19.1  Internet Media Type message/http and application/http ......164\n   19.2  Internet Media Type multipart/byteranges ...................165\n   19.3  Tolerant Applications ......................................166\n   19.4  Differences Between HTTP Entities and RFC 2045 Entities ....167\n\n\n\nFielding, et al.            Standards Track                     [Page 6]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_6",
        "original_index": 6,
        "content": "Fielding, et al.            Standards Track                     [Page 6]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   19.4.1   MIME-Version ............................................167\n   19.4.2   Conversion to Canonical Form ............................167\n   19.4.3   Conversion of Date Formats ..............................168\n   19.4.4   Introduction of Content-Encoding ........................168\n   19.4.5   No Content-Transfer-Encoding ............................168\n   19.4.6   Introduction of Transfer-Encoding .......................169\n   19.4.7   MHTML and Line Length Limitations .......................169\n   19.5  Additional Features ........................................169\n   19.5.1   Content-Disposition .....................................170\n   19.6  Compatibility with Previous Versions .......................170\n   19.6.1   Changes from HTTP/1.0 ...................................171\n   19.6.2   Compatibility with HTTP/1.0 Persistent Connections ......172\n   19.6.3   Changes from RFC 2068 ...................................172\n   20   Index .......................................................175\n   21   Full Copyright Statement ....................................176\n\n1 Introduction\n\n1.1 Purpose\n\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n   protocol for distributed, collaborative, hypermedia information\n   systems. HTTP has been in use by the World-Wide Web global\n   information initiative since 1990. The first version of HTTP,\n   referred to as HTTP/0.9, was a simple protocol for raw data transfer\n   across the Internet. HTTP/1.0, as defined by RFC 1945 [6], improved\n   the protocol by allowing messages to be in the format of MIME-like\n   messages, containing metainformation about the data transferred and\n   modifiers on the request/response semantics. However, HTTP/1.0 does\n   not sufficiently take into consideration the effects of hierarchical\n   proxies, caching, the need for persistent connections, or virtual\n   hosts. In addition, the proliferation of incompletely-implemented\n   applications calling themselves \"HTTP/1.0\" has necessitated a\n   protocol version change in order for two communicating applications\n   to determine each other's true capabilities.\n\n   This specification defines the protocol referred to as \"HTTP/1.1\".\n   This protocol includes more stringent requirements than HTTP/1.0 in\n   order to ensure reliable implementation of its features.\n\n   Practical information systems require more functionality than simple\n   retrieval, including search, front-end update, and annotation. HTTP\n   allows an open-ended set of methods and headers that indicate the\n   purpose of a request [47]. It builds on the discipline of reference\n   provided by the Uniform Resource Identifier (URI) [3], as a location\n   (URL) [4] or name (URN) [20], for indicating the resource to which a\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 7]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   method is to be applied. Messages are passed in a format similar to\n   that used by Internet mail [9] as defined by the Multipurpose\n   Internet Mail Extensions (MIME) [7].\n\n   HTTP is also used as a generic protocol for communication between\n   user agents and proxies/gateways to other Internet systems, including\n   those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2],\n   and WAIS [10] protocols. In this way, HTTP allows basic hypermedia\n   access to resources available from diverse applications.\n\n1.2 Requirements\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC 2119 [34]."
      },
      {
        "chunk_id": "rfc_http_chunk_7",
        "original_index": 7,
        "content": "An implementation is not compliant if it fails to satisfy one or more\n   of the MUST or REQUIRED level requirements for the protocols it\n   implements. An implementation that satisfies all the MUST or REQUIRED\n   level and all the SHOULD level requirements for its protocols is said\n   to be \"unconditionally compliant\"; one that satisfies all the MUST\n   level requirements but not all the SHOULD level requirements for its\n   protocols is said to be \"conditionally compliant.\"\n\n1.3 Terminology\n\n   This specification uses a number of terms to refer to the roles\n   played by participants in, and objects of, the HTTP communication.\n\n   connection\n      A transport layer virtual circuit established between two programs\n      for the purpose of communication.\n\n   message\n      The basic unit of HTTP communication, consisting of a structured\n      sequence of octets matching the syntax defined in section 4 and\n      transmitted via the connection.\n\n   request\n      An HTTP request message, as defined in section 5.\n\n   response\n      An HTTP response message, as defined in section 6.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 8]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   resource\n      A network data object or service that can be identified by a URI,\n      as defined in section 3.2. Resources may be available in multiple\n      representations (e.g. multiple languages, data formats, size, and\n      resolutions) or vary in other ways.\n\n   entity\n      The information transferred as the payload of a request or\n      response. An entity consists of metainformation in the form of\n      entity-header fields and content in the form of an entity-body, as\n      described in section 7.\n\n   representation\n      An entity included with a response that is subject to content\n      negotiation, as described in section 12. There may exist multiple\n      representations associated with a particular response status.\n\n   content negotiation\n      The mechanism for selecting the appropriate representation when\n      servicing a request, as described in section 12. The\n      representation of entities in any response can be negotiated\n      (including error responses).\n\n   variant\n      A resource may have one, or more than one, representation(s)\n      associated with it at any given instant. Each of these\n      representations is termed a `varriant'.  Use of the term `variant'\n      does not necessarily imply that the resource is subject to content\n      negotiation.\n\n   client\n      A program that establishes connections for the purpose of sending\n      requests.\n\n   user agent\n      The client which initiates a request. These are often browsers,\n      editors, spiders (web-traversing robots), or other end user tools.\n\n   server\n      An application program that accepts connections in order to\n      service requests by sending back responses. Any given program may\n      be capable of being both a client and a server; our use of these\n      terms refers only to the role being performed by the program for a\n      particular connection, rather than to the program's capabilities\n      in general. Likewise, any server may act as an origin server,\n      proxy, gateway, or tunnel, switching behavior based on the nature\n      of each request.\n\n\n\n\nFielding, et al.            Standards Track                     [Page 9]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   origin server\n      The server on which a given resource resides or is to be created."
      },
      {
        "chunk_id": "rfc_http_chunk_8",
        "original_index": 8,
        "content": "origin server\n      The server on which a given resource resides or is to be created.\n\n   proxy\n      An intermediary program which acts as both a server and a client\n      for the purpose of making requests on behalf of other clients.\n      Requests are serviced internally or by passing them on, with\n      possible translation, to other servers. A proxy MUST implement\n      both the client and server requirements of this specification. A\n      \"transparent proxy\" is a proxy that does not modify the request or\n      response beyond what is required for proxy authentication and\n      identification. A \"non-transparent proxy\" is a proxy that modifies\n      the request or response in order to provide some added service to\n      the user agent, such as group annotation services, media type\n      transformation, protocol reduction, or anonymity filtering. Except\n      where either transparent or non-transparent behavior is explicitly\n      stated, the HTTP proxy requirements apply to both types of\n      proxies.\n\n   gateway\n      A server which acts as an intermediary for some other server.\n      Unlike a proxy, a gateway receives requests as if it were the\n      origin server for the requested resource; the requesting client\n      may not be aware that it is communicating with a gateway.\n\n   tunnel\n      An intermediary program which is acting as a blind relay between\n      two connections. Once active, a tunnel is not considered a party\n      to the HTTP communication, though the tunnel may have been\n      initiated by an HTTP request. The tunnel ceases to exist when both\n      ends of the relayed connections are closed.\n\n   cache\n      A program's local store of response messages and the subsystem\n      that controls its message storage, retrieval, and deletion. A\n      cache stores cacheable responses in order to reduce the response\n      time and network bandwidth consumption on future, equivalent\n      requests. Any client or server may include a cache, though a cache\n      cannot be used by a server that is acting as a tunnel.\n\n   cacheable\n      A response is cacheable if a cache is allowed to store a copy of\n      the response message for use in answering subsequent requests. The\n      rules for determining the cacheability of HTTP responses are\n      defined in section 13. Even if a resource is cacheable, there may\n      be additional constraints on whether a cache can use the cached\n      copy for a particular request.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 10]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   first-hand\n      A response is first-hand if it comes directly and without\n      unnecessary delay from the origin server, perhaps via one or more\n      proxies. A response is also first-hand if its validity has just\n      been checked directly with the origin server.\n\n   explicit expiration time\n      The time at which the origin server intends that an entity should\n      no longer be returned by a cache without further validation.\n\n   heuristic expiration time\n      An expiration time assigned by a cache when no explicit expiration\n      time is available.\n\n   age\n      The age of a response is the time since it was sent by, or\n      successfully validated with, the origin server.\n\n   freshness lifetime\n      The length of time between the generation of a response and its\n      expiration time.\n\n   fresh\n      A response is fresh if its age has not yet exceeded its freshness\n      lifetime.\n\n   stale\n      A response is stale if its age has passed its freshness lifetime."
      },
      {
        "chunk_id": "rfc_http_chunk_9",
        "original_index": 9,
        "content": "fresh\n      A response is fresh if its age has not yet exceeded its freshness\n      lifetime.\n\n   stale\n      A response is stale if its age has passed its freshness lifetime.\n\n   semantically transparent\n      A cache behaves in a \"semantically transparent\" manner, with\n      respect to a particular response, when its use affects neither the\n      requesting client nor the origin server, except to improve\n      performance. When a cache is semantically transparent, the client\n      receives exactly the same response (except for hop-by-hop headers)\n      that it would have received had its request been handled directly\n      by the origin server.\n\n   validator\n      A protocol element (e.g., an entity tag or a Last-Modified time)\n      that is used to find out whether a cache entry is an equivalent\n      copy of an entity.\n\n   upstream/downstream\n      Upstream and downstream describe the flow of a message: all\n      messages flow from upstream to downstream.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 11]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   inbound/outbound\n      Inbound and outbound refer to the request and response paths for\n      messages: \"inbound\" means \"traveling toward the origin server\",\n      and \"outbound\" means \"traveling toward the user agent\"\n\n1.4 Overall Operation\n\n   The HTTP protocol is a request/response protocol. A client sends a\n   request to the server in the form of a request method, URI, and\n   protocol version, followed by a MIME-like message containing request\n   modifiers, client information, and possible body content over a\n   connection with a server. The server responds with a status line,\n   including the message's protocol version and a success or error code,\n   followed by a MIME-like message containing server information, entity\n   metainformation, and possible entity-body content. The relationship\n   between HTTP and MIME is described in appendix 19.4.\n\n   Most HTTP communication is initiated by a user agent and consists of\n   a request to be applied to a resource on some origin server. In the\n   simplest case, this may be accomplished via a single connection (v)\n   between the user agent (UA) and the origin server (O).\n\n          request chain ------------------------>\n       UA -------------------v------------------- O\n          <----------------------- response chain\n\n   A more complicated situation occurs when one or more intermediaries\n   are present in the request/response chain. There are three common\n   forms of intermediary: proxy, gateway, and tunnel. A proxy is a\n   forwarding agent, receiving requests for a URI in its absolute form,\n   rewriting all or part of the message, and forwarding the reformatted\n   request toward the server identified by the URI. A gateway is a\n   receiving agent, acting as a layer above some other server(s) and, if\n   necessary, translating the requests to the underlying server's\n   protocol. A tunnel acts as a relay point between two connections\n   without changing the messages; tunnels are used when the\n   communication needs to pass through an intermediary (such as a\n   firewall) even when the intermediary cannot understand the contents\n   of the messages.\n\n          request chain -------------------------------------->\n       UA -----v----- A -----v----- B -----v----- C -----v----- O\n          <------------------------------------- response chain\n\n   The figure above shows three intermediaries (A, B, and C) between the\n   user agent and origin server. A request or response message that\n   travels the whole chain will pass through four separate connections.\n   This distinction is important because some HTTP communication options\n\n\n\nFielding, et al.            Standards Track                    [Page 12]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_10",
        "original_index": 10,
        "content": "Fielding, et al.            Standards Track                    [Page 12]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   may apply only to the connection with the nearest, non-tunnel\n   neighbor, only to the end-points of the chain, or to all connections\n   along the chain. Although the diagram is linear, each participant may\n   be engaged in multiple, simultaneous communications. For example, B\n   may be receiving requests from many clients other than A, and/or\n   forwarding requests to servers other than C, at the same time that it\n   is handling A's request.\n\n   Any party to the communication which is not acting as a tunnel may\n   employ an internal cache for handling requests. The effect of a cache\n   is that the request/response chain is shortened if one of the\n   participants along the chain has a cached response applicable to that\n   request. The following illustrates the resulting chain if B has a\n   cached copy of an earlier response from O (via C) for a request which\n   has not been cached by UA or A.\n\n          request chain ---------->\n       UA -----v----- A -----v----- B - - - - - - C - - - - - - O\n          <--------- response chain\n\n   Not all responses are usefully cacheable, and some requests may\n   contain modifiers which place special requirements on cache behavior.\n   HTTP requirements for cache behavior and cacheable responses are\n   defined in section 13.\n\n   In fact, there are a wide variety of architectures and configurations\n   of caches and proxies currently being experimented with or deployed\n   across the World Wide Web. These systems include national hierarchies\n   of proxy caches to save transoceanic bandwidth, systems that\n   broadcast or multicast cache entries, organizations that distribute\n   subsets of cached data via CD-ROM, and so on. HTTP systems are used\n   in corporate intranets over high-bandwidth links, and for access via\n   PDAs with low-power radio links and intermittent connectivity. The\n   goal of HTTP/1.1 is to support the wide diversity of configurations\n   already deployed while introducing protocol constructs that meet the\n   needs of those who build web applications that require high\n   reliability and, failing that, at least reliable indications of\n   failure.\n\n   HTTP communication usually takes place over TCP/IP connections. The\n   default port is TCP 80 [19], but other ports can be used. This does\n   not preclude HTTP from being implemented on top of any other protocol\n   on the Internet, or on other networks. HTTP only presumes a reliable\n   transport; any protocol that provides such guarantees can be used;\n   the mapping of the HTTP/1.1 request and response structures onto the\n   transport data units of the protocol in question is outside the scope\n   of this specification.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 13]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   In HTTP/1.0, most implementations used a new connection for each\n   request/response exchange. In HTTP/1.1, a connection may be used for\n   one or more request/response exchanges, although connections may be\n   closed for a variety of reasons (see section 8.1).\n\n2 Notational Conventions and Generic Grammar\n\n2.1 Augmented BNF\n\n   All of the mechanisms specified in this document are described in\n   both prose and an augmented Backus-Naur Form (BNF) similar to that\n   used by RFC 822 [9]. Implementors will need to be familiar with the\n   notation in order to understand this specification. The augmented BNF\n   includes the following constructs:"
      },
      {
        "chunk_id": "rfc_http_chunk_11",
        "original_index": 11,
        "content": "name = definition\n      The name of a rule is simply the name itself (without any\n      enclosing \"<\" and \">\") and is separated from its definition by the\n      equal \"=\" character. White space is only significant in that\n      indentation of continuation lines is used to indicate a rule\n      definition that spans more than one line. Certain basic rules are\n      in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle\n      brackets are used within definitions whenever their presence will\n      facilitate discerning the use of rule names.\n\n   \"literal\"\n      Quotation marks surround literal text. Unless stated otherwise,\n      the text is case-insensitive.\n\n   rule1 | rule2\n      Elements separated by a bar (\"|\") are alternatives, e.g., \"yes |\n      no\" will accept yes or no.\n\n   (rule1 rule2)\n      Elements enclosed in parentheses are treated as a single element.\n      Thus, \"(elem (foo | bar) elem)\" allows the token sequences \"elem\n      foo elem\" and \"elem bar elem\".\n\n   *rule\n      The character \"*\" preceding an element indicates repetition. The\n      full form is \"<n>*<m>element\" indicating at least <n> and at most\n      <m> occurrences of element. Default values are 0 and infinity so\n      that \"*(element)\" allows any number, including zero; \"1*element\"\n      requires at least one; and \"1*2element\" allows one or two.\n\n   [rule]\n      Square brackets enclose optional elements; \"[foo bar]\" is\n      equivalent to \"*1(foo bar)\".\n\n\n\nFielding, et al.            Standards Track                    [Page 14]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   N rule\n      Specific repetition: \"<n>(element)\" is equivalent to\n      \"<n>*<n>(element)\"; that is, exactly <n> occurrences of (element).\n      Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three\n      alphabetic characters.\n\n   #rule\n      A construct \"#\" is defined, similar to \"*\", for defining lists of\n      elements. The full form is \"<n>#<m>element\" indicating at least\n      <n> and at most <m> elements, each separated by one or more commas\n      (\",\") and OPTIONAL linear white space (LWS). This makes the usual\n      form of lists very easy; a rule such as\n         ( *LWS element *( *LWS \",\" *LWS element ))\n      can be shown as\n         1#element\n      Wherever this construct is used, null elements are allowed, but do\n      not contribute to the count of elements present. That is,\n      \"(element), , (element) \" is permitted, but counts as only two\n      elements. Therefore, where at least one element is required, at\n      least one non-null element MUST be present. Default values are 0\n      and infinity so that \"#element\" allows any number, including zero;\n      \"1#element\" requires at least one; and \"1#2element\" allows one or\n      two.\n\n   ; comment\n      A semi-colon, set off some distance to the right of rule text,\n      starts a comment that continues to the end of line. This is a\n      simple way of including useful notes in parallel with the\n      specifications.\n\n   implied *LWS\n      The grammar described by this specification is word-based. Except\n      where noted otherwise, linear white space (LWS) can be included\n      between any two adjacent words (token or quoted-string), and\n      between adjacent words and separators, without changing the\n      interpretation of a field. At least one delimiter (LWS and/or\n\n      separators) MUST exist between any two tokens (for the definition\n      of \"token\" below), since they would otherwise be interpreted as a\n      single token.\n\n2.2 Basic Rules\n\n   The following rules are used throughout this specification to\n   describe basic parsing constructs. The US-ASCII coded character set\n   is defined by ANSI X3.4-1986 [21].\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 15]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_12",
        "original_index": 12,
        "content": "Fielding, et al.            Standards Track                    [Page 15]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       OCTET          = <any 8-bit sequence of data>\n       CHAR           = <any US-ASCII character (octets 0 - 127)>\n       UPALPHA        = <any US-ASCII uppercase letter \"A\"..\"Z\">\n       LOALPHA        = <any US-ASCII lowercase letter \"a\"..\"z\">\n       ALPHA          = UPALPHA | LOALPHA\n       DIGIT          = <any US-ASCII digit \"0\"..\"9\">\n       CTL            = <any US-ASCII control character\n                        (octets 0 - 31) and DEL (127)>\n       CR             = <US-ASCII CR, carriage return (13)>\n       LF             = <US-ASCII LF, linefeed (10)>\n       SP             = <US-ASCII SP, space (32)>\n       HT             = <US-ASCII HT, horizontal-tab (9)>\n       <\">            = <US-ASCII double-quote mark (34)>\n\n   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all\n   protocol elements except the entity-body (see appendix 19.3 for\n   tolerant applications). The end-of-line marker within an entity-body\n   is defined by its associated media type, as described in section 3.7.\n\n       CRLF           = CR LF\n\n   HTTP/1.1 header field values can be folded onto multiple lines if the\n   continuation line begins with a space or horizontal tab. All linear\n   white space, including folding, has the same semantics as SP. A\n   recipient MAY replace any linear white space with a single SP before\n   interpreting the field value or forwarding the message downstream.\n\n       LWS            = [CRLF] 1*( SP | HT )\n\n   The TEXT rule is only used for descriptive field contents and values\n   that are not intended to be interpreted by the message parser. Words\n   of *TEXT MAY contain characters from character sets other than ISO-\n   8859-1 [22] only when encoded according to the rules of RFC 2047\n   [14].\n\n       TEXT           = <any OCTET except CTLs,\n                        but including LWS>\n\n   A CRLF is allowed in the definition of TEXT only as part of a header\n   field continuation. It is expected that the folding LWS will be\n   replaced with a single SP before interpretation of the TEXT value.\n\n   Hexadecimal numeric characters are used in several protocol elements.\n\n       HEX            = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n                      | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | DIGIT\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 16]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Many HTTP/1.1 header field values consist of words separated by LWS\n   or special characters. These special characters MUST be in a quoted\n   string to be used within a parameter value (as defined in section\n   3.6).\n\n       token          = 1*<any CHAR except CTLs or separators>\n       separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                      | \"{\" | \"}\" | SP | HT\n\n   Comments can be included in some HTTP header fields by surrounding\n   the comment text with parentheses. Comments are only allowed in\n   fields containing \"comment\" as part of their field value definition.\n   In all other fields, parentheses are considered part of the field\n   value.\n\n       comment        = \"(\" *( ctext | quoted-pair | comment ) \")\"\n       ctext          = <any TEXT excluding \"(\" and \")\">\n\n   A string of text is parsed as a single word if it is quoted using\n   double-quote marks.\n\n       quoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n       qdtext         = <any TEXT except <\">>\n\n   The backslash character (\"\\\") MAY be used as a single-character\n   quoting mechanism only within quoted-string and comment constructs.\n\n       quoted-pair    = \"\\\" CHAR\n\n3 Protocol Parameters\n\n3.1 HTTP Version"
      },
      {
        "chunk_id": "rfc_http_chunk_13",
        "original_index": 13,
        "content": "quoted-pair    = \"\\\" CHAR\n\n3 Protocol Parameters\n\n3.1 HTTP Version\n\n   HTTP uses a \"<major>.<minor>\" numbering scheme to indicate versions\n   of the protocol. The protocol versioning policy is intended to allow\n   the sender to indicate the format of a message and its capacity for\n   understanding further HTTP communication, rather than the features\n   obtained via that communication. No change is made to the version\n   number for the addition of message components which do not affect\n   communication behavior or which only add to extensible field values.\n   The <minor> number is incremented when the changes made to the\n   protocol add features which do not change the general message parsing\n   algorithm, but which may add to the message semantics and imply\n   additional capabilities of the sender. The <major> number is\n   incremented when the format of a message within the protocol is\n   changed. See RFC 2145 [36] for a fuller explanation.\n\n\n\nFielding, et al.            Standards Track                    [Page 17]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The version of an HTTP message is indicated by an HTTP-Version field\n   in the first line of the message.\n\n       HTTP-Version   = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n\n   Note that the major and minor numbers MUST be treated as separate\n   integers and that each MAY be incremented higher than a single digit.\n   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is\n   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and\n   MUST NOT be sent.\n\n   An application that sends a request or response message that includes\n   HTTP-Version of \"HTTP/1.1\" MUST be at least conditionally compliant\n   with this specification. Applications that are at least conditionally\n   compliant with this specification SHOULD use an HTTP-Version of\n   \"HTTP/1.1\" in their messages, and MUST do so for any message that is\n   not compatible with HTTP/1.0. For more details on when to send\n   specific HTTP-Version values, see RFC 2145 [36].\n\n   The HTTP version of an application is the highest HTTP version for\n   which the application is at least conditionally compliant.\n\n   Proxy and gateway applications need to be careful when forwarding\n   messages in protocol versions different from that of the application.\n   Since the protocol version indicates the protocol capability of the\n   sender, a proxy/gateway MUST NOT send a message with a version\n   indicator which is greater than its actual version. If a higher\n   version request is received, the proxy/gateway MUST either downgrade\n   the request version, or respond with an error, or switch to tunnel\n   behavior.\n\n   Due to interoperability problems with HTTP/1.0 proxies discovered\n   since the publication of RFC 2068[33], caching proxies MUST, gateways\n   MAY, and tunnels MUST NOT upgrade the request to the highest version\n   they support. The proxy/gateway's response to that request MUST be in\n   the same major version as the request.\n\n      Note: Converting between versions of HTTP may involve modification\n      of header fields required or forbidden by the versions involved.\n\n3.2 Uniform Resource Identifiers\n\n   URIs have been known by many names: WWW addresses, Universal Document\n   Identifiers, Universal Resource Identifiers [3], and finally the\n   combination of Uniform Resource Locators (URL) [4] and Names (URN)\n   [20]. As far as HTTP is concerned, Uniform Resource Identifiers are\n   simply formatted strings which identify--via name, location, or any\n   other characteristic--a resource.\n\n\n\nFielding, et al.            Standards Track                    [Page 18]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.1 General Syntax"
      },
      {
        "chunk_id": "rfc_http_chunk_14",
        "original_index": 14,
        "content": "Fielding, et al.            Standards Track                    [Page 18]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.1 General Syntax\n\n   URIs in HTTP can be represented in absolute form or relative to some\n   known base URI [11], depending upon the context of their use. The two\n   forms are differentiated by the fact that absolute URIs always begin\n   with a scheme name followed by a colon. For definitive information on\n   URL syntax and semantics, see \"Uniform Resource Identifiers (URI):\n   Generic Syntax and Semantics,\" RFC 2396 [42] (which replaces RFCs\n   1738 [4] and RFC 1808 [11]). This specification adopts the\n   definitions of \"URI-reference\", \"absoluteURI\", \"relativeURI\", \"port\",\n   \"host\",\"abs_path\", \"rel_path\", and \"authority\" from that\n   specification.\n\n   The HTTP protocol does not place any a priori limit on the length of\n   a URI. Servers MUST be able to handle the URI of any resource they\n   serve, and SHOULD be able to handle URIs of unbounded length if they\n   provide GET-based forms that could generate such URIs. A server\n   SHOULD return 414 (Request-URI Too Long) status if a URI is longer\n   than the server can handle (see section 10.4.15).\n\n      Note: Servers ought to be cautious about depending on URI lengths\n      above 255 bytes, because some older client or proxy\n      implementations might not properly support these lengths.\n\n3.2.2 http URL\n\n   The \"http\" scheme is used to locate network resources via the HTTP\n   protocol. This section defines the scheme-specific syntax and\n   semantics for http URLs.\n\n   http_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query ]]\n\n   If the port is empty or not given, port 80 is assumed. The semantics\n   are that the identified resource is located at the server listening\n   for TCP connections on that port of that host, and the Request-URI\n   for the resource is abs_path (section 5.1.2). The use of IP addresses\n   in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]). If\n   the abs_path is not present in the URL, it MUST be given as \"/\" when\n   used as a Request-URI for a resource (section 5.1.2). If a proxy\n   receives a host name which is not a fully qualified domain name, it\n   MAY add its domain to the host name it received. If a proxy receives\n   a fully qualified domain name, the proxy MUST NOT change the host\n   name.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 19]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.3 URI Comparison\n\n   When comparing two URIs to decide if they match or not, a client\n   SHOULD use a case-sensitive octet-by-octet comparison of the entire\n   URIs, with these exceptions:\n\n      - A port that is empty or not given is equivalent to the default\n        port for that URI-reference;\n\n        - Comparisons of host names MUST be case-insensitive;\n\n        - Comparisons of scheme names MUST be case-insensitive;\n\n        - An empty abs_path is equivalent to an abs_path of \"/\".\n\n   Characters other than those in the \"reserved\" and \"unsafe\" sets (see\n   RFC 2396 [42]) are equivalent to their \"\"%\" HEX HEX\" encoding.\n\n   For example, the following three URIs are equivalent:\n\n      http://abc.com:80/~smith/home.html\n      http://ABC.com/%7Esmith/home.html\n      http://ABC.com:/%7esmith/home.html\n\n3.3 Date/Time Formats\n\n3.3.1 Full Date\n\n   HTTP applications have historically allowed three different formats\n   for the representation of date/time stamps:\n\n      Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n      Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036\n      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format"
      },
      {
        "chunk_id": "rfc_http_chunk_15",
        "original_index": 15,
        "content": "The first format is preferred as an Internet standard and represents\n   a fixed-length subset of that defined by RFC 1123 [8] (an update to\n   RFC 822 [9]). The second format is in common use, but is based on the\n   obsolete RFC 850 [12] date format and lacks a four-digit year.\n   HTTP/1.1 clients and servers that parse the date value MUST accept\n   all three formats (for compatibility with HTTP/1.0), though they MUST\n   only generate the RFC 1123 format for representing HTTP-date values\n   in header fields. See section 19.3 for further information.\n\n      Note: Recipients of date values are encouraged to be robust in\n      accepting date values that may have been sent by non-HTTP\n      applications, as is sometimes the case when retrieving or posting\n      messages via proxies/gateways to SMTP or NNTP.\n\n\n\nFielding, et al.            Standards Track                    [Page 20]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   All HTTP date/time stamps MUST be represented in Greenwich Mean Time\n   (GMT), without exception. For the purposes of HTTP, GMT is exactly\n   equal to UTC (Coordinated Universal Time). This is indicated in the\n   first two formats by the inclusion of \"GMT\" as the three-letter\n   abbreviation for time zone, and MUST be assumed when reading the\n   asctime format. HTTP-date is case sensitive and MUST NOT include\n   additional LWS beyond that specifically included as SP in the\n   grammar.\n\n       HTTP-date    = rfc1123-date | rfc850-date | asctime-date\n       rfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\n       rfc850-date  = weekday \",\" SP date2 SP time SP \"GMT\"\n       asctime-date = wkday SP date3 SP time SP 4DIGIT\n       date1        = 2DIGIT SP month SP 4DIGIT\n                      ; day month year (e.g., 02 Jun 1982)\n       date2        = 2DIGIT \"-\" month \"-\" 2DIGIT\n                      ; day-month-year (e.g., 02-Jun-82)\n       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n                      ; month day (e.g., Jun  2)\n       time         = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n                      ; 00:00:00 - 23:59:59\n       wkday        = \"Mon\" | \"Tue\" | \"Wed\"\n                    | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\n       weekday      = \"Monday\" | \"Tuesday\" | \"Wednesday\"\n                    | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\"\n       month        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n                    | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n                    | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n\n      Note: HTTP requirements for the date/time stamp format apply only\n      to their usage within the protocol stream. Clients and servers are\n      not required to use these formats for user presentation, request\n      logging, etc.\n\n3.3.2 Delta Seconds\n\n   Some HTTP header fields allow a time value to be specified as an\n   integer number of seconds, represented in decimal, after the time\n   that the message was received.\n\n       delta-seconds  = 1*DIGIT\n\n3.4 Character Sets\n\n   HTTP uses the same definition of the term \"character set\" as that\n   described for MIME:\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 21]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_16",
        "original_index": 16,
        "content": "Fielding, et al.            Standards Track                    [Page 21]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The term \"character set\" is used in this document to refer to a\n   method used with one or more tables to convert a sequence of octets\n   into a sequence of characters. Note that unconditional conversion in\n   the other direction is not required, in that not all characters may\n   be available in a given character set and a character set may provide\n   more than one sequence of octets to represent a particular character.\n   This definition is intended to allow various kinds of character\n   encoding, from simple single-table mappings such as US-ASCII to\n   complex table switching methods such as those that use ISO-2022's\n   techniques. However, the definition associated with a MIME character\n   set name MUST fully specify the mapping to be performed from octets\n   to characters. In particular, use of external profiling information\n   to determine the exact mapping is not permitted.\n\n      Note: This use of the term \"character set\" is more commonly\n      referred to as a \"character encoding.\" However, since HTTP and\n      MIME share the same registry, it is important that the terminology\n      also be shared.\n\n   HTTP character sets are identified by case-insensitive tokens. The\n   complete set of tokens is defined by the IANA Character Set registry\n   [19].\n\n       charset = token\n\n   Although HTTP allows an arbitrary token to be used as a charset\n   value, any token that has a predefined value within the IANA\n   Character Set registry [19] MUST represent the character set defined\n   by that registry. Applications SHOULD limit their use of character\n   sets to those defined by the IANA registry.\n\n   Implementors should be aware of IETF character set requirements [38]\n   [41].\n\n3.4.1 Missing Charset\n\n   Some HTTP/1.0 software has interpreted a Content-Type header without\n   charset parameter incorrectly to mean \"recipient should guess.\"\n   Senders wishing to defeat this behavior MAY include a charset\n   parameter even when the charset is ISO-8859-1 and SHOULD do so when\n   it is known that it will not confuse the recipient.\n\n   Unfortunately, some older HTTP/1.0 clients did not deal properly with\n   an explicit charset parameter. HTTP/1.1 recipients MUST respect the\n   charset label provided by the sender; and those user agents that have\n   a provision to \"guess\" a charset MUST use the charset from the\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 22]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   content-type field if they support that charset, rather than the\n   recipient's preference, when initially displaying a document. See\n   section 3.7.1.\n\n3.5 Content Codings\n\n   Content coding values indicate an encoding transformation that has\n   been or can be applied to an entity. Content codings are primarily\n   used to allow a document to be compressed or otherwise usefully\n   transformed without losing the identity of its underlying media type\n   and without loss of information. Frequently, the entity is stored in\n   coded form, transmitted directly, and only decoded by the recipient.\n\n       content-coding   = token\n\n   All content-coding values are case-insensitive. HTTP/1.1 uses\n   content-coding values in the Accept-Encoding (section 14.3) and\n   Content-Encoding (section 14.11) header fields. Although the value\n   describes the content-coding, what is more important is that it\n   indicates what decoding mechanism will be required to remove the\n   encoding.\n\n   The Internet Assigned Numbers Authority (IANA) acts as a registry for\n   content-coding value tokens. Initially, the registry contains the\n   following tokens:\n\n   gzip An encoding format produced by the file compression program\n        \"gzip\" (GNU zip) as described in RFC 1952 [25]. This format is a\n        Lempel-Ziv coding (LZ77) with a 32 bit CRC."
      },
      {
        "chunk_id": "rfc_http_chunk_17",
        "original_index": 17,
        "content": "gzip An encoding format produced by the file compression program\n        \"gzip\" (GNU zip) as described in RFC 1952 [25]. This format is a\n        Lempel-Ziv coding (LZ77) with a 32 bit CRC.\n\n   compress\n        The encoding format produced by the common UNIX file compression\n        program \"compress\". This format is an adaptive Lempel-Ziv-Welch\n        coding (LZW).\n\n        Use of program names for the identification of encoding formats\n        is not desirable and is discouraged for future encodings. Their\n        use here is representative of historical practice, not good\n        design. For compatibility with previous implementations of HTTP,\n        applications SHOULD consider \"x-gzip\" and \"x-compress\" to be\n        equivalent to \"gzip\" and \"compress\" respectively.\n\n   deflate\n        The \"zlib\" format defined in RFC 1950 [31] in combination with\n        the \"deflate\" compression mechanism described in RFC 1951 [29].\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 23]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   identity\n        The default (identity) encoding; the use of no transformation\n        whatsoever. This content-coding is used only in the Accept-\n        Encoding header, and SHOULD NOT be used in the Content-Encoding\n        header.\n\n   New content-coding value tokens SHOULD be registered; to allow\n   interoperability between clients and servers, specifications of the\n   content coding algorithms needed to implement a new value SHOULD be\n   publicly available and adequate for independent implementation, and\n   conform to the purpose of content coding defined in this section.\n\n3.6 Transfer Codings\n\n   Transfer-coding values are used to indicate an encoding\n   transformation that has been, can be, or may need to be applied to an\n   entity-body in order to ensure \"safe transport\" through the network.\n   This differs from a content coding in that the transfer-coding is a\n   property of the message, not of the original entity.\n\n       transfer-coding         = \"chunked\" | transfer-extension\n       transfer-extension      = token *( \";\" parameter )\n\n   Parameters are in  the form of attribute/value pairs.\n\n       parameter               = attribute \"=\" value\n       attribute               = token\n       value                   = token | quoted-string\n\n   All transfer-coding values are case-insensitive. HTTP/1.1 uses\n   transfer-coding values in the TE header field (section 14.39) and in\n   the Transfer-Encoding header field (section 14.41).\n\n   Whenever a transfer-coding is applied to a message-body, the set of\n   transfer-codings MUST include \"chunked\", unless the message is\n   terminated by closing the connection. When the \"chunked\" transfer-\n   coding is used, it MUST be the last transfer-coding applied to the\n   message-body. The \"chunked\" transfer-coding MUST NOT be applied more\n   than once to a message-body. These rules allow the recipient to\n   determine the transfer-length of the message (section 4.4).\n\n   Transfer-codings are analogous to the Content-Transfer-Encoding\n   values of MIME [7], which were designed to enable safe transport of\n   binary data over a 7-bit transport service. However, safe transport\n   has a different focus for an 8bit-clean transfer protocol. In HTTP,\n   the only unsafe characteristic of message-bodies is the difficulty in\n   determining the exact body length (section 7.2.2), or the desire to\n   encrypt data over a shared transport.\n\n\n\nFielding, et al.            Standards Track                    [Page 24]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Internet Assigned Numbers Authority (IANA) acts as a registry for\n   transfer-coding value tokens. Initially, the registry contains the\n   following tokens: \"chunked\" (section 3.6.1), \"identity\" (section\n   3.6.2), \"gzip\" (section 3.5), \"compress\" (section 3.5), and \"deflate\"\n   (section 3.5)."
      },
      {
        "chunk_id": "rfc_http_chunk_18",
        "original_index": 18,
        "content": "New transfer-coding value tokens SHOULD be registered in the same way\n   as new content-coding value tokens (section 3.5).\n\n   A server which receives an entity-body with a transfer-coding it does\n   not understand SHOULD return 501 (Unimplemented), and close the\n   connection. A server MUST NOT send transfer-codings to an HTTP/1.0\n   client.\n\n3.6.1 Chunked Transfer Coding\n\n   The chunked encoding modifies the body of a message in order to\n   transfer it as a series of chunks, each with its own size indicator,\n   followed by an OPTIONAL trailer containing entity-header fields. This\n   allows dynamically produced content to be transferred along with the\n   information necessary for the recipient to verify that it has\n   received the full message.\n\n       Chunked-Body   = *chunk\n                        last-chunk\n                        trailer\n                        CRLF\n\n       chunk          = chunk-size [ chunk-extension ] CRLF\n                        chunk-data CRLF\n       chunk-size     = 1*HEX\n       last-chunk     = 1*(\"0\") [ chunk-extension ] CRLF\n\n       chunk-extension= *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )\n       chunk-ext-name = token\n       chunk-ext-val  = token | quoted-string\n       chunk-data     = chunk-size(OCTET)\n       trailer        = *(entity-header CRLF)\n\n   The chunk-size field is a string of hex digits indicating the size of\n   the chunk. The chunked encoding is ended by any chunk whose size is\n   zero, followed by the trailer, which is terminated by an empty line.\n\n   The trailer allows the sender to include additional HTTP header\n   fields at the end of the message. The Trailer header field can be\n   used to indicate which header fields are included in a trailer (see\n   section 14.40).\n\n\n\n\nFielding, et al.            Standards Track                    [Page 25]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A server using chunked transfer-coding in a response MUST NOT use the\n   trailer for any header fields unless at least one of the following is\n   true:\n\n   a)the request included a TE header field that indicates \"trailers\" is\n     acceptable in the transfer-coding of the  response, as described in\n     section 14.39; or,\n\n   b)the server is the origin server for the response, the trailer\n     fields consist entirely of optional metadata, and the recipient\n     could use the message (in a manner acceptable to the origin server)\n     without receiving this metadata.  In other words, the origin server\n     is willing to accept the possibility that the trailer fields might\n     be silently discarded along the path to the client.\n\n   This requirement prevents an interoperability failure when the\n   message is being received by an HTTP/1.1 (or later) proxy and\n   forwarded to an HTTP/1.0 recipient. It avoids a situation where\n   compliance with the protocol would have necessitated a possibly\n   infinite buffer on the proxy.\n\n   An example process for decoding a Chunked-Body is presented in\n   appendix 19.4.6.\n\n   All HTTP/1.1 applications MUST be able to receive and decode the\n   \"chunked\" transfer-coding, and MUST ignore chunk-extension extensions\n   they do not understand.\n\n3.7 Media Types\n\n   HTTP uses Internet Media Types [17] in the Content-Type (section\n   14.17) and Accept (section 14.1) header fields in order to provide\n   open and extensible data typing and type negotiation.\n\n       media-type     = type \"/\" subtype *( \";\" parameter )\n       type           = token\n       subtype        = token\n\n   Parameters MAY follow the type/subtype in the form of attribute/value\n   pairs (as defined in section 3.6)."
      },
      {
        "chunk_id": "rfc_http_chunk_19",
        "original_index": 19,
        "content": "Parameters MAY follow the type/subtype in the form of attribute/value\n   pairs (as defined in section 3.6).\n\n   The type, subtype, and parameter attribute names are case-\n   insensitive. Parameter values might or might not be case-sensitive,\n   depending on the semantics of the parameter name. Linear white space\n   (LWS) MUST NOT be used between the type and subtype, nor between an\n   attribute and its value. The presence or absence of a parameter might\n   be significant to the processing of a media-type, depending on its\n   definition within the media type registry.\n\n\n\nFielding, et al.            Standards Track                    [Page 26]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Note that some older HTTP applications do not recognize media type\n   parameters. When sending data to older HTTP applications,\n   implementations SHOULD only use media type parameters when they are\n   required by that type/subtype definition.\n\n   Media-type values are registered with the Internet Assigned Number\n   Authority (IANA [19]). The media type registration process is\n   outlined in RFC 1590 [17]. Use of non-registered media types is\n   discouraged.\n\n3.7.1 Canonicalization and Text Defaults\n\n   Internet media types are registered with a canonical form. An\n   entity-body transferred via HTTP messages MUST be represented in the\n   appropriate canonical form prior to its transmission except for\n   \"text\" types, as defined in the next paragraph.\n\n   When in canonical form, media subtypes of the \"text\" type use CRLF as\n   the text line break. HTTP relaxes this requirement and allows the\n   transport of text media with plain CR or LF alone representing a line\n   break when it is done consistently for an entire entity-body. HTTP\n   applications MUST accept CRLF, bare CR, and bare LF as being\n   representative of a line break in text media received via HTTP. In\n   addition, if the text is represented in a character set that does not\n   use octets 13 and 10 for CR and LF respectively, as is the case for\n   some multi-byte character sets, HTTP allows the use of whatever octet\n   sequences are defined by that character set to represent the\n   equivalent of CR and LF for line breaks. This flexibility regarding\n   line breaks applies only to text media in the entity-body; a bare CR\n   or LF MUST NOT be substituted for CRLF within any of the HTTP control\n   structures (such as header fields and multipart boundaries).\n\n   If an entity-body is encoded with a content-coding, the underlying\n   data MUST be in a form defined above prior to being encoded.\n\n   The \"charset\" parameter is used with some media types to define the\n   character set (section 3.4) of the data. When no explicit charset\n   parameter is provided by the sender, media subtypes of the \"text\"\n   type are defined to have a default charset value of \"ISO-8859-1\" when\n   received via HTTP. Data in character sets other than \"ISO-8859-1\" or\n   its subsets MUST be labeled with an appropriate charset value. See\n   section 3.4.1 for compatibility problems.\n\n3.7.2 Multipart Types\n\n   MIME provides for a number of \"multipart\" types -- encapsulations of\n   one or more entities within a single message-body. All multipart\n   types share a common syntax, as defined in section 5.1.1 of RFC 2046\n\n\n\nFielding, et al.            Standards Track                    [Page 27]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_20",
        "original_index": 20,
        "content": "Fielding, et al.            Standards Track                    [Page 27]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [40], and MUST include a boundary parameter as part of the media type\n   value. The message body is itself a protocol element and MUST\n   therefore use only CRLF to represent line breaks between body-parts.\n   Unlike in RFC 2046, the epilogue of any multipart message MUST be\n   empty; HTTP applications MUST NOT transmit the epilogue (even if the\n   original multipart contains an epilogue). These restrictions exist in\n   order to preserve the self-delimiting nature of a multipart message-\n   body, wherein the \"end\" of the message-body is indicated by the\n   ending multipart boundary.\n\n   In general, HTTP treats a multipart message-body no differently than\n   any other media type: strictly as payload. The one exception is the\n   \"multipart/byteranges\" type (appendix 19.2) when it appears in a 206\n   (Partial Content) response, which will be interpreted by some HTTP\n   caching mechanisms as described in sections 13.5.4 and 14.16. In all\n   other cases, an HTTP user agent SHOULD follow the same or similar\n   behavior as a MIME user agent would upon receipt of a multipart type.\n   The MIME header fields within each body-part of a multipart message-\n   body do not have any significance to HTTP beyond that defined by\n   their MIME semantics.\n\n   In general, an HTTP user agent SHOULD follow the same or similar\n   behavior as a MIME user agent would upon receipt of a multipart type.\n   If an application receives an unrecognized multipart subtype, the\n   application MUST treat it as being equivalent to \"multipart/mixed\".\n\n      Note: The \"multipart/form-data\" type has been specifically defined\n      for carrying form data suitable for processing via the POST\n      request method, as described in RFC 1867 [15].\n\n3.8 Product Tokens\n\n   Product tokens are used to allow communicating applications to\n   identify themselves by software name and version. Most fields using\n   product tokens also allow sub-products which form a significant part\n   of the application to be listed, separated by white space. By\n   convention, the products are listed in order of their significance\n   for identifying the application.\n\n       product         = token [\"/\" product-version]\n       product-version = token\n\n   Examples:\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n       Server: Apache/0.8.4\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 28]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Product tokens SHOULD be short and to the point. They MUST NOT be\n   used for advertising or other non-essential information. Although any\n   token character MAY appear in a product-version, this token SHOULD\n   only be used for a version identifier (i.e., successive versions of\n   the same product SHOULD only differ in the product-version portion of\n   the product value).\n\n3.9 Quality Values\n\n   HTTP content negotiation (section 12) uses short \"floating point\"\n   numbers to indicate the relative importance (\"weight\") of various\n   negotiable parameters.  A weight is normalized to a real number in\n   the range 0 through 1, where 0 is the minimum and 1 the maximum\n   value. If a parameter has a quality value of 0, then content with\n   this parameter is `not acceptable' for the client. HTTP/1.1\n   applications MUST NOT generate more than three digits after the\n   decimal point. User configuration of these values SHOULD also be\n   limited in this fashion.\n\n       qvalue         = ( \"0\" [ \".\" 0*3DIGIT ] )\n                      | ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n   \"Quality values\" is a misnomer, since these values merely represent\n   relative degradation in desired quality.\n\n3.10 Language Tags"
      },
      {
        "chunk_id": "rfc_http_chunk_21",
        "original_index": 21,
        "content": "\"Quality values\" is a misnomer, since these values merely represent\n   relative degradation in desired quality.\n\n3.10 Language Tags\n\n   A language tag identifies a natural language spoken, written, or\n   otherwise conveyed by human beings for communication of information\n   to other human beings. Computer languages are explicitly excluded.\n   HTTP uses language tags within the Accept-Language and Content-\n   Language fields.\n\n   The syntax and registry of HTTP language tags is the same as that\n   defined by RFC 1766 [1]. In summary, a language tag is composed of 1\n   or more parts: A primary language tag and a possibly empty series of\n   subtags:\n\n        language-tag  = primary-tag *( \"-\" subtag )\n        primary-tag   = 1*8ALPHA\n        subtag        = 1*8ALPHA\n\n   White space is not allowed within the tag and all tags are case-\n   insensitive. The name space of language tags is administered by the\n   IANA. Example tags include:\n\n       en, en-US, en-cockney, i-cherokee, x-pig-latin\n\n\n\n\nFielding, et al.            Standards Track                    [Page 29]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   where any two-letter primary-tag is an ISO-639 language abbreviation\n   and any two-letter initial subtag is an ISO-3166 country code. (The\n   last three tags above are not registered tags; all but the last are\n   examples of tags which could be registered in future.)\n\n3.11 Entity Tags\n\n   Entity tags are used for comparing two or more entities from the same\n   requested resource. HTTP/1.1 uses entity tags in the ETag (section\n   14.19), If-Match (section 14.24), If-None-Match (section 14.26), and\n   If-Range (section 14.27) header fields. The definition of how they\n   are used and compared as cache validators is in section 13.3.3. An\n   entity tag consists of an opaque quoted string, possibly prefixed by\n   a weakness indicator.\n\n      entity-tag = [ weak ] opaque-tag\n      weak       = \"W/\"\n      opaque-tag = quoted-string\n\n   A \"strong entity tag\" MAY be shared by two entities of a resource\n   only if they are equivalent by octet equality.\n\n   A \"weak entity tag,\" indicated by the \"W/\" prefix, MAY be shared by\n   two entities of a resource only if the entities are equivalent and\n   could be substituted for each other with no significant change in\n   semantics. A weak entity tag can only be used for weak comparison.\n\n   An entity tag MUST be unique across all versions of all entities\n   associated with a particular resource. A given entity tag value MAY\n   be used for entities obtained by requests on different URIs. The use\n   of the same entity tag value in conjunction with entities obtained by\n   requests on different URIs does not imply the equivalence of those\n   entities.\n\n3.12 Range Units\n\n   HTTP/1.1 allows a client to request that only part (a range of) the\n   response entity be included within the response. HTTP/1.1 uses range\n   units in the Range (section 14.35) and Content-Range (section 14.16)\n   header fields. An entity can be broken down into subranges according\n   to various structural units.\n\n      range-unit       = bytes-unit | other-range-unit\n      bytes-unit       = \"bytes\"\n      other-range-unit = token\n\n   The only range unit defined by HTTP/1.1 is \"bytes\". HTTP/1.1\n   implementations MAY ignore ranges specified using other units.\n\n\n\nFielding, et al.            Standards Track                    [Page 30]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 has been designed to allow implementations of applications\n   that do not depend on knowledge of ranges.\n\n4 HTTP Message\n\n4.1 Message Types\n\n   HTTP messages consist of requests from client to server and responses\n   from server to client.\n\n       HTTP-message   = Request | Response     ; HTTP/1.1 messages"
      },
      {
        "chunk_id": "rfc_http_chunk_22",
        "original_index": 22,
        "content": "4.1 Message Types\n\n   HTTP messages consist of requests from client to server and responses\n   from server to client.\n\n       HTTP-message   = Request | Response     ; HTTP/1.1 messages\n\n   Request (section 5) and Response (section 6) messages use the generic\n   message format of RFC 822 [9] for transferring entities (the payload\n   of the message). Both types of message consist of a start-line, zero\n   or more header fields (also known as \"headers\"), an empty line (i.e.,\n   a line with nothing preceding the CRLF) indicating the end of the\n   header fields, and possibly a message-body.\n\n        generic-message = start-line\n                          *(message-header CRLF)\n                          CRLF\n                          [ message-body ]\n        start-line      = Request-Line | Status-Line\n\n   In the interest of robustness, servers SHOULD ignore any empty\n   line(s) received where a Request-Line is expected. In other words, if\n   the server is reading the protocol stream at the beginning of a\n   message and receives a CRLF first, it should ignore the CRLF.\n\n   Certain buggy HTTP/1.0 client implementations generate extra CRLF's\n   after a POST request. To restate what is explicitly forbidden by the\n   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an\n   extra CRLF.\n\n4.2 Message Headers\n\n   HTTP header fields, which include general-header (section 4.5),\n   request-header (section 5.3), response-header (section 6.2), and\n   entity-header (section 7.1) fields, follow the same generic format as\n   that given in Section 3.1 of RFC 822 [9]. Each header field consists\n   of a name followed by a colon (\":\") and the field value. Field names\n   are case-insensitive. The field value MAY be preceded by any amount\n   of LWS, though a single SP is preferred. Header fields can be\n   extended over multiple lines by preceding each extra line with at\n   least one SP or HT. Applications ought to follow \"common form\", where\n   one is known or indicated, when generating HTTP constructs, since\n   there might exist some implementations that fail to accept anything\n\n\n\nFielding, et al.            Standards Track                    [Page 31]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   beyond the common forms.\n\n       message-header = field-name \":\" [ field-value ]\n       field-name     = token\n       field-value    = *( field-content | LWS )\n       field-content  = <the OCTETs making up the field-value\n                        and consisting of either *TEXT or combinations\n                        of token, separators, and quoted-string>\n\n   The field-content does not include any leading or trailing LWS:\n   linear white space occurring before the first non-whitespace\n   character of the field-value or after the last non-whitespace\n   character of the field-value. Such leading or trailing LWS MAY be\n   removed without changing the semantics of the field value. Any LWS\n   that occurs between field-content MAY be replaced with a single SP\n   before interpreting the field value or forwarding the message\n   downstream.\n\n   The order in which header fields with differing field names are\n   received is not significant. However, it is \"good practice\" to send\n   general-header fields first, followed by request-header or response-\n   header fields, and ending with the entity-header fields."
      },
      {
        "chunk_id": "rfc_http_chunk_23",
        "original_index": 23,
        "content": "Multiple message-header fields with the same field-name MAY be\n   present in a message if and only if the entire field-value for that\n   header field is defined as a comma-separated list [i.e., #(values)].\n   It MUST be possible to combine the multiple header fields into one\n   \"field-name: field-value\" pair, without changing the semantics of the\n   message, by appending each subsequent field-value to the first, each\n   separated by a comma. The order in which header fields with the same\n   field-name are received is therefore significant to the\n   interpretation of the combined field value, and thus a proxy MUST NOT\n   change the order of these field values when a message is forwarded.\n\n4.3 Message Body\n\n   The message-body (if any) of an HTTP message is used to carry the\n   entity-body associated with the request or response. The message-body\n   differs from the entity-body only when a transfer-coding has been\n   applied, as indicated by the Transfer-Encoding header field (section\n   14.41).\n\n       message-body = entity-body\n                    | <entity-body encoded as per Transfer-Encoding>\n\n   Transfer-Encoding MUST be used to indicate any transfer-codings\n   applied by an application to ensure safe and proper transfer of the\n   message. Transfer-Encoding is a property of the message, not of the\n\n\n\nFielding, et al.            Standards Track                    [Page 32]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   entity, and thus MAY be added or removed by any application along the\n   request/response chain. (However, section 3.6 places restrictions on\n   when certain transfer-codings may be used.)\n\n   The rules for when a message-body is allowed in a message differ for\n   requests and responses.\n\n   The presence of a message-body in a request is signaled by the\n   inclusion of a Content-Length or Transfer-Encoding header field in\n   the request's message-headers. A message-body MUST NOT be included in\n   a request if the specification of the request method (section 5.1.1)\n   does not allow sending an entity-body in requests. A server SHOULD\n   read and forward a message-body on any request; if the request method\n   does not include defined semantics for an entity-body, then the\n   message-body SHOULD be ignored when handling the request.\n\n   For response messages, whether or not a message-body is included with\n   a message is dependent on both the request method and the response\n   status code (section 6.1.1). All responses to the HEAD request method\n   MUST NOT include a message-body, even though the presence of entity-\n   header fields might lead one to believe they do. All 1xx\n   (informational), 204 (no content), and 304 (not modified) responses\n   MUST NOT include a message-body. All other responses do include a\n   message-body, although it MAY be of zero length.\n\n4.4 Message Length\n\n   The transfer-length of a message is the length of the message-body as\n   it appears in the message; that is, after any transfer-codings have\n   been applied. When a message-body is included with a message, the\n   transfer-length of that body is determined by one of the following\n   (in order of precedence):\n\n   1.Any response message which \"MUST NOT\" include a message-body (such\n     as the 1xx, 204, and 304 responses and any response to a HEAD\n     request) is always terminated by the first empty line after the\n     header fields, regardless of the entity-header fields present in\n     the message.\n\n   2.If a Transfer-Encoding header field (section 14.41) is present and\n     has any value other than \"identity\", then the transfer-length is\n     defined by use of the \"chunked\" transfer-coding (section 3.6),\n     unless the message is terminated by closing the connection."
      },
      {
        "chunk_id": "rfc_http_chunk_24",
        "original_index": 24,
        "content": "3.If a Content-Length header field (section 14.13) is present, its\n     decimal value in OCTETs represents both the entity-length and the\n     transfer-length. The Content-Length header field MUST NOT be sent\n     if these two lengths are different (i.e., if a Transfer-Encoding\n\n\n\nFielding, et al.            Standards Track                    [Page 33]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n     header field is present). If a message is received with both a\n     Transfer-Encoding header field and a Content-Length header field,\n     the latter MUST be ignored.\n\n   4.If the message uses the media type \"multipart/byteranges\", and the\n     ransfer-length is not otherwise specified, then this self-\n     elimiting media type defines the transfer-length. This media type\n     UST NOT be used unless the sender knows that the recipient can arse\n     it; the presence in a request of a Range header with ultiple byte-\n     range specifiers from a 1.1 client implies that the lient can parse\n     multipart/byteranges responses.\n\n       A range header might be forwarded by a 1.0 proxy that does not\n       understand multipart/byteranges; in this case the server MUST\n       delimit the message using methods defined in items 1,3 or 5 of\n       this section.\n\n   5.By the server closing the connection. (Closing the connection\n     cannot be used to indicate the end of a request body, since that\n     would leave no possibility for the server to send back a response.)\n\n   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests\n   containing a message-body MUST include a valid Content-Length header\n   field unless the server is known to be HTTP/1.1 compliant. If a\n   request contains a message-body and a Content-Length is not given,\n   the server SHOULD respond with 400 (bad request) if it cannot\n   determine the length of the message, or with 411 (length required) if\n   it wishes to insist on receiving a valid Content-Length.\n\n   All HTTP/1.1 applications that receive entities MUST accept the\n   \"chunked\" transfer-coding (section 3.6), thus allowing this mechanism\n   to be used for messages when the message length cannot be determined\n   in advance.\n\n   Messages MUST NOT include both a Content-Length header field and a\n   non-identity transfer-coding. If the message does include a non-\n   identity transfer-coding, the Content-Length MUST be ignored.\n\n   When a Content-Length is given in a message where a message-body is\n   allowed, its field value MUST exactly match the number of OCTETs in\n   the message-body. HTTP/1.1 user agents MUST notify the user when an\n   invalid length is received and detected.\n\n4.5 General Header Fields\n\n   There are a few header fields which have general applicability for\n   both request and response messages, but which do not apply to the\n   entity being transferred. These header fields apply only to the\n\n\n\nFielding, et al.            Standards Track                    [Page 34]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   message being transmitted.\n\n       general-header = Cache-Control            ; Section 14.9\n                      | Connection               ; Section 14.10\n                      | Date                     ; Section 14.18\n                      | Pragma                   ; Section 14.32\n                      | Trailer                  ; Section 14.40\n                      | Transfer-Encoding        ; Section 14.41\n                      | Upgrade                  ; Section 14.42\n                      | Via                      ; Section 14.45\n                      | Warning                  ; Section 14.46"
      },
      {
        "chunk_id": "rfc_http_chunk_25",
        "original_index": 25,
        "content": "General-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields may be given the semantics of general\n   header fields if all parties in the communication recognize them to\n   be general-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n5 Request\n\n   A request message from a client to a server includes, within the\n   first line of that message, the method to be applied to the resource,\n   the identifier of the resource, and the protocol version in use.\n\n        Request       = Request-Line              ; Section 5.1\n                        *(( general-header        ; Section 4.5\n                         | request-header         ; Section 5.3\n                         | entity-header ) CRLF)  ; Section 7.1\n                        CRLF\n                        [ message-body ]          ; Section 4.3\n\n5.1 Request-Line\n\n   The Request-Line begins with a method token, followed by the\n   Request-URI and the protocol version, and ending with CRLF. The\n   elements are separated by SP characters. No CR or LF is allowed\n   except in the final CRLF sequence.\n\n        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 35]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n5.1.1 Method\n\n   The Method  token indicates the method to be performed on the\n   resource identified by the Request-URI. The method is case-sensitive.\n\n       Method         = \"OPTIONS\"                ; Section 9.2\n                      | \"GET\"                    ; Section 9.3\n                      | \"HEAD\"                   ; Section 9.4\n                      | \"POST\"                   ; Section 9.5\n                      | \"PUT\"                    ; Section 9.6\n                      | \"DELETE\"                 ; Section 9.7\n                      | \"TRACE\"                  ; Section 9.8\n                      | \"CONNECT\"                ; Section 9.9\n                      | extension-method\n       extension-method = token\n\n   The list of methods allowed by a resource can be specified in an\n   Allow header field (section 14.7). The return code of the response\n   always notifies the client whether a method is currently allowed on a\n   resource, since the set of allowed methods can change dynamically. An\n   origin server SHOULD return the status code 405 (Method Not Allowed)\n   if the method is known by the origin server but not allowed for the\n   requested resource, and 501 (Not Implemented) if the method is\n   unrecognized or not implemented by the origin server. The methods GET\n   and HEAD MUST be supported by all general-purpose servers. All other\n   methods are OPTIONAL; however, if the above methods are implemented,\n   they MUST be implemented with the same semantics as those specified\n   in section 9.\n\n5.1.2 Request-URI\n\n   The Request-URI is a Uniform Resource Identifier (section 3.2) and\n   identifies the resource upon which to apply the request.\n\n       Request-URI    = \"*\" | absoluteURI | abs_path | authority\n\n   The four options for Request-URI are dependent on the nature of the\n   request. The asterisk \"*\" means that the request does not apply to a\n   particular resource, but to the server itself, and is only allowed\n   when the method used does not necessarily apply to a resource. One\n   example would be\n\n       OPTIONS * HTTP/1.1\n\n   The absoluteURI form is REQUIRED when the request is being made to a\n   proxy. The proxy is requested to forward the request or service it\n   from a valid cache, and return the response. Note that the proxy MAY\n   forward the request on to another proxy or directly to the server\n\n\n\nFielding, et al.            Standards Track                    [Page 36]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_26",
        "original_index": 26,
        "content": "Fielding, et al.            Standards Track                    [Page 36]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   specified by the absoluteURI. In order to avoid request loops, a\n   proxy MUST be able to recognize all of its server names, including\n   any aliases, local variations, and the numeric IP address. An example\n   Request-Line would be:\n\n       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1\n\n   To allow for transition to absoluteURIs in all requests in future\n   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI\n   form in requests, even though HTTP/1.1 clients will only generate\n   them in requests to proxies.\n\n   The authority form is only used by the CONNECT method (section 9.9).\n\n   The most common form of Request-URI is that used to identify a\n   resource on an origin server or gateway. In this case the absolute\n   path of the URI MUST be transmitted (see section 3.2.1, abs_path) as\n   the Request-URI, and the network location of the URI (authority) MUST\n   be transmitted in a Host header field. For example, a client wishing\n   to retrieve the resource above directly from the origin server would\n   create a TCP connection to port 80 of the host \"www.w3.org\" and send\n   the lines:\n\n       GET /pub/WWW/TheProject.html HTTP/1.1\n       Host: www.w3.org\n\n   followed by the remainder of the Request. Note that the absolute path\n   cannot be empty; if none is present in the original URI, it MUST be\n   given as \"/\" (the server root).\n\n   The Request-URI is transmitted in the format specified in section\n   3.2.1. If the Request-URI is encoded using the \"% HEX HEX\" encoding\n   [42], the origin server MUST decode the Request-URI in order to\n   properly interpret the request. Servers SHOULD respond to invalid\n   Request-URIs with an appropriate status code.\n\n   A transparent proxy MUST NOT rewrite the \"abs_path\" part of the\n   received Request-URI when forwarding it to the next inbound server,\n   except as noted above to replace a null abs_path with \"/\".\n\n      Note: The \"no rewrite\" rule prevents the proxy from changing the\n      meaning of the request when the origin server is improperly using\n      a non-reserved URI character for a reserved purpose.  Implementors\n      should be aware that some pre-HTTP/1.1 proxies have been known to\n      rewrite the Request-URI.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 37]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n5.2 The Resource Identified by a Request\n\n   The exact resource identified by an Internet request is determined by\n   examining both the Request-URI and the Host header field.\n\n   An origin server that does not allow resources to differ by the\n   requested host MAY ignore the Host header field value when\n   determining the resource identified by an HTTP/1.1 request. (But see\n   section 19.6.1.1 for other requirements on Host support in HTTP/1.1.)\n\n   An origin server that does differentiate resources based on the host\n   requested (sometimes referred to as virtual hosts or vanity host\n   names) MUST use the following rules for determining the requested\n   resource on an HTTP/1.1 request:\n\n   1. If Request-URI is an absoluteURI, the host is part of the\n     Request-URI. Any Host header field value in the request MUST be\n     ignored.\n\n   2. If the Request-URI is not an absoluteURI, and the request includes\n     a Host header field, the host is determined by the Host header\n     field value.\n\n   3. If the host as determined by rule 1 or 2 is not a valid host on\n     the server, the response MUST be a 400 (Bad Request) error message.\n\n   Recipients of an HTTP/1.0 request that lacks a Host header field MAY\n   attempt to use heuristics (e.g., examination of the URI path for\n   something unique to a particular host) in order to determine what\n   exact resource is being requested.\n\n5.3 Request Header Fields"
      },
      {
        "chunk_id": "rfc_http_chunk_27",
        "original_index": 27,
        "content": "5.3 Request Header Fields\n\n   The request-header fields allow the client to pass additional\n   information about the request, and about the client itself, to the\n   server. These fields act as request modifiers, with semantics\n   equivalent to the parameters on a programming language method\n   invocation.\n\n       request-header = Accept                   ; Section 14.1\n                      | Accept-Charset           ; Section 14.2\n                      | Accept-Encoding          ; Section 14.3\n                      | Accept-Language          ; Section 14.4\n                      | Authorization            ; Section 14.8\n                      | Expect                   ; Section 14.20\n                      | From                     ; Section 14.22\n                      | Host                     ; Section 14.23\n                      | If-Match                 ; Section 14.24\n\n\n\nFielding, et al.            Standards Track                    [Page 38]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                      | If-Modified-Since        ; Section 14.25\n                      | If-None-Match            ; Section 14.26\n                      | If-Range                 ; Section 14.27\n                      | If-Unmodified-Since      ; Section 14.28\n                      | Max-Forwards             ; Section 14.31\n                      | Proxy-Authorization      ; Section 14.34\n                      | Range                    ; Section 14.35\n                      | Referer                  ; Section 14.36\n                      | TE                       ; Section 14.39\n                      | User-Agent               ; Section 14.43\n\n   Request-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields MAY be given the semantics of request-\n   header fields if all parties in the communication recognize them to\n   be request-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n6 Response\n\n   After receiving and interpreting a request message, a server responds\n   with an HTTP response message.\n\n       Response      = Status-Line               ; Section 6.1\n                       *(( general-header        ; Section 4.5\n                        | response-header        ; Section 6.2\n                        | entity-header ) CRLF)  ; Section 7.1\n                       CRLF\n                       [ message-body ]          ; Section 7.2\n\n6.1 Status-Line\n\n   The first line of a Response message is the Status-Line, consisting\n   of the protocol version followed by a numeric status code and its\n   associated textual phrase, with each element separated by SP\n   characters. No CR or LF is allowed except in the final CRLF sequence.\n\n       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n\n6.1.1 Status Code and Reason Phrase\n\n   The Status-Code element is a 3-digit integer result code of the\n   attempt to understand and satisfy the request. These codes are fully\n   defined in section 10. The Reason-Phrase is intended to give a short\n   textual description of the Status-Code. The Status-Code is intended\n   for use by automata and the Reason-Phrase is intended for the human\n   user. The client is not required to examine or display the Reason-\n   Phrase.\n\n\n\nFielding, et al.            Standards Track                    [Page 39]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The first digit of the Status-Code defines the class of response. The\n   last two digits do not have any categorization role. There are 5\n   values for the first digit:\n\n      - 1xx: Informational - Request received, continuing process\n\n      - 2xx: Success - The action was successfully received,\n        understood, and accepted\n\n      - 3xx: Redirection - Further action must be taken in order to\n        complete the request"
      },
      {
        "chunk_id": "rfc_http_chunk_28",
        "original_index": 28,
        "content": "- 2xx: Success - The action was successfully received,\n        understood, and accepted\n\n      - 3xx: Redirection - Further action must be taken in order to\n        complete the request\n\n      - 4xx: Client Error - The request contains bad syntax or cannot\n        be fulfilled\n\n      - 5xx: Server Error - The server failed to fulfill an apparently\n        valid request\n\n   The individual values of the numeric status codes defined for\n   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are\n   presented below. The reason phrases listed here are only\n   recommendations -- they MAY be replaced by local equivalents without\n   affecting the protocol.\n\n      Status-Code    =\n            \"100\"  ; Section 10.1.1: Continue\n          | \"101\"  ; Section 10.1.2: Switching Protocols\n          | \"200\"  ; Section 10.2.1: OK\n          | \"201\"  ; Section 10.2.2: Created\n          | \"202\"  ; Section 10.2.3: Accepted\n          | \"203\"  ; Section 10.2.4: Non-Authoritative Information\n          | \"204\"  ; Section 10.2.5: No Content\n          | \"205\"  ; Section 10.2.6: Reset Content\n          | \"206\"  ; Section 10.2.7: Partial Content\n          | \"300\"  ; Section 10.3.1: Multiple Choices\n          | \"301\"  ; Section 10.3.2: Moved Permanently\n          | \"302\"  ; Section 10.3.3: Found\n          | \"303\"  ; Section 10.3.4: See Other\n          | \"304\"  ; Section 10.3.5: Not Modified\n          | \"305\"  ; Section 10.3.6: Use Proxy\n          | \"307\"  ; Section 10.3.8: Temporary Redirect\n          | \"400\"  ; Section 10.4.1: Bad Request\n          | \"401\"  ; Section 10.4.2: Unauthorized\n          | \"402\"  ; Section 10.4.3: Payment Required\n          | \"403\"  ; Section 10.4.4: Forbidden\n          | \"404\"  ; Section 10.4.5: Not Found\n          | \"405\"  ; Section 10.4.6: Method Not Allowed\n          | \"406\"  ; Section 10.4.7: Not Acceptable\n\n\n\nFielding, et al.            Standards Track                    [Page 40]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n          | \"407\"  ; Section 10.4.8: Proxy Authentication Required\n          | \"408\"  ; Section 10.4.9: Request Time-out\n          | \"409\"  ; Section 10.4.10: Conflict\n          | \"410\"  ; Section 10.4.11: Gone\n          | \"411\"  ; Section 10.4.12: Length Required\n          | \"412\"  ; Section 10.4.13: Precondition Failed\n          | \"413\"  ; Section 10.4.14: Request Entity Too Large\n          | \"414\"  ; Section 10.4.15: Request-URI Too Large\n          | \"415\"  ; Section 10.4.16: Unsupported Media Type\n          | \"416\"  ; Section 10.4.17: Requested range not satisfiable\n          | \"417\"  ; Section 10.4.18: Expectation Failed\n          | \"500\"  ; Section 10.5.1: Internal Server Error\n          | \"501\"  ; Section 10.5.2: Not Implemented\n          | \"502\"  ; Section 10.5.3: Bad Gateway\n          | \"503\"  ; Section 10.5.4: Service Unavailable\n          | \"504\"  ; Section 10.5.5: Gateway Time-out\n          | \"505\"  ; Section 10.5.6: HTTP Version not supported\n          | extension-code\n\n      extension-code = 3DIGIT\n      Reason-Phrase  = *<TEXT, excluding CR, LF>\n\n   HTTP status codes are extensible. HTTP applications are not required\n   to understand the meaning of all registered status codes, though such\n   understanding is obviously desirable. However, applications MUST\n   understand the class of any status code, as indicated by the first\n   digit, and treat any unrecognized response as being equivalent to the\n   x00 status code of that class, with the exception that an\n   unrecognized response MUST NOT be cached. For example, if an\n   unrecognized status code of 431 is received by the client, it can\n   safely assume that there was something wrong with its request and\n   treat the response as if it had received a 400 status code. In such\n   cases, user agents SHOULD present to the user the entity returned\n   with the response, since that entity is likely to include human-\n   readable information which will explain the unusual status."
      },
      {
        "chunk_id": "rfc_http_chunk_29",
        "original_index": 29,
        "content": "6.2 Response Header Fields\n\n   The response-header fields allow the server to pass additional\n   information about the response which cannot be placed in the Status-\n   Line. These header fields give information about the server and about\n   further access to the resource identified by the Request-URI.\n\n       response-header = Accept-Ranges           ; Section 14.5\n                       | Age                     ; Section 14.6\n                       | ETag                    ; Section 14.19\n                       | Location                ; Section 14.30\n                       | Proxy-Authenticate      ; Section 14.33\n\n\n\nFielding, et al.            Standards Track                    [Page 41]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                       | Retry-After             ; Section 14.37\n                       | Server                  ; Section 14.38\n                       | Vary                    ; Section 14.44\n                       | WWW-Authenticate        ; Section 14.47\n\n   Response-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields MAY be given the semantics of response-\n   header fields if all parties in the communication recognize them to\n   be response-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n7 Entity\n\n   Request and Response messages MAY transfer an entity if not otherwise\n   restricted by the request method or response status code. An entity\n   consists of entity-header fields and an entity-body, although some\n   responses will only include the entity-headers.\n\n   In this section, both sender and recipient refer to either the client\n   or the server, depending on who sends and who receives the entity.\n\n7.1 Entity Header Fields\n\n   Entity-header fields define metainformation about the entity-body or,\n   if no body is present, about the resource identified by the request.\n   Some of this metainformation is OPTIONAL; some might be REQUIRED by\n   portions of this specification.\n\n       entity-header  = Allow                    ; Section 14.7\n                      | Content-Encoding         ; Section 14.11\n                      | Content-Language         ; Section 14.12\n                      | Content-Length           ; Section 14.13\n                      | Content-Location         ; Section 14.14\n                      | Content-MD5              ; Section 14.15\n                      | Content-Range            ; Section 14.16\n                      | Content-Type             ; Section 14.17\n                      | Expires                  ; Section 14.21\n                      | Last-Modified            ; Section 14.29\n                      | extension-header\n\n       extension-header = message-header\n\n   The extension-header mechanism allows additional entity-header fields\n   to be defined without changing the protocol, but these fields cannot\n   be assumed to be recognizable by the recipient. Unrecognized header\n   fields SHOULD be ignored by the recipient and MUST be forwarded by\n   transparent proxies.\n\n\n\nFielding, et al.            Standards Track                    [Page 42]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n7.2 Entity Body\n\n   The entity-body (if any) sent with an HTTP request or response is in\n   a format and encoding defined by the entity-header fields.\n\n       entity-body    = *OCTET\n\n   An entity-body is only present in a message when a message-body is\n   present, as described in section 4.3. The entity-body is obtained\n   from the message-body by decoding any Transfer-Encoding that might\n   have been applied to ensure safe and proper transfer of the message.\n\n7.2.1 Type\n\n   When an entity-body is included with a message, the data type of that\n   body is determined via the header fields Content-Type and Content-\n   Encoding. These define a two-layer, ordered encoding model:"
      },
      {
        "chunk_id": "rfc_http_chunk_30",
        "original_index": 30,
        "content": "entity-body := Content-Encoding( Content-Type( data ) )\n\n   Content-Type specifies the media type of the underlying data.\n   Content-Encoding may be used to indicate any additional content\n   codings applied to the data, usually for the purpose of data\n   compression, that are a property of the requested resource. There is\n   no default encoding.\n\n   Any HTTP/1.1 message containing an entity-body SHOULD include a\n   Content-Type header field defining the media type of that body. If\n   and only if the media type is not given by a Content-Type field, the\n   recipient MAY attempt to guess the media type via inspection of its\n   content and/or the name extension(s) of the URI used to identify the\n   resource. If the media type remains unknown, the recipient SHOULD\n   treat it as type \"application/octet-stream\".\n\n7.2.2 Entity Length\n\n   The entity-length of a message is the length of the message-body\n   before any transfer-codings have been applied. Section 4.4 defines\n   how the transfer-length of a message-body is determined.\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 43]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8 Connections\n\n8.1 Persistent Connections\n\n8.1.1 Purpose\n\n   Prior to persistent connections, a separate TCP connection was\n   established to fetch each URL, increasing the load on HTTP servers\n   and causing congestion on the Internet. The use of inline images and\n   other associated data often require a client to make multiple\n   requests of the same server in a short amount of time. Analysis of\n   these performance problems and results from a prototype\n   implementation are available [26] [30]. Implementation experience and\n   measurements of actual HTTP/1.1 (RFC 2068) implementations show good\n   results [39]. Alternatives have also been explored, for example,\n   T/TCP [27].\n\n   Persistent HTTP connections have a number of advantages:\n\n      - By opening and closing fewer TCP connections, CPU time is saved\n        in routers and hosts (clients, servers, proxies, gateways,\n        tunnels, or caches), and memory used for TCP protocol control\n        blocks can be saved in hosts.\n\n      - HTTP requests and responses can be pipelined on a connection.\n        Pipelining allows a client to make multiple requests without\n        waiting for each response, allowing a single TCP connection to\n        be used much more efficiently, with much lower elapsed time.\n\n      - Network congestion is reduced by reducing the number of packets\n        caused by TCP opens, and by allowing TCP sufficient time to\n        determine the congestion state of the network.\n\n      - Latency on subsequent requests is reduced since there is no time\n        spent in TCP's connection opening handshake.\n\n      - HTTP can evolve more gracefully, since errors can be reported\n        without the penalty of closing the TCP connection. Clients using\n        future versions of HTTP might optimistically try a new feature,\n        but if communicating with an older server, retry with old\n        semantics after an error is reported.\n\n   HTTP implementations SHOULD implement persistent connections.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 44]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.1.2 Overall Operation\n\n   A significant difference between HTTP/1.1 and earlier versions of\n   HTTP is that persistent connections are the default behavior of any\n   HTTP connection. That is, unless otherwise indicated, the client\n   SHOULD assume that the server will maintain a persistent connection,\n   even after error responses from the server."
      },
      {
        "chunk_id": "rfc_http_chunk_31",
        "original_index": 31,
        "content": "Persistent connections provide a mechanism by which a client and a\n   server can signal the close of a TCP connection. This signaling takes\n   place using the Connection header field (section 14.10). Once a close\n   has been signaled, the client MUST NOT send any more requests on that\n   connection.\n\n8.1.2.1 Negotiation\n\n   An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to\n   maintain a persistent connection unless a Connection header including\n   the connection-token \"close\" was sent in the request. If the server\n   chooses to close the connection immediately after sending the\n   response, it SHOULD send a Connection header including the\n   connection-token close.\n\n   An HTTP/1.1 client MAY expect a connection to remain open, but would\n   decide to keep it open based on whether the response from a server\n   contains a Connection header with the connection-token close. In case\n   the client does not want to maintain a connection for more than that\n   request, it SHOULD send a Connection header including the\n   connection-token close.\n\n   If either the client or the server sends the close token in the\n   Connection header, that request becomes the last one for the\n   connection.\n\n   Clients and servers SHOULD NOT assume that a persistent connection is\n   maintained for HTTP versions less than 1.1 unless it is explicitly\n   signaled. See section 19.6.2 for more information on backward\n   compatibility with HTTP/1.0 clients.\n\n   In order to remain persistent, all messages on the connection MUST\n   have a self-defined message length (i.e., one not defined by closure\n   of the connection), as described in section 4.4.\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 45]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.1.2.2 Pipelining\n\n   A client that supports persistent connections MAY \"pipeline\" its\n   requests (i.e., send multiple requests without waiting for each\n   response). A server MUST send its responses to those requests in the\n   same order that the requests were received.\n\n   Clients which assume persistent connections and pipeline immediately\n   after connection establishment SHOULD be prepared to retry their\n   connection if the first pipelined attempt fails. If a client does\n   such a retry, it MUST NOT pipeline before it knows the connection is\n   persistent. Clients MUST also be prepared to resend their requests if\n   the server closes the connection before sending all of the\n   corresponding responses.\n\n   Clients SHOULD NOT pipeline requests using non-idempotent methods or\n   non-idempotent sequences of methods (see section 9.1.2). Otherwise, a\n   premature termination of the transport connection could lead to\n   indeterminate results. A client wishing to send a non-idempotent\n   request SHOULD wait to send that request until it has received the\n   response status for the previous request.\n\n8.1.3 Proxy Servers\n\n   It is especially important that proxies correctly implement the\n   properties of the Connection header field as specified in section\n   14.10.\n\n   The proxy server MUST signal persistent connections separately with\n   its clients and the origin servers (or other proxy servers) that it\n   connects to. Each persistent connection applies to only one transport\n   link.\n\n   A proxy server MUST NOT establish a HTTP/1.1 persistent connection\n   with an HTTP/1.0 client (but see RFC 2068 [33] for information and\n   discussion of the problems with the Keep-Alive header implemented by\n   many HTTP/1.0 clients).\n\n8.1.4 Practical Considerations"
      },
      {
        "chunk_id": "rfc_http_chunk_32",
        "original_index": 32,
        "content": "8.1.4 Practical Considerations\n\n   Servers will usually have some time-out value beyond which they will\n   no longer maintain an inactive connection. Proxy servers might make\n   this a higher value since it is likely that the client will be making\n   more connections through the same server. The use of persistent\n   connections places no requirements on the length (or existence) of\n   this time-out for either the client or the server.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 46]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   When a client or server wishes to time-out it SHOULD issue a graceful\n   close on the transport connection. Clients and servers SHOULD both\n   constantly watch for the other side of the transport close, and\n   respond to it as appropriate. If a client or server does not detect\n   the other side's close promptly it could cause unnecessary resource\n   drain on the network.\n\n   A client, server, or proxy MAY close the transport connection at any\n   time. For example, a client might have started to send a new request\n   at the same time that the server has decided to close the \"idle\"\n   connection. From the server's point of view, the connection is being\n   closed while it was idle, but from the client's point of view, a\n   request is in progress.\n\n   This means that clients, servers, and proxies MUST be able to recover\n   from asynchronous close events. Client software SHOULD reopen the\n   transport connection and retransmit the aborted sequence of requests\n   without user interaction so long as the request sequence is\n   idempotent (see section 9.1.2). Non-idempotent methods or sequences\n   MUST NOT be automatically retried, although user agents MAY offer a\n   human operator the choice of retrying the request(s). Confirmation by\n   user-agent software with semantic understanding of the application\n   MAY substitute for user confirmation. The automatic retry SHOULD NOT\n   be repeated if the second sequence of requests fails.\n\n   Servers SHOULD always respond to at least one request per connection,\n   if at all possible. Servers SHOULD NOT close a connection in the\n   middle of transmitting a response, unless a network or client failure\n   is suspected.\n\n   Clients that use persistent connections SHOULD limit the number of\n   simultaneous connections that they maintain to a given server. A\n   single-user client SHOULD NOT maintain more than 2 connections with\n   any server or proxy. A proxy SHOULD use up to 2*N connections to\n   another server or proxy, where N is the number of simultaneously\n   active users. These guidelines are intended to improve HTTP response\n   times and avoid congestion.\n\n8.2 Message Transmission Requirements\n\n8.2.1 Persistent Connections and Flow Control\n\n   HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's\n   flow control mechanisms to resolve temporary overloads, rather than\n   terminating connections with the expectation that clients will retry.\n   The latter technique can exacerbate network congestion.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 47]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.2.2 Monitoring Connections for Error Status Messages\n\n   An HTTP/1.1 (or later) client sending a message-body SHOULD monitor\n   the network connection for an error status while it is transmitting\n   the request. If the client sees an error status, it SHOULD\n   immediately cease transmitting the body. If the body is being sent\n   using a \"chunked\" encoding (section 3.6), a zero length chunk and\n   empty trailer MAY be used to prematurely mark the end of the message.\n   If the body was preceded by a Content-Length header, the client MUST\n   close the connection.\n\n8.2.3 Use of the 100 (Continue) Status"
      },
      {
        "chunk_id": "rfc_http_chunk_33",
        "original_index": 33,
        "content": "8.2.3 Use of the 100 (Continue) Status\n\n   The purpose of the 100 (Continue) status (see section 10.1.1) is to\n   allow a client that is sending a request message with a request body\n   to determine if the origin server is willing to accept the request\n   (based on the request headers) before the client sends the request\n   body. In some cases, it might either be inappropriate or highly\n   inefficient for the client to send the body if the server will reject\n   the message without looking at the body.\n\n   Requirements for HTTP/1.1 clients:\n\n      - If a client will wait for a 100 (Continue) response before\n        sending the request body, it MUST send an Expect request-header\n        field (section 14.20) with the \"100-continue\" expectation.\n\n      - A client MUST NOT send an Expect request-header field (section\n        14.20) with the \"100-continue\" expectation if it does not intend\n        to send a request body.\n\n   Because of the presence of older implementations, the protocol allows\n   ambiguous situations in which a client may send \"Expect: 100-\n   continue\" without receiving either a 417 (Expectation Failed) status\n   or a 100 (Continue) status. Therefore, when a client sends this\n   header field to an origin server (possibly via a proxy) from which it\n   has never seen a 100 (Continue) status, the client SHOULD NOT wait\n   for an indefinite period before sending the request body.\n\n   Requirements for HTTP/1.1 origin servers:\n\n      - Upon receiving a request which includes an Expect request-header\n        field with the \"100-continue\" expectation, an origin server MUST\n        either respond with 100 (Continue) status and continue to read\n        from the input stream, or respond with a final status code. The\n        origin server MUST NOT wait for the request body before sending\n        the 100 (Continue) response. If it responds with a final status\n        code, it MAY close the transport connection or it MAY continue\n\n\n\nFielding, et al.            Standards Track                    [Page 48]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n        to read and discard the rest of the request.  It MUST NOT\n        perform the requested method if it returns a final status code.\n\n      - An origin server SHOULD NOT send a 100 (Continue) response if\n        the request message does not include an Expect request-header\n        field with the \"100-continue\" expectation, and MUST NOT send a\n        100 (Continue) response if such a request comes from an HTTP/1.0\n        (or earlier) client. There is an exception to this rule: for\n        compatibility with RFC 2068, a server MAY send a 100 (Continue)\n        status in response to an HTTP/1.1 PUT or POST request that does\n        not include an Expect request-header field with the \"100-\n        continue\" expectation. This exception, the purpose of which is\n        to minimize any client processing delays associated with an\n        undeclared wait for 100 (Continue) status, applies only to\n        HTTP/1.1 requests, and not to requests with any other HTTP-\n        version value.\n\n      - An origin server MAY omit a 100 (Continue) response if it has\n        already received some or all of the request body for the\n        corresponding request.\n\n      - An origin server that sends a 100 (Continue) response MUST\n        ultimately send a final status code, once the request body is\n        received and processed, unless it terminates the transport\n        connection prematurely."
      },
      {
        "chunk_id": "rfc_http_chunk_34",
        "original_index": 34,
        "content": "- If an origin server receives a request that does not include an\n        Expect request-header field with the \"100-continue\" expectation,\n        the request includes a request body, and the server responds\n        with a final status code before reading the entire request body\n        from the transport connection, then the server SHOULD NOT close\n        the transport connection until it has read the entire request,\n        or until the client closes the connection. Otherwise, the client\n        might not reliably receive the response message. However, this\n        requirement is not be construed as preventing a server from\n        defending itself against denial-of-service attacks, or from\n        badly broken client implementations.\n\n   Requirements for HTTP/1.1 proxies:\n\n      - If a proxy receives a request that includes an Expect request-\n        header field with the \"100-continue\" expectation, and the proxy\n        either knows that the next-hop server complies with HTTP/1.1 or\n        higher, or does not know the HTTP version of the next-hop\n        server, it MUST forward the request, including the Expect header\n        field.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 49]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If the proxy knows that the version of the next-hop server is\n        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST\n        respond with a 417 (Expectation Failed) status.\n\n      - Proxies SHOULD maintain a cache recording the HTTP version\n        numbers received from recently-referenced next-hop servers.\n\n      - A proxy MUST NOT forward a 100 (Continue) response if the\n        request message was received from an HTTP/1.0 (or earlier)\n        client and did not include an Expect request-header field with\n        the \"100-continue\" expectation. This requirement overrides the\n        general rule for forwarding of 1xx responses (see section 10.1).\n\n8.2.4 Client Behavior if Server Prematurely Closes Connection\n\n   If an HTTP/1.1 client sends a request which includes a request body,\n   but which does not include an Expect request-header field with the\n   \"100-continue\" expectation, and if the client is not directly\n   connected to an HTTP/1.1 origin server, and if the client sees the\n   connection close before receiving any status from the server, the\n   client SHOULD retry the request.  If the client does retry this\n   request, it MAY use the following \"binary exponential backoff\"\n   algorithm to be assured of obtaining a reliable response:\n\n      1. Initiate a new connection to the server\n\n      2. Transmit the request-headers\n\n      3. Initialize a variable R to the estimated round-trip time to the\n         server (e.g., based on the time it took to establish the\n         connection), or to a constant value of 5 seconds if the round-\n         trip time is not available.\n\n      4. Compute T = R * (2**N), where N is the number of previous\n         retries of this request.\n\n      5. Wait either for an error response from the server, or for T\n         seconds (whichever comes first)\n\n      6. If no error response is received, after T seconds transmit the\n         body of the request.\n\n      7. If client sees that the connection is closed prematurely,\n         repeat from step 1 until the request is accepted, an error\n         response is received, or the user becomes impatient and\n         terminates the retry process.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 50]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If at any point an error status is received, the client\n\n      - SHOULD NOT continue and\n\n      - SHOULD close the connection if it has not completed sending the\n        request message.\n\n9 Method Definitions"
      },
      {
        "chunk_id": "rfc_http_chunk_35",
        "original_index": 35,
        "content": "- SHOULD NOT continue and\n\n      - SHOULD close the connection if it has not completed sending the\n        request message.\n\n9 Method Definitions\n\n   The set of common methods for HTTP/1.1 is defined below. Although\n   this set can be expanded, additional methods cannot be assumed to\n   share the same semantics for separately extended clients and servers.\n\n   The Host request-header field (section 14.23) MUST accompany all\n   HTTP/1.1 requests.\n\n9.1 Safe and Idempotent Methods\n\n9.1.1 Safe Methods\n\n   Implementors should be aware that the software represents the user in\n   their interactions over the Internet, and should be careful to allow\n   the user to be aware of any actions they might take which may have an\n   unexpected significance to themselves or others.\n\n   In particular, the convention has been established that the GET and\n   HEAD methods SHOULD NOT have the significance of taking an action\n   other than retrieval. These methods ought to be considered \"safe\".\n   This allows user agents to represent other methods, such as POST, PUT\n   and DELETE, in a special way, so that the user is made aware of the\n   fact that a possibly unsafe action is being requested.\n\n   Naturally, it is not possible to ensure that the server does not\n   generate side-effects as a result of performing a GET request; in\n   fact, some dynamic resources consider that a feature. The important\n   distinction here is that the user did not request the side-effects,\n   so therefore cannot be held accountable for them.\n\n9.1.2 Idempotent Methods\n\n   Methods can also have the property of \"idempotence\" in that (aside\n   from error or expiration issues) the side-effects of N > 0 identical\n   requests is the same as for a single request. The methods GET, HEAD,\n   PUT and DELETE share this property. Also, the methods OPTIONS and\n   TRACE SHOULD NOT have side effects, and so are inherently idempotent.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 51]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   However, it is possible that a sequence of several requests is non-\n   idempotent, even if all of the methods executed in that sequence are\n   idempotent. (A sequence is idempotent if a single execution of the\n   entire sequence always yields a result that is not changed by a\n   reexecution of all, or part, of that sequence.) For example, a\n   sequence is non-idempotent if its result depends on a value that is\n   later modified in the same sequence.\n\n   A sequence that never has side effects is idempotent, by definition\n   (provided that no concurrent operations are being executed on the\n   same set of resources).\n\n9.2 OPTIONS\n\n   The OPTIONS method represents a request for information about the\n   communication options available on the request/response chain\n   identified by the Request-URI. This method allows the client to\n   determine the options and/or requirements associated with a resource,\n   or the capabilities of a server, without implying a resource action\n   or initiating a resource retrieval.\n\n   Responses to this method are not cacheable.\n\n   If the OPTIONS request includes an entity-body (as indicated by the\n   presence of Content-Length or Transfer-Encoding), then the media type\n   MUST be indicated by a Content-Type field. Although this\n   specification does not define any use for such a body, future\n   extensions to HTTP might use the OPTIONS body to make more detailed\n   queries on the server. A server that does not support such an\n   extension MAY discard the request body."
      },
      {
        "chunk_id": "rfc_http_chunk_36",
        "original_index": 36,
        "content": "If the Request-URI is an asterisk (\"*\"), the OPTIONS request is\n   intended to apply to the server in general rather than to a specific\n   resource. Since a server's communication options typically depend on\n   the resource, the \"*\" request is only useful as a \"ping\" or \"no-op\"\n   type of method; it does nothing beyond allowing the client to test\n   the capabilities of the server. For example, this can be used to test\n   a proxy for HTTP/1.1 compliance (or lack thereof).\n\n   If the Request-URI is not an asterisk, the OPTIONS request applies\n   only to the options that are available when communicating with that\n   resource.\n\n   A 200 response SHOULD include any header fields that indicate\n   optional features implemented by the server and applicable to that\n   resource (e.g., Allow), possibly including extensions not defined by\n   this specification. The response body, if any, SHOULD also include\n   information about the communication options. The format for such a\n\n\n\nFielding, et al.            Standards Track                    [Page 52]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   body is not defined by this specification, but might be defined by\n   future extensions to HTTP. Content negotiation MAY be used to select\n   the appropriate response format. If no response body is included, the\n   response MUST include a Content-Length field with a field-value of\n   \"0\".\n\n   The Max-Forwards request-header field MAY be used to target a\n   specific proxy in the request chain. When a proxy receives an OPTIONS\n   request on an absoluteURI for which request forwarding is permitted,\n   the proxy MUST check for a Max-Forwards field. If the Max-Forwards\n   field-value is zero (\"0\"), the proxy MUST NOT forward the message;\n   instead, the proxy SHOULD respond with its own communication options.\n   If the Max-Forwards field-value is an integer greater than zero, the\n   proxy MUST decrement the field-value when it forwards the request. If\n   no Max-Forwards field is present in the request, then the forwarded\n   request MUST NOT include a Max-Forwards field.\n\n9.3 GET\n\n   The GET method means retrieve whatever information (in the form of an\n   entity) is identified by the Request-URI. If the Request-URI refers\n   to a data-producing process, it is the produced data which shall be\n   returned as the entity in the response and not the source text of the\n   process, unless that text happens to be the output of the process.\n\n   The semantics of the GET method change to a \"conditional GET\" if the\n   request message includes an If-Modified-Since, If-Unmodified-Since,\n   If-Match, If-None-Match, or If-Range header field. A conditional GET\n   method requests that the entity be transferred only under the\n   circumstances described by the conditional header field(s). The\n   conditional GET method is intended to reduce unnecessary network\n   usage by allowing cached entities to be refreshed without requiring\n   multiple requests or transferring data already held by the client.\n\n   The semantics of the GET method change to a \"partial GET\" if the\n   request message includes a Range header field. A partial GET requests\n   that only part of the entity be transferred, as described in section\n   14.35. The partial GET method is intended to reduce unnecessary\n   network usage by allowing partially-retrieved entities to be\n   completed without transferring data already held by the client.\n\n   The response to a GET request is cacheable if and only if it meets\n   the requirements for HTTP caching described in section 13.\n\n   See section 15.1.3 for security considerations when used for forms.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 53]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n9.4 HEAD"
      },
      {
        "chunk_id": "rfc_http_chunk_37",
        "original_index": 37,
        "content": "Fielding, et al.            Standards Track                    [Page 53]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n9.4 HEAD\n\n   The HEAD method is identical to GET except that the server MUST NOT\n   return a message-body in the response. The metainformation contained\n   in the HTTP headers in response to a HEAD request SHOULD be identical\n   to the information sent in response to a GET request. This method can\n   be used for obtaining metainformation about the entity implied by the\n   request without transferring the entity-body itself. This method is\n   often used for testing hypertext links for validity, accessibility,\n   and recent modification.\n\n   The response to a HEAD request MAY be cacheable in the sense that the\n   information contained in the response MAY be used to update a\n   previously cached entity from that resource. If the new field values\n   indicate that the cached entity differs from the current entity (as\n   would be indicated by a change in Content-Length, Content-MD5, ETag\n   or Last-Modified), then the cache MUST treat the cache entry as\n   stale.\n\n9.5 POST\n\n   The POST method is used to request that the origin server accept the\n   entity enclosed in the request as a new subordinate of the resource\n   identified by the Request-URI in the Request-Line. POST is designed\n   to allow a uniform method to cover the following functions:\n\n      - Annotation of existing resources;\n\n      - Posting a message to a bulletin board, newsgroup, mailing list,\n        or similar group of articles;\n\n      - Providing a block of data, such as the result of submitting a\n        form, to a data-handling process;\n\n      - Extending a database through an append operation.\n\n   The actual function performed by the POST method is determined by the\n   server and is usually dependent on the Request-URI. The posted entity\n   is subordinate to that URI in the same way that a file is subordinate\n   to a directory containing it, a news article is subordinate to a\n   newsgroup to which it is posted, or a record is subordinate to a\n   database.\n\n   The action performed by the POST method might not result in a\n   resource that can be identified by a URI. In this case, either 200\n   (OK) or 204 (No Content) is the appropriate response status,\n   depending on whether or not the response includes an entity that\n   describes the result.\n\n\n\nFielding, et al.            Standards Track                    [Page 54]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If a resource has been created on the origin server, the response\n   SHOULD be 201 (Created) and contain an entity which describes the\n   status of the request and refers to the new resource, and a Location\n   header (see section 14.30).\n\n   Responses to this method are not cacheable, unless the response\n   includes appropriate Cache-Control or Expires header fields. However,\n   the 303 (See Other) response can be used to direct the user agent to\n   retrieve a cacheable resource.\n\n   POST requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   See section 15.1.3 for security considerations.\n\n9.6 PUT"
      },
      {
        "chunk_id": "rfc_http_chunk_38",
        "original_index": 38,
        "content": "POST requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   See section 15.1.3 for security considerations.\n\n9.6 PUT\n\n   The PUT method requests that the enclosed entity be stored under the\n   supplied Request-URI. If the Request-URI refers to an already\n   existing resource, the enclosed entity SHOULD be considered as a\n   modified version of the one residing on the origin server. If the\n   Request-URI does not point to an existing resource, and that URI is\n   capable of being defined as a new resource by the requesting user\n   agent, the origin server can create the resource with that URI. If a\n   new resource is created, the origin server MUST inform the user agent\n   via the 201 (Created) response. If an existing resource is modified,\n   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent\n   to indicate successful completion of the request. If the resource\n   could not be created or modified with the Request-URI, an appropriate\n   error response SHOULD be given that reflects the nature of the\n   problem. The recipient of the entity MUST NOT ignore any Content-*\n   (e.g. Content-Range) headers that it does not understand or implement\n   and MUST return a 501 (Not Implemented) response in such cases.\n\n   If the request passes through a cache and the Request-URI identifies\n   one or more currently cached entities, those entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\n   The fundamental difference between the POST and PUT requests is\n   reflected in the different meaning of the Request-URI. The URI in a\n   POST request identifies the resource that will handle the enclosed\n   entity. That resource might be a data-accepting process, a gateway to\n   some other protocol, or a separate entity that accepts annotations.\n   In contrast, the URI in a PUT request identifies the entity enclosed\n   with the request -- the user agent knows what URI is intended and the\n   server MUST NOT attempt to apply the request to some other resource.\n   If the server desires that the request be applied to a different URI,\n\n\n\n\nFielding, et al.            Standards Track                    [Page 55]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   it MUST send a 301 (Moved Permanently) response; the user agent MAY\n   then make its own decision regarding whether or not to redirect the\n   request.\n\n   A single resource MAY be identified by many different URIs. For\n   example, an article might have a URI for identifying \"the current\n   version\" which is separate from the URI identifying each particular\n   version. In this case, a PUT request on a general URI might result in\n   several other URIs being defined by the origin server.\n\n   HTTP/1.1 does not define how a PUT method affects the state of an\n   origin server.\n\n   PUT requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   Unless otherwise specified for a particular entity-header, the\n   entity-headers in the PUT request SHOULD be applied to the resource\n   created or modified by the PUT.\n\n9.7 DELETE\n\n   The DELETE method requests that the origin server delete the resource\n   identified by the Request-URI. This method MAY be overridden by human\n   intervention (or other means) on the origin server. The client cannot\n   be guaranteed that the operation has been carried out, even if the\n   status code returned from the origin server indicates that the action\n   has been completed successfully. However, the server SHOULD NOT\n   indicate success unless, at the time the response is given, it\n   intends to delete the resource or move it to an inaccessible\n   location.\n\n   A successful response SHOULD be 200 (OK) if the response includes an\n   entity describing the status, 202 (Accepted) if the action has not\n   yet been enacted, or 204 (No Content) if the action has been enacted\n   but the response does not include an entity."
      },
      {
        "chunk_id": "rfc_http_chunk_39",
        "original_index": 39,
        "content": "If the request passes through a cache and the Request-URI identifies\n   one or more currently cached entities, those entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\n9.8 TRACE\n\n   The TRACE method is used to invoke a remote, application-layer loop-\n   back of the request message. The final recipient of the request\n   SHOULD reflect the message received back to the client as the\n   entity-body of a 200 (OK) response. The final recipient is either the\n\n\n\n\nFielding, et al.            Standards Track                    [Page 56]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   origin server or the first proxy or gateway to receive a Max-Forwards\n   value of zero (0) in the request (see section 14.31). A TRACE request\n   MUST NOT include an entity.\n\n   TRACE allows the client to see what is being received at the other\n   end of the request chain and use that data for testing or diagnostic\n   information. The value of the Via header field (section 14.45) is of\n   particular interest, since it acts as a trace of the request chain.\n   Use of the Max-Forwards header field allows the client to limit the\n   length of the request chain, which is useful for testing a chain of\n   proxies forwarding messages in an infinite loop.\n\n   If the request is valid, the response SHOULD contain the entire\n   request message in the entity-body, with a Content-Type of\n   \"message/http\". Responses to this method MUST NOT be cached.\n\n9.9 CONNECT\n\n   This specification reserves the method name CONNECT for use with a\n   proxy that can dynamically switch to being a tunnel (e.g. SSL\n   tunneling [44]).\n\n10 Status Code Definitions\n\n   Each Status-Code is described below, including a description of which\n   method(s) it can follow and any metainformation required in the\n   response.\n\n10.1 Informational 1xx\n\n   This class of status code indicates a provisional response,\n   consisting only of the Status-Line and optional headers, and is\n   terminated by an empty line. There are no required headers for this\n   class of status code. Since HTTP/1.0 did not define any 1xx status\n   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client\n   except under experimental conditions.\n\n   A client MUST be prepared to accept one or more 1xx status responses\n   prior to a regular response, even if the client does not expect a 100\n   (Continue) status message. Unexpected 1xx status responses MAY be\n   ignored by a user agent.\n\n   Proxies MUST forward 1xx responses, unless the connection between the\n   proxy and its client has been closed, or unless the proxy itself\n   requested the generation of the 1xx response. (For example, if a\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 57]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   proxy adds a \"Expect: 100-continue\" field when it forwards a request,\n   then it need not forward the corresponding 100 (Continue)\n   response(s).)\n\n10.1.1 100 Continue\n\n   The client SHOULD continue with its request. This interim response is\n   used to inform the client that the initial part of the request has\n   been received and has not yet been rejected by the server. The client\n   SHOULD continue by sending the remainder of the request or, if the\n   request has already been completed, ignore this response. The server\n   MUST send a final response after the request has been completed. See\n   section 8.2.3 for detailed discussion of the use and handling of this\n   status code.\n\n10.1.2 101 Switching Protocols\n\n   The server understands and is willing to comply with the client's\n   request, via the Upgrade message header field (section 14.42), for a\n   change in the application protocol being used on this connection. The\n   server will switch protocols to those defined by the response's\n   Upgrade header field immediately after the empty line which\n   terminates the 101 response."
      },
      {
        "chunk_id": "rfc_http_chunk_40",
        "original_index": 40,
        "content": "The protocol SHOULD be switched only when it is advantageous to do\n   so. For example, switching to a newer version of HTTP is advantageous\n   over older versions, and switching to a real-time, synchronous\n   protocol might be advantageous when delivering resources that use\n   such features.\n\n10.2 Successful 2xx\n\n   This class of status code indicates that the client's request was\n   successfully received, understood, and accepted.\n\n10.2.1 200 OK\n\n   The request has succeeded. The information returned with the response\n   is dependent on the method used in the request, for example:\n\n   GET    an entity corresponding to the requested resource is sent in\n          the response;\n\n   HEAD   the entity-header fields corresponding to the requested\n          resource are sent in the response without any message-body;\n\n   POST   an entity describing or containing the result of the action;\n\n\n\n\nFielding, et al.            Standards Track                    [Page 58]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   TRACE  an entity containing the request message as received by the\n          end server.\n\n10.2.2 201 Created\n\n   The request has been fulfilled and resulted in a new resource being\n   created. The newly created resource can be referenced by the URI(s)\n   returned in the entity of the response, with the most specific URI\n   for the resource given by a Location header field. The response\n   SHOULD include an entity containing a list of resource\n   characteristics and location(s) from which the user or user agent can\n   choose the one most appropriate. The entity format is specified by\n   the media type given in the Content-Type header field. The origin\n   server MUST create the resource before returning the 201 status code.\n   If the action cannot be carried out immediately, the server SHOULD\n   respond with 202 (Accepted) response instead.\n\n   A 201 response MAY contain an ETag response header field indicating\n   the current value of the entity tag for the requested variant just\n   created, see section 14.19.\n\n10.2.3 202 Accepted\n\n   The request has been accepted for processing, but the processing has\n   not been completed.  The request might or might not eventually be\n   acted upon, as it might be disallowed when processing actually takes\n   place. There is no facility for re-sending a status code from an\n   asynchronous operation such as this.\n\n   The 202 response is intentionally non-committal. Its purpose is to\n   allow a server to accept a request for some other process (perhaps a\n   batch-oriented process that is only run once per day) without\n   requiring that the user agent's connection to the server persist\n   until the process is completed. The entity returned with this\n   response SHOULD include an indication of the request's current status\n   and either a pointer to a status monitor or some estimate of when the\n   user can expect the request to be fulfilled.\n\n10.2.4 203 Non-Authoritative Information\n\n   The returned metainformation in the entity-header is not the\n   definitive set as available from the origin server, but is gathered\n   from a local or a third-party copy. The set presented MAY be a subset\n   or superset of the original version. For example, including local\n   annotation information about the resource might result in a superset\n   of the metainformation known by the origin server. Use of this\n   response code is not required and is only appropriate when the\n   response would otherwise be 200 (OK).\n\n\n\nFielding, et al.            Standards Track                    [Page 59]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.2.5 204 No Content\n\n   The server has fulfilled the request but does not need to return an\n   entity-body, and might want to return updated metainformation. The\n   response MAY include new or updated metainformation in the form of\n   entity-headers, which if present SHOULD be associated with the\n   requested variant."
      },
      {
        "chunk_id": "rfc_http_chunk_41",
        "original_index": 41,
        "content": "If the client is a user agent, it SHOULD NOT change its document view\n   from that which caused the request to be sent. This response is\n   primarily intended to allow input for actions to take place without\n   causing a change to the user agent's active document view, although\n   any new or updated metainformation SHOULD be applied to the document\n   currently in the user agent's active view.\n\n   The 204 response MUST NOT include a message-body, and thus is always\n   terminated by the first empty line after the header fields.\n\n10.2.6 205 Reset Content\n\n   The server has fulfilled the request and the user agent SHOULD reset\n   the document view which caused the request to be sent. This response\n   is primarily intended to allow input for actions to take place via\n   user input, followed by a clearing of the form in which the input is\n   given so that the user can easily initiate another input action. The\n   response MUST NOT include an entity.\n\n10.2.7 206 Partial Content\n\n   The server has fulfilled the partial GET request for the resource.\n   The request MUST have included a Range header field (section 14.35)\n   indicating the desired range, and MAY have included an If-Range\n   header field (section 14.27) to make the request conditional.\n\n   The response MUST include the following header fields:\n\n      - Either a Content-Range header field (section 14.16) indicating\n        the range included with this response, or a multipart/byteranges\n        Content-Type including Content-Range fields for each part. If a\n        Content-Length header field is present in the response, its\n        value MUST match the actual number of OCTETs transmitted in the\n        message-body.\n\n      - Date\n\n      - ETag and/or Content-Location, if the header would have been sent\n        in a 200 response to the same request\n\n\n\n\nFielding, et al.            Standards Track                    [Page 60]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - Expires, Cache-Control, and/or Vary, if the field-value might\n        differ from that sent in any previous response for the same\n        variant\n\n   If the 206 response is the result of an If-Range request that used a\n   strong cache validator (see section 13.3.3), the response SHOULD NOT\n   include other entity-headers. If the response is the result of an\n   If-Range request that used a weak validator, the response MUST NOT\n   include other entity-headers; this prevents inconsistencies between\n   cached entity-bodies and updated headers. Otherwise, the response\n   MUST include all of the entity-headers that would have been returned\n   with a 200 (OK) response to the same request.\n\n   A cache MUST NOT combine a 206 response with other previously cached\n   content if the ETag or Last-Modified headers do not match exactly,\n   see 13.5.4.\n\n   A cache that does not support the Range and Content-Range headers\n   MUST NOT cache 206 (Partial) responses.\n\n10.3 Redirection 3xx\n\n   This class of status code indicates that further action needs to be\n   taken by the user agent in order to fulfill the request.  The action\n   required MAY be carried out by the user agent without interaction\n   with the user if and only if the method used in the second request is\n   GET or HEAD. A client SHOULD detect infinite redirection loops, since\n   such loops generate network traffic for each redirection.\n\n      Note: previous versions of this specification recommended a\n      maximum of five redirections. Content developers should be aware\n      that there might be clients that implement such a fixed\n      limitation.\n\n10.3.1 300 Multiple Choices\n\n   The requested resource corresponds to any one of a set of\n   representations, each with its own specific location, and agent-\n   driven negotiation information (section 12) is being provided so that\n   the user (or user agent) can select a preferred representation and\n   redirect its request to that location."
      },
      {
        "chunk_id": "rfc_http_chunk_42",
        "original_index": 42,
        "content": "Unless it was a HEAD request, the response SHOULD include an entity\n   containing a list of resource characteristics and location(s) from\n   which the user or user agent can choose the one most appropriate. The\n   entity format is specified by the media type given in the Content-\n   Type header field. Depending upon the format and the capabilities of\n\n\n\n\nFielding, et al.            Standards Track                    [Page 61]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the user agent, selection of the most appropriate choice MAY be\n   performed automatically. However, this specification does not define\n   any standard for such automatic selection.\n\n   If the server has a preferred choice of representation, it SHOULD\n   include the specific URI for that representation in the Location\n   field; user agents MAY use the Location field value for automatic\n   redirection. This response is cacheable unless indicated otherwise.\n\n10.3.2 301 Moved Permanently\n\n   The requested resource has been assigned a new permanent URI and any\n   future references to this resource SHOULD use one of the returned\n   URIs.  Clients with link editing capabilities ought to automatically\n   re-link references to the Request-URI to one or more of the new\n   references returned by the server, where possible. This response is\n   cacheable unless indicated otherwise.\n\n   The new permanent URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n   If the 301 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n      Note: When automatically redirecting a POST request after\n      receiving a 301 status code, some existing HTTP/1.0 user agents\n      will erroneously change it into a GET request.\n\n10.3.3 302 Found\n\n   The requested resource resides temporarily under a different URI.\n   Since the redirection might be altered on occasion, the client SHOULD\n   continue to use the Request-URI for future requests.  This response\n   is only cacheable if indicated by a Cache-Control or Expires header\n   field.\n\n   The temporary URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 62]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the 302 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n      Note: RFC 1945 and RFC 2068 specify that the client is not allowed\n      to change the method on the redirected request.  However, most\n      existing user agent implementations treat 302 as if it were a 303\n      response, performing a GET on the Location field-value regardless\n      of the original request method. The status codes 303 and 307 have\n      been added for servers that wish to make unambiguously clear which\n      kind of reaction is expected of the client.\n\n10.3.4 303 See Other"
      },
      {
        "chunk_id": "rfc_http_chunk_43",
        "original_index": 43,
        "content": "10.3.4 303 See Other\n\n   The response to the request can be found under a different URI and\n   SHOULD be retrieved using a GET method on that resource. This method\n   exists primarily to allow the output of a POST-activated script to\n   redirect the user agent to a selected resource. The new URI is not a\n   substitute reference for the originally requested resource. The 303\n   response MUST NOT be cached, but the response to the second\n   (redirected) request might be cacheable.\n\n   The different URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n      Note: Many pre-HTTP/1.1 user agents do not understand the 303\n      status. When interoperability with such clients is a concern, the\n      302 status code may be used instead, since most user agents react\n      to a 302 response as described here for 303.\n\n10.3.5 304 Not Modified\n\n   If the client has performed a conditional GET request and access is\n   allowed, but the document has not been modified, the server SHOULD\n   respond with this status code. The 304 response MUST NOT contain a\n   message-body, and thus is always terminated by the first empty line\n   after the header fields.\n\n   The response MUST include the following header fields:\n\n      - Date, unless its omission is required by section 14.18.1\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 63]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If a clockless origin server obeys these rules, and proxies and\n   clients add their own Date to any response received without one (as\n   already specified by [RFC 2068], section 14.19), caches will operate\n   correctly.\n\n      - ETag and/or Content-Location, if the header would have been sent\n        in a 200 response to the same request\n\n      - Expires, Cache-Control, and/or Vary, if the field-value might\n        differ from that sent in any previous response for the same\n        variant\n\n   If the conditional GET used a strong cache validator (see section\n   13.3.3), the response SHOULD NOT include other entity-headers.\n   Otherwise (i.e., the conditional GET used a weak validator), the\n   response MUST NOT include other entity-headers; this prevents\n   inconsistencies between cached entity-bodies and updated headers.\n\n   If a 304 response indicates an entity not currently cached, then the\n   cache MUST disregard the response and repeat the request without the\n   conditional.\n\n   If a cache uses a received 304 response to update a cache entry, the\n   cache MUST update the entry to reflect any new field values given in\n   the response.\n\n10.3.6 305 Use Proxy\n\n   The requested resource MUST be accessed through the proxy given by\n   the Location field. The Location field gives the URI of the proxy.\n   The recipient is expected to repeat this single request via the\n   proxy. 305 responses MUST only be generated by origin servers.\n\n      Note: RFC 2068 was not clear that 305 was intended to redirect a\n      single request, and to be generated by origin servers only.  Not\n      observing these limitations has significant security consequences.\n\n10.3.7 306 (Unused)\n\n   The 306 status code was used in a previous version of the\n   specification, is no longer used, and the code is reserved.\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 64]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.3.8 307 Temporary Redirect\n\n   The requested resource resides temporarily under a different URI.\n   Since the redirection MAY be altered on occasion, the client SHOULD\n   continue to use the Request-URI for future requests.  This response\n   is only cacheable if indicated by a Cache-Control or Expires header\n   field."
      },
      {
        "chunk_id": "rfc_http_chunk_44",
        "original_index": 44,
        "content": "The temporary URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s) , since many pre-HTTP/1.1 user agents do not\n   understand the 307 status. Therefore, the note SHOULD contain the\n   information necessary for a user to repeat the original request on\n   the new URI.\n\n   If the 307 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n10.4 Client Error 4xx\n\n   The 4xx class of status code is intended for cases in which the\n   client seems to have erred. Except when responding to a HEAD request,\n   the server SHOULD include an entity containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n   condition. These status codes are applicable to any request method.\n   User agents SHOULD display any included entity to the user.\n\n   If the client is sending data, a server implementation using TCP\n   SHOULD be careful to ensure that the client acknowledges receipt of\n   the packet(s) containing the response, before the server closes the\n   input connection. If the client continues sending data to the server\n   after the close, the server's TCP stack will send a reset packet to\n   the client, which may erase the client's unacknowledged input buffers\n   before they can be read and interpreted by the HTTP application.\n\n10.4.1 400 Bad Request\n\n   The request could not be understood by the server due to malformed\n   syntax. The client SHOULD NOT repeat the request without\n   modifications.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 65]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.2 401 Unauthorized\n\n   The request requires user authentication. The response MUST include a\n   WWW-Authenticate header field (section 14.47) containing a challenge\n   applicable to the requested resource. The client MAY repeat the\n   request with a suitable Authorization header field (section 14.8). If\n   the request already included Authorization credentials, then the 401\n   response indicates that authorization has been refused for those\n   credentials. If the 401 response contains the same challenge as the\n   prior response, and the user agent has already attempted\n   authentication at least once, then the user SHOULD be presented the\n   entity that was given in the response, since that entity might\n   include relevant diagnostic information. HTTP access authentication\n   is explained in \"HTTP Authentication: Basic and Digest Access\n   Authentication\" [43].\n\n10.4.3 402 Payment Required\n\n   This code is reserved for future use.\n\n10.4.4 403 Forbidden\n\n   The server understood the request, but is refusing to fulfill it.\n   Authorization will not help and the request SHOULD NOT be repeated.\n   If the request method was not HEAD and the server wishes to make\n   public why the request has not been fulfilled, it SHOULD describe the\n   reason for the refusal in the entity.  If the server does not wish to\n   make this information available to the client, the status code 404\n   (Not Found) can be used instead.\n\n10.4.5 404 Not Found\n\n   The server has not found anything matching the Request-URI. No\n   indication is given of whether the condition is temporary or\n   permanent. The 410 (Gone) status code SHOULD be used if the server\n   knows, through some internally configurable mechanism, that an old\n   resource is permanently unavailable and has no forwarding address.\n   This status code is commonly used when the server does not wish to\n   reveal exactly why the request has been refused, or when no other\n   response is applicable.\n\n10.4.6 405 Method Not Allowed"
      },
      {
        "chunk_id": "rfc_http_chunk_45",
        "original_index": 45,
        "content": "10.4.6 405 Method Not Allowed\n\n   The method specified in the Request-Line is not allowed for the\n   resource identified by the Request-URI. The response MUST include an\n   Allow header containing a list of valid methods for the requested\n   resource.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 66]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.7 406 Not Acceptable\n\n   The resource identified by the request is only capable of generating\n   response entities which have content characteristics not acceptable\n   according to the accept headers sent in the request.\n\n   Unless it was a HEAD request, the response SHOULD include an entity\n   containing a list of available entity characteristics and location(s)\n   from which the user or user agent can choose the one most\n   appropriate. The entity format is specified by the media type given\n   in the Content-Type header field. Depending upon the format and the\n   capabilities of the user agent, selection of the most appropriate\n   choice MAY be performed automatically. However, this specification\n   does not define any standard for such automatic selection.\n\n      Note: HTTP/1.1 servers are allowed to return responses which are\n      not acceptable according to the accept headers sent in the\n      request. In some cases, this may even be preferable to sending a\n      406 response. User agents are encouraged to inspect the headers of\n      an incoming response to determine if it is acceptable.\n\n   If the response could be unacceptable, a user agent SHOULD\n   temporarily stop receipt of more data and query the user for a\n   decision on further actions.\n\n10.4.8 407 Proxy Authentication Required\n\n   This code is similar to 401 (Unauthorized), but indicates that the\n   client must first authenticate itself with the proxy. The proxy MUST\n   return a Proxy-Authenticate header field (section 14.33) containing a\n   challenge applicable to the proxy for the requested resource. The\n   client MAY repeat the request with a suitable Proxy-Authorization\n   header field (section 14.34). HTTP access authentication is explained\n   in \"HTTP Authentication: Basic and Digest Access Authentication\"\n   [43].\n\n10.4.9 408 Request Timeout\n\n   The client did not produce a request within the time that the server\n   was prepared to wait. The client MAY repeat the request without\n   modifications at any later time.\n\n10.4.10 409 Conflict\n\n   The request could not be completed due to a conflict with the current\n   state of the resource. This code is only allowed in situations where\n   it is expected that the user might be able to resolve the conflict\n   and resubmit the request. The response body SHOULD include enough\n\n\n\nFielding, et al.            Standards Track                    [Page 67]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   information for the user to recognize the source of the conflict.\n   Ideally, the response entity would include enough information for the\n   user or user agent to fix the problem; however, that might not be\n   possible and is not required.\n\n   Conflicts are most likely to occur in response to a PUT request. For\n   example, if versioning were being used and the entity being PUT\n   included changes to a resource which conflict with those made by an\n   earlier (third-party) request, the server might use the 409 response\n   to indicate that it can't complete the request. In this case, the\n   response entity would likely contain a list of the differences\n   between the two versions in a format defined by the response\n   Content-Type.\n\n10.4.11 410 Gone"
      },
      {
        "chunk_id": "rfc_http_chunk_46",
        "original_index": 46,
        "content": "10.4.11 410 Gone\n\n   The requested resource is no longer available at the server and no\n   forwarding address is known. This condition is expected to be\n   considered permanent. Clients with link editing capabilities SHOULD\n   delete references to the Request-URI after user approval. If the\n   server does not know, or has no facility to determine, whether or not\n   the condition is permanent, the status code 404 (Not Found) SHOULD be\n   used instead. This response is cacheable unless indicated otherwise.\n\n   The 410 response is primarily intended to assist the task of web\n   maintenance by notifying the recipient that the resource is\n   intentionally unavailable and that the server owners desire that\n   remote links to that resource be removed. Such an event is common for\n   limited-time, promotional services and for resources belonging to\n   individuals no longer working at the server's site. It is not\n   necessary to mark all permanently unavailable resources as \"gone\" or\n   to keep the mark for any length of time -- that is left to the\n   discretion of the server owner.\n\n10.4.12 411 Length Required\n\n   The server refuses to accept the request without a defined Content-\n   Length. The client MAY repeat the request if it adds a valid\n   Content-Length header field containing the length of the message-body\n   in the request message.\n\n10.4.13 412 Precondition Failed\n\n   The precondition given in one or more of the request-header fields\n   evaluated to false when it was tested on the server. This response\n   code allows the client to place preconditions on the current resource\n   metainformation (header field data) and thus prevent the requested\n   method from being applied to a resource other than the one intended.\n\n\n\nFielding, et al.            Standards Track                    [Page 68]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.14 413 Request Entity Too Large\n\n   The server is refusing to process a request because the request\n   entity is larger than the server is willing or able to process. The\n   server MAY close the connection to prevent the client from continuing\n   the request.\n\n   If the condition is temporary, the server SHOULD include a Retry-\n   After header field to indicate that it is temporary and after what\n   time the client MAY try again.\n\n10.4.15 414 Request-URI Too Long\n\n   The server is refusing to service the request because the Request-URI\n   is longer than the server is willing to interpret. This rare\n   condition is only likely to occur when a client has improperly\n   converted a POST request to a GET request with long query\n   information, when the client has descended into a URI \"black hole\" of\n   redirection (e.g., a redirected URI prefix that points to a suffix of\n   itself), or when the server is under attack by a client attempting to\n   exploit security holes present in some servers using fixed-length\n   buffers for reading or manipulating the Request-URI.\n\n10.4.16 415 Unsupported Media Type\n\n   The server is refusing to service the request because the entity of\n   the request is in a format not supported by the requested resource\n   for the requested method.\n\n10.4.17 416 Requested Range Not Satisfiable\n\n   A server SHOULD return a response with this status code if a request\n   included a Range request-header field (section 14.35), and none of\n   the range-specifier values in this field overlap the current extent\n   of the selected resource, and the request did not include an If-Range\n   request-header field. (For byte-ranges, this means that the first-\n   byte-pos of all of the byte-range-spec values were greater than the\n   current length of the selected resource.)\n\n   When this status code is returned for a byte-range request, the\n   response SHOULD include a Content-Range entity-header field\n   specifying the current length of the selected resource (see section\n   14.16). This response MUST NOT use the multipart/byteranges content-\n   type."
      },
      {
        "chunk_id": "rfc_http_chunk_47",
        "original_index": 47,
        "content": "Fielding, et al.            Standards Track                    [Page 69]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.18 417 Expectation Failed\n\n   The expectation given in an Expect request-header field (see section\n   14.20) could not be met by this server, or, if the server is a proxy,\n   the server has unambiguous evidence that the request could not be met\n   by the next-hop server.\n\n10.5 Server Error 5xx\n\n   Response status codes beginning with the digit \"5\" indicate cases in\n   which the server is aware that it has erred or is incapable of\n   performing the request. Except when responding to a HEAD request, the\n   server SHOULD include an entity containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n   condition. User agents SHOULD display any included entity to the\n   user. These response codes are applicable to any request method.\n\n10.5.1 500 Internal Server Error\n\n   The server encountered an unexpected condition which prevented it\n   from fulfilling the request.\n\n10.5.2 501 Not Implemented\n\n   The server does not support the functionality required to fulfill the\n   request. This is the appropriate response when the server does not\n   recognize the request method and is not capable of supporting it for\n   any resource.\n\n10.5.3 502 Bad Gateway\n\n   The server, while acting as a gateway or proxy, received an invalid\n   response from the upstream server it accessed in attempting to\n   fulfill the request.\n\n10.5.4 503 Service Unavailable\n\n   The server is currently unable to handle the request due to a\n   temporary overloading or maintenance of the server. The implication\n   is that this is a temporary condition which will be alleviated after\n   some delay. If known, the length of the delay MAY be indicated in a\n   Retry-After header. If no Retry-After is given, the client SHOULD\n   handle the response as it would for a 500 response.\n\n      Note: The existence of the 503 status code does not imply that a\n      server must use it when becoming overloaded. Some servers may wish\n      to simply refuse the connection.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 70]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.5.5 504 Gateway Timeout\n\n   The server, while acting as a gateway or proxy, did not receive a\n   timely response from the upstream server specified by the URI (e.g.\n   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed\n   to access in attempting to complete the request.\n\n      Note: Note to implementors: some deployed proxies are known to\n      return 400 or 500 when DNS lookups time out.\n\n10.5.6 505 HTTP Version Not Supported\n\n   The server does not support, or refuses to support, the HTTP protocol\n   version that was used in the request message. The server is\n   indicating that it is unable or unwilling to complete the request\n   using the same major version as the client, as described in section\n   3.1, other than with this error message. The response SHOULD contain\n   an entity describing why that version is not supported and what other\n   protocols are supported by that server.\n\n11 Access Authentication\n\n   HTTP provides several OPTIONAL challenge-response authentication\n   mechanisms which can be used by a server to challenge a client\n   request and by a client to provide authentication information. The\n   general framework for access authentication, and the specification of\n   \"basic\" and \"digest\" authentication, are specified in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. This\n   specification adopts the definitions of \"challenge\" and \"credentials\"\n   from that specification.\n\n12 Content Negotiation"
      },
      {
        "chunk_id": "rfc_http_chunk_48",
        "original_index": 48,
        "content": "12 Content Negotiation\n\n   Most HTTP responses include an entity which contains information for\n   interpretation by a human user. Naturally, it is desirable to supply\n   the user with the \"best available\" entity corresponding to the\n   request. Unfortunately for servers and caches, not all users have the\n   same preferences for what is \"best,\" and not all user agents are\n   equally capable of rendering all entity types. For that reason, HTTP\n   has provisions for several mechanisms for \"content negotiation\" --\n   the process of selecting the best representation for a given response\n   when there are multiple representations available.\n\n      Note: This is not called \"format negotiation\" because the\n      alternate representations may be of the same media type, but use\n      different capabilities of that type, be in different languages,\n      etc.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 71]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Any response containing an entity-body MAY be subject to negotiation,\n   including error responses.\n\n   There are two kinds of content negotiation which are possible in\n   HTTP: server-driven and agent-driven negotiation. These two kinds of\n   negotiation are orthogonal and thus may be used separately or in\n   combination. One method of combination, referred to as transparent\n   negotiation, occurs when a cache uses the agent-driven negotiation\n   information provided by the origin server in order to provide\n   server-driven negotiation for subsequent requests.\n\n12.1 Server-driven Negotiation\n\n   If the selection of the best representation for a response is made by\n   an algorithm located at the server, it is called server-driven\n   negotiation. Selection is based on the available representations of\n   the response (the dimensions over which it can vary; e.g. language,\n   content-coding, etc.) and the contents of particular header fields in\n   the request message or on other information pertaining to the request\n   (such as the network address of the client).\n\n   Server-driven negotiation is advantageous when the algorithm for\n   selecting from among the available representations is difficult to\n   describe to the user agent, or when the server desires to send its\n   \"best guess\" to the client along with the first response (hoping to\n   avoid the round-trip delay of a subsequent request if the \"best\n   guess\" is good enough for the user). In order to improve the server's\n   guess, the user agent MAY include request header fields (Accept,\n   Accept-Language, Accept-Encoding, etc.) which describe its\n   preferences for such a response.\n\n   Server-driven negotiation has disadvantages:\n\n      1. It is impossible for the server to accurately determine what\n         might be \"best\" for any given user, since that would require\n         complete knowledge of both the capabilities of the user agent\n         and the intended use for the response (e.g., does the user want\n         to view it on screen or print it on paper?).\n\n      2. Having the user agent describe its capabilities in every\n         request can be both very inefficient (given that only a small\n         percentage of responses have multiple representations) and a\n         potential violation of the user's privacy.\n\n      3. It complicates the implementation of an origin server and the\n         algorithms for generating responses to a request.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 72]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      4. It may limit a public cache's ability to use the same response\n         for multiple user's requests."
      },
      {
        "chunk_id": "rfc_http_chunk_49",
        "original_index": 49,
        "content": "4. It may limit a public cache's ability to use the same response\n         for multiple user's requests.\n\n   HTTP/1.1 includes the following request-header fields for enabling\n   server-driven negotiation through description of user agent\n   capabilities and user preferences: Accept (section 14.1), Accept-\n   Charset (section 14.2), Accept-Encoding (section 14.3), Accept-\n   Language (section 14.4), and User-Agent (section 14.43). However, an\n   origin server is not limited to these dimensions and MAY vary the\n   response based on any aspect of the request, including information\n   outside the request-header fields or within extension header fields\n   not defined by this specification.\n\n   The Vary  header field can be used to express the parameters the\n   server uses to select a representation that is subject to server-\n   driven negotiation. See section 13.6 for use of the Vary header field\n   by caches and section 14.44 for use of the Vary header field by\n   servers.\n\n12.2 Agent-driven Negotiation\n\n   With agent-driven negotiation, selection of the best representation\n   for a response is performed by the user agent after receiving an\n   initial response from the origin server. Selection is based on a list\n   of the available representations of the response included within the\n   header fields or entity-body of the initial response, with each\n   representation identified by its own URI. Selection from among the\n   representations may be performed automatically (if the user agent is\n   capable of doing so) or manually by the user selecting from a\n   generated (possibly hypertext) menu.\n\n   Agent-driven negotiation is advantageous when the response would vary\n   over commonly-used dimensions (such as type, language, or encoding),\n   when the origin server is unable to determine a user agent's\n   capabilities from examining the request, and generally when public\n   caches are used to distribute server load and reduce network usage.\n\n   Agent-driven negotiation suffers from the disadvantage of needing a\n   second request to obtain the best alternate representation. This\n   second request is only efficient when caching is used. In addition,\n   this specification does not define any mechanism for supporting\n   automatic selection, though it also does not prevent any such\n   mechanism from being developed as an extension and used within\n   HTTP/1.1.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 73]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)\n   status codes for enabling agent-driven negotiation when the server is\n   unwilling or unable to provide a varying response using server-driven\n   negotiation.\n\n12.3 Transparent Negotiation\n\n   Transparent negotiation is a combination of both server-driven and\n   agent-driven negotiation. When a cache is supplied with a form of the\n   list of available representations of the response (as in agent-driven\n   negotiation) and the dimensions of variance are completely understood\n   by the cache, then the cache becomes capable of performing server-\n   driven negotiation on behalf of the origin server for subsequent\n   requests on that resource.\n\n   Transparent negotiation has the advantage of distributing the\n   negotiation work that would otherwise be required of the origin\n   server and also removing the second request delay of agent-driven\n   negotiation when the cache is able to correctly guess the right\n   response.\n\n   This specification does not define any mechanism for transparent\n   negotiation, though it also does not prevent any such mechanism from\n   being developed as an extension that could be used within HTTP/1.1.\n\n13 Caching in HTTP"
      },
      {
        "chunk_id": "rfc_http_chunk_50",
        "original_index": 50,
        "content": "13 Caching in HTTP\n\n   HTTP is typically used for distributed information systems, where\n   performance can be improved by the use of response caches. The\n   HTTP/1.1 protocol includes a number of elements intended to make\n   caching work as well as possible. Because these elements are\n   inextricable from other aspects of the protocol, and because they\n   interact with each other, it is useful to describe the basic caching\n   design of HTTP separately from the detailed descriptions of methods,\n   headers, response codes, etc.\n\n   Caching would be useless if it did not significantly improve\n   performance. The goal of caching in HTTP/1.1 is to eliminate the need\n   to send requests in many cases, and to eliminate the need to send\n   full responses in many other cases. The former reduces the number of\n   network round-trips required for many operations; we use an\n   \"expiration\" mechanism for this purpose (see section 13.2). The\n   latter reduces network bandwidth requirements; we use a \"validation\"\n   mechanism for this purpose (see section 13.3).\n\n   Requirements for performance, availability, and disconnected\n   operation require us to be able to relax the goal of semantic\n   transparency. The HTTP/1.1 protocol allows origin servers, caches,\n\n\n\nFielding, et al.            Standards Track                    [Page 74]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   and clients to explicitly reduce transparency when necessary.\n   However, because non-transparent operation may confuse non-expert\n   users, and might be incompatible with certain server applications\n   (such as those for ordering merchandise), the protocol requires that\n   transparency be relaxed\n\n      - only by an explicit protocol-level request when relaxed by\n        client or origin server\n\n      - only with an explicit warning to the end user when relaxed by\n        cache or client\n\n   Therefore, the HTTP/1.1 protocol provides these important elements:\n\n      1. Protocol features that provide full semantic transparency when\n         this is required by all parties.\n\n      2. Protocol features that allow an origin server or user agent to\n         explicitly request and control non-transparent operation.\n\n      3. Protocol features that allow a cache to attach warnings to\n         responses that do not preserve the requested approximation of\n         semantic transparency.\n\n   A basic principle is that it must be possible for the clients to\n   detect any potential relaxation of semantic transparency.\n\n      Note: The server, cache, or client implementor might be faced with\n      design decisions not explicitly discussed in this specification.\n      If a decision might affect semantic transparency, the implementor\n      ought to err on the side of maintaining transparency unless a\n      careful and complete analysis shows significant benefits in\n      breaking transparency.\n\n13.1.1 Cache Correctness\n\n   A correct cache MUST respond to a request with the most up-to-date\n   response held by the cache that is appropriate to the request (see\n   sections 13.2.5, 13.2.6, and 13.12) which meets one of the following\n   conditions:\n\n      1. It has been checked for equivalence with what the origin server\n         would have returned by revalidating the response with the\n         origin server (section 13.3);\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 75]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      2. It is \"fresh enough\" (see section 13.2). In the default case,\n         this means it meets the least restrictive freshness requirement\n         of the client, origin server, and cache (see section 14.9); if\n         the origin server so specifies, it is the freshness requirement\n         of the origin server alone."
      },
      {
        "chunk_id": "rfc_http_chunk_51",
        "original_index": 51,
        "content": "If a stored response is not \"fresh enough\" by the most\n         restrictive freshness requirement of both the client and the\n         origin server, in carefully considered circumstances the cache\n         MAY still return the response with the appropriate Warning\n         header (see section 13.1.5 and 14.46), unless such a response\n         is prohibited (e.g., by a \"no-store\" cache-directive, or by a\n         \"no-cache\" cache-request-directive; see section 14.9).\n\n      3. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect),\n         or error (4xx or 5xx) response message.\n\n   If the cache can not communicate with the origin server, then a\n   correct cache SHOULD respond as above if the response can be\n   correctly served from the cache; if not it MUST return an error or\n   warning indicating that there was a communication failure.\n\n   If a cache receives a response (either an entire response, or a 304\n   (Not Modified) response) that it would normally forward to the\n   requesting client, and the received response is no longer fresh, the\n   cache SHOULD forward it to the requesting client without adding a new\n   Warning (but without removing any existing Warning headers). A cache\n   SHOULD NOT attempt to revalidate a response simply because that\n   response became stale in transit; this might lead to an infinite\n   loop. A user agent that receives a stale response without a Warning\n   MAY display a warning indication to the user.\n\n13.1.2 Warnings\n\n   Whenever a cache returns a response that is neither first-hand nor\n   \"fresh enough\" (in the sense of condition 2 in section 13.1.1), it\n   MUST attach a warning to that effect, using a Warning general-header.\n   The Warning header and the currently defined warnings are described\n   in section 14.46. The warning allows clients to take appropriate\n   action.\n\n   Warnings MAY be used for other purposes, both cache-related and\n   otherwise. The use of a warning, rather than an error status code,\n   distinguish these responses from true failures.\n\n   Warnings are assigned three digit warn-codes. The first digit\n   indicates whether the Warning MUST or MUST NOT be deleted from a\n   stored cache entry after a successful revalidation:\n\n\n\nFielding, et al.            Standards Track                    [Page 76]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   1xx  Warnings that describe the freshness or revalidation status of\n     the response, and so MUST be deleted after a successful\n     revalidation. 1XX warn-codes MAY be generated by a cache only when\n     validating a cached entry. It MUST NOT be generated by clients.\n\n   2xx  Warnings that describe some aspect of the entity body or entity\n     headers that is not rectified by a revalidation (for example, a\n     lossy compression of the entity bodies) and which MUST NOT be\n     deleted after a successful revalidation.\n\n   See section 14.46 for the definitions of the codes themselves.\n\n   HTTP/1.0 caches will cache all Warnings in responses, without\n   deleting the ones in the first category. Warnings in responses that\n   are passed to HTTP/1.0 caches carry an extra warning-date field,\n   which prevents a future HTTP/1.1 recipient from believing an\n   erroneously cached Warning.\n\n   Warnings also carry a warning text. The text MAY be in any\n   appropriate natural language (perhaps based on the client's Accept\n   headers), and include an OPTIONAL indication of what character set is\n   used.\n\n   Multiple warnings MAY be attached to a response (either by the origin\n   server or by a cache), including multiple warnings with the same code\n   number. For example, a server might provide the same warning with\n   texts in both English and Basque."
      },
      {
        "chunk_id": "rfc_http_chunk_52",
        "original_index": 52,
        "content": "When multiple warnings are attached to a response, it might not be\n   practical or reasonable to display all of them to the user. This\n   version of HTTP does not specify strict priority rules for deciding\n   which warnings to display and in what order, but does suggest some\n   heuristics.\n\n13.1.3 Cache-control Mechanisms\n\n   The basic cache mechanisms in HTTP/1.1 (server-specified expiration\n   times and validators) are implicit directives to caches. In some\n   cases, a server or client might need to provide explicit directives\n   to the HTTP caches. We use the Cache-Control header for this purpose.\n\n   The Cache-Control header allows a client or server to transmit a\n   variety of directives in either requests or responses. These\n   directives typically override the default caching algorithms. As a\n   general rule, if there is any apparent conflict between header\n   values, the most restrictive interpretation is applied (that is, the\n   one that is most likely to preserve semantic transparency). However,\n\n\n\n\nFielding, et al.            Standards Track                    [Page 77]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   in some cases, cache-control directives are explicitly specified as\n   weakening the approximation of semantic transparency (for example,\n   \"max-stale\" or \"public\").\n\n   The cache-control directives are described in detail in section 14.9.\n\n13.1.4 Explicit User Agent Warnings\n\n   Many user agents make it possible for users to override the basic\n   caching mechanisms. For example, the user agent might allow the user\n   to specify that cached entities (even explicitly stale ones) are\n   never validated. Or the user agent might habitually add \"Cache-\n   Control: max-stale=3600\" to every request. The user agent SHOULD NOT\n   default to either non-transparent behavior, or behavior that results\n   in abnormally ineffective caching, but MAY be explicitly configured\n   to do so by an explicit action of the user.\n\n   If the user has overridden the basic caching mechanisms, the user\n   agent SHOULD explicitly indicate to the user whenever this results in\n   the display of information that might not meet the server's\n   transparency requirements (in particular, if the displayed entity is\n   known to be stale). Since the protocol normally allows the user agent\n   to determine if responses are stale or not, this indication need only\n   be displayed when this actually happens. The indication need not be a\n   dialog box; it could be an icon (for example, a picture of a rotting\n   fish) or some other indicator.\n\n   If the user has overridden the caching mechanisms in a way that would\n   abnormally reduce the effectiveness of caches, the user agent SHOULD\n   continually indicate this state to the user (for example, by a\n   display of a picture of currency in flames) so that the user does not\n   inadvertently consume excess resources or suffer from excessive\n   latency.\n\n13.1.5 Exceptions to the Rules and Warnings\n\n   In some cases, the operator of a cache MAY choose to configure it to\n   return stale responses even when not requested by clients. This\n   decision ought not be made lightly, but may be necessary for reasons\n   of availability or performance, especially when the cache is poorly\n   connected to the origin server. Whenever a cache returns a stale\n   response, it MUST mark it as such (using a Warning header) enabling\n   the client software to alert the user that there might be a potential\n   problem.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 78]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   It also allows the user agent to take steps to obtain a first-hand or\n   fresh response. For this reason, a cache SHOULD NOT return a stale\n   response if the client explicitly requests a first-hand or fresh one,\n   unless it is impossible to comply for technical or policy reasons.\n\n13.1.6 Client-controlled Behavior"
      },
      {
        "chunk_id": "rfc_http_chunk_53",
        "original_index": 53,
        "content": "13.1.6 Client-controlled Behavior\n\n   While the origin server (and to a lesser extent, intermediate caches,\n   by their contribution to the age of a response) are the primary\n   source of expiration information, in some cases the client might need\n   to control a cache's decision about whether to return a cached\n   response without validating it. Clients do this using several\n   directives of the Cache-Control header.\n\n   A client's request MAY specify the maximum age it is willing to\n   accept of an unvalidated response; specifying a value of zero forces\n   the cache(s) to revalidate all responses. A client MAY also specify\n   the minimum time remaining before a response expires. Both of these\n   options increase constraints on the behavior of caches, and so cannot\n   further relax the cache's approximation of semantic transparency.\n\n   A client MAY also specify that it will accept stale responses, up to\n   some maximum amount of staleness. This loosens the constraints on the\n   caches, and so might violate the origin server's specified\n   constraints on semantic transparency, but might be necessary to\n   support disconnected operation, or high availability in the face of\n   poor connectivity.\n\n13.2 Expiration Model\n\n13.2.1 Server-Specified Expiration\n\n   HTTP caching works best when caches can entirely avoid making\n   requests to the origin server. The primary mechanism for avoiding\n   requests is for an origin server to provide an explicit expiration\n   time in the future, indicating that a response MAY be used to satisfy\n   subsequent requests. In other words, a cache can return a fresh\n   response without first contacting the server.\n\n   Our expectation is that servers will assign future explicit\n   expiration times to responses in the belief that the entity is not\n   likely to change, in a semantically significant way, before the\n   expiration time is reached. This normally preserves semantic\n   transparency, as long as the server's expiration times are carefully\n   chosen.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 79]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The expiration mechanism applies only to responses taken from a cache\n   and not to first-hand responses forwarded immediately to the\n   requesting client.\n\n   If an origin server wishes to force a semantically transparent cache\n   to validate every request, it MAY assign an explicit expiration time\n   in the past. This means that the response is always stale, and so the\n   cache SHOULD validate it before using it for subsequent requests. See\n   section 14.9.4 for a more restrictive way to force revalidation.\n\n   If an origin server wishes to force any HTTP/1.1 cache, no matter how\n   it is configured, to validate every request, it SHOULD use the \"must-\n   revalidate\" cache-control directive (see section 14.9).\n\n   Servers specify explicit expiration times using either the Expires\n   header, or the max-age directive of the Cache-Control header.\n\n   An expiration time cannot be used to force a user agent to refresh\n   its display or reload a resource; its semantics apply only to caching\n   mechanisms, and such mechanisms need only check a resource's\n   expiration status when a new request for that resource is initiated.\n   See section 13.13 for an explanation of the difference between caches\n   and history mechanisms.\n\n13.2.2 Heuristic Expiration"
      },
      {
        "chunk_id": "rfc_http_chunk_54",
        "original_index": 54,
        "content": "13.2.2 Heuristic Expiration\n\n   Since origin servers do not always provide explicit expiration times,\n   HTTP caches typically assign heuristic expiration times, employing\n   algorithms that use other header values (such as the Last-Modified\n   time) to estimate a plausible expiration time. The HTTP/1.1\n   specification does not provide specific algorithms, but does impose\n   worst-case constraints on their results. Since heuristic expiration\n   times might compromise semantic transparency, they ought to used\n   cautiously, and we encourage origin servers to provide explicit\n   expiration times as much as possible.\n\n13.2.3 Age Calculations\n\n   In order to know if a cached entry is fresh, a cache needs to know if\n   its age exceeds its freshness lifetime. We discuss how to calculate\n   the latter in section 13.2.4; this section describes how to calculate\n   the age of a response or cache entry.\n\n   In this discussion, we use the term \"now\" to mean \"the current value\n   of the clock at the host performing the calculation.\" Hosts that use\n   HTTP, but especially hosts running origin servers and caches, SHOULD\n   use NTP [28] or some similar protocol to synchronize their clocks to\n   a globally accurate time standard.\n\n\n\nFielding, et al.            Standards Track                    [Page 80]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 requires origin servers to send a Date header, if possible,\n   with every response, giving the time at which the response was\n   generated (see section 14.18). We use the term \"date_value\" to denote\n   the value of the Date header, in a form appropriate for arithmetic\n   operations.\n\n   HTTP/1.1 uses the Age response-header to convey the estimated age of\n   the response message when obtained from a cache. The Age field value\n   is the cache's estimate of the amount of time since the response was\n   generated or revalidated by the origin server.\n\n   In essence, the Age value is the sum of the time that the response\n   has been resident in each of the caches along the path from the\n   origin server, plus the amount of time it has been in transit along\n   network paths.\n\n   We use the term \"age_value\" to denote the value of the Age header, in\n   a form appropriate for arithmetic operations.\n\n   A response's age can be calculated in two entirely independent ways:\n\n      1. now minus date_value, if the local clock is reasonably well\n         synchronized to the origin server's clock. If the result is\n         negative, the result is replaced by zero.\n\n      2. age_value, if all of the caches along the response path\n         implement HTTP/1.1.\n\n   Given that we have two independent ways to compute the age of a\n   response when it is received, we can combine these as\n\n       corrected_received_age = max(now - date_value, age_value)\n\n   and as long as we have either nearly synchronized clocks or all-\n   HTTP/1.1 paths, one gets a reliable (conservative) result.\n\n   Because of network-imposed delays, some significant interval might\n   pass between the time that a server generates a response and the time\n   it is received at the next outbound cache or client. If uncorrected,\n   this delay could result in improperly low ages.\n\n   Because the request that resulted in the returned Age value must have\n   been initiated prior to that Age value's generation, we can correct\n   for delays imposed by the network by recording the time at which the\n   request was initiated. Then, when an Age value is received, it MUST\n   be interpreted relative to the time the request was initiated, not\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 81]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the time that the response was received. This algorithm results in\n   conservative behavior no matter how much delay is experienced. So, we\n   compute:"
      },
      {
        "chunk_id": "rfc_http_chunk_55",
        "original_index": 55,
        "content": "the time that the response was received. This algorithm results in\n   conservative behavior no matter how much delay is experienced. So, we\n   compute:\n\n      corrected_initial_age = corrected_received_age\n                            + (now - request_time)\n\n   where \"request_time\" is the time (according to the local clock) when\n   the request that elicited this response was sent.\n\n   Summary of age calculation algorithm, when a cache receives a\n   response:\n\n      /*\n       * age_value\n       *      is the value of Age: header received by the cache with\n       *              this response.\n       * date_value\n       *      is the value of the origin server's Date: header\n       * request_time\n       *      is the (local) time when the cache made the request\n       *              that resulted in this cached response\n       * response_time\n       *      is the (local) time when the cache received the\n       *              response\n       * now\n       *      is the current (local) time\n       */\n\n      apparent_age = max(0, response_time - date_value);\n      corrected_received_age = max(apparent_age, age_value);\n      response_delay = response_time - request_time;\n      corrected_initial_age = corrected_received_age + response_delay;\n      resident_time = now - response_time;\n      current_age   = corrected_initial_age + resident_time;\n\n   The current_age of a cache entry is calculated by adding the amount\n   of time (in seconds) since the cache entry was last validated by the\n   origin server to the corrected_initial_age. When a response is\n   generated from a cache entry, the cache MUST include a single Age\n   header field in the response with a value equal to the cache entry's\n   current_age.\n\n   The presence of an Age header field in a response implies that a\n   response is not first-hand. However, the converse is not true, since\n   the lack of an Age header field in a response does not imply that the\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 82]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   response is first-hand unless all caches along the request path are\n   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement\n   the Age header field).\n\n13.2.4 Expiration Calculations\n\n   In order to decide whether a response is fresh or stale, we need to\n   compare its freshness lifetime to its age. The age is calculated as\n   described in section 13.2.3; this section describes how to calculate\n   the freshness lifetime, and to determine if a response has expired.\n   In the discussion below, the values can be represented in any form\n   appropriate for arithmetic operations.\n\n   We use the term \"expires_value\" to denote the value of the Expires\n   header. We use the term \"max_age_value\" to denote an appropriate\n   value of the number of seconds carried by the \"max-age\" directive of\n   the Cache-Control header in a response (see section 14.9.3).\n\n   The max-age directive takes priority over Expires, so if max-age is\n   present in a response, the calculation is simply:\n\n      freshness_lifetime = max_age_value\n\n   Otherwise, if Expires is present in the response, the calculation is:\n\n      freshness_lifetime = expires_value - date_value\n\n   Note that neither of these calculations is vulnerable to clock skew,\n   since all of the information comes from the origin server.\n\n   If none of Expires, Cache-Control: max-age, or Cache-Control: s-\n   maxage (see section 14.9.3) appears in the response, and the response\n   does not include other restrictions on caching, the cache MAY compute\n   a freshness lifetime using a heuristic. The cache MUST attach Warning\n   113 to any response whose age is more than 24 hours if such warning\n   has not already been added."
      },
      {
        "chunk_id": "rfc_http_chunk_56",
        "original_index": 56,
        "content": "Also, if the response does have a Last-Modified time, the heuristic\n   expiration value SHOULD be no more than some fraction of the interval\n   since that time. A typical setting of this fraction might be 10%.\n\n   The calculation to determine if a response has expired is quite\n   simple:\n\n      response_is_fresh = (freshness_lifetime > current_age)\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 83]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.2.5 Disambiguating Expiration Values\n\n   Because expiration values are assigned optimistically, it is possible\n   for two caches to contain fresh values for the same resource that are\n   different.\n\n   If a client performing a retrieval receives a non-first-hand response\n   for a request that was already fresh in its own cache, and the Date\n   header in its existing cache entry is newer than the Date on the new\n   response, then the client MAY ignore the response. If so, it MAY\n   retry the request with a \"Cache-Control: max-age=0\" directive (see\n   section 14.9), to force a check with the origin server.\n\n   If a cache has two fresh responses for the same representation with\n   different validators, it MUST use the one with the more recent Date\n   header. This situation might arise because the cache is pooling\n   responses from other caches, or because a client has asked for a\n   reload or a revalidation of an apparently fresh cache entry.\n\n13.2.6 Disambiguating Multiple Responses\n\n   Because a client might be receiving responses via multiple paths, so\n   that some responses flow through one set of caches and other\n   responses flow through a different set of caches, a client might\n   receive responses in an order different from that in which the origin\n   server sent them. We would like the client to use the most recently\n   generated response, even if older responses are still apparently\n   fresh.\n\n   Neither the entity tag nor the expiration value can impose an\n   ordering on responses, since it is possible that a later response\n   intentionally carries an earlier expiration time. The Date values are\n   ordered to a granularity of one second.\n\n   When a client tries to revalidate a cache entry, and the response it\n   receives contains a Date header that appears to be older than the one\n   for the existing entry, then the client SHOULD repeat the request\n   unconditionally, and include\n\n       Cache-Control: max-age=0\n\n   to force any intermediate caches to validate their copies directly\n   with the origin server, or\n\n       Cache-Control: no-cache\n\n   to force any intermediate caches to obtain a new copy from the origin\n   server.\n\n\n\nFielding, et al.            Standards Track                    [Page 84]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the Date values are equal, then the client MAY use either response\n   (or MAY, if it is being extremely prudent, request a new response).\n   Servers MUST NOT depend on clients being able to choose\n   deterministically between responses generated during the same second,\n   if their expiration times overlap.\n\n13.3 Validation Model\n\n   When a cache has a stale entry that it would like to use as a\n   response to a client's request, it first has to check with the origin\n   server (or possibly an intermediate cache with a fresh response) to\n   see if its cached entry is still usable. We call this \"validating\"\n   the cache entry. Since we do not want to have to pay the overhead of\n   retransmitting the full response if the cached entry is good, and we\n   do not want to pay the overhead of an extra round trip if the cached\n   entry is invalid, the HTTP/1.1 protocol supports the use of\n   conditional methods."
      },
      {
        "chunk_id": "rfc_http_chunk_57",
        "original_index": 57,
        "content": "The key protocol features for supporting conditional methods are\n   those concerned with \"cache validators.\" When an origin server\n   generates a full response, it attaches some sort of validator to it,\n   which is kept with the cache entry. When a client (user agent or\n   proxy cache) makes a conditional request for a resource for which it\n   has a cache entry, it includes the associated validator in the\n   request.\n\n   The server then checks that validator against the current validator\n   for the entity, and, if they match (see section 13.3.3), it responds\n   with a special status code (usually, 304 (Not Modified)) and no\n   entity-body. Otherwise, it returns a full response (including\n   entity-body). Thus, we avoid transmitting the full response if the\n   validator matches, and we avoid an extra round trip if it does not\n   match.\n\n   In HTTP/1.1, a conditional request looks exactly the same as a normal\n   request for the same resource, except that it carries a special\n   header (which includes the validator) that implicitly turns the\n   method (usually, GET) into a conditional.\n\n   The protocol includes both positive and negative senses of cache-\n   validating conditions. That is, it is possible to request either that\n   a method be performed if and only if a validator matches or if and\n   only if no validators match.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 85]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      Note: a response that lacks a validator may still be cached, and\n      served from cache until it expires, unless this is explicitly\n      prohibited by a cache-control directive. However, a cache cannot\n      do a conditional retrieval if it does not have a validator for the\n      entity, which means it will not be refreshable after it expires.\n\n13.3.1 Last-Modified Dates\n\n   The Last-Modified entity-header field value is often used as a cache\n   validator. In simple terms, a cache entry is considered to be valid\n   if the entity has not been modified since the Last-Modified value.\n\n13.3.2 Entity Tag Cache Validators\n\n   The ETag response-header field value, an entity tag, provides for an\n   \"opaque\" cache validator. This might allow more reliable validation\n   in situations where it is inconvenient to store modification dates,\n   where the one-second resolution of HTTP date values is not\n   sufficient, or where the origin server wishes to avoid certain\n   paradoxes that might arise from the use of modification dates.\n\n   Entity Tags are described in section 3.11. The headers used with\n   entity tags are described in sections 14.19, 14.24, 14.26 and 14.44.\n\n13.3.3 Weak and Strong Validators\n\n   Since both origin servers and caches will compare two validators to\n   decide if they represent the same or different entities, one normally\n   would expect that if the entity (the entity-body or any entity-\n   headers) changes in any way, then the associated validator would\n   change as well. If this is true, then we call this validator a\n   \"strong validator.\"\n\n   However, there might be cases when a server prefers to change the\n   validator only on semantically significant changes, and not when\n   insignificant aspects of the entity change. A validator that does not\n   always change when the resource changes is a \"weak validator.\"\n\n   Entity tags are normally \"strong validators,\" but the protocol\n   provides a mechanism to tag an entity tag as \"weak.\" One can think of\n   a strong validator as one that changes whenever the bits of an entity\n   changes, while a weak value changes whenever the meaning of an entity\n   changes. Alternatively, one can think of a strong validator as part\n   of an identifier for a specific entity, while a weak validator is\n   part of an identifier for a set of semantically equivalent entities."
      },
      {
        "chunk_id": "rfc_http_chunk_58",
        "original_index": 58,
        "content": "Note: One example of a strong validator is an integer that is\n      incremented in stable storage every time an entity is changed.\n\n\n\nFielding, et al.            Standards Track                    [Page 86]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      An entity's modification time, if represented with one-second\n      resolution, could be a weak validator, since it is possible that\n      the resource might be modified twice during a single second.\n\n      Support for weak validators is optional. However, weak validators\n      allow for more efficient caching of equivalent objects; for\n      example, a hit counter on a site is probably good enough if it is\n      updated every few days or weeks, and any value during that period\n      is likely \"good enough\" to be equivalent.\n\n   A \"use\" of a validator is either when a client generates a request\n   and includes the validator in a validating header field, or when a\n   server compares two validators.\n\n   Strong validators are usable in any context. Weak validators are only\n   usable in contexts that do not depend on exact equality of an entity.\n   For example, either kind is usable for a conditional GET of a full\n   entity. However, only a strong validator is usable for a sub-range\n   retrieval, since otherwise the client might end up with an internally\n   inconsistent entity.\n\n   Clients MAY issue simple (non-subrange) GET requests with either weak\n   validators or strong validators. Clients MUST NOT use weak validators\n   in other forms of request.\n\n   The only function that the HTTP/1.1 protocol defines on validators is\n   comparison. There are two validator comparison functions, depending\n   on whether the comparison context allows the use of weak validators\n   or not:\n\n      - The strong comparison function: in order to be considered equal,\n        both validators MUST be identical in every way, and both MUST\n        NOT be weak.\n\n      - The weak comparison function: in order to be considered equal,\n        both validators MUST be identical in every way, but either or\n        both of them MAY be tagged as \"weak\" without affecting the\n        result.\n\n   An entity tag is strong unless it is explicitly tagged as weak.\n   Section 3.11 gives the syntax for entity tags.\n\n   A Last-Modified time, when used as a validator in a request, is\n   implicitly weak unless it is possible to deduce that it is strong,\n   using the following rules:\n\n      - The validator is being compared by an origin server to the\n        actual current validator for the entity and,\n\n\n\nFielding, et al.            Standards Track                    [Page 87]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - That origin server reliably knows that the associated entity did\n        not change twice during the second covered by the presented\n        validator.\n\n   or\n\n      - The validator is about to be used by a client in an If-\n        Modified-Since or If-Unmodified-Since header, because the client\n        has a cache entry for the associated entity, and\n\n      - That cache entry includes a Date value, which gives the time\n        when the origin server sent the original response, and\n\n      - The presented Last-Modified time is at least 60 seconds before\n        the Date value.\n\n   or\n\n      - The validator is being compared by an intermediate cache to the\n        validator stored in its cache entry for the entity, and\n\n      - That cache entry includes a Date value, which gives the time\n        when the origin server sent the original response, and\n\n      - The presented Last-Modified time is at least 60 seconds before\n        the Date value."
      },
      {
        "chunk_id": "rfc_http_chunk_59",
        "original_index": 59,
        "content": "- The presented Last-Modified time is at least 60 seconds before\n        the Date value.\n\n   This method relies on the fact that if two different responses were\n   sent by the origin server during the same second, but both had the\n   same Last-Modified time, then at least one of those responses would\n   have a Date value equal to its Last-Modified time. The arbitrary 60-\n   second limit guards against the possibility that the Date and Last-\n   Modified values are generated from different clocks, or at somewhat\n   different times during the preparation of the response. An\n   implementation MAY use a value larger than 60 seconds, if it is\n   believed that 60 seconds is too short.\n\n   If a client wishes to perform a sub-range retrieval on a value for\n   which it has only a Last-Modified time and no opaque validator, it\n   MAY do this only if the Last-Modified time is strong in the sense\n   described here.\n\n   A cache or origin server receiving a conditional request, other than\n   a full-body GET request, MUST use the strong comparison function to\n   evaluate the condition.\n\n   These rules allow HTTP/1.1 caches and clients to safely perform sub-\n   range retrievals on values that have been obtained from HTTP/1.0\n\n\n\nFielding, et al.            Standards Track                    [Page 88]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   servers.\n\n13.3.4 Rules for When to Use Entity Tags and Last-Modified Dates\n\n   We adopt a set of rules and recommendations for origin servers,\n   clients, and caches regarding when various validator types ought to\n   be used, and for what purposes.\n\n   HTTP/1.1 origin servers:\n\n      - SHOULD send an entity tag validator unless it is not feasible to\n        generate one.\n\n      - MAY send a weak entity tag instead of a strong entity tag, if\n        performance considerations support the use of weak entity tags,\n        or if it is unfeasible to send a strong entity tag.\n\n      - SHOULD send a Last-Modified value if it is feasible to send one,\n        unless the risk of a breakdown in semantic transparency that\n        could result from using this date in an If-Modified-Since header\n        would lead to serious problems.\n\n   In other words, the preferred behavior for an HTTP/1.1 origin server\n   is to send both a strong entity tag and a Last-Modified value.\n\n   In order to be legal, a strong entity tag MUST change whenever the\n   associated entity value changes in any way. A weak entity tag SHOULD\n   change whenever the associated entity changes in a semantically\n   significant way.\n\n      Note: in order to provide semantically transparent caching, an\n      origin server must avoid reusing a specific strong entity tag\n      value for two different entities, or reusing a specific weak\n      entity tag value for two semantically different entities. Cache\n      entries might persist for arbitrarily long periods, regardless of\n      expiration times, so it might be inappropriate to expect that a\n      cache will never again attempt to validate an entry using a\n      validator that it obtained at some point in the past.\n\n   HTTP/1.1 clients:\n\n      - If an entity tag has been provided by the origin server, MUST\n        use that entity tag in any cache-conditional request (using If-\n        Match or If-None-Match).\n\n      - If only a Last-Modified value has been provided by the origin\n        server, SHOULD use that value in non-subrange cache-conditional\n        requests (using If-Modified-Since).\n\n\n\nFielding, et al.            Standards Track                    [Page 89]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If only a Last-Modified value has been provided by an HTTP/1.0\n        origin server, MAY use that value in subrange cache-conditional\n        requests (using If-Unmodified-Since:). The user agent SHOULD\n        provide a way to disable this, in case of difficulty."
      },
      {
        "chunk_id": "rfc_http_chunk_60",
        "original_index": 60,
        "content": "- If both an entity tag and a Last-Modified value have been\n        provided by the origin server, SHOULD use both validators in\n        cache-conditional requests. This allows both HTTP/1.0 and\n        HTTP/1.1 caches to respond appropriately.\n\n   An HTTP/1.1 origin server, upon receiving a conditional request that\n   includes both a Last-Modified date (e.g., in an If-Modified-Since or\n   If-Unmodified-Since header field) and one or more entity tags (e.g.,\n   in an If-Match, If-None-Match, or If-Range header field) as cache\n   validators, MUST NOT return a response status of 304 (Not Modified)\n   unless doing so is consistent with all of the conditional header\n   fields in the request.\n\n   An HTTP/1.1 caching proxy, upon receiving a conditional request that\n   includes both a Last-Modified date and one or more entity tags as\n   cache validators, MUST NOT return a locally cached response to the\n   client unless that cached response is consistent with all of the\n   conditional header fields in the request.\n\n      Note: The general principle behind these rules is that HTTP/1.1\n      servers and clients should transmit as much non-redundant\n      information as is available in their responses and requests.\n      HTTP/1.1 systems receiving this information will make the most\n      conservative assumptions about the validators they receive.\n\n      HTTP/1.0 clients and caches will ignore entity tags. Generally,\n      last-modified values received or used by these systems will\n      support transparent and efficient caching, and so HTTP/1.1 origin\n      servers should provide Last-Modified values. In those rare cases\n      where the use of a Last-Modified value as a validator by an\n      HTTP/1.0 system could result in a serious problem, then HTTP/1.1\n      origin servers should not provide one.\n\n13.3.5 Non-validating Conditionals\n\n   The principle behind entity tags is that only the service author\n   knows the semantics of a resource well enough to select an\n   appropriate cache validation mechanism, and the specification of any\n   validator comparison function more complex than byte-equality would\n   open up a can of worms. Thus, comparisons of any other headers\n   (except Last-Modified, for compatibility with HTTP/1.0) are never\n   used for purposes of validating a cache entry.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 90]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.4 Response Cacheability\n\n   Unless specifically constrained by a cache-control (section 14.9)\n   directive, a caching system MAY always store a successful response\n   (see section 13.8) as a cache entry, MAY return it without validation\n   if it is fresh, and MAY return it after successful validation. If\n   there is neither a cache validator nor an explicit expiration time\n   associated with a response, we do not expect it to be cached, but\n   certain caches MAY violate this expectation (for example, when little\n   or no network connectivity is available). A client can usually detect\n   that such a response was taken from a cache by comparing the Date\n   header to the current time.\n\n      Note: some HTTP/1.0 caches are known to violate this expectation\n      without providing any Warning.\n\n   However, in some cases it might be inappropriate for a cache to\n   retain an entity, or to return it in response to a subsequent\n   request. This might be because absolute semantic transparency is\n   deemed necessary by the service author, or because of security or\n   privacy considerations. Certain cache-control directives are\n   therefore provided so that the server can indicate that certain\n   resource entities, or portions thereof, are not to be cached\n   regardless of other considerations.\n\n   Note that section 14.8 normally prevents a shared cache from saving\n   and returning a response to a previous request if that request\n   included an Authorization header."
      },
      {
        "chunk_id": "rfc_http_chunk_61",
        "original_index": 61,
        "content": "Note that section 14.8 normally prevents a shared cache from saving\n   and returning a response to a previous request if that request\n   included an Authorization header.\n\n   A response received with a status code of 200, 203, 206, 300, 301 or\n   410 MAY be stored by a cache and used in reply to a subsequent\n   request, subject to the expiration mechanism, unless a cache-control\n   directive prohibits caching. However, a cache that does not support\n   the Range and Content-Range headers MUST NOT cache 206 (Partial\n   Content) responses.\n\n   A response received with any other status code (e.g. status codes 302\n   and 307) MUST NOT be returned in a reply to a subsequent request\n   unless there are cache-control directives or another header(s) that\n   explicitly allow it. For example, these include the following: an\n   Expires header (section 14.21); a \"max-age\", \"s-maxage\",  \"must-\n   revalidate\", \"proxy-revalidate\", \"public\" or \"private\" cache-control\n   directive (section 14.9).\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 91]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5 Constructing Responses From Caches\n\n   The purpose of an HTTP cache is to store information received in\n   response to requests for use in responding to future requests. In\n   many cases, a cache simply returns the appropriate parts of a\n   response to the requester. However, if the cache holds a cache entry\n   based on a previous response, it might have to combine parts of a new\n   response with what is held in the cache entry.\n\n13.5.1 End-to-end and Hop-by-hop Headers\n\n   For the purpose of defining the behavior of caches and non-caching\n   proxies, we divide HTTP headers into two categories:\n\n      - End-to-end headers, which are  transmitted to the ultimate\n        recipient of a request or response. End-to-end headers in\n        responses MUST be stored as part of a cache entry and MUST be\n        transmitted in any response formed from a cache entry.\n\n      - Hop-by-hop headers, which are meaningful only for a single\n        transport-level connection, and are not stored by caches or\n        forwarded by proxies.\n\n   The following HTTP/1.1 headers are hop-by-hop headers:\n\n      - Connection\n      - Keep-Alive\n      - Proxy-Authenticate\n      - Proxy-Authorization\n      - TE\n      - Trailers\n      - Transfer-Encoding\n      - Upgrade\n\n   All other headers defined by HTTP/1.1 are end-to-end headers.\n\n   Other hop-by-hop headers MUST be listed in a Connection header,\n   (section 14.10) to be introduced into HTTP/1.1 (or later).\n\n13.5.2 Non-modifiable Headers\n\n   Some features of the HTTP/1.1 protocol, such as Digest\n   Authentication, depend on the value of certain end-to-end headers. A\n   transparent proxy SHOULD NOT modify an end-to-end header unless the\n   definition of that header requires or specifically allows that.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 92]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A transparent proxy MUST NOT modify any of the following fields in a\n   request or response, and it MUST NOT add any of these fields if not\n   already present:\n\n      - Content-Location\n\n      - Content-MD5\n\n      - ETag\n\n      - Last-Modified\n\n   A transparent proxy MUST NOT modify any of the following fields in a\n   response:\n\n      - Expires\n\n   but it MAY add any of these fields if not already present. If an\n   Expires header is added, it MUST be given a field-value identical to\n   that of the Date header in that response.\n\n   A  proxy MUST NOT modify or add any of the following fields in a\n   message that contains the no-transform cache-control directive, or in\n   any request:\n\n      - Content-Encoding\n\n      - Content-Range\n\n      - Content-Type"
      },
      {
        "chunk_id": "rfc_http_chunk_62",
        "original_index": 62,
        "content": "- Content-Encoding\n\n      - Content-Range\n\n      - Content-Type\n\n   A non-transparent proxy MAY modify or add these fields to a message\n   that does not include no-transform, but if it does so, it MUST add a\n   Warning 214 (Transformation applied) if one does not already appear\n   in the message (see section 14.46).\n\n      Warning: unnecessary modification of end-to-end headers might\n      cause authentication failures if stronger authentication\n      mechanisms are introduced in later versions of HTTP. Such\n      authentication mechanisms MAY rely on the values of header fields\n      not listed here.\n\n   The Content-Length field of a request or response is added or deleted\n   according to the rules in section 4.4. A transparent proxy MUST\n   preserve the entity-length (section 7.2.2) of the entity-body,\n   although it MAY change the transfer-length (section 4.4).\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 93]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5.3 Combining Headers\n\n   When a cache makes a validating request to a server, and the server\n   provides a 304 (Not Modified) response or a 206 (Partial Content)\n   response, the cache then constructs a response to send to the\n   requesting client.\n\n   If the status code is 304 (Not Modified), the cache uses the entity-\n   body stored in the cache entry as the entity-body of this outgoing\n   response. If the status code is 206 (Partial Content) and the ETag or\n   Last-Modified headers match exactly, the cache MAY combine the\n   contents stored in the cache entry with the new contents received in\n   the response and use the result as the entity-body of this outgoing\n   response, (see 13.5.4).\n\n   The end-to-end headers stored in the cache entry are used for the\n   constructed response, except that\n\n      - any stored Warning headers with warn-code 1xx (see section\n        14.46) MUST be deleted from the cache entry and the forwarded\n        response.\n\n      - any stored Warning headers with warn-code 2xx MUST be retained\n        in the cache entry and the forwarded response.\n\n      - any end-to-end headers provided in the 304 or 206 response MUST\n        replace the corresponding headers from the cache entry.\n\n   Unless the cache decides to remove the cache entry, it MUST also\n   replace the end-to-end headers stored with the cache entry with\n   corresponding headers received in the incoming response, except for\n   Warning headers as described immediately above. If a header field-\n   name in the incoming response matches more than one header in the\n   cache entry, all such old headers MUST be replaced.\n\n   In other words, the set of end-to-end headers received in the\n   incoming response overrides all corresponding end-to-end headers\n   stored with the cache entry (except for stored Warning headers with\n   warn-code 1xx, which are deleted even if not overridden).\n\n      Note: this rule allows an origin server to use a 304 (Not\n      Modified) or a 206 (Partial Content) response to update any header\n      associated with a previous response for the same entity or sub-\n      ranges thereof, although it might not always be meaningful or\n      correct to do so. This rule does not allow an origin server to use\n      a 304 (Not Modified) or a 206 (Partial Content) response to\n      entirely delete a header that it had provided with a previous\n      response.\n\n\n\nFielding, et al.            Standards Track                    [Page 94]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5.4 Combining Byte Ranges\n\n   A response might transfer only a subrange of the bytes of an entity-\n   body, either because the request included one or more Range\n   specifications, or because a connection was broken prematurely. After\n   several such transfers, a cache might have received several ranges of\n   the same entity-body."
      },
      {
        "chunk_id": "rfc_http_chunk_63",
        "original_index": 63,
        "content": "If a cache has a stored non-empty set of subranges for an entity, and\n   an incoming response transfers another subrange, the cache MAY\n   combine the new subrange with the existing set if both the following\n   conditions are met:\n\n      - Both the incoming response and the cache entry have a cache\n        validator.\n\n      - The two cache validators match using the strong comparison\n        function (see section 13.3.3).\n\n   If either requirement is not met, the cache MUST use only the most\n   recent partial response (based on the Date values transmitted with\n   every response, and using the incoming response if these values are\n   equal or missing), and MUST discard the other partial information.\n\n13.6 Caching Negotiated Responses\n\n   Use of server-driven content negotiation (section 12.1), as indicated\n   by the presence of a Vary header field in a response, alters the\n   conditions and procedure by which a cache can use the response for\n   subsequent requests. See section 14.44 for use of the Vary header\n   field by servers.\n\n   A server SHOULD use the Vary header field to inform a cache of what\n   request-header fields were used to select among multiple\n   representations of a cacheable response subject to server-driven\n   negotiation. The set of header fields named by the Vary field value\n   is known as the \"selecting\" request-headers.\n\n   When the cache receives a subsequent request whose Request-URI\n   specifies one or more cache entries including a Vary header field,\n   the cache MUST NOT use such a cache entry to construct a response to\n   the new request unless all of the selecting request-headers present\n   in the new request match the corresponding stored request-headers in\n   the original request.\n\n   The selecting request-headers from two requests are defined to match\n   if and only if the selecting request-headers in the first request can\n   be transformed to the selecting request-headers in the second request\n\n\n\nFielding, et al.            Standards Track                    [Page 95]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   by adding or removing linear white space (LWS) at places where this\n   is allowed by the corresponding BNF, and/or combining multiple\n   message-header fields with the same field name following the rules\n   about message headers in section 4.2.\n\n   A Vary header field-value of \"*\" always fails to match and subsequent\n   requests on that resource can only be properly interpreted by the\n   origin server.\n\n   If the selecting request header fields for the cached entry do not\n   match the selecting request header fields of the new request, then\n   the cache MUST NOT use a cached entry to satisfy the request unless\n   it first relays the new request to the origin server in a conditional\n   request and the server responds with 304 (Not Modified), including an\n   entity tag or Content-Location that indicates the entity to be used.\n\n   If an entity tag was assigned to a cached representation, the\n   forwarded request SHOULD be conditional and include the entity tags\n   in an If-None-Match header field from all its cache entries for the\n   resource. This conveys to the server the set of entities currently\n   held by the cache, so that if any one of these entities matches the\n   requested entity, the server can use the ETag header field in its 304\n   (Not Modified) response to tell the cache which entry is appropriate.\n   If the entity-tag of the new response matches that of an existing\n   entry, the new response SHOULD be used to update the header fields of\n   the existing entry, and the result MUST be returned to the client.\n\n   If any of the existing cache entries contains only partial content\n   for the associated entity, its entity-tag SHOULD NOT be included in\n   the If-None-Match header field unless the request is for a range that\n   would be fully satisfied by that entry."
      },
      {
        "chunk_id": "rfc_http_chunk_64",
        "original_index": 64,
        "content": "If a cache receives a successful response whose Content-Location\n   field matches that of an existing cache entry for the same Request-\n   ]URI, whose entity-tag differs from that of the existing entry, and\n   whose Date is more recent than that of the existing entry, the\n   existing entry SHOULD NOT be returned in response to future requests\n   and SHOULD be deleted from the cache.\n\n13.7 Shared and Non-Shared Caches\n\n   For reasons of security and privacy, it is necessary to make a\n   distinction between \"shared\" and \"non-shared\" caches. A non-shared\n   cache is one that is accessible only to a single user. Accessibility\n   in this case SHOULD be enforced by appropriate security mechanisms.\n   All other caches are considered to be \"shared.\" Other sections of\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 96]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   this specification place certain constraints on the operation of\n   shared caches in order to prevent loss of privacy or failure of\n   access controls.\n\n13.8 Errors or Incomplete Response Cache Behavior\n\n   A cache that receives an incomplete response (for example, with fewer\n   bytes of data than specified in a Content-Length header) MAY store\n   the response. However, the cache MUST treat this as a partial\n   response. Partial responses MAY be combined as described in section\n   13.5.4; the result might be a full response or might still be\n   partial. A cache MUST NOT return a partial response to a client\n   without explicitly marking it as such, using the 206 (Partial\n   Content) status code. A cache MUST NOT return a partial response\n   using a status code of 200 (OK).\n\n   If a cache receives a 5xx response while attempting to revalidate an\n   entry, it MAY either forward this response to the requesting client,\n   or act as if the server failed to respond. In the latter case, it MAY\n   return a previously received response unless the cached entry\n   includes the \"must-revalidate\" cache-control directive (see section\n   14.9).\n\n13.9 Side Effects of GET and HEAD\n\n   Unless the origin server explicitly prohibits the caching of their\n   responses, the application of GET and HEAD methods to any resources\n   SHOULD NOT have side effects that would lead to erroneous behavior if\n   these responses are taken from a cache. They MAY still have side\n   effects, but a cache is not required to consider such side effects in\n   its caching decisions. Caches are always expected to observe an\n   origin server's explicit restrictions on caching.\n\n   We note one exception to this rule: since some applications have\n   traditionally used GETs and HEADs with query URLs (those containing a\n   \"?\" in the rel_path part) to perform operations with significant side\n   effects, caches MUST NOT treat responses to such URIs as fresh unless\n   the server provides an explicit expiration time. This specifically\n   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT\n   be taken from a cache. See section 9.1.1 for related information.\n\n13.10 Invalidation After Updates or Deletions\n\n   The effect of certain methods performed on a resource at the origin\n   server might cause one or more existing cache entries to become non-\n   transparently invalid. That is, although they might continue to be\n   \"fresh,\" they do not accurately reflect what the origin server would\n   return for a new request on that resource.\n\n\n\nFielding, et al.            Standards Track                    [Page 97]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   There is no way for the HTTP protocol to guarantee that all such\n   cache entries are marked invalid. For example, the request that\n   caused the change at the origin server might not have gone through\n   the proxy where a cache entry is stored. However, several rules help\n   reduce the likelihood of erroneous behavior."
      },
      {
        "chunk_id": "rfc_http_chunk_65",
        "original_index": 65,
        "content": "In this section, the phrase \"invalidate an entity\" means that the\n   cache will either remove all instances of that entity from its\n   storage, or will mark these as \"invalid\" and in need of a mandatory\n   revalidation before they can be returned in response to a subsequent\n   request.\n\n   Some HTTP methods MUST cause a cache to invalidate an entity. This is\n   either the entity referred to by the Request-URI, or by the Location\n   or Content-Location headers (if present). These methods are:\n\n      - PUT\n\n      - DELETE\n\n      - POST\n\n   In order to prevent denial of service attacks, an invalidation based\n   on the URI in a Location or Content-Location header MUST only be\n   performed if the host part is the same as in the Request-URI.\n\n   A cache that passes through requests for methods it does not\n   understand SHOULD invalidate any entities referred to by the\n   Request-URI.\n\n13.11 Write-Through Mandatory\n\n   All methods that might be expected to cause modifications to the\n   origin server's resources MUST be written through to the origin\n   server. This currently includes all methods except for GET and HEAD.\n   A cache MUST NOT reply to such a request from a client before having\n   transmitted the request to the inbound server, and having received a\n   corresponding response from the inbound server. This does not prevent\n   a proxy cache from sending a 100 (Continue) response before the\n   inbound server has sent its final reply.\n\n   The alternative (known as \"write-back\" or \"copy-back\" caching) is not\n   allowed in HTTP/1.1, due to the difficulty of providing consistent\n   updates and the problems arising from server, cache, or network\n   failure prior to write-back.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 98]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.12 Cache Replacement\n\n   If a new cacheable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8)\n   response is received from a resource while any existing responses for\n   the same resource are cached, the cache SHOULD use the new response\n   to reply to the current request. It MAY insert it into cache storage\n   and MAY, if it meets all other requirements, use it to respond to any\n   future requests that would previously have caused the old response to\n   be returned. If it inserts the new response into cache storage  the\n   rules in section 13.5.3 apply.\n\n      Note: a new response that has an older Date header value than\n      existing cached responses is not cacheable.\n\n13.13 History Lists\n\n   User agents often have history mechanisms, such as \"Back\" buttons and\n   history lists, which can be used to redisplay an entity retrieved\n   earlier in a session.\n\n   History mechanisms and caches are different. In particular history\n   mechanisms SHOULD NOT try to show a semantically transparent view of\n   the current state of a resource. Rather, a history mechanism is meant\n   to show exactly what the user saw at the time when the resource was\n   retrieved.\n\n   By default, an expiration time does not apply to history mechanisms.\n   If the entity is still in storage, a history mechanism SHOULD display\n   it even if the entity has expired, unless the user has specifically\n   configured the agent to refresh expired history documents.\n\n   This is not to be construed to prohibit the history mechanism from\n   telling the user that a view might be stale."
      },
      {
        "chunk_id": "rfc_http_chunk_66",
        "original_index": 66,
        "content": "This is not to be construed to prohibit the history mechanism from\n   telling the user that a view might be stale.\n\n      Note: if history list mechanisms unnecessarily prevent users from\n      viewing stale resources, this will tend to force service authors\n      to avoid using HTTP expiration controls and cache controls when\n      they would otherwise like to. Service authors may consider it\n      important that users not be presented with error messages or\n      warning messages when they use navigation controls (such as BACK)\n      to view previously fetched resources. Even though sometimes such\n      resources ought not to cached, or ought to expire quickly, user\n      interface considerations may force service authors to resort to\n      other means of preventing caching (e.g. \"once-only\" URLs) in order\n      not to suffer the effects of improperly functioning history\n      mechanisms.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 99]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14 Header Field Definitions\n\n   This section defines the syntax and semantics of all standard\n   HTTP/1.1 header fields. For entity-header fields, both sender and\n   recipient refer to either the client or the server, depending on who\n   sends and who receives the entity.\n\n14.1 Accept\n\n   The Accept request-header field can be used to specify certain media\n   types which are acceptable for the response. Accept headers can be\n   used to indicate that the request is specifically limited to a small\n   set of desired types, as in the case of a request for an in-line\n   image.\n\n       Accept         = \"Accept\" \":\"\n                        #( media-range [ accept-params ] )\n\n       media-range    = ( \"*/*\"\n                        | ( type \"/\" \"*\" )\n                        | ( type \"/\" subtype )\n                        ) *( \";\" parameter )\n       accept-params  = \";\" \"q\" \"=\" qvalue *( accept-extension )\n       accept-extension = \";\" token [ \"=\" ( token | quoted-string ) ]\n\n   The asterisk \"*\" character is used to group media types into ranges,\n   with \"*/*\" indicating all media types and \"type/*\" indicating all\n   subtypes of that type. The media-range MAY include media type\n   parameters that are applicable to that range.\n\n   Each media-range MAY be followed by one or more accept-params,\n   beginning with the \"q\" parameter for indicating a relative quality\n   factor. The first \"q\" parameter (if any) separates the media-range\n   parameter(s) from the accept-params. Quality factors allow the user\n   or user agent to indicate the relative degree of preference for that\n   media-range, using the qvalue scale from 0 to 1 (section 3.9). The\n   default value is q=1.\n\n      Note: Use of the \"q\" parameter name to separate media type\n      parameters from Accept extension parameters is due to historical\n      practice. Although this prevents any media type parameter named\n      \"q\" from being used with a media range, such an event is believed\n      to be unlikely given the lack of any \"q\" parameters in the IANA\n      media type registry and the rare usage of any media type\n      parameters in Accept. Future media types are discouraged from\n      registering any parameter named \"q\".\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 100]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The example\n\n       Accept: audio/*; q=0.2, audio/basic\n\n   SHOULD be interpreted as \"I prefer audio/basic, but send me any audio\n   type if it is the best available after an 80% mark-down in quality.\"\n\n   If no Accept header field is present, then it is assumed that the\n   client accepts all media types. If an Accept header field is present,\n   and if the server cannot send a response which is acceptable\n   according to the combined Accept field value, then the server SHOULD\n   send a 406 (not acceptable) response.\n\n   A more elaborate example is"
      },
      {
        "chunk_id": "rfc_http_chunk_67",
        "original_index": 67,
        "content": "A more elaborate example is\n\n       Accept: text/plain; q=0.5, text/html,\n               text/x-dvi; q=0.8, text/x-c\n\n   Verbally, this would be interpreted as \"text/html and text/x-c are\n   the preferred media types, but if they do not exist, then send the\n   text/x-dvi entity, and if that does not exist, send the text/plain\n   entity.\"\n\n   Media ranges can be overridden by more specific media ranges or\n   specific media types. If more than one media range applies to a given\n   type, the most specific reference has precedence. For example,\n\n       Accept: text/*, text/html, text/html;level=1, */*\n\n   have the following precedence:\n\n       1) text/html;level=1\n       2) text/html\n       3) text/*\n       4) */*\n\n   The media type quality factor associated with a given type is\n   determined by finding the media range with the highest precedence\n   which matches that type. For example,\n\n       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,\n               text/html;level=2;q=0.4, */*;q=0.5\n\n   would cause the following values to be associated:\n\n       text/html;level=1         = 1\n       text/html                 = 0.7\n       text/plain                = 0.3\n\n\n\nFielding, et al.            Standards Track                   [Page 101]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       image/jpeg                = 0.5\n       text/html;level=2         = 0.4\n       text/html;level=3         = 0.7\n\n      Note: A user agent might be provided with a default set of quality\n      values for certain media ranges. However, unless the user agent is\n      a closed system which cannot interact with other rendering agents,\n      this default set ought to be configurable by the user.\n\n14.2 Accept-Charset\n\n   The Accept-Charset request-header field can be used to indicate what\n   character sets are acceptable for the response. This field allows\n   clients capable of understanding more comprehensive or special-\n   purpose character sets to signal that capability to a server which is\n   capable of representing documents in those character sets.\n\n      Accept-Charset = \"Accept-Charset\" \":\"\n              1#( ( charset | \"*\" )[ \";\" \"q\" \"=\" qvalue ] )\n\n\n   Character set values are described in section 3.4. Each charset MAY\n   be given an associated quality value which represents the user's\n   preference for that charset. The default value is q=1. An example is\n\n      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n\n   The special value \"*\", if present in the Accept-Charset field,\n   matches every character set (including ISO-8859-1) which is not\n   mentioned elsewhere in the Accept-Charset field. If no \"*\" is present\n   in an Accept-Charset field, then all character sets not explicitly\n   mentioned get a quality value of 0, except for ISO-8859-1, which gets\n   a quality value of 1 if not explicitly mentioned.\n\n   If no Accept-Charset header is present, the default is that any\n   character set is acceptable. If an Accept-Charset header is present,\n   and if the server cannot send a response which is acceptable\n   according to the Accept-Charset header, then the server SHOULD send\n   an error response with the 406 (not acceptable) status code, though\n   the sending of an unacceptable response is also allowed.\n\n14.3 Accept-Encoding\n\n   The Accept-Encoding request-header field is similar to Accept, but\n   restricts the content-codings (section 3.5) that are acceptable in\n   the response.\n\n       Accept-Encoding  = \"Accept-Encoding\" \":\"\n\n\n\nFielding, et al.            Standards Track                   [Page 102]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                          1#( codings [ \";\" \"q\" \"=\" qvalue ] )\n       codings          = ( content-coding | \"*\" )\n\n   Examples of its use are:"
      },
      {
        "chunk_id": "rfc_http_chunk_68",
        "original_index": 68,
        "content": "1#( codings [ \";\" \"q\" \"=\" qvalue ] )\n       codings          = ( content-coding | \"*\" )\n\n   Examples of its use are:\n\n       Accept-Encoding: compress, gzip\n       Accept-Encoding:\n       Accept-Encoding: *\n       Accept-Encoding: compress;q=0.5, gzip;q=1.0\n       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n\n   A server tests whether a content-coding is acceptable, according to\n   an Accept-Encoding field, using these rules:\n\n      1. If the content-coding is one of the content-codings listed in\n         the Accept-Encoding field, then it is acceptable, unless it is\n         accompanied by a qvalue of 0. (As defined in section 3.9, a\n         qvalue of 0 means \"not acceptable.\")\n\n      2. The special \"*\" symbol in an Accept-Encoding field matches any\n         available content-coding not explicitly listed in the header\n         field.\n\n      3. If multiple content-codings are acceptable, then the acceptable\n         content-coding with the highest non-zero qvalue is preferred.\n\n      4. The \"identity\" content-coding is always acceptable, unless\n         specifically refused because the Accept-Encoding field includes\n         \"identity;q=0\", or because the field includes \"*;q=0\" and does\n         not explicitly include the \"identity\" content-coding. If the\n         Accept-Encoding field-value is empty, then only the \"identity\"\n         encoding is acceptable.\n\n   If an Accept-Encoding field is present in a request, and if the\n   server cannot send a response which is acceptable according to the\n   Accept-Encoding header, then the server SHOULD send an error response\n   with the 406 (Not Acceptable) status code.\n\n   If no Accept-Encoding field is present in a request, the server MAY\n   assume that the client will accept any content coding. In this case,\n   if \"identity\" is one of the available content-codings, then the\n   server SHOULD use the \"identity\" content-coding, unless it has\n   additional information that a different content-coding is meaningful\n   to the client.\n\n      Note: If the request does not include an Accept-Encoding field,\n      and if the \"identity\" content-coding is unavailable, then\n      content-codings commonly understood by HTTP/1.0 clients (i.e.,\n\n\n\nFielding, et al.            Standards Track                   [Page 103]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      \"gzip\" and \"compress\") are preferred; some older clients\n      improperly display messages sent with other content-codings.  The\n      server might also make this decision based on information about\n      the particular user-agent or client.\n\n      Note: Most HTTP/1.0 applications do not recognize or obey qvalues\n      associated with content-codings. This means that qvalues will not\n      work and are not permitted with x-gzip or x-compress.\n\n14.4 Accept-Language\n\n   The Accept-Language request-header field is similar to Accept, but\n   restricts the set of natural languages that are preferred as a\n   response to the request. Language tags are defined in section 3.10.\n\n       Accept-Language = \"Accept-Language\" \":\"\n                         1#( language-range [ \";\" \"q\" \"=\" qvalue ] )\n       language-range  = ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) | \"*\" )\n\n   Each language-range MAY be given an associated quality value which\n   represents an estimate of the user's preference for the languages\n   specified by that range. The quality value defaults to \"q=1\". For\n   example,\n\n       Accept-Language: da, en-gb;q=0.8, en;q=0.7\n\n   would mean: \"I prefer Danish, but will accept British English and\n   other types of English.\" A language-range matches a language-tag if\n   it exactly equals the tag, or if it exactly equals a prefix of the\n   tag such that the first tag character following the prefix is \"-\".\n   The special range \"*\", if present in the Accept-Language field,\n   matches every tag not matched by any other range present in the\n   Accept-Language field."
      },
      {
        "chunk_id": "rfc_http_chunk_69",
        "original_index": 69,
        "content": "Note: This use of a prefix matching rule does not imply that\n      language tags are assigned to languages in such a way that it is\n      always true that if a user understands a language with a certain\n      tag, then this user will also understand all languages with tags\n      for which this tag is a prefix. The prefix rule simply allows the\n      use of prefix tags if this is the case.\n\n   The language quality factor assigned to a language-tag by the\n   Accept-Language field is the quality value of the longest language-\n   range in the field that matches the language-tag. If no language-\n   range in the field matches the tag, the language quality factor\n   assigned is 0. If no Accept-Language header is present in the\n   request, the server\n\n\n\n\nFielding, et al.            Standards Track                   [Page 104]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   SHOULD assume that all languages are equally acceptable. If an\n   Accept-Language header is present, then all languages which are\n   assigned a quality factor greater than 0 are acceptable.\n\n   It might be contrary to the privacy expectations of the user to send\n   an Accept-Language header with the complete linguistic preferences of\n   the user in every request. For a discussion of this issue, see\n   section 15.1.4.\n\n   As intelligibility is highly dependent on the individual user, it is\n   recommended that client applications make the choice of linguistic\n   preference available to the user. If the choice is not made\n   available, then the Accept-Language header field MUST NOT be given in\n   the request.\n\n      Note: When making the choice of linguistic preference available to\n      the user, we remind implementors of  the fact that users are not\n      familiar with the details of language matching as described above,\n      and should provide appropriate guidance. As an example, users\n      might assume that on selecting \"en-gb\", they will be served any\n      kind of English document if British English is not available. A\n      user agent might suggest in such a case to add \"en\" to get the\n      best matching behavior.\n\n14.5 Accept-Ranges\n\n      The Accept-Ranges response-header field allows the server to\n      indicate its acceptance of range requests for a resource:\n\n          Accept-Ranges     = \"Accept-Ranges\" \":\" acceptable-ranges\n          acceptable-ranges = 1#range-unit | \"none\"\n\n      Origin servers that accept byte-range requests MAY send\n\n          Accept-Ranges: bytes\n\n      but are not required to do so. Clients MAY generate byte-range\n      requests without having received this header for the resource\n      involved. Range units are defined in section 3.12.\n\n      Servers that do not accept any kind of range request for a\n      resource MAY send\n\n          Accept-Ranges: none\n\n      to advise the client not to attempt a range request.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 105]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.6 Age\n\n      The Age response-header field conveys the sender's estimate of the\n      amount of time since the response (or its revalidation) was\n      generated at the origin server. A cached response is \"fresh\" if\n      its age does not exceed its freshness lifetime. Age values are\n      calculated as specified in section 13.2.3.\n\n           Age = \"Age\" \":\" age-value\n           age-value = delta-seconds\n\n      Age values are non-negative decimal integers, representing time in\n      seconds.\n\n      If a cache receives a value larger than the largest positive\n      integer it can represent, or if any of its age calculations\n      overflows, it MUST transmit an Age header with a value of\n      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST\n      include an Age header field in every response generated from its\n      own cache. Caches SHOULD use an arithmetic type of at least 31\n      bits of range.\n\n14.7 Allow"
      },
      {
        "chunk_id": "rfc_http_chunk_70",
        "original_index": 70,
        "content": "14.7 Allow\n\n      The Allow entity-header field lists the set of methods supported\n      by the resource identified by the Request-URI. The purpose of this\n      field is strictly to inform the recipient of valid methods\n      associated with the resource. An Allow header field MUST be\n      present in a 405 (Method Not Allowed) response.\n\n          Allow   = \"Allow\" \":\" #Method\n\n      Example of use:\n\n          Allow: GET, HEAD, PUT\n\n      This field cannot prevent a client from trying other methods.\n      However, the indications given by the Allow header field value\n      SHOULD be followed. The actual set of allowed methods is defined\n      by the origin server at the time of each request.\n\n      The Allow header field MAY be provided with a PUT request to\n      recommend the methods to be supported by the new or modified\n      resource. The server is not required to support these methods and\n      SHOULD include an Allow header in the response giving the actual\n      supported methods.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 106]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      A proxy MUST NOT modify the Allow header field even if it does not\n      understand all the methods specified, since the user agent might\n      have other means of communicating with the origin server.\n\n14.8 Authorization\n\n      A user agent that wishes to authenticate itself with a server--\n      usually, but not necessarily, after receiving a 401 response--does\n      so by including an Authorization request-header field with the\n      request.  The Authorization field value consists of credentials\n      containing the authentication information of the user agent for\n      the realm of the resource being requested.\n\n          Authorization  = \"Authorization\" \":\" credentials\n\n      HTTP access authentication is described in \"HTTP Authentication:\n      Basic and Digest Access Authentication\" [43]. If a request is\n      authenticated and a realm specified, the same credentials SHOULD\n      be valid for all other requests within this realm (assuming that\n      the authentication scheme itself does not require otherwise, such\n      as credentials that vary according to a challenge value or using\n      synchronized clocks).\n\n      When a shared cache (see section 13.7) receives a request\n      containing an Authorization field, it MUST NOT return the\n      corresponding response as a reply to any other request, unless one\n      of the following specific exceptions holds:\n\n      1. If the response includes the \"s-maxage\" cache-control\n         directive, the cache MAY use that response in replying to a\n         subsequent request. But (if the specified maximum age has\n         passed) a proxy cache MUST first revalidate it with the origin\n         server, using the request-headers from the new request to allow\n         the origin server to authenticate the new request. (This is the\n         defined behavior for s-maxage.) If the response includes \"s-\n         maxage=0\", the proxy MUST always revalidate it before re-using\n         it.\n\n      2. If the response includes the \"must-revalidate\" cache-control\n         directive, the cache MAY use that response in replying to a\n         subsequent request. But if the response is stale, all caches\n         MUST first revalidate it with the origin server, using the\n         request-headers from the new request to allow the origin server\n         to authenticate the new request.\n\n      3. If the response includes the \"public\" cache-control directive,\n         it MAY be returned in reply to any subsequent request.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 107]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.9 Cache-Control"
      },
      {
        "chunk_id": "rfc_http_chunk_71",
        "original_index": 71,
        "content": "Fielding, et al.            Standards Track                   [Page 107]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.9 Cache-Control\n\n   The Cache-Control general-header field is used to specify directives\n   that MUST be obeyed by all caching mechanisms along the\n   request/response chain. The directives specify behavior intended to\n   prevent caches from adversely interfering with the request or\n   response. These directives typically override the default caching\n   algorithms. Cache directives are unidirectional in that the presence\n   of a directive in a request does not imply that the same directive is\n   to be given in the response.\n\n      Note that HTTP/1.0 caches might not implement Cache-Control and\n      might only implement Pragma: no-cache (see section 14.32).\n\n   Cache directives MUST be passed through by a proxy or gateway\n   application, regardless of their significance to that application,\n   since the directives might be applicable to all recipients along the\n   request/response chain. It is not possible to specify a cache-\n   directive for a specific cache.\n\n    Cache-Control   = \"Cache-Control\" \":\" 1#cache-directive\n\n    cache-directive = cache-request-directive\n         | cache-response-directive\n\n    cache-request-directive =\n           \"no-cache\"                          ; Section 14.9.1\n         | \"no-store\"                          ; Section 14.9.2\n         | \"max-age\" \"=\" delta-seconds         ; Section 14.9.3, 14.9.4\n         | \"max-stale\" [ \"=\" delta-seconds ]   ; Section 14.9.3\n         | \"min-fresh\" \"=\" delta-seconds       ; Section 14.9.3\n         | \"no-transform\"                      ; Section 14.9.5\n         | \"only-if-cached\"                    ; Section 14.9.4\n         | cache-extension                     ; Section 14.9.6\n\n     cache-response-directive =\n           \"public\"                               ; Section 14.9.1\n         | \"private\" [ \"=\" <\"> 1#field-name <\"> ] ; Section 14.9.1\n         | \"no-cache\" [ \"=\" <\"> 1#field-name <\"> ]; Section 14.9.1\n         | \"no-store\"                             ; Section 14.9.2\n         | \"no-transform\"                         ; Section 14.9.5\n         | \"must-revalidate\"                      ; Section 14.9.4\n         | \"proxy-revalidate\"                     ; Section 14.9.4\n         | \"max-age\" \"=\" delta-seconds            ; Section 14.9.3\n         | \"s-maxage\" \"=\" delta-seconds           ; Section 14.9.3\n         | cache-extension                        ; Section 14.9.6\n\n    cache-extension = token [ \"=\" ( token | quoted-string ) ]\n\n\n\nFielding, et al.            Standards Track                   [Page 108]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   When a directive appears without any 1#field-name parameter, the\n   directive applies to the entire request or response. When such a\n   directive appears with a 1#field-name parameter, it applies only to\n   the named field or fields, and not to the rest of the request or\n   response. This mechanism supports extensibility; implementations of\n   future versions of the HTTP protocol might apply these directives to\n   header fields not defined in HTTP/1.1.\n\n   The cache-control directives can be broken down into these general\n   categories:\n\n      - Restrictions on what are cacheable; these may only be imposed by\n        the origin server.\n\n      - Restrictions on what may be stored by a cache; these may be\n        imposed by either the origin server or the user agent.\n\n      - Modifications of the basic expiration mechanism; these may be\n        imposed by either the origin server or the user agent.\n\n      - Controls over cache revalidation and reload; these may only be\n        imposed by a user agent.\n\n      - Control over transformation of entities.\n\n      - Extensions to the caching system.\n\n14.9.1 What is Cacheable"
      },
      {
        "chunk_id": "rfc_http_chunk_72",
        "original_index": 72,
        "content": "- Control over transformation of entities.\n\n      - Extensions to the caching system.\n\n14.9.1 What is Cacheable\n\n   By default, a response is cacheable if the requirements of the\n   request method, request header fields, and the response status\n   indicate that it is cacheable. Section 13.4 summarizes these defaults\n   for cacheability. The following Cache-Control response directives\n   allow an origin server to override the default cacheability of a\n   response:\n\n   public\n      Indicates that the response MAY be cached by any cache, even if it\n      would normally be non-cacheable or cacheable only within a non-\n      shared cache. (See also Authorization, section 14.8, for\n      additional details.)\n\n   private\n      Indicates that all or part of the response message is intended for\n      a single user and MUST NOT be cached by a shared cache. This\n      allows an origin server to state that the specified parts of the\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 109]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      response are intended for only one user and are not a valid\n      response for requests by other users. A private (non-shared) cache\n      MAY cache the response.\n\n       Note: This usage of the word private only controls where the\n       response may be cached, and cannot ensure the privacy of the\n       message content.\n\n   no-cache\n       If the no-cache directive does not specify a field-name, then a\n      cache MUST NOT use the response to satisfy a subsequent request\n      without successful revalidation with the origin server. This\n      allows an origin server to prevent caching even by caches that\n      have been configured to return stale responses to client requests.\n\n      If the no-cache directive does specify one or more field-names,\n      then a cache MAY use the response to satisfy a subsequent request,\n      subject to any other restrictions on caching. However, the\n      specified field-name(s) MUST NOT be sent in the response to a\n      subsequent request without successful revalidation with the origin\n      server. This allows an origin server to prevent the re-use of\n      certain header fields in a response, while still allowing caching\n      of the rest of the response.\n\n       Note: Most HTTP/1.0 caches will not recognize or obey this\n       directive.\n\n14.9.2 What May be Stored by Caches\n\n   no-store\n      The purpose of the no-store directive is to prevent the\n      inadvertent release or retention of sensitive information (for\n      example, on backup tapes). The no-store directive applies to the\n      entire message, and MAY be sent either in a response or in a\n      request. If sent in a request, a cache MUST NOT store any part of\n      either this request or any response to it. If sent in a response,\n      a cache MUST NOT store any part of either this response or the\n      request that elicited it. This directive applies to both non-\n      shared and shared caches. \"MUST NOT store\" in this context means\n      that the cache MUST NOT intentionally store the information in\n      non-volatile storage, and MUST make a best-effort attempt to\n      remove the information from volatile storage as promptly as\n      possible after forwarding it.\n\n      Even when this directive is associated with a response, users\n      might explicitly store such a response outside of the caching\n      system (e.g., with a \"Save As\" dialog). History buffers MAY store\n      such responses as part of their normal operation.\n\n\n\nFielding, et al.            Standards Track                   [Page 110]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_73",
        "original_index": 73,
        "content": "Fielding, et al.            Standards Track                   [Page 110]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      The purpose of this directive is to meet the stated requirements\n      of certain users and service authors who are concerned about\n      accidental releases of information via unanticipated accesses to\n      cache data structures. While the use of this directive might\n      improve privacy in some cases, we caution that it is NOT in any\n      way a reliable or sufficient mechanism for ensuring privacy. In\n      particular, malicious or compromised caches might not recognize or\n      obey this directive, and communications networks might be\n      vulnerable to eavesdropping.\n\n14.9.3 Modifications of the Basic Expiration Mechanism\n\n   The expiration time of an entity MAY be specified by the origin\n   server using the Expires header (see section 14.21). Alternatively,\n   it MAY be specified using the max-age directive in a response. When\n   the max-age cache-control directive is present in a cached response,\n   the response is stale if its current age is greater than the age\n   value given (in seconds) at the time of a new request for that\n   resource. The max-age directive on a response implies that the\n   response is cacheable (i.e., \"public\") unless some other, more\n   restrictive cache directive is also present.\n\n   If a response includes both an Expires header and a max-age\n   directive, the max-age directive overrides the Expires header, even\n   if the Expires header is more restrictive. This rule allows an origin\n   server to provide, for a given response, a longer expiration time to\n   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be\n   useful if certain HTTP/1.0 caches improperly calculate ages or\n   expiration times, perhaps due to desynchronized clocks.\n\n   Many HTTP/1.0 cache implementations will treat an Expires value that\n   is less than or equal to the response Date value as being equivalent\n   to the Cache-Control response directive \"no-cache\". If an HTTP/1.1\n   cache receives such a response, and the response does not include a\n   Cache-Control header field, it SHOULD consider the response to be\n   non-cacheable in order to retain compatibility with HTTP/1.0 servers.\n\n       Note: An origin server might wish to use a relatively new HTTP\n       cache control feature, such as the \"private\" directive, on a\n       network including older caches that do not understand that\n       feature. The origin server will need to combine the new feature\n       with an Expires field whose value is less than or equal to the\n       Date value. This will prevent older caches from improperly\n       caching the response.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 111]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   s-maxage\n       If a response includes an s-maxage directive, then for a shared\n       cache (but not for a private cache), the maximum age specified by\n       this directive overrides the maximum age specified by either the\n       max-age directive or the Expires header. The s-maxage directive\n       also implies the semantics of the proxy-revalidate directive (see\n       section 14.9.4), i.e., that the shared cache must not use the\n       entry after it becomes stale to respond to a subsequent request\n       without first revalidating it with the origin server. The s-\n       maxage directive is always ignored by a private cache.\n\n   Note that most older caches, not compliant with this specification,\n   do not implement any cache-control directives. An origin server\n   wishing to use a cache-control directive that restricts, but does not\n   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the\n   requirement that the max-age directive overrides the Expires header,\n   and the fact that pre-HTTP/1.1-compliant caches do not observe the\n   max-age directive."
      },
      {
        "chunk_id": "rfc_http_chunk_74",
        "original_index": 74,
        "content": "Other directives allow a user agent to modify the basic expiration\n   mechanism. These directives MAY be specified on a request:\n\n   max-age\n      Indicates that the client is willing to accept a response whose\n      age is no greater than the specified time in seconds. Unless max-\n      stale directive is also included, the client is not willing to\n      accept a stale response.\n\n   min-fresh\n      Indicates that the client is willing to accept a response whose\n      freshness lifetime is no less than its current age plus the\n      specified time in seconds. That is, the client wants a response\n      that will still be fresh for at least the specified number of\n      seconds.\n\n   max-stale\n      Indicates that the client is willing to accept a response that has\n      exceeded its expiration time. If max-stale is assigned a value,\n      then the client is willing to accept a response that has exceeded\n      its expiration time by no more than the specified number of\n      seconds. If no value is assigned to max-stale, then the client is\n      willing to accept a stale response of any age.\n\n   If a cache returns a stale response, either because of a max-stale\n   directive on a request, or because the cache is configured to\n   override the expiration time of a response, the cache MUST attach a\n   Warning header to the stale response, using Warning 110 (Response is\n   stale).\n\n\n\nFielding, et al.            Standards Track                   [Page 112]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A cache MAY be configured to return stale responses without\n   validation, but only if this does not conflict with any \"MUST\"-level\n   requirements concerning cache validation (e.g., a \"must-revalidate\"\n   cache-control directive).\n\n   If both the new request and the cached entry include \"max-age\"\n   directives, then the lesser of the two values is used for determining\n   the freshness of the cached entry for that request.\n\n14.9.4 Cache Revalidation and Reload Controls\n\n   Sometimes a user agent might want or need to insist that a cache\n   revalidate its cache entry with the origin server (and not just with\n   the next cache along the path to the origin server), or to reload its\n   cache entry from the origin server. End-to-end revalidation might be\n   necessary if either the cache or the origin server has overestimated\n   the expiration time of the cached response. End-to-end reload may be\n   necessary if the cache entry has become corrupted for some reason.\n\n   End-to-end revalidation may be requested either when the client does\n   not have its own local cached copy, in which case we call it\n   \"unspecified end-to-end revalidation\", or when the client does have a\n   local cached copy, in which case we call it \"specific end-to-end\n   revalidation.\"\n\n   The client can specify these three kinds of action using Cache-\n   Control request directives:\n\n   End-to-end reload\n      The request includes a \"no-cache\" cache-control directive or, for\n      compatibility with HTTP/1.0 clients, \"Pragma: no-cache\". Field\n      names MUST NOT be included with the no-cache directive in a\n      request. The server MUST NOT use a cached copy when responding to\n      such a request.\n\n   Specific end-to-end revalidation\n      The request includes a \"max-age=0\" cache-control directive, which\n      forces each cache along the path to the origin server to\n      revalidate its own entry, if any, with the next cache or server.\n      The initial request includes a cache-validating conditional with\n      the client's current validator.\n\n   Unspecified end-to-end revalidation\n      The request includes \"max-age=0\" cache-control directive, which\n      forces each cache along the path to the origin server to\n      revalidate its own entry, if any, with the next cache or server.\n      The initial request does not include a cache-validating"
      },
      {
        "chunk_id": "rfc_http_chunk_75",
        "original_index": 75,
        "content": "Fielding, et al.            Standards Track                   [Page 113]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      conditional; the first cache along the path (if any) that holds a\n      cache entry for this resource includes a cache-validating\n      conditional with its current validator.\n\n   max-age\n      When an intermediate cache is forced, by means of a max-age=0\n      directive, to revalidate its own cache entry, and the client has\n      supplied its own validator in the request, the supplied validator\n      might differ from the validator currently stored with the cache\n      entry. In this case, the cache MAY use either validator in making\n      its own request without affecting semantic transparency.\n\n      However, the choice of validator might affect performance. The\n      best approach is for the intermediate cache to use its own\n      validator when making its request. If the server replies with 304\n      (Not Modified), then the cache can return its now validated copy\n      to the client with a 200 (OK) response. If the server replies with\n      a new entity and cache validator, however, the intermediate cache\n      can compare the returned validator with the one provided in the\n      client's request, using the strong comparison function. If the\n      client's validator is equal to the origin server's, then the\n      intermediate cache simply returns 304 (Not Modified). Otherwise,\n      it returns the new entity with a 200 (OK) response.\n\n      If a request includes the no-cache directive, it SHOULD NOT\n      include min-fresh, max-stale, or max-age.\n\n   only-if-cached\n      In some cases, such as times of extremely poor network\n      connectivity, a client may want a cache to return only those\n      responses that it currently has stored, and not to reload or\n      revalidate with the origin server. To do this, the client may\n      include the only-if-cached directive in a request. If it receives\n      this directive, a cache SHOULD either respond using a cached entry\n      that is consistent with the other constraints of the request, or\n      respond with a 504 (Gateway Timeout) status. However, if a group\n      of caches is being operated as a unified system with good internal\n      connectivity, such a request MAY be forwarded within that group of\n      caches.\n\n   must-revalidate\n      Because a cache MAY be configured to ignore a server's specified\n      expiration time, and because a client request MAY include a max-\n      stale directive (which has a similar effect), the protocol also\n      includes a mechanism for the origin server to require revalidation\n      of a cache entry on any subsequent use. When the must-revalidate\n      directive is present in a response received by a cache, that cache\n      MUST NOT use the entry after it becomes stale to respond to a\n\n\n\nFielding, et al.            Standards Track                   [Page 114]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      subsequent request without first revalidating it with the origin\n      server. (I.e., the cache MUST do an end-to-end revalidation every\n      time, if, based solely on the origin server's Expires or max-age\n      value, the cached response is stale.)\n\n      The must-revalidate directive is necessary to support reliable\n      operation for certain protocol features. In all circumstances an\n      HTTP/1.1 cache MUST obey the must-revalidate directive; in\n      particular, if the cache cannot reach the origin server for any\n      reason, it MUST generate a 504 (Gateway Timeout) response."
      },
      {
        "chunk_id": "rfc_http_chunk_76",
        "original_index": 76,
        "content": "Servers SHOULD send the must-revalidate directive if and only if\n      failure to revalidate a request on the entity could result in\n      incorrect operation, such as a silently unexecuted financial\n      transaction. Recipients MUST NOT take any automated action that\n      violates this directive, and MUST NOT automatically provide an\n      unvalidated copy of the entity if revalidation fails.\n\n      Although this is not recommended, user agents operating under\n      severe connectivity constraints MAY violate this directive but, if\n      so, MUST explicitly warn the user that an unvalidated response has\n      been provided. The warning MUST be provided on each unvalidated\n      access, and SHOULD require explicit user confirmation.\n\n   proxy-revalidate\n      The proxy-revalidate directive has the same meaning as the must-\n      revalidate directive, except that it does not apply to non-shared\n      user agent caches. It can be used on a response to an\n      authenticated request to permit the user's cache to store and\n      later return the response without needing to revalidate it (since\n      it has already been authenticated once by that user), while still\n      requiring proxies that service many users to revalidate each time\n      (in order to make sure that each user has been authenticated).\n      Note that such authenticated responses also need the public cache\n      control directive in order to allow them to be cached at all.\n\n14.9.5 No-Transform Directive\n\n   no-transform\n      Implementors of intermediate caches (proxies) have found it useful\n      to convert the media type of certain entity bodies. A non-\n      transparent proxy might, for example, convert between image\n      formats in order to save cache space or to reduce the amount of\n      traffic on a slow link.\n\n      Serious operational problems occur, however, when these\n      transformations are applied to entity bodies intended for certain\n      kinds of applications. For example, applications for medical\n\n\n\nFielding, et al.            Standards Track                   [Page 115]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      imaging, scientific data analysis and those using end-to-end\n      authentication, all depend on receiving an entity body that is bit\n      for bit identical to the original entity-body.\n\n      Therefore, if a message includes the no-transform directive, an\n      intermediate cache or proxy MUST NOT change those headers that are\n      listed in section 13.5.2 as being subject to the no-transform\n      directive. This implies that the cache or proxy MUST NOT change\n      any aspect of the entity-body that is specified by these headers,\n      including the value of the entity-body itself.\n\n14.9.6 Cache Control Extensions\n\n   The Cache-Control header field can be extended through the use of one\n   or more cache-extension tokens, each with an optional assigned value.\n   Informational extensions (those which do not require a change in\n   cache behavior) MAY be added without changing the semantics of other\n   directives. Behavioral extensions are designed to work by acting as\n   modifiers to the existing base of cache directives. Both the new\n   directive and the standard directive are supplied, such that\n   applications which do not understand the new directive will default\n   to the behavior specified by the standard directive, and those that\n   understand the new directive will recognize it as modifying the\n   requirements associated with the standard directive. In this way,\n   extensions to the cache-control directives can be made without\n   requiring changes to the base protocol.\n\n   This extension mechanism depends on an HTTP cache obeying all of the\n   cache-control directives defined for its native HTTP-version, obeying\n   certain extensions, and ignoring all directives that it does not\n   understand."
      },
      {
        "chunk_id": "rfc_http_chunk_77",
        "original_index": 77,
        "content": "For example, consider a hypothetical new response directive called\n   community which acts as a modifier to the private directive. We\n   define this new directive to mean that, in addition to any non-shared\n   cache, any cache which is shared only by members of the community\n   named within its value may cache the response. An origin server\n   wishing to allow the UCI community to use an otherwise private\n   response in their shared cache(s) could do so by including\n\n       Cache-Control: private, community=\"UCI\"\n\n   A cache seeing this header field will act correctly even if the cache\n   does not understand the community cache-extension, since it will also\n   see and understand the private directive and thus default to the safe\n   behavior.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 116]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Unrecognized cache-directives MUST be ignored; it is assumed that any\n   cache-directive likely to be unrecognized by an HTTP/1.1 cache will\n   be combined with standard directives (or the response's default\n   cacheability) such that the cache behavior will remain minimally\n   correct even if the cache does not understand the extension(s).\n\n14.10 Connection\n\n   The Connection general-header field allows the sender to specify\n   options that are desired for that particular connection and MUST NOT\n   be communicated by proxies over further connections.\n\n   The Connection header has the following grammar:\n\n       Connection = \"Connection\" \":\" 1#(connection-token)\n       connection-token  = token\n\n   HTTP/1.1 proxies MUST parse the Connection header field before a\n   message is forwarded and, for each connection-token in this field,\n   remove any header field(s) from the message with the same name as the\n   connection-token. Connection options are signaled by the presence of\n   a connection-token in the Connection header field, not by any\n   corresponding additional header field(s), since the additional header\n   field may not be sent if there are no parameters associated with that\n   connection option.\n\n   Message headers listed in the Connection header MUST NOT include\n   end-to-end headers, such as Cache-Control.\n\n   HTTP/1.1 defines the \"close\" connection option for the sender to\n   signal that the connection will be closed after completion of the\n   response. For example,\n\n       Connection: close\n\n   in either the request or the response header fields indicates that\n   the connection SHOULD NOT be considered `persistent' (section 8.1)\n   after the current request/response is complete.\n\n   HTTP/1.1 applications that do not support persistent connections MUST\n   include the \"close\" connection option in every message.\n\n   A system receiving an HTTP/1.0 (or lower-version) message that\n   includes a Connection header MUST, for each connection-token in this\n   field, remove and ignore any header field(s) from the message with\n   the same name as the connection-token. This protects against mistaken\n   forwarding of such header fields by pre-HTTP/1.1 proxies. See section\n   19.6.2.\n\n\n\nFielding, et al.            Standards Track                   [Page 117]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.11 Content-Encoding\n\n   The Content-Encoding entity-header field is used as a modifier to the\n   media-type. When present, its value indicates what additional content\n   codings have been applied to the entity-body, and thus what decoding\n   mechanisms must be applied in order to obtain the media-type\n   referenced by the Content-Type header field. Content-Encoding is\n   primarily used to allow a document to be compressed without losing\n   the identity of its underlying media type.\n\n       Content-Encoding  = \"Content-Encoding\" \":\" 1#content-coding\n\n   Content codings are defined in section 3.5. An example of its use is\n\n       Content-Encoding: gzip"
      },
      {
        "chunk_id": "rfc_http_chunk_78",
        "original_index": 78,
        "content": "Content-Encoding  = \"Content-Encoding\" \":\" 1#content-coding\n\n   Content codings are defined in section 3.5. An example of its use is\n\n       Content-Encoding: gzip\n\n   The content-coding is a characteristic of the entity identified by\n   the Request-URI. Typically, the entity-body is stored with this\n   encoding and is only decoded before rendering or analogous usage.\n   However, a non-transparent proxy MAY modify the content-coding if the\n   new coding is known to be acceptable to the recipient, unless the\n   \"no-transform\" cache-control directive is present in the message.\n\n   If the content-coding of an entity is not \"identity\", then the\n   response MUST include a Content-Encoding entity-header (section\n   14.11) that lists the non-identity content-coding(s) used.\n\n   If the content-coding of an entity in a request message is not\n   acceptable to the origin server, the server SHOULD respond with a\n   status code of 415 (Unsupported Media Type).\n\n   If multiple encodings have been applied to an entity, the content\n   codings MUST be listed in the order in which they were applied.\n   Additional information about the encoding parameters MAY be provided\n   by other entity-header fields not defined by this specification.\n\n14.12 Content-Language\n\n   The Content-Language entity-header field describes the natural\n   language(s) of the intended audience for the enclosed entity. Note\n   that this might not be equivalent to all the languages used within\n   the entity-body.\n\n       Content-Language  = \"Content-Language\" \":\" 1#language-tag\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 118]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Language tags are defined in section 3.10. The primary purpose of\n   Content-Language is to allow a user to identify and differentiate\n   entities according to the user's own preferred language. Thus, if the\n   body content is intended only for a Danish-literate audience, the\n   appropriate field is\n\n       Content-Language: da\n\n   If no Content-Language is specified, the default is that the content\n   is intended for all language audiences. This might mean that the\n   sender does not consider it to be specific to any natural language,\n   or that the sender does not know for which language it is intended.\n\n   Multiple languages MAY be listed for content that is intended for\n   multiple audiences. For example, a rendition of the \"Treaty of\n   Waitangi,\" presented simultaneously in the original Maori and English\n   versions, would call for\n\n       Content-Language: mi, en\n\n   However, just because multiple languages are present within an entity\n   does not mean that it is intended for multiple linguistic audiences.\n   An example would be a beginner's language primer, such as \"A First\n   Lesson in Latin,\" which is clearly intended to be used by an\n   English-literate audience. In this case, the Content-Language would\n   properly only include \"en\".\n\n   Content-Language MAY be applied to any media type -- it is not\n   limited to textual documents.\n\n14.13 Content-Length\n\n   The Content-Length entity-header field indicates the size of the\n   entity-body, in decimal number of OCTETs, sent to the recipient or,\n   in the case of the HEAD method, the size of the entity-body that\n   would have been sent had the request been a GET.\n\n       Content-Length    = \"Content-Length\" \":\" 1*DIGIT\n\n   An example is\n\n       Content-Length: 3495\n\n   Applications SHOULD use this field to indicate the transfer-length of\n   the message-body, unless this is prohibited by the rules in section\n   4.4.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 119]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Any Content-Length greater than or equal to zero is a valid value.\n   Section 4.4 describes how to determine the length of a message-body\n   if a Content-Length is not given."
      },
      {
        "chunk_id": "rfc_http_chunk_79",
        "original_index": 79,
        "content": "Any Content-Length greater than or equal to zero is a valid value.\n   Section 4.4 describes how to determine the length of a message-body\n   if a Content-Length is not given.\n\n   Note that the meaning of this field is significantly different from\n   the corresponding definition in MIME, where it is an optional field\n   used within the \"message/external-body\" content-type. In HTTP, it\n   SHOULD be sent whenever the message's length can be determined prior\n   to being transferred, unless this is prohibited by the rules in\n   section 4.4.\n\n14.14 Content-Location\n\n   The Content-Location entity-header field MAY be used to supply the\n   resource location for the entity enclosed in the message when that\n   entity is accessible from a location separate from the requested\n   resource's URI. A server SHOULD provide a Content-Location for the\n   variant corresponding to the response entity; especially in the case\n   where a resource has multiple entities associated with it, and those\n   entities actually have separate locations by which they might be\n   individually accessed, the server SHOULD provide a Content-Location\n   for the particular variant which is returned.\n\n       Content-Location = \"Content-Location\" \":\"\n                         ( absoluteURI | relativeURI )\n\n   The value of Content-Location also defines the base URI for the\n   entity.\n\n   The Content-Location value is not a replacement for the original\n   requested URI; it is only a statement of the location of the resource\n   corresponding to this particular entity at the time of the request.\n   Future requests MAY specify the Content-Location URI as the request-\n   URI if the desire is to identify the source of that particular\n   entity.\n\n   A cache cannot assume that an entity with a Content-Location\n   different from the URI used to retrieve it can be used to respond to\n   later requests on that Content-Location URI. However, the Content-\n   Location can be used to differentiate between multiple entities\n   retrieved from a single requested resource, as described in section\n   13.6.\n\n   If the Content-Location is a relative URI, the relative URI is\n   interpreted relative to the Request-URI.\n\n   The meaning of the Content-Location header in PUT or POST requests is\n   undefined; servers are free to ignore it in those cases.\n\n\n\nFielding, et al.            Standards Track                   [Page 120]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.15 Content-MD5\n\n   The Content-MD5 entity-header field, as defined in RFC 1864 [23], is\n   an MD5 digest of the entity-body for the purpose of providing an\n   end-to-end message integrity check (MIC) of the entity-body. (Note: a\n   MIC is good for detecting accidental modification of the entity-body\n   in transit, but is not proof against malicious attacks.)\n\n        Content-MD5   = \"Content-MD5\" \":\" md5-digest\n        md5-digest   = <base64 of 128 bit MD5 digest as per RFC 1864>\n\n   The Content-MD5 header field MAY be generated by an origin server or\n   client to function as an integrity check of the entity-body. Only\n   origin servers or clients MAY generate the Content-MD5 header field;\n   proxies and gateways MUST NOT generate it, as this would defeat its\n   value as an end-to-end integrity check. Any recipient of the entity-\n   body, including gateways and proxies, MAY check that the digest value\n   in this header field matches that of the entity-body as received.\n\n   The MD5 digest is computed based on the content of the entity-body,\n   including any content-coding that has been applied, but not including\n   any transfer-encoding applied to the message-body. If the message is\n   received with a transfer-encoding, that encoding MUST be removed\n   prior to checking the Content-MD5 value against the received entity."
      },
      {
        "chunk_id": "rfc_http_chunk_80",
        "original_index": 80,
        "content": "This has the result that the digest is computed on the octets of the\n   entity-body exactly as, and in the order that, they would be sent if\n   no transfer-encoding were being applied.\n\n   HTTP extends RFC 1864 to permit the digest to be computed for MIME\n   composite media-types (e.g., multipart/* and message/rfc822), but\n   this does not change how the digest is computed as defined in the\n   preceding paragraph.\n\n   There are several consequences of this. The entity-body for composite\n   types MAY contain many body-parts, each with its own MIME and HTTP\n   headers (including Content-MD5, Content-Transfer-Encoding, and\n   Content-Encoding headers). If a body-part has a Content-Transfer-\n   Encoding or Content-Encoding header, it is assumed that the content\n   of the body-part has had the encoding applied, and the body-part is\n   included in the Content-MD5 digest as is -- i.e., after the\n   application. The Transfer-Encoding header field is not allowed within\n   body-parts.\n\n   Conversion of all line breaks to CRLF MUST NOT be done before\n   computing or checking the digest: the line break convention used in\n   the text actually transmitted MUST be left unaltered when computing\n   the digest.\n\n\n\nFielding, et al.            Standards Track                   [Page 121]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      Note: while the definition of Content-MD5 is exactly the same for\n      HTTP as in RFC 1864 for MIME entity-bodies, there are several ways\n      in which the application of Content-MD5 to HTTP entity-bodies\n      differs from its application to MIME entity-bodies. One is that\n      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and\n      does use Transfer-Encoding and Content-Encoding. Another is that\n      HTTP more frequently uses binary content types than MIME, so it is\n      worth noting that, in such cases, the byte order used to compute\n      the digest is the transmission byte order defined for the type.\n      Lastly, HTTP allows transmission of text types with any of several\n      line break conventions and not just the canonical form using CRLF.\n\n14.16 Content-Range\n\n   The Content-Range entity-header is sent with a partial entity-body to\n   specify where in the full entity-body the partial body should be\n   applied. Range units are defined in section 3.12.\n\n       Content-Range = \"Content-Range\" \":\" content-range-spec\n\n       content-range-spec      = byte-content-range-spec\n       byte-content-range-spec = bytes-unit SP\n                                 byte-range-resp-spec \"/\"\n                                 ( instance-length | \"*\" )\n\n       byte-range-resp-spec = (first-byte-pos \"-\" last-byte-pos)\n                                      | \"*\"\n       instance-length           = 1*DIGIT\n\n   The header SHOULD indicate the total length of the full entity-body,\n   unless this length is unknown or difficult to determine. The asterisk\n   \"*\" character means that the instance-length is unknown at the time\n   when the response was generated.\n\n   Unlike byte-ranges-specifier values (see section 14.35.1), a byte-\n   range-resp-spec MUST only specify one range, and MUST contain\n   absolute byte positions for both the first and last byte of the\n   range.\n\n   A byte-content-range-spec with a byte-range-resp-spec whose last-\n   byte-pos value is less than its first-byte-pos value, or whose\n   instance-length value is less than or equal to its last-byte-pos\n   value, is invalid. The recipient of an invalid byte-content-range-\n   spec MUST ignore it and any content transferred along with it.\n\n   A server sending a response with status code 416 (Requested range not\n   satisfiable) SHOULD include a Content-Range field with a byte-range-\n   resp-spec of \"*\". The instance-length specifies the current length of\n\n\n\nFielding, et al.            Standards Track                   [Page 122]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_81",
        "original_index": 81,
        "content": "Fielding, et al.            Standards Track                   [Page 122]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the selected resource. A response with status code 206 (Partial\n   Content) MUST NOT include a Content-Range field with a byte-range-\n   resp-spec of \"*\".\n\n   Examples of byte-content-range-spec values, assuming that the entity\n   contains a total of 1234 bytes:\n\n      . The first 500 bytes:\n       bytes 0-499/1234\n\n      . The second 500 bytes:\n       bytes 500-999/1234\n\n      . All except for the first 500 bytes:\n       bytes 500-1233/1234\n\n      . The last 500 bytes:\n       bytes 734-1233/1234\n\n   When an HTTP message includes the content of a single range (for\n   example, a response to a request for a single range, or to a request\n   for a set of ranges that overlap without any holes), this content is\n   transmitted with a Content-Range header, and a Content-Length header\n   showing the number of bytes actually transferred. For example,\n\n       HTTP/1.1 206 Partial content\n       Date: Wed, 15 Nov 1995 06:25:24 GMT\n       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n       Content-Range: bytes 21010-47021/47022\n       Content-Length: 26012\n       Content-Type: image/gif\n\n   When an HTTP message includes the content of multiple ranges (for\n   example, a response to a request for multiple non-overlapping\n   ranges), these are transmitted as a multipart message. The multipart\n   media type used for this purpose is \"multipart/byteranges\" as defined\n   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.\n\n   A response to a request for a single range MUST NOT be sent using the\n   multipart/byteranges media type.  A response to a request for\n   multiple ranges, whose result is a single range, MAY be sent as a\n   multipart/byteranges media type with one part. A client that cannot\n   decode a multipart/byteranges message MUST NOT ask for multiple\n   byte-ranges in a single request.\n\n   When a client requests multiple byte-ranges in one request, the\n   server SHOULD return them in the order that they appeared in the\n   request.\n\n\n\nFielding, et al.            Standards Track                   [Page 123]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the server ignores a byte-range-spec because it is syntactically\n   invalid, the server SHOULD treat the request as if the invalid Range\n   header field did not exist. (Normally, this means return a 200\n   response containing the full entity).\n\n   If the server receives a request (other than one including an If-\n   Range request-header field) with an unsatisfiable Range request-\n   header field (that is, all of whose byte-range-spec values have a\n   first-byte-pos value greater than the current length of the selected\n   resource), it SHOULD return a response code of 416 (Requested range\n   not satisfiable) (section 10.4.17).\n\n      Note: clients cannot depend on servers to send a 416 (Requested\n      range not satisfiable) response instead of a 200 (OK) response for\n      an unsatisfiable Range request-header, since not all servers\n      implement this request-header.\n\n14.17 Content-Type\n\n   The Content-Type entity-header field indicates the media type of the\n   entity-body sent to the recipient or, in the case of the HEAD method,\n   the media type that would have been sent had the request been a GET.\n\n       Content-Type   = \"Content-Type\" \":\" media-type\n\n   Media types are defined in section 3.7. An example of the field is\n\n       Content-Type: text/html; charset=ISO-8859-4\n\n   Further discussion of methods for identifying the media type of an\n   entity is provided in section 7.2.1.\n\n14.18 Date\n\n   The Date general-header field represents the date and time at which\n   the message was originated, having the same semantics as orig-date in\n   RFC 822. The field value is an HTTP-date, as described in section\n   3.3.1; it MUST be sent in RFC 1123 [8]-date format."
      },
      {
        "chunk_id": "rfc_http_chunk_82",
        "original_index": 82,
        "content": "Date  = \"Date\" \":\" HTTP-date\n\n   An example is\n\n       Date: Tue, 15 Nov 1994 08:12:31 GMT\n\n   Origin servers MUST include a Date header field in all responses,\n   except in these cases:\n\n\n\n\nFielding, et al.            Standards Track                   [Page 124]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      1. If the response status code is 100 (Continue) or 101 (Switching\n         Protocols), the response MAY include a Date header field, at\n         the server's option.\n\n      2. If the response status code conveys a server error, e.g. 500\n         (Internal Server Error) or 503 (Service Unavailable), and it is\n         inconvenient or impossible to generate a valid Date.\n\n      3. If the server does not have a clock that can provide a\n         reasonable approximation of the current time, its responses\n         MUST NOT include a Date header field. In this case, the rules\n         in section 14.18.1 MUST be followed.\n\n   A received message that does not have a Date header field MUST be\n   assigned one by the recipient if the message will be cached by that\n   recipient or gatewayed via a protocol which requires a Date. An HTTP\n   implementation without a clock MUST NOT cache responses without\n   revalidating them on every use. An HTTP cache, especially a shared\n   cache, SHOULD use a mechanism, such as NTP [28], to synchronize its\n   clock with a reliable external standard.\n\n   Clients SHOULD only send a Date header field in messages that include\n   an entity-body, as in the case of the PUT and POST requests, and even\n   then it is optional. A client without a clock MUST NOT send a Date\n   header field in a request.\n\n   The HTTP-date sent in a Date header SHOULD NOT represent a date and\n   time subsequent to the generation of the message. It SHOULD represent\n   the best available approximation of the date and time of message\n   generation, unless the implementation has no means of generating a\n   reasonably accurate date and time. In theory, the date ought to\n   represent the moment just before the entity is generated. In\n   practice, the date can be generated at any time during the message\n   origination without affecting its semantic value.\n\n14.18.1 Clockless Origin Server Operation\n\n   Some origin server implementations might not have a clock available.\n   An origin server without a clock MUST NOT assign Expires or Last-\n   Modified values to a response, unless these values were associated\n   with the resource by a system or user with a reliable clock. It MAY\n   assign an Expires value that is known, at or before server\n   configuration time, to be in the past (this allows \"pre-expiration\"\n   of responses without storing separate Expires values for each\n   resource).\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 125]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.19 ETag\n\n   The ETag response-header field provides the current value of the\n   entity tag for the requested variant. The headers used with entity\n   tags are described in sections 14.24, 14.26 and 14.44. The entity tag\n   MAY be used for comparison with other entities from the same resource\n   (see section 13.3.3).\n\n      ETag = \"ETag\" \":\" entity-tag\n\n   Examples:\n\n      ETag: \"xyzzy\"\n      ETag: W/\"xyzzy\"\n      ETag: \"\"\n\n14.20 Expect\n\n   The Expect request-header field is used to indicate that particular\n   server behaviors are required by the client.\n\n      Expect       =  \"Expect\" \":\" 1#expectation\n\n      expectation  =  \"100-continue\" | expectation-extension\n      expectation-extension =  token [ \"=\" ( token | quoted-string )\n                               *expect-params ]\n      expect-params =  \";\" token [ \"=\" ( token | quoted-string ) ]"
      },
      {
        "chunk_id": "rfc_http_chunk_83",
        "original_index": 83,
        "content": "A server that does not understand or is unable to comply with any of\n   the expectation values in the Expect field of a request MUST respond\n   with appropriate error status. The server MUST respond with a 417\n   (Expectation Failed) status if any of the expectations cannot be met\n   or, if there are other problems with the request, some other 4xx\n   status.\n\n   This header field is defined with extensible syntax to allow for\n   future extensions. If a server receives a request containing an\n   Expect field that includes an expectation-extension that it does not\n   support, it MUST respond with a 417 (Expectation Failed) status.\n\n   Comparison of expectation values is case-insensitive for unquoted\n   tokens (including the 100-continue token), and is case-sensitive for\n   quoted-string expectation-extensions.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 126]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST\n   return a 417 (Expectation Failed) status if it receives a request\n   with an expectation that it cannot meet. However, the Expect\n   request-header itself is end-to-end; it MUST be forwarded if the\n   request is forwarded.\n\n   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the\n   Expect header.\n\n   See section 8.2.3 for the use of the 100 (continue) status.\n\n14.21 Expires\n\n   The Expires entity-header field gives the date/time after which the\n   response is considered stale. A stale cache entry may not normally be\n   returned by a cache (either a proxy cache or a user agent cache)\n   unless it is first validated with the origin server (or with an\n   intermediate cache that has a fresh copy of the entity). See section\n   13.2 for further discussion of the expiration model.\n\n   The presence of an Expires field does not imply that the original\n   resource will change or cease to exist at, before, or after that\n   time.\n\n   The format is an absolute date and time as defined by HTTP-date in\n   section 3.3.1; it MUST be in RFC 1123 date format:\n\n      Expires = \"Expires\" \":\" HTTP-date\n\n   An example of its use is\n\n      Expires: Thu, 01 Dec 1994 16:00:00 GMT\n\n      Note: if a response includes a Cache-Control field with the max-\n      age directive (see section 14.9.3), that directive overrides the\n      Expires field.\n\n   HTTP/1.1 clients and caches MUST treat other invalid date formats,\n   especially including the value \"0\", as in the past (i.e., \"already\n   expired\").\n\n   To mark a response as \"already expired,\" an origin server sends an\n   Expires date that is equal to the Date header value. (See the rules\n   for expiration calculations in section 13.2.4.)\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 127]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   To mark a response as \"never expires,\" an origin server sends an\n   Expires date approximately one year from the time the response is\n   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one\n   year in the future.\n\n   The presence of an Expires header field with a date value of some\n   time in the future on a response that otherwise would by default be\n   non-cacheable indicates that the response is cacheable, unless\n   indicated otherwise by a Cache-Control header field (section 14.9).\n\n14.22 From\n\n   The From request-header field, if given, SHOULD contain an Internet\n   e-mail address for the human user who controls the requesting user\n   agent. The address SHOULD be machine-usable, as defined by \"mailbox\"\n   in RFC 822 [9] as updated by RFC 1123 [8]:\n\n       From   = \"From\" \":\" mailbox\n\n   An example is:\n\n       From: webmaster@w3.org"
      },
      {
        "chunk_id": "rfc_http_chunk_84",
        "original_index": 84,
        "content": "From   = \"From\" \":\" mailbox\n\n   An example is:\n\n       From: webmaster@w3.org\n\n   This header field MAY be used for logging purposes and as a means for\n   identifying the source of invalid or unwanted requests. It SHOULD NOT\n   be used as an insecure form of access protection. The interpretation\n   of this field is that the request is being performed on behalf of the\n   person given, who accepts responsibility for the method performed. In\n   particular, robot agents SHOULD include this header so that the\n   person responsible for running the robot can be contacted if problems\n   occur on the receiving end.\n\n   The Internet e-mail address in this field MAY be separate from the\n   Internet host which issued the request. For example, when a request\n   is passed through a proxy the original issuer's address SHOULD be\n   used.\n\n   The client SHOULD NOT send the From header field without the user's\n   approval, as it might conflict with the user's privacy interests or\n   their site's security policy. It is strongly recommended that the\n   user be able to disable, enable, and modify the value of this field\n   at any time prior to a request.\n\n14.23 Host\n\n   The Host request-header field specifies the Internet host and port\n   number of the resource being requested, as obtained from the original\n   URI given by the user or referring resource (generally an HTTP URL,\n\n\n\nFielding, et al.            Standards Track                   [Page 128]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   as described in section 3.2.2). The Host field value MUST represent\n   the naming authority of the origin server or gateway given by the\n   original URL. This allows the origin server or gateway to\n   differentiate between internally-ambiguous URLs, such as the root \"/\"\n   URL of a server for multiple host names on a single IP address.\n\n       Host = \"Host\" \":\" host [ \":\" port ] ; Section 3.2.2\n\n   A \"host\" without any trailing port information implies the default\n   port for the service requested (e.g., \"80\" for an HTTP URL). For\n   example, a request on the origin server for\n   <http://www.w3.org/pub/WWW/> would properly include:\n\n       GET /pub/WWW/ HTTP/1.1\n       Host: www.w3.org\n\n   A client MUST include a Host header field in all HTTP/1.1 request\n   messages . If the requested URI does not include an Internet host\n   name for the service being requested, then the Host header field MUST\n   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any\n   request message it forwards does contain an appropriate Host header\n   field that identifies the service being requested by the proxy. All\n   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)\n   status code to any HTTP/1.1 request message which lacks a Host header\n   field.\n\n   See sections 5.2 and 19.6.1.1 for other requirements relating to\n   Host.\n\n14.24 If-Match\n\n   The If-Match request-header field is used with a method to make it\n   conditional. A client that has one or more entities previously\n   obtained from the resource can verify that one of those entities is\n   current by including a list of their associated entity tags in the\n   If-Match header field. Entity tags are defined in section 3.11. The\n   purpose of this feature is to allow efficient updates of cached\n   information with a minimum amount of transaction overhead. It is also\n   used, on updating requests, to prevent inadvertent modification of\n   the wrong version of a resource. As a special case, the value \"*\"\n   matches any current entity of the resource.\n\n       If-Match = \"If-Match\" \":\" ( \"*\" | 1#entity-tag )\n\n   If any of the entity tags match the entity tag of the entity that\n   would have been returned in the response to a similar GET request\n   (without the If-Match header) on that resource, or if \"*\" is given"
      },
      {
        "chunk_id": "rfc_http_chunk_85",
        "original_index": 85,
        "content": "Fielding, et al.            Standards Track                   [Page 129]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   and any current entity exists for that resource, then the server MAY\n   perform the requested method as if the If-Match header field did not\n   exist.\n\n   A server MUST use the strong comparison function (see section 13.3.3)\n   to compare the entity tags in If-Match.\n\n   If none of the entity tags match, or if \"*\" is given and no current\n   entity exists, the server MUST NOT perform the requested method, and\n   MUST return a 412 (Precondition Failed) response. This behavior is\n   most useful when the client wants to prevent an updating method, such\n   as PUT, from modifying a resource that has changed since the client\n   last retrieved it.\n\n   If the request would, without the If-Match header field, result in\n   anything other than a 2xx or 412 status, then the If-Match header\n   MUST be ignored.\n\n   The meaning of \"If-Match: *\" is that the method SHOULD be performed\n   if the representation selected by the origin server (or by a cache,\n   possibly using the Vary mechanism, see section 14.44) exists, and\n   MUST NOT be performed if the representation does not exist.\n\n   A request intended to update a resource (e.g., a PUT) MAY include an\n   If-Match header field to signal that the request method MUST NOT be\n   applied if the entity corresponding to the If-Match value (a single\n   entity tag) is no longer a representation of that resource. This\n   allows the user to indicate that they do not wish the request to be\n   successful if the resource has been changed without their knowledge.\n   Examples:\n\n       If-Match: \"xyzzy\"\n       If-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n       If-Match: *\n\n   The result of a request having both an If-Match header field and\n   either an If-None-Match or an If-Modified-Since header fields is\n   undefined by this specification.\n\n14.25 If-Modified-Since\n\n   The If-Modified-Since request-header field is used with a method to\n   make it conditional: if the requested variant has not been modified\n   since the time specified in this field, an entity will not be\n   returned from the server; instead, a 304 (not modified) response will\n   be returned without any message-body.\n\n       If-Modified-Since = \"If-Modified-Since\" \":\" HTTP-date\n\n\n\nFielding, et al.            Standards Track                   [Page 130]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   An example of the field is:\n\n       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n   A GET method with an If-Modified-Since header and no Range header\n   requests that the identified entity be transferred only if it has\n   been modified since the date given by the If-Modified-Since header.\n   The algorithm for determining this includes the following cases:\n\n      a) If the request would normally result in anything other than a\n         200 (OK) status, or if the passed If-Modified-Since date is\n         invalid, the response is exactly the same as for a normal GET.\n         A date which is later than the server's current time is\n         invalid.\n\n      b) If the variant has been modified since the If-Modified-Since\n         date, the response is exactly the same as for a normal GET.\n\n      c) If the variant has not been modified since a valid If-\n         Modified-Since date, the server SHOULD return a 304 (Not\n         Modified) response.\n\n   The purpose of this feature is to allow efficient updates of cached\n   information with a minimum amount of transaction overhead.\n\n      Note: The Range request-header field modifies the meaning of If-\n      Modified-Since; see section 14.35 for full details.\n\n      Note: If-Modified-Since times are interpreted by the server, whose\n      clock might not be synchronized with the client."
      },
      {
        "chunk_id": "rfc_http_chunk_86",
        "original_index": 86,
        "content": "Note: If-Modified-Since times are interpreted by the server, whose\n      clock might not be synchronized with the client.\n\n      Note: When handling an If-Modified-Since header field, some\n      servers will use an exact date comparison function, rather than a\n      less-than function, for deciding whether to send a 304 (Not\n      Modified) response. To get best results when sending an If-\n      Modified-Since header field for cache validation, clients are\n      advised to use the exact date string received in a previous Last-\n      Modified header field whenever possible.\n\n      Note: If a client uses an arbitrary date in the If-Modified-Since\n      header instead of a date taken from the Last-Modified header for\n      the same request, the client should be aware of the fact that this\n      date is interpreted in the server's understanding of time. The\n      client should consider unsynchronized clocks and rounding problems\n      due to the different encodings of time between the client and\n      server. This includes the possibility of race conditions if the\n      document has changed between the time it was first requested and\n      the If-Modified-Since date of a subsequent request, and the\n\n\n\nFielding, et al.            Standards Track                   [Page 131]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      possibility of clock-skew-related problems if the If-Modified-\n      Since date is derived from the client's clock without correction\n      to the server's clock. Corrections for different time bases\n      between client and server are at best approximate due to network\n      latency.\n\n   The result of a request having both an If-Modified-Since header field\n   and either an If-Match or an If-Unmodified-Since header fields is\n   undefined by this specification.\n\n14.26 If-None-Match\n\n   The If-None-Match request-header field is used with a method to make\n   it conditional. A client that has one or more entities previously\n   obtained from the resource can verify that none of those entities is\n   current by including a list of their associated entity tags in the\n   If-None-Match header field. The purpose of this feature is to allow\n   efficient updates of cached information with a minimum amount of\n   transaction overhead. It is also used to prevent a method (e.g. PUT)\n   from inadvertently modifying an existing resource when the client\n   believes that the resource does not exist.\n\n   As a special case, the value \"*\" matches any current entity of the\n   resource.\n\n       If-None-Match = \"If-None-Match\" \":\" ( \"*\" | 1#entity-tag )\n\n   If any of the entity tags match the entity tag of the entity that\n   would have been returned in the response to a similar GET request\n   (without the If-None-Match header) on that resource, or if \"*\" is\n   given and any current entity exists for that resource, then the\n   server MUST NOT perform the requested method, unless required to do\n   so because the resource's modification date fails to match that\n   supplied in an If-Modified-Since header field in the request.\n   Instead, if the request method was GET or HEAD, the server SHOULD\n   respond with a 304 (Not Modified) response, including the cache-\n   related header fields (particularly ETag) of one of the entities that\n   matched. For all other request methods, the server MUST respond with\n   a status of 412 (Precondition Failed).\n\n   See section 13.3.3 for rules on how to determine if two entities tags\n   match. The weak comparison function can only be used with GET or HEAD\n   requests.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 132]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_http_chunk_87",
        "original_index": 87,
        "content": "Fielding, et al.            Standards Track                   [Page 132]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If none of the entity tags match, then the server MAY perform the\n   requested method as if the If-None-Match header field did not exist,\n   but MUST also ignore any If-Modified-Since header field(s) in the\n   request. That is, if no entity tags match, then the server MUST NOT\n   return a 304 (Not Modified) response.\n\n   If the request would, without the If-None-Match header field, result\n   in anything other than a 2xx or 304 status, then the If-None-Match\n   header MUST be ignored. (See section 13.3.4 for a discussion of\n   server behavior when both If-Modified-Since and If-None-Match appear\n   in the same request.)\n\n   The meaning of \"If-None-Match: *\" is that the method MUST NOT be\n   performed if the representation selected by the origin server (or by\n   a cache, possibly using the Vary mechanism, see section 14.44)\n   exists, and SHOULD be performed if the representation does not exist.\n   This feature is intended to be useful in preventing races between PUT\n   operations.\n\n   Examples:\n\n       If-None-Match: \"xyzzy\"\n       If-None-Match: W/\"xyzzy\"\n       If-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n       If-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"\n       If-None-Match: *\n\n   The result of a request having both an If-None-Match header field and\n   either an If-Match or an If-Unmodified-Since header fields is\n   undefined by this specification.\n\n14.27 If-Range\n\n   If a client has a partial copy of an entity in its cache, and wishes\n   to have an up-to-date copy of the entire entity in its cache, it\n   could use the Range request-header with a conditional GET (using\n   either or both of If-Unmodified-Since and If-Match.) However, if the\n   condition fails because the entity has been modified, the client\n   would then have to make a second request to obtain the entire current\n   entity-body.\n\n   The If-Range header allows a client to \"short-circuit\" the second\n   request. Informally, its meaning is `if the entity is unchanged, send\n   me the part(s) that I am missing; otherwise, send me the entire new\n   entity'.\n\n        If-Range = \"If-Range\" \":\" ( entity-tag | HTTP-date )\n\n\n\n\nFielding, et al.            Standards Track                   [Page 133]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the client has no entity tag for an entity, but does have a Last-\n   Modified date, it MAY use that date in an If-Range header. (The\n   server can distinguish between a valid HTTP-date and any form of\n   entity-tag by examining no more than two characters.) The If-Range\n   header SHOULD only be used together with a Range header, and MUST be\n   ignored if the request does not include a Range header, or if the\n   server does not support the sub-range operation.\n\n   If the entity tag given in the If-Range header matches the current\n   entity tag for the entity, then the server SHOULD provide the\n   specified sub-range of the entity using a 206 (Partial content)\n   response. If the entity tag does not match, then the server SHOULD\n   return the entire entity using a 200 (OK) response.\n\n14.28 If-Unmodified-Since\n\n   The If-Unmodified-Since request-header field is used with a method to\n   make it conditional. If the requested resource has not been modified\n   since the time specified in this field, the server SHOULD perform the\n   requested operation as if the If-Unmodified-Since header were not\n   present.\n\n   If the requested variant has been modified since the specified time,\n   the server MUST NOT perform the requested operation, and MUST return\n   a 412 (Precondition Failed).\n\n      If-Unmodified-Since = \"If-Unmodified-Since\" \":\" HTTP-date\n\n   An example of the field is:\n\n       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT"
      },
      {
        "chunk_id": "rfc_http_chunk_88",
        "original_index": 88,
        "content": "If-Unmodified-Since = \"If-Unmodified-Since\" \":\" HTTP-date\n\n   An example of the field is:\n\n       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n   If the request normally (i.e., without the If-Unmodified-Since\n   header) would result in anything other than a 2xx or 412 status, the\n   If-Unmodified-Since header SHOULD be ignored.\n\n   If the specified date is invalid, the header is ignored.\n\n   The result of a request having both an If-Unmodified-Since header\n   field and either an If-None-Match or an If-Modified-Since header\n   fields is undefined by this specification.\n\n14.29 Last-Modified\n\n   The Last-Modified entity-header field indicates the date and time at\n   which the origin server believes the variant was last modified.\n\n       Last-Modified  = \"Last-Modified\" \":\" HTTP-date\n\n\n\nFielding, et al.            Standards Track                   [Page 134]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   An example of its use is\n\n       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n\n   The exact meaning of this header field depends on the implementation\n   of the origin server and the nature of the original resource. For\n   files, it may be just the file system last-modified time. For\n   entities with dynamically included parts, it may be the most recent\n   of the set of last-modify times for its component parts. For database\n   gateways, it may be the last-update time stamp of the record. For\n   virtual objects, it may be the last time the internal state changed.\n\n   An origin server MUST NOT send a Last-Modified date which is later\n   than the server's time of message origination. In such cases, where\n   the resource's last modification would indicate some time in the\n   future, the server MUST replace that date with the message\n   origination date.\n\n   An origin server SHOULD obtain the Last-Modified value of the entity\n   as close as possible to the time that it generates the Date value of\n   its response. This allows a recipient to make an accurate assessment\n   of the entity's modification time, especially if the entity changes\n   near the time that the response is generated.\n\n   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.\n\n14.30 Location\n\n   The Location response-header field is used to redirect the recipient\n   to a location other than the Request-URI for completion of the\n   request or identification of a new resource. For 201 (Created)\n   responses, the Location is that of the new resource which was created\n   by the request. For 3xx responses, the location SHOULD indicate the\n   server's preferred URI for automatic redirection to the resource. The\n   field value consists of a single absolute URI.\n\n       Location       = \"Location\" \":\" absoluteURI\n\n   An example is:\n\n       Location: http://www.w3.org/pub/WWW/People.html\n\n      Note: The Content-Location header field (section 14.14) differs\n      from Location in that the Content-Location identifies the original\n      location of the entity enclosed in the request. It is therefore\n      possible for a response to contain header fields for both Location\n      and Content-Location. Also see section 13.10 for cache\n      requirements of some methods.\n\n\n\nFielding, et al.            Standards Track                   [Page 135]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.31 Max-Forwards\n\n   The Max-Forwards request-header field provides a mechanism with the\n   TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit the\n   number of proxies or gateways that can forward the request to the\n   next inbound server. This can be useful when the client is attempting\n   to trace a request chain which appears to be failing or looping in\n   mid-chain.\n\n       Max-Forwards   = \"Max-Forwards\" \":\" 1*DIGIT\n\n   The Max-Forwards value is a decimal integer indicating the remaining\n   number of times this request message may be forwarded."
      },
      {
        "chunk_id": "rfc_http_chunk_89",
        "original_index": 89,
        "content": "Max-Forwards   = \"Max-Forwards\" \":\" 1*DIGIT\n\n   The Max-Forwards value is a decimal integer indicating the remaining\n   number of times this request message may be forwarded.\n\n   Each proxy or gateway recipient of a TRACE or OPTIONS request\n   containing a Max-Forwards header field MUST check and update its\n   value prior to forwarding the request. If the received value is zero\n   (0), the recipient MUST NOT forward the request; instead, it MUST\n   respond as the final recipient. If the received Max-Forwards value is\n   greater than zero, then the forwarded message MUST contain an updated\n   Max-Forwards field with a value decremented by one (1).\n\n   The Max-Forwards header field MAY be ignored for all other methods\n   defined by this specification and for any extension methods for which\n   it is not explicitly referred to as part of that method definition.\n\n14.32 Pragma\n\n   The Pragma general-header field is used to include implementation-\n   specific directives that might apply to any recipient along the\n   request/response chain. All pragma directives specify optional\n   behavior from the viewpoint of the protocol; however, some systems\n   MAY require that behavior be consistent with the directives.\n\n       Pragma            = \"Pragma\" \":\" 1#pragma-directive\n       pragma-directive  = \"no-cache\" | extension-pragma\n       extension-pragma  = token [ \"=\" ( token | quoted-string ) ]\n\n   When the no-cache directive is present in a request message, an\n   application SHOULD forward the request toward the origin server even\n   if it has a cached copy of what is being requested. This pragma\n   directive has the same semantics as the no-cache cache-directive (see\n   section 14.9) and is defined here for backward compatibility with\n   HTTP/1.0. Clients SHOULD include both header fields when a no-cache\n   request is sent to a server not known to be HTTP/1.1 compliant.\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 136]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Pragma directives MUST be passed through by a proxy or gateway\n   application, regardless of their significance to that application,\n   since the directives might be applicable to all recipients along the\n   request/response chain. It is not possible to specify a pragma for a\n   specific recipient; however, any pragma directive not relevant to a\n   recipient SHOULD be ignored by that recipient.\n\n   HTTP/1.1 caches SHOULD treat \"Pragma: no-cache\" as if the client had\n   sent \"Cache-Control: no-cache\". No new Pragma directives will be\n   defined in HTTP.\n\n      Note: because the meaning of \"Pragma: no-cache as a response\n      header field is not actually specified, it does not provide a\n      reliable replacement for \"Cache-Control: no-cache\" in a response\n\n14.33 Proxy-Authenticate\n\n   The Proxy-Authenticate response-header field MUST be included as part\n   of a 407 (Proxy Authentication Required) response. The field value\n   consists of a challenge that indicates the authentication scheme and\n   parameters applicable to the proxy for this Request-URI.\n\n       Proxy-Authenticate  = \"Proxy-Authenticate\" \":\" 1#challenge\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. Unlike\n   WWW-Authenticate, the Proxy-Authenticate header field applies only to\n   the current connection and SHOULD NOT be passed on to downstream\n   clients. However, an intermediate proxy might need to obtain its own\n   credentials by requesting them from the downstream client, which in\n   some circumstances will appear as if the proxy is forwarding the\n   Proxy-Authenticate header field.\n\n14.34 Proxy-Authorization"
      },
      {
        "chunk_id": "rfc_http_chunk_90",
        "original_index": 90,
        "content": "14.34 Proxy-Authorization\n\n   The Proxy-Authorization request-header field allows the client to\n   identify itself (or its user) to a proxy which requires\n   authentication. The Proxy-Authorization field value consists of\n   credentials containing the authentication information of the user\n   agent for the proxy and/or realm of the resource being requested.\n\n       Proxy-Authorization     = \"Proxy-Authorization\" \":\" credentials\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43] . Unlike\n   Authorization, the Proxy-Authorization header field applies only to\n   the next outbound proxy that demanded authentication using the Proxy-\n   Authenticate field. When multiple proxies are used in a chain, the\n\n\n\nFielding, et al.            Standards Track                   [Page 137]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Proxy-Authorization header field is consumed by the first outbound\n   proxy that was expecting to receive credentials. A proxy MAY relay\n   the credentials from the client request to the next proxy if that is\n   the mechanism by which the proxies cooperatively authenticate a given\n   request.\n\n14.35 Range\n\n14.35.1 Byte Ranges\n\n   Since all HTTP entities are represented in HTTP messages as sequences\n   of bytes, the concept of a byte range is meaningful for any HTTP\n   entity. (However, not all clients and servers need to support byte-\n   range operations.)\n\n   Byte range specifications in HTTP apply to the sequence of bytes in\n   the entity-body (not necessarily the same as the message-body).\n\n   A byte range operation MAY specify a single range of bytes, or a set\n   of ranges within a single entity.\n\n       ranges-specifier = byte-ranges-specifier\n       byte-ranges-specifier = bytes-unit \"=\" byte-range-set\n       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )\n       byte-range-spec = first-byte-pos \"-\" [last-byte-pos]\n       first-byte-pos  = 1*DIGIT\n       last-byte-pos   = 1*DIGIT\n\n   The first-byte-pos value in a byte-range-spec gives the byte-offset\n   of the first byte in a range. The last-byte-pos value gives the\n   byte-offset of the last byte in the range; that is, the byte\n   positions specified are inclusive. Byte offsets start at zero.\n\n   If the last-byte-pos value is present, it MUST be greater than or\n   equal to the first-byte-pos in that byte-range-spec, or the byte-\n   range-spec is syntactically invalid. The recipient of a byte-range-\n   set that includes one or more syntactically invalid byte-range-spec\n   values MUST ignore the header field that includes that byte-range-\n   set.\n\n   If the last-byte-pos value is absent, or if the value is greater than\n   or equal to the current length of the entity-body, last-byte-pos is\n   taken to be equal to one less than the current length of the entity-\n   body in bytes.\n\n   By its choice of last-byte-pos, a client can limit the number of\n   bytes retrieved without knowing the size of the entity.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 138]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       suffix-byte-range-spec = \"-\" suffix-length\n       suffix-length = 1*DIGIT\n\n   A suffix-byte-range-spec is used to specify the suffix of the\n   entity-body, of a length given by the suffix-length value. (That is,\n   this form specifies the last N bytes of an entity-body.) If the\n   entity is shorter than the specified suffix-length, the entire\n   entity-body is used."
      },
      {
        "chunk_id": "rfc_http_chunk_91",
        "original_index": 91,
        "content": "If a syntactically valid byte-range-set includes at least one byte-\n   range-spec whose first-byte-pos is less than the current length of\n   the entity-body, or at least one suffix-byte-range-spec with a non-\n   zero suffix-length, then the byte-range-set is satisfiable.\n   Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set\n   is unsatisfiable, the server SHOULD return a response with a status\n   of 416 (Requested range not satisfiable). Otherwise, the server\n   SHOULD return a response with a status of 206 (Partial Content)\n   containing the satisfiable ranges of the entity-body.\n\n   Examples of byte-ranges-specifier values (assuming an entity-body of\n   length 10000):\n\n      - The first 500 bytes (byte offsets 0-499, inclusive):  bytes=0-\n        499\n\n      - The second 500 bytes (byte offsets 500-999, inclusive):\n        bytes=500-999\n\n      - The final 500 bytes (byte offsets 9500-9999, inclusive):\n        bytes=-500\n\n      - Or bytes=9500-\n\n      - The first and last bytes only (bytes 0 and 9999):  bytes=0-0,-1\n\n      - Several legal but not canonical specifications of the second 500\n        bytes (byte offsets 500-999, inclusive):\n         bytes=500-600,601-999\n         bytes=500-700,601-999\n\n14.35.2 Range Retrieval Requests\n\n   HTTP retrieval requests using conditional or unconditional GET\n   methods MAY request one or more sub-ranges of the entity, instead of\n   the entire entity, using the Range request header, which applies to\n   the entity returned as the result of the request:\n\n      Range = \"Range\" \":\" ranges-specifier\n\n\n\nFielding, et al.            Standards Track                   [Page 139]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A server MAY ignore the Range header. However, HTTP/1.1 origin\n   servers and intermediate caches ought to support byte ranges when\n   possible, since Range supports efficient recovery from partially\n   failed transfers, and supports efficient partial retrieval of large\n   entities.\n\n   If the server supports the Range header and the specified range or\n   ranges are appropriate for the entity:\n\n      - The presence of a Range header in an unconditional GET modifies\n        what is returned if the GET is otherwise successful. In other\n        words, the response carries a status code of 206 (Partial\n        Content) instead of 200 (OK).\n\n      - The presence of a Range header in a conditional GET (a request\n        using one or both of If-Modified-Since and If-None-Match, or\n        one or both of If-Unmodified-Since and If-Match) modifies what\n        is returned if the GET is otherwise successful and the\n        condition is true. It does not affect the 304 (Not Modified)\n        response returned if the conditional is false.\n\n   In some cases, it might be more appropriate to use the If-Range\n   header (see section 14.27) in addition to the Range header.\n\n   If a proxy that supports ranges receives a Range request, forwards\n   the request to an inbound server, and receives an entire entity in\n   reply, it SHOULD only return the requested range to its client. It\n   SHOULD store the entire received response in its cache if that is\n   consistent with its cache allocation policies.\n\n14.36 Referer\n\n   The Referer[sic] request-header field allows the client to specify,\n   for the server's benefit, the address (URI) of the resource from\n   which the Request-URI was obtained (the \"referrer\", although the\n   header field is misspelled.) The Referer request-header allows a\n   server to generate lists of back-links to resources for interest,\n   logging, optimized caching, etc. It also allows obsolete or mistyped\n   links to be traced for maintenance. The Referer field MUST NOT be\n   sent if the Request-URI was obtained from a source that does not have\n   its own URI, such as input from the user keyboard.\n\n       Referer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\n\n   Example:"
      },
      {
        "chunk_id": "rfc_http_chunk_92",
        "original_index": 92,
        "content": "Referer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\n\n   Example:\n\n       Referer: http://www.w3.org/hypertext/DataSources/Overview.html\n\n\n\n\nFielding, et al.            Standards Track                   [Page 140]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the field value is a relative URI, it SHOULD be interpreted\n   relative to the Request-URI. The URI MUST NOT include a fragment. See\n   section 15.1.3 for security considerations.\n\n14.37 Retry-After\n\n   The Retry-After response-header field can be used with a 503 (Service\n   Unavailable) response to indicate how long the service is expected to\n   be unavailable to the requesting client. This field MAY also be used\n   with any 3xx (Redirection) response to indicate the minimum time the\n   user-agent is asked wait before issuing the redirected request. The\n   value of this field can be either an HTTP-date or an integer number\n   of seconds (in decimal) after the time of the response.\n\n       Retry-After  = \"Retry-After\" \":\" ( HTTP-date | delta-seconds )\n\n   Two examples of its use are\n\n       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT\n       Retry-After: 120\n\n   In the latter example, the delay is 2 minutes.\n\n14.38 Server\n\n   The Server response-header field contains information about the\n   software used by the origin server to handle the request. The field\n   can contain multiple product tokens (section 3.8) and comments\n   identifying the server and any significant subproducts. The product\n   tokens are listed in order of their significance for identifying the\n   application.\n\n       Server         = \"Server\" \":\" 1*( product | comment )\n\n   Example:\n\n       Server: CERN/3.0 libwww/2.17\n\n   If the response is being forwarded through a proxy, the proxy\n   application MUST NOT modify the Server response-header. Instead, it\n   SHOULD include a Via field (as described in section 14.45).\n\n      Note: Revealing the specific software version of the server might\n      allow the server machine to become more vulnerable to attacks\n      against software that is known to contain security holes. Server\n      implementors are encouraged to make this field a configurable\n      option.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 141]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.39 TE\n\n   The TE request-header field indicates what extension transfer-codings\n   it is willing to accept in the response and whether or not it is\n   willing to accept trailer fields in a chunked transfer-coding. Its\n   value may consist of the keyword \"trailers\" and/or a comma-separated\n   list of extension transfer-coding names with optional accept\n   parameters (as described in section 3.6).\n\n       TE        = \"TE\" \":\" #( t-codings )\n       t-codings = \"trailers\" | ( transfer-extension [ accept-params ] )\n\n   The presence of the keyword \"trailers\" indicates that the client is\n   willing to accept trailer fields in a chunked transfer-coding, as\n   defined in section 3.6.1. This keyword is reserved for use with\n   transfer-coding values even though it does not itself represent a\n   transfer-coding.\n\n   Examples of its use are:\n\n       TE: deflate\n       TE:\n       TE: trailers, deflate;q=0.5\n\n   The TE header field only applies to the immediate connection.\n   Therefore, the keyword MUST be supplied within a Connection header\n   field (section 14.10) whenever TE is present in an HTTP/1.1 message.\n\n   A server tests whether a transfer-coding is acceptable, according to\n   a TE field, using these rules:"
      },
      {
        "chunk_id": "rfc_http_chunk_93",
        "original_index": 93,
        "content": "A server tests whether a transfer-coding is acceptable, according to\n   a TE field, using these rules:\n\n      1. The \"chunked\" transfer-coding is always acceptable. If the\n         keyword \"trailers\" is listed, the client indicates that it is\n         willing to accept trailer fields in the chunked response on\n         behalf of itself and any downstream clients. The implication is\n         that, if given, the client is stating that either all\n         downstream clients are willing to accept trailer fields in the\n         forwarded response, or that it will attempt to buffer the\n         response on behalf of downstream recipients.\n\n         Note: HTTP/1.1 does not define any means to limit the size of a\n         chunked response such that a client can be assured of buffering\n         the entire response.\n\n      2. If the transfer-coding being tested is one of the transfer-\n         codings listed in the TE field, then it is acceptable unless it\n         is accompanied by a qvalue of 0. (As defined in section 3.9, a\n         qvalue of 0 means \"not acceptable.\")\n\n\n\nFielding, et al.            Standards Track                   [Page 142]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      3. If multiple transfer-codings are acceptable, then the\n         acceptable transfer-coding with the highest non-zero qvalue is\n         preferred.  The \"chunked\" transfer-coding always has a qvalue\n         of 1.\n\n   If the TE field-value is empty or if no TE field is present, the only\n   transfer-coding  is \"chunked\". A message with no transfer-coding is\n   always acceptable.\n\n14.40 Trailer\n\n   The Trailer general field value indicates that the given set of\n   header fields is present in the trailer of a message encoded with\n   chunked transfer-coding.\n\n       Trailer  = \"Trailer\" \":\" 1#field-name\n\n   An HTTP/1.1 message SHOULD include a Trailer header field in a\n   message using chunked transfer-coding with a non-empty trailer. Doing\n   so allows the recipient to know which header fields to expect in the\n   trailer.\n\n   If no Trailer header field is present, the trailer SHOULD NOT include\n   any header fields. See section 3.6.1 for restrictions on the use of\n   trailer fields in a \"chunked\" transfer-coding.\n\n   Message header fields listed in the Trailer header field MUST NOT\n   include the following header fields:\n\n      . Transfer-Encoding\n\n      . Content-Length\n\n      . Trailer\n\n14.41 Transfer-Encoding\n\n   The Transfer-Encoding general-header field indicates what (if any)\n   type of transformation has been applied to the message body in order\n   to safely transfer it between the sender and the recipient. This\n   differs from the content-coding in that the transfer-coding is a\n   property of the message, not of the entity.\n\n     Transfer-Encoding       = \"Transfer-Encoding\" \":\" 1#transfer-coding\n\n   Transfer-codings are defined in section 3.6. An example is:\n\n     Transfer-Encoding: chunked\n\n\n\nFielding, et al.            Standards Track                   [Page 143]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If multiple encodings have been applied to an entity, the transfer-\n   codings MUST be listed in the order in which they were applied.\n   Additional information about the encoding parameters MAY be provided\n   by other entity-header fields not defined by this specification.\n\n   Many older HTTP/1.0 applications do not understand the Transfer-\n   Encoding header.\n\n14.42 Upgrade\n\n   The Upgrade general-header allows the client to specify what\n   additional communication protocols it supports and would like to use\n   if the server finds it appropriate to switch protocols. The server\n   MUST use the Upgrade header field within a 101 (Switching Protocols)\n   response to indicate which protocol(s) are being switched.\n\n       Upgrade        = \"Upgrade\" \":\" 1#product\n\n   For example,\n\n       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11"
      },
      {
        "chunk_id": "rfc_http_chunk_94",
        "original_index": 94,
        "content": "Upgrade        = \"Upgrade\" \":\" 1#product\n\n   For example,\n\n       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\n\n   The Upgrade header field is intended to provide a simple mechanism\n   for transition from HTTP/1.1 to some other, incompatible protocol. It\n   does so by allowing the client to advertise its desire to use another\n   protocol, such as a later version of HTTP with a higher major version\n   number, even though the current request has been made using HTTP/1.1.\n   This eases the difficult transition between incompatible protocols by\n   allowing the client to initiate a request in the more commonly\n   supported protocol while indicating to the server that it would like\n   to use a \"better\" protocol if available (where \"better\" is determined\n   by the server, possibly according to the nature of the method and/or\n   resource being requested).\n\n   The Upgrade header field only applies to switching application-layer\n   protocols upon the existing transport-layer connection. Upgrade\n   cannot be used to insist on a protocol change; its acceptance and use\n   by the server is optional. The capabilities and nature of the\n   application-layer communication after the protocol change is entirely\n   dependent upon the new protocol chosen, although the first action\n   after changing the protocol MUST be a response to the initial HTTP\n   request containing the Upgrade header field.\n\n   The Upgrade header field only applies to the immediate connection.\n   Therefore, the upgrade keyword MUST be supplied within a Connection\n   header field (section 14.10) whenever Upgrade is present in an\n   HTTP/1.1 message.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 144]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Upgrade header field cannot be used to indicate a switch to a\n   protocol on a different connection. For that purpose, it is more\n   appropriate to use a 301, 302, 303, or 305 redirection response.\n\n   This specification only defines the protocol name \"HTTP\" for use by\n   the family of Hypertext Transfer Protocols, as defined by the HTTP\n   version rules of section 3.1 and future updates to this\n   specification. Any token can be used as a protocol name; however, it\n   will only be useful if both the client and server associate the name\n   with the same protocol.\n\n14.43 User-Agent\n\n   The User-Agent request-header field contains information about the\n   user agent originating the request. This is for statistical purposes,\n   the tracing of protocol violations, and automated recognition of user\n   agents for the sake of tailoring responses to avoid particular user\n   agent limitations. User agents SHOULD include this field with\n   requests. The field can contain multiple product tokens (section 3.8)\n   and comments identifying the agent and any subproducts which form a\n   significant part of the user agent. By convention, the product tokens\n   are listed in order of their significance for identifying the\n   application.\n\n       User-Agent     = \"User-Agent\" \":\" 1*( product | comment )\n\n   Example:\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n\n14.44 Vary\n\n   The Vary field value indicates the set of request-header fields that\n   fully determines, while the response is fresh, whether a cache is\n   permitted to use the response to reply to a subsequent request\n   without revalidation. For uncacheable or stale responses, the Vary\n   field value advises the user agent about the criteria that were used\n   to select the representation. A Vary field value of \"*\" implies that\n   a cache cannot determine from the request headers of a subsequent\n   request whether this response is the appropriate representation. See\n   section 13.6 for use of the Vary header field by caches.\n\n       Vary  = \"Vary\" \":\" ( \"*\" | 1#field-name )"
      },
      {
        "chunk_id": "rfc_http_chunk_95",
        "original_index": 95,
        "content": "Vary  = \"Vary\" \":\" ( \"*\" | 1#field-name )\n\n   An HTTP/1.1 server SHOULD include a Vary header field with any\n   cacheable response that is subject to server-driven negotiation.\n   Doing so allows a cache to properly interpret future requests on that\n   resource and informs the user agent about the presence of negotiation\n\n\n\nFielding, et al.            Standards Track                   [Page 145]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   on that resource. A server MAY include a Vary header field with a\n   non-cacheable response that is subject to server-driven negotiation,\n   since this might provide the user agent with useful information about\n   the dimensions over which the response varies at the time of the\n   response.\n\n   A Vary field value consisting of a list of field-names signals that\n   the representation selected for the response is based on a selection\n   algorithm which considers ONLY the listed request-header field values\n   in selecting the most appropriate representation. A cache MAY assume\n   that the same selection will be made for future requests with the\n   same values for the listed field names, for the duration of time for\n   which the response is fresh.\n\n   The field-names given are not limited to the set of standard\n   request-header fields defined by this specification. Field names are\n   case-insensitive.\n\n   A Vary field value of \"*\" signals that unspecified parameters not\n   limited to the request-headers (e.g., the network address of the\n   client), play a role in the selection of the response representation.\n   The \"*\" value MUST NOT be generated by a proxy server; it may only be\n   generated by an origin server.\n\n14.45  Via\n\n   The Via general-header field MUST be used by gateways and proxies to\n   indicate the intermediate protocols and recipients between the user\n   agent and the server on requests, and between the origin server and\n   the client on responses. It is analogous to the \"Received\" field of\n   RFC 822 [9] and is intended to be used for tracking message forwards,\n   avoiding request loops, and identifying the protocol capabilities of\n   all senders along the request/response chain.\n\n      Via =  \"Via\" \":\" 1#( received-protocol received-by [ comment ] )\n      received-protocol = [ protocol-name \"/\" ] protocol-version\n      protocol-name     = token\n      protocol-version  = token\n      received-by       = ( host [ \":\" port ] ) | pseudonym\n      pseudonym         = token\n\n   The received-protocol indicates the protocol version of the message\n   received by the server or client along each segment of the\n   request/response chain. The received-protocol version is appended to\n   the Via field value when the message is forwarded so that information\n   about the protocol capabilities of upstream applications remains\n   visible to all recipients.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 146]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The protocol-name is optional if and only if it would be \"HTTP\". The\n   received-by field is normally the host and optional port number of a\n   recipient server or client that subsequently forwarded the message.\n   However, if the real host is considered to be sensitive information,\n   it MAY be replaced by a pseudonym. If the port is not given, it MAY\n   be assumed to be the default port of the received-protocol.\n\n   Multiple Via field values represents each proxy or gateway that has\n   forwarded the message. Each recipient MUST append its information\n   such that the end result is ordered according to the sequence of\n   forwarding applications.\n\n   Comments MAY be used in the Via header field to identify the software\n   of the recipient proxy or gateway, analogous to the User-Agent and\n   Server header fields. However, all comments in the Via field are\n   optional and MAY be removed by any recipient prior to forwarding the\n   message."
      },
      {
        "chunk_id": "rfc_http_chunk_96",
        "original_index": 96,
        "content": "For example, a request message could be sent from an HTTP/1.0 user\n   agent to an internal proxy code-named \"fred\", which uses HTTP/1.1 to\n   forward the request to a public proxy at nowhere.com, which completes\n   the request by forwarding it to the origin server at www.ics.uci.edu.\n   The request received by www.ics.uci.edu would then have the following\n   Via header field:\n\n       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\n\n   Proxies and gateways used as a portal through a network firewall\n   SHOULD NOT, by default, forward the names and ports of hosts within\n   the firewall region. This information SHOULD only be propagated if\n   explicitly enabled. If not enabled, the received-by host of any host\n   behind the firewall SHOULD be replaced by an appropriate pseudonym\n   for that host.\n\n   For organizations that have strong privacy requirements for hiding\n   internal structures, a proxy MAY combine an ordered subsequence of\n   Via header field entries with identical received-protocol values into\n   a single such entry. For example,\n\n       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy\n\n        could be collapsed to\n\n       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 147]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Applications SHOULD NOT combine multiple entries unless they are all\n   under the same organizational control and the hosts have already been\n   replaced by pseudonyms. Applications MUST NOT combine entries which\n   have different received-protocol values.\n\n14.46 Warning\n\n   The Warning general-header field is used to carry additional\n   information about the status or transformation of a message which\n   might not be reflected in the message. This information is typically\n   used to warn about a possible lack of semantic transparency from\n   caching operations or transformations applied to the entity body of\n   the message.\n\n   Warning headers are sent with responses using:\n\n       Warning    = \"Warning\" \":\" 1#warning-value\n\n       warning-value = warn-code SP warn-agent SP warn-text\n                                             [SP warn-date]\n\n       warn-code  = 3DIGIT\n       warn-agent = ( host [ \":\" port ] ) | pseudonym\n                       ; the name or pseudonym of the server adding\n                       ; the Warning header, for use in debugging\n       warn-text  = quoted-string\n       warn-date  = <\"> HTTP-date <\">\n\n   A response MAY carry more than one Warning header.\n\n   The warn-text SHOULD be in a natural language and character set that\n   is most likely to be intelligible to the human user receiving the\n   response. This decision MAY be based on any available knowledge, such\n   as the location of the cache or user, the Accept-Language field in a\n   request, the Content-Language field in a response, etc. The default\n   language is English and the default character set is ISO-8859-1.\n\n   If a character set other than ISO-8859-1 is used, it MUST be encoded\n   in the warn-text using the method described in RFC 2047 [14].\n\n   Warning headers can in general be applied to any message, however\n   some specific warn-codes are specific to caches and can only be\n   applied to response messages. New Warning headers SHOULD be added\n   after any existing Warning headers. A cache MUST NOT delete any\n   Warning header that it received with a message. However, if a cache\n   successfully validates a cache entry, it SHOULD remove any Warning\n   headers previously attached to that entry except as specified for\n\n\n\n\nFielding, et al.            Standards Track                   [Page 148]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   specific Warning codes. It MUST then add any Warning headers received\n   in the validating response. In other words, Warning headers are those\n   that would be attached to the most recent relevant response."
      },
      {
        "chunk_id": "rfc_http_chunk_97",
        "original_index": 97,
        "content": "When multiple Warning headers are attached to a response, the user\n   agent ought to inform the user of as many of them as possible, in the\n   order that they appear in the response. If it is not possible to\n   inform the user of all of the warnings, the user agent SHOULD follow\n   these heuristics:\n\n      - Warnings that appear early in the response take priority over\n        those appearing later in the response.\n\n      - Warnings in the user's preferred character set take priority\n        over warnings in other character sets but with identical warn-\n        codes and warn-agents.\n\n   Systems that generate multiple Warning headers SHOULD order them with\n   this user agent behavior in mind.\n\n   Requirements for the behavior of caches with respect to Warnings are\n   stated in section 13.1.2.\n\n   This is a list of the currently-defined warn-codes, each with a\n   recommended warn-text in English, and a description of its meaning.\n\n   110 Response is stale\n     MUST be included whenever the returned response is stale.\n\n   111 Revalidation failed\n     MUST be included if a cache returns a stale response because an\n     attempt to revalidate the response failed, due to an inability to\n     reach the server.\n\n   112 Disconnected operation\n     SHOULD be included if the cache is intentionally disconnected from\n     the rest of the network for a period of time.\n\n   113 Heuristic expiration\n     MUST be included if the cache heuristically chose a freshness\n     lifetime greater than 24 hours and the response's age is greater\n     than 24 hours.\n\n   199 Miscellaneous warning\n     The warning text MAY include arbitrary information to be presented\n     to a human user, or logged. A system receiving this warning MUST\n     NOT take any automated action, besides presenting the warning to\n     the user.\n\n\n\nFielding, et al.            Standards Track                   [Page 149]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   214 Transformation applied\n     MUST be added by an intermediate cache or proxy if it applies any\n     transformation changing the content-coding (as specified in the\n     Content-Encoding header) or media-type (as specified in the\n     Content-Type header) of the response, or the entity-body of the\n     response, unless this Warning code already appears in the response.\n\n   299 Miscellaneous persistent warning\n     The warning text MAY include arbitrary information to be presented\n     to a human user, or logged. A system receiving this warning MUST\n     NOT take any automated action.\n\n   If an implementation sends a message with one or more Warning headers\n   whose version is HTTP/1.0 or lower, then the sender MUST include in\n   each warning-value a warn-date that matches the date in the response.\n\n   If an implementation receives a message with a warning-value that\n   includes a warn-date, and that warn-date is different from the Date\n   value in the response, then that warning-value MUST be deleted from\n   the message before storing, forwarding, or using it. (This prevents\n   bad consequences of naive caching of Warning header fields.) If all\n   of the warning-values are deleted for this reason, the Warning header\n   MUST be deleted as well.\n\n14.47 WWW-Authenticate\n\n   The WWW-Authenticate response-header field MUST be included in 401\n   (Unauthorized) response messages. The field value consists of at\n   least one challenge that indicates the authentication scheme(s) and\n   parameters applicable to the Request-URI.\n\n       WWW-Authenticate  = \"WWW-Authenticate\" \":\" 1#challenge"
      },
      {
        "chunk_id": "rfc_http_chunk_98",
        "original_index": 98,
        "content": "WWW-Authenticate  = \"WWW-Authenticate\" \":\" 1#challenge\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. User\n   agents are advised to take special care in parsing the WWW-\n   Authenticate field value as it might contain more than one challenge,\n   or if more than one WWW-Authenticate header field is provided, the\n   contents of a challenge itself can contain a comma-separated list of\n   authentication parameters.\n\n15 Security Considerations\n\n   This section is meant to inform application developers, information\n   providers, and users of the security limitations in HTTP/1.1 as\n   described by this document. The discussion does not include\n   definitive solutions to the problems revealed, though it does make\n   some suggestions for reducing security risks.\n\n\n\nFielding, et al.            Standards Track                   [Page 150]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.1 Personal Information\n\n   HTTP clients are often privy to large amounts of personal information\n   (e.g. the user's name, location, mail address, passwords, encryption\n   keys, etc.), and SHOULD be very careful to prevent unintentional\n   leakage of this information via the HTTP protocol to other sources.\n   We very strongly recommend that a convenient interface be provided\n   for the user to control dissemination of such information, and that\n   designers and implementors be particularly careful in this area.\n   History shows that errors in this area often create serious security\n   and/or privacy problems and generate highly adverse publicity for the\n   implementor's company.\n\n15.1.1 Abuse of Server Log Information\n\n   A server is in the position to save personal data about a user's\n   requests which might identify their reading patterns or subjects of\n   interest. This information is clearly confidential in nature and its\n   handling can be constrained by law in certain countries. People using\n   the HTTP protocol to provide data are responsible for ensuring that\n   such material is not distributed without the permission of any\n   individuals that are identifiable by the published results.\n\n15.1.2 Transfer of Sensitive Information\n\n   Like any generic data transfer protocol, HTTP cannot regulate the\n   content of the data that is transferred, nor is there any a priori\n   method of determining the sensitivity of any particular piece of\n   information within the context of any given request. Therefore,\n   applications SHOULD supply as much control over this information as\n   possible to the provider of that information. Four header fields are\n   worth special mention in this context: Server, Via, Referer and From.\n\n   Revealing the specific software version of the server might allow the\n   server machine to become more vulnerable to attacks against software\n   that is known to contain security holes. Implementors SHOULD make the\n   Server header field a configurable option.\n\n   Proxies which serve as a portal through a network firewall SHOULD\n   take special precautions regarding the transfer of header information\n   that identifies the hosts behind the firewall. In particular, they\n   SHOULD remove, or replace with sanitized versions, any Via fields\n   generated behind the firewall.\n\n   The Referer header allows reading patterns to be studied and reverse\n   links drawn. Although it can be very useful, its power can be abused\n   if user details are not separated from the information contained in\n\n\n\n\nFielding, et al.            Standards Track                   [Page 151]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the Referer. Even when the personal information has been removed, the\n   Referer header might indicate a private document's URI whose\n   publication would be inappropriate."
      },
      {
        "chunk_id": "rfc_http_chunk_99",
        "original_index": 99,
        "content": "the Referer. Even when the personal information has been removed, the\n   Referer header might indicate a private document's URI whose\n   publication would be inappropriate.\n\n   The information sent in the From field might conflict with the user's\n   privacy interests or their site's security policy, and hence it\n   SHOULD NOT be transmitted without the user being able to disable,\n   enable, and modify the contents of the field. The user MUST be able\n   to set the contents of this field within a user preference or\n   application defaults configuration.\n\n   We suggest, though do not require, that a convenient toggle interface\n   be provided for the user to enable or disable the sending of From and\n   Referer information.\n\n   The User-Agent (section 14.43) or Server (section 14.38) header\n   fields can sometimes be used to determine that a specific client or\n   server have a particular security hole which might be exploited.\n   Unfortunately, this same information is often used for other valuable\n   purposes for which HTTP currently has no better mechanism.\n\n15.1.3 Encoding Sensitive Information in URI's\n\n   Because the source of a link might be private information or might\n   reveal an otherwise private information source, it is strongly\n   recommended that the user be able to select whether or not the\n   Referer field is sent. For example, a browser client could have a\n   toggle switch for browsing openly/anonymously, which would\n   respectively enable/disable the sending of Referer and From\n   information.\n\n   Clients SHOULD NOT include a Referer header field in a (non-secure)\n   HTTP request if the referring page was transferred with a secure\n   protocol.\n\n   Authors of services which use the HTTP protocol SHOULD NOT use GET\n   based forms for the submission of sensitive data, because this will\n   cause this data to be encoded in the Request-URI. Many existing\n   servers, proxies, and user agents will log the request URI in some\n   place where it might be visible to third parties. Servers can use\n   POST-based form submission instead\n\n15.1.4 Privacy Issues Connected to Accept Headers\n\n   Accept request-headers can reveal information about the user to all\n   servers which are accessed. The Accept-Language header in particular\n   can reveal information the user would consider to be of a private\n   nature, because the understanding of particular languages is often\n\n\n\nFielding, et al.            Standards Track                   [Page 152]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   strongly correlated to the membership of a particular ethnic group.\n   User agents which offer the option to configure the contents of an\n   Accept-Language header to be sent in every request are strongly\n   encouraged to let the configuration process include a message which\n   makes the user aware of the loss of privacy involved.\n\n   An approach that limits the loss of privacy would be for a user agent\n   to omit the sending of Accept-Language headers by default, and to ask\n   the user whether or not to start sending Accept-Language headers to a\n   server if it detects, by looking for any Vary response-header fields\n   generated by the server, that such sending could improve the quality\n   of service."
      },
      {
        "chunk_id": "rfc_http_chunk_100",
        "original_index": 100,
        "content": "Elaborate user-customized accept header fields sent in every request,\n   in particular if these include quality values, can be used by servers\n   as relatively reliable and long-lived user identifiers. Such user\n   identifiers would allow content providers to do click-trail tracking,\n   and would allow collaborating content providers to match cross-server\n   click-trails or form submissions of individual users. Note that for\n   many users not behind a proxy, the network address of the host\n   running the user agent will also serve as a long-lived user\n   identifier. In environments where proxies are used to enhance\n   privacy, user agents ought to be conservative in offering accept\n   header configuration options to end users. As an extreme privacy\n   measure, proxies could filter the accept headers in relayed requests.\n   General purpose user agents which provide a high degree of header\n   configurability SHOULD warn users about the loss of privacy which can\n   be involved.\n\n15.2 Attacks Based On File and Path Names\n\n   Implementations of HTTP origin servers SHOULD be careful to restrict\n   the documents returned by HTTP requests to be only those that were\n   intended by the server administrators. If an HTTP server translates\n   HTTP URIs directly into file system calls, the server MUST take\n   special care not to serve files that were not intended to be\n   delivered to HTTP clients. For example, UNIX, Microsoft Windows, and\n   other operating systems use \"..\" as a path component to indicate a\n   directory level above the current one. On such a system, an HTTP\n   server MUST disallow any such construct in the Request-URI if it\n   would otherwise allow access to a resource outside those intended to\n   be accessible via the HTTP server. Similarly, files intended for\n   reference only internally to the server (such as access control\n   files, configuration files, and script code) MUST be protected from\n   inappropriate retrieval, since they might contain sensitive\n   information. Experience has shown that minor bugs in such HTTP server\n   implementations have turned into security risks.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 153]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.3 DNS Spoofing\n\n   Clients using HTTP rely heavily on the Domain Name Service, and are\n   thus generally prone to security attacks based on the deliberate\n   mis-association of IP addresses and DNS names. Clients need to be\n   cautious in assuming the continuing validity of an IP number/DNS name\n   association.\n\n   In particular, HTTP clients SHOULD rely on their name resolver for\n   confirmation of an IP number/DNS name association, rather than\n   caching the result of previous host name lookups. Many platforms\n   already can cache host name lookups locally when appropriate, and\n   they SHOULD be configured to do so. It is proper for these lookups to\n   be cached, however, only when the TTL (Time To Live) information\n   reported by the name server makes it likely that the cached\n   information will remain useful.\n\n   If HTTP clients cache the results of host name lookups in order to\n   achieve a performance improvement, they MUST observe the TTL\n   information reported by DNS.\n\n   If HTTP clients do not observe this rule, they could be spoofed when\n   a previously-accessed server's IP address changes. As network\n   renumbering is expected to become increasingly common [24], the\n   possibility of this form of attack will grow. Observing this\n   requirement thus reduces this potential security vulnerability.\n\n   This requirement also improves the load-balancing behavior of clients\n   for replicated servers using the same DNS name and reduces the\n   likelihood of a user's experiencing failure in accessing sites which\n   use that strategy.\n\n15.4 Location Headers and Spoofing"
      },
      {
        "chunk_id": "rfc_http_chunk_101",
        "original_index": 101,
        "content": "15.4 Location Headers and Spoofing\n\n   If a single server supports multiple organizations that do not trust\n   one another, then it MUST check the values of Location and Content-\n   Location headers in responses that are generated under control of\n   said organizations to make sure that they do not attempt to\n   invalidate resources over which they have no authority.\n\n15.5 Content-Disposition Issues\n\n   RFC 1806 [35], from which the often implemented Content-Disposition\n   (see section 19.5.1) header in HTTP is derived, has a number of very\n   serious security considerations. Content-Disposition is not part of\n   the HTTP standard, but since it is widely implemented, we are\n   documenting its use and risks for implementors. See RFC 2183 [49]\n   (which updates RFC 1806) for details.\n\n\n\nFielding, et al.            Standards Track                   [Page 154]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.6 Authentication Credentials and Idle Clients\n\n   Existing HTTP clients and user agents typically retain authentication\n   information indefinitely. HTTP/1.1. does not provide a method for a\n   server to direct clients to discard these cached credentials. This is\n   a significant defect that requires further extensions to HTTP.\n   Circumstances under which credential caching can interfere with the\n   application's security model include but are not limited to:\n\n      - Clients which have been idle for an extended period following\n        which the server might wish to cause the client to reprompt the\n        user for credentials.\n\n      - Applications which include a session termination indication\n        (such as a `logout' or `commit' button on a page) after which\n        the server side of the application `knows' that there is no\n        further reason for the client to retain the credentials.\n\n   This is currently under separate study. There are a number of work-\n   arounds to parts of this problem, and we encourage the use of\n   password protection in screen savers, idle time-outs, and other\n   methods which mitigate the security problems inherent in this\n   problem. In particular, user agents which cache credentials are\n   encouraged to provide a readily accessible mechanism for discarding\n   cached credentials under user control.\n\n15.7 Proxies and Caching\n\n   By their very nature, HTTP proxies are men-in-the-middle, and\n   represent an opportunity for man-in-the-middle attacks. Compromise of\n   the systems on which the proxies run can result in serious security\n   and privacy problems. Proxies have access to security-related\n   information, personal information about individual users and\n   organizations, and proprietary information belonging to users and\n   content providers. A compromised proxy, or a proxy implemented or\n   configured without regard to security and privacy considerations,\n   might be used in the commission of a wide range of potential attacks.\n\n   Proxy operators should protect the systems on which proxies run as\n   they would protect any system that contains or transports sensitive\n   information. In particular, log information gathered at proxies often\n   contains highly sensitive personal information, and/or information\n   about organizations. Log information should be carefully guarded, and\n   appropriate guidelines for use developed and followed. (Section\n   15.1.1).\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 155]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Caching proxies provide additional potential vulnerabilities, since\n   the contents of the cache represent an attractive target for\n   malicious exploitation. Because cache contents persist after an HTTP\n   request is complete, an attack on the cache can reveal information\n   long after a user believes that the information has been removed from\n   the network. Therefore, cache contents should be protected as\n   sensitive information."
      },
      {
        "chunk_id": "rfc_http_chunk_102",
        "original_index": 102,
        "content": "Proxy implementors should consider the privacy and security\n   implications of their design and coding decisions, and of the\n   configuration options they provide to proxy operators (especially the\n   default configuration).\n\n   Users of a proxy need to be aware that they are no trustworthier than\n   the people who run the proxy; HTTP itself cannot solve this problem.\n\n   The judicious use of cryptography, when appropriate, may suffice to\n   protect against a broad range of security and privacy attacks. Such\n   cryptography is beyond the scope of the HTTP/1.1 specification.\n\n15.7.1 Denial of Service Attacks on Proxies\n\n   They exist. They are hard to defend against. Research continues.\n   Beware.\n\n16 Acknowledgments\n\n   This specification makes heavy use of the augmented BNF and generic\n   constructs defined by David H. Crocker for RFC 822 [9]. Similarly, it\n   reuses many of the definitions provided by Nathaniel Borenstein and\n   Ned Freed for MIME [7]. We hope that their inclusion in this\n   specification will help reduce past confusion over the relationship\n   between HTTP and Internet mail message formats.\n\n   The HTTP protocol has evolved considerably over the years. It has\n   benefited from a large and active developer community--the many\n   people who have participated on the www-talk mailing list--and it is\n   that community which has been most responsible for the success of\n   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert\n   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois\n   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob\n   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc\n   VanHeyningen deserve special recognition for their efforts in\n   defining early aspects of the protocol.\n\n   This document has benefited greatly from the comments of all those\n   participating in the HTTP-WG. In addition to those already mentioned,\n   the following individuals have contributed to this specification:\n\n\n\nFielding, et al.            Standards Track                   [Page 156]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       Gary Adams                  Ross Patterson\n       Harald Tveit Alvestrand     Albert Lunde\n       Keith Ball                  John C. Mallery\n       Brian Behlendorf            Jean-Philippe Martin-Flatin\n       Paul Burchard               Mitra\n       Maurizio Codogno            David Morris\n       Mike Cowlishaw              Gavin Nicol\n       Roman Czyborra              Bill Perry\n       Michael A. Dolan            Jeffrey Perry\n       David J. Fiander            Scott Powers\n       Alan Freier                 Owen Rees\n       Marc Hedlund                Luigi Rizzo\n       Greg Herlihy                David Robinson\n       Koen Holtman                Marc Salomon\n       Alex Hopmann                Rich Salz\n       Bob Jernigan                Allan M. Schiffman\n       Shel Kaphan                 Jim Seidman\n       Rohit Khare                 Chuck Shotton\n       John Klensin                Eric W. Sink\n       Martijn Koster              Simon E. Spero\n       Alexei Kosut                Richard N. Taylor\n       David M. Kristol            Robert S. Thau\n       Daniel LaLiberte            Bill (BearHeart) Weinman\n       Ben Laurie                  Francois Yergeau\n       Paul J. Leach               Mary Ellen Zurko\n       Daniel DuBois               Josh Cohen\n\n\n   Much of the content and presentation of the caching design is due to\n   suggestions and comments from individuals including: Shel Kaphan,\n   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.\n\n   Most of the specification of ranges is based on work originally done\n   by Ari Luotonen and John Franks, with additional input from Steve\n   Zilles.\n\n   Thanks to the \"cave men\" of Palo Alto. You know who you are."
      },
      {
        "chunk_id": "rfc_http_chunk_103",
        "original_index": 103,
        "content": "Thanks to the \"cave men\" of Palo Alto. You know who you are.\n\n   Jim Gettys (the current editor of this document) wishes particularly\n   to thank Roy Fielding, the previous editor of this document, along\n   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen\n   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and\n   Larry Masinter for their help. And thanks go particularly to Jeff\n   Mogul and Scott Lawrence for performing the \"MUST/MAY/SHOULD\" audit.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 157]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik\n   Frystyk implemented RFC 2068 early, and we wish to thank them for the\n   discovery of many of the problems that this document attempts to\n   rectify.\n\n17 References\n\n   [1] Alvestrand, H., \"Tags for the Identification of Languages\", RFC\n       1766, March 1995.\n\n   [2] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,\n       D. and B. Alberti, \"The Internet Gopher Protocol (a distributed\n       document search and retrieval protocol)\", RFC 1436, March 1993.\n\n   [3] Berners-Lee, T., \"Universal Resource Identifiers in WWW\", RFC\n       1630, June 1994.\n\n   [4] Berners-Lee, T., Masinter, L. and M. McCahill, \"Uniform Resource\n       Locators (URL)\", RFC 1738, December 1994.\n\n   [5] Berners-Lee, T. and D. Connolly, \"Hypertext Markup Language -\n       2.0\", RFC 1866, November 1995.\n\n   [6] Berners-Lee, T., Fielding, R. and H. Frystyk, \"Hypertext Transfer\n       Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n\n   [7] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n       Extensions (MIME) Part One: Format of Internet Message Bodies\",\n       RFC 2045, November 1996.\n\n   [8] Braden, R., \"Requirements for Internet Hosts -- Communication\n       Layers\", STD 3, RFC 1123, October 1989.\n\n   [9] Crocker, D., \"Standard for The Format of ARPA Internet Text\n       Messages\", STD 11, RFC 822, August 1982.\n\n   [10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,\n        Sui, J., and M. Grinbaum, \"WAIS Interface Protocol Prototype\n        Functional Specification,\" (v1.5), Thinking Machines\n        Corporation, April 1990.\n\n   [11] Fielding, R., \"Relative Uniform Resource Locators\", RFC 1808,\n        June 1995.\n\n   [12] Horton, M. and R. Adams, \"Standard for Interchange of USENET\n        Messages\", RFC 1036, December 1987.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 158]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [13] Kantor, B. and P. Lapsley, \"Network News Transfer Protocol\", RFC\n        977, February 1986.\n\n   [14] Moore, K., \"MIME (Multipurpose Internet Mail Extensions) Part\n        Three: Message Header Extensions for Non-ASCII Text\", RFC 2047,\n        November 1996.\n\n   [15] Nebel, E. and L. Masinter, \"Form-based File Upload in HTML\", RFC\n        1867, November 1995.\n\n   [16] Postel, J., \"Simple Mail Transfer Protocol\", STD 10, RFC 821,\n        August 1982.\n\n   [17] Postel, J., \"Media Type Registration Procedure\", RFC 1590,\n        November 1996.\n\n   [18] Postel, J. and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC\n        959, October 1985.\n\n   [19] Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700,\n        October 1994.\n\n   [20] Sollins, K. and L. Masinter, \"Functional Requirements for\n        Uniform Resource Names\", RFC 1737, December 1994.\n\n   [21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for\n        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986."
      },
      {
        "chunk_id": "rfc_http_chunk_104",
        "original_index": 104,
        "content": "[21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for\n        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.\n\n   [22] ISO-8859. International Standard -- Information Processing --\n        8-bit Single-Byte Coded Graphic Character Sets --\n        Part 1: Latin alphabet No. 1, ISO-8859-1:1987.\n        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.\n        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.\n        Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.\n        Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.\n        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.\n        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.\n        Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.\n        Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.\n\n   [23] Meyers, J. and M. Rose, \"The Content-MD5 Header Field\", RFC\n        1864, October 1995.\n\n   [24] Carpenter, B. and Y. Rekhter, \"Renumbering Needs Work\", RFC\n        1900, February 1996.\n\n   [25] Deutsch, P., \"GZIP file format specification version 4.3\", RFC\n        1952, May 1996.\n\n\n\nFielding, et al.            Standards Track                   [Page 159]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [26] Venkata N. Padmanabhan, and Jeffrey C. Mogul. \"Improving HTTP\n        Latency\", Computer Networks and ISDN Systems, v. 28, pp. 25-35,\n        Dec. 1995. Slightly revised version of paper in Proc. 2nd\n        International WWW Conference '94: Mosaic and the Web, Oct. 1994,\n        which is available at\n        http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat\n        ency.html.\n\n   [27] Joe Touch, John Heidemann, and Katia Obraczka. \"Analysis of HTTP\n        Performance\", <URL: http://www.isi.edu/touch/pubs/http-perf96/>,\n        ISI Research Report ISI/RR-98-463, (original report dated Aug.\n        1996), USC/Information Sciences Institute, August 1998.\n\n   [28] Mills, D., \"Network Time Protocol (Version 3) Specification,\n        Implementation and Analysis\", RFC 1305, March 1992.\n\n   [29] Deutsch, P., \"DEFLATE Compressed Data Format Specification\n        version 1.3\", RFC 1951, May 1996.\n\n   [30] S. Spero, \"Analysis of HTTP Performance Problems,\"\n        http://sunsite.unc.edu/mdma-release/http-prob.html.\n\n   [31] Deutsch, P. and J. Gailly, \"ZLIB Compressed Data Format\n        Specification version 3.3\", RFC 1950, May 1996.\n\n   [32] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,\n        Luotonen, A., Sink, E. and L. Stewart, \"An Extension to HTTP:\n        Digest Access Authentication\", RFC 2069, January 1997.\n\n   [33] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T.\n        Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC\n        2068, January 1997.\n\n   [34] Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n\n   [35] Troost, R. and Dorner, S., \"Communicating Presentation\n        Information in Internet Messages: The Content-Disposition\n        Header\", RFC 1806, June 1995.\n\n   [36] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, \"Use and\n        Interpretation of HTTP Version Numbers\", RFC 2145, May 1997.\n        [jg639]\n\n   [37] Palme, J., \"Common Internet Message Headers\", RFC 2076, February\n        1997. [jg640]\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 160]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [38] Yergeau, F., \"UTF-8, a transformation format of Unicode and\n        ISO-10646\", RFC 2279, January 1998. [jg641]\n\n   [39] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E.,\n        Lie, H., and C. Lilley. \"Network Performance Effects of\n        HTTP/1.1, CSS1, and PNG,\" Proceedings of ACM SIGCOMM '97, Cannes\n        France, September 1997.[jg642]\n\n   [40] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Two: Media Types\", RFC 2046, November\n        1996. [jg643]"
      },
      {
        "chunk_id": "rfc_http_chunk_105",
        "original_index": 105,
        "content": "[40] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Two: Media Types\", RFC 2046, November\n        1996. [jg643]\n\n   [41] Alvestrand, H., \"IETF Policy on Character Sets and Languages\",\n        BCP 18, RFC 2277, January 1998. [jg644]\n\n   [42] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource\n        Identifiers (URI): Generic Syntax and Semantics\", RFC 2396,\n        August 1998. [jg645]\n\n   [43] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n        Leach, P., Luotonen, A., Sink, E. and L. Stewart, \"HTTP\n        Authentication: Basic and Digest Access Authentication\", RFC\n        2617, June 1999. [jg646]\n\n   [44] Luotonen, A., \"Tunneling TCP based protocols through Web proxy\n        servers,\" Work in Progress. [jg647]\n\n   [45] Palme, J. and A. Hopmann, \"MIME E-mail Encapsulation of\n        Aggregate Documents, such as HTML (MHTML)\", RFC 2110, March\n        1997.\n\n   [46] Bradner, S., \"The Internet Standards Process -- Revision 3\", BCP\n        9, RFC 2026, October 1996.\n\n   [47] Masinter, L., \"Hyper Text Coffee Pot Control Protocol\n        (HTCPCP/1.0)\", RFC 2324, 1 April 1998.\n\n   [48] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Five: Conformance Criteria and Examples\",\n        RFC 2049, November 1996.\n\n   [49] Troost, R., Dorner, S. and K. Moore, \"Communicating Presentation\n        Information in Internet Messages: The Content-Disposition Header\n        Field\", RFC 2183, August 1997.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 161]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n18 Authors' Addresses\n\n   Roy T. Fielding\n   Information and Computer Science\n   University of California, Irvine\n   Irvine, CA 92697-3425, USA\n\n   Fax: +1 (949) 824-1715\n   EMail: fielding@ics.uci.edu\n\n\n   James Gettys\n   World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: jg@w3.org\n\n\n   Jeffrey C. Mogul\n   Western Research Laboratory\n   Compaq Computer Corporation\n   250 University Avenue\n   Palo Alto, California, 94305, USA\n\n   EMail: mogul@wrl.dec.com\n\n\n   Henrik Frystyk Nielsen\n   World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: frystyk@w3.org\n\n\n   Larry Masinter\n   Xerox Corporation\n   3333 Coyote Hill Road\n   Palo Alto, CA 94034, USA\n\n   EMail: masinter@parc.xerox.com\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 162]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Paul J. Leach\n   Microsoft Corporation\n   1 Microsoft Way\n   Redmond, WA 98052, USA\n\n   EMail: paulle@microsoft.com\n\n\n   Tim Berners-Lee\n   Director, World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: timbl@w3.org\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 163]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n19 Appendices\n\n19.1 Internet Media Type message/http and application/http\n\n   In addition to defining the HTTP/1.1 protocol, this document serves\n   as the specification for the Internet media type \"message/http\" and\n   \"application/http\". The message/http type can be used to enclose a\n   single HTTP request or response message, provided that it obeys the\n   MIME restrictions for all \"message\" types regarding line length and\n   encodings. The application/http type can be used to enclose a\n   pipeline of one or more HTTP request or response messages (not\n   intermixed). The following is to be registered with IANA [17]."
      },
      {
        "chunk_id": "rfc_http_chunk_106",
        "original_index": 106,
        "content": "Media Type name:         message\n       Media subtype name:      http\n       Required parameters:     none\n       Optional parameters:     version, msgtype\n        version: The HTTP-Version number of the enclosed message\n                 (e.g., \"1.1\"). If not present, the version can be\n                 determined from the first line of the body.\n        msgtype: The message type -- \"request\" or \"response\". If not\n                 present, the type can be determined from the first\n                 line of the body.\n       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                                permitted\n       Security considerations: none\n\n       Media Type name:         application\n       Media subtype name:      http\n       Required parameters:     none\n       Optional parameters:     version, msgtype\n        version: The HTTP-Version number of the enclosed messages\n                 (e.g., \"1.1\"). If not present, the version can be\n                 determined from the first line of the body.\n        msgtype: The message type -- \"request\" or \"response\". If not\n                 present, the type can be determined from the first\n                 line of the body.\n       Encoding considerations: HTTP messages enclosed by this type\n                 are in \"binary\" format; use of an appropriate\n                 Content-Transfer-Encoding is required when\n                 transmitted via E-mail.\n       Security considerations: none\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 164]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n19.2 Internet Media Type multipart/byteranges\n\n   When an HTTP 206 (Partial Content) response message includes the\n   content of multiple ranges (a response to a request for multiple\n   non-overlapping ranges), these are transmitted as a multipart\n   message-body. The media type for this purpose is called\n   \"multipart/byteranges\".\n\n   The multipart/byteranges media type includes two or more parts, each\n   with its own Content-Type and Content-Range fields. The required\n   boundary parameter specifies the boundary string used to separate\n   each body-part.\n\n       Media Type name:         multipart\n       Media subtype name:      byteranges\n       Required parameters:     boundary\n       Optional parameters:     none\n       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                                permitted\n       Security considerations: none\n\n\n   For example:\n\n   HTTP/1.1 206 Partial Content\n   Date: Wed, 15 Nov 1995 06:25:24 GMT\n   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n\n   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n   Content-range: bytes 500-999/8000\n\n   ...the first range...\n   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n   Content-range: bytes 7000-7999/8000\n\n   ...the second range\n   --THIS_STRING_SEPARATES--\n\n      Notes:\n\n      1) Additional CRLFs may precede the first boundary string in the\n         entity.\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 165]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      2) Although RFC 2046 [40] permits the boundary string to be\n         quoted, some existing implementations handle a quoted boundary\n         string incorrectly.\n\n      3) A number of browsers and servers were coded to an early draft\n         of the byteranges specification to use a media type of\n         multipart/x-byteranges, which is almost, but not quite\n         compatible with the version documented in HTTP/1.1.\n\n19.3 Tolerant Applications"
      },
      {
        "chunk_id": "rfc_http_chunk_107",
        "original_index": 107,
        "content": "19.3 Tolerant Applications\n\n   Although this document specifies the requirements for the generation\n   of HTTP/1.1 messages, not all applications will be correct in their\n   implementation. We therefore recommend that operational applications\n   be tolerant of deviations whenever those deviations can be\n   interpreted unambiguously.\n\n   Clients SHOULD be tolerant in parsing the Status-Line and servers\n   tolerant when parsing the Request-Line. In particular, they SHOULD\n   accept any amount of SP or HT characters between fields, even though\n   only a single SP is required.\n\n   The line terminator for message-header fields is the sequence CRLF.\n   However, we recommend that applications, when parsing such headers,\n   recognize a single LF as a line terminator and ignore the leading CR.\n\n   The character set of an entity-body SHOULD be labeled as the lowest\n   common denominator of the character codes used within that body, with\n   the exception that not labeling the entity is preferred over labeling\n   the entity with the labels US-ASCII or ISO-8859-1. See section 3.7.1\n   and 3.4.1.\n\n   Additional rules for requirements on parsing and encoding of dates\n   and other potential problems with date encodings include:\n\n      - HTTP/1.1 clients and caches SHOULD assume that an RFC-850 date\n        which appears to be more than 50 years in the future is in fact\n        in the past (this helps solve the \"year 2000\" problem).\n\n      - An HTTP/1.1 implementation MAY internally represent a parsed\n        Expires date as earlier than the proper value, but MUST NOT\n        internally represent a parsed Expires date as later than the\n        proper value.\n\n      - All expiration-related calculations MUST be done in GMT. The\n        local time zone MUST NOT influence the calculation or comparison\n        of an age or expiration time.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 166]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If an HTTP header incorrectly carries a date value with a time\n        zone other than GMT, it MUST be converted into GMT using the\n        most conservative possible conversion.\n\n19.4 Differences Between HTTP Entities and RFC 2045 Entities\n\n   HTTP/1.1 uses many of the constructs defined for Internet Mail (RFC\n   822 [9]) and the Multipurpose Internet Mail Extensions (MIME [7]) to\n   allow entities to be transmitted in an open variety of\n   representations and with extensible mechanisms. However, RFC 2045\n   discusses mail, and HTTP has a few features that are different from\n   those described in RFC 2045. These differences were carefully chosen\n   to optimize performance over binary connections, to allow greater\n   freedom in the use of new media types, to make date comparisons\n   easier, and to acknowledge the practice of some early HTTP servers\n   and clients.\n\n   This appendix describes specific areas where HTTP differs from RFC\n   2045. Proxies and gateways to strict MIME environments SHOULD be\n   aware of these differences and provide the appropriate conversions\n   where necessary. Proxies and gateways from MIME environments to HTTP\n   also need to be aware of the differences because some conversions\n   might be required.\n\n19.4.1 MIME-Version\n\n   HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY\n   include a single MIME-Version general-header field to indicate what\n   version of the MIME protocol was used to construct the message. Use\n   of the MIME-Version header field indicates that the message is in\n   full compliance with the MIME protocol (as defined in RFC 2045[7]).\n   Proxies/gateways are responsible for ensuring full compliance (where\n   possible) when exporting HTTP messages to strict MIME environments.\n\n       MIME-Version   = \"MIME-Version\" \":\" 1*DIGIT \".\" 1*DIGIT"
      },
      {
        "chunk_id": "rfc_http_chunk_108",
        "original_index": 108,
        "content": "MIME-Version   = \"MIME-Version\" \":\" 1*DIGIT \".\" 1*DIGIT\n\n   MIME version \"1.0\" is the default for use in HTTP/1.1. However,\n   HTTP/1.1 message parsing and semantics are defined by this document\n   and not the MIME specification.\n\n19.4.2 Conversion to Canonical Form\n\n   RFC 2045 [7] requires that an Internet mail entity be converted to\n   canonical form prior to being transferred, as described in section 4\n   of RFC 2049 [48]. Section 3.7.1 of this document describes the forms\n   allowed for subtypes of the \"text\" media type when transmitted over\n   HTTP. RFC 2046 requires that content with a type of \"text\" represent\n   line breaks as CRLF and forbids the use of CR or LF outside of line\n\n\n\nFielding, et al.            Standards Track                   [Page 167]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a\n   line break within text content when a message is transmitted over\n   HTTP.\n\n   Where it is possible, a proxy or gateway from HTTP to a strict MIME\n   environment SHOULD translate all line breaks within the text media\n   types described in section 3.7.1 of this document to the RFC 2049\n   canonical form of CRLF. Note, however, that this might be complicated\n   by the presence of a Content-Encoding and by the fact that HTTP\n   allows the use of some character sets which do not use octets 13 and\n   10 to represent CR and LF, as is the case for some multi-byte\n   character sets.\n\n   Implementors should note that conversion will break any cryptographic\n   checksums applied to the original content unless the original content\n   is already in canonical form. Therefore, the canonical form is\n   recommended for any content that uses such checksums in HTTP.\n\n19.4.3 Conversion of Date Formats\n\n   HTTP/1.1 uses a restricted set of date formats (section 3.3.1) to\n   simplify the process of date comparison. Proxies and gateways from\n   other protocols SHOULD ensure that any Date header field present in a\n   message conforms to one of the HTTP/1.1 formats and rewrite the date\n   if necessary.\n\n19.4.4 Introduction of Content-Encoding\n\n   RFC 2045 does not include any concept equivalent to HTTP/1.1's\n   Content-Encoding header field. Since this acts as a modifier on the\n   media type, proxies and gateways from HTTP to MIME-compliant\n   protocols MUST either change the value of the Content-Type header\n   field or decode the entity-body before forwarding the message. (Some\n   experimental applications of Content-Type for Internet mail have used\n   a media-type parameter of \";conversions=<content-coding>\" to perform\n   a function equivalent to Content-Encoding. However, this parameter is\n   not part of RFC 2045.)\n\n19.4.5 No Content-Transfer-Encoding\n\n   HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC\n   2045. Proxies and gateways from MIME-compliant protocols to HTTP MUST\n   remove any non-identity CTE (\"quoted-printable\" or \"base64\") encoding\n   prior to delivering the response message to an HTTP client.\n\n   Proxies and gateways from HTTP to MIME-compliant protocols are\n   responsible for ensuring that the message is in the correct format\n   and encoding for safe transport on that protocol, where \"safe\n\n\n\nFielding, et al.            Standards Track                   [Page 168]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   transport\" is defined by the limitations of the protocol being used.\n   Such a proxy or gateway SHOULD label the data with an appropriate\n   Content-Transfer-Encoding if doing so will improve the likelihood of\n   safe transport over the destination protocol.\n\n19.4.6 Introduction of Transfer-Encoding\n\n   HTTP/1.1 introduces the Transfer-Encoding header field (section\n   14.41). Proxies/gateways MUST remove any transfer-coding prior to\n   forwarding a message via a MIME-compliant protocol."
      },
      {
        "chunk_id": "rfc_http_chunk_109",
        "original_index": 109,
        "content": "HTTP/1.1 introduces the Transfer-Encoding header field (section\n   14.41). Proxies/gateways MUST remove any transfer-coding prior to\n   forwarding a message via a MIME-compliant protocol.\n\n   A process for decoding the \"chunked\" transfer-coding (section 3.6)\n   can be represented in pseudo-code as:\n\n       length := 0\n       read chunk-size, chunk-extension (if any) and CRLF\n       while (chunk-size > 0) {\n          read chunk-data and CRLF\n          append chunk-data to entity-body\n          length := length + chunk-size\n          read chunk-size and CRLF\n       }\n       read entity-header\n       while (entity-header not empty) {\n          append entity-header to existing header fields\n          read entity-header\n       }\n       Content-Length := length\n       Remove \"chunked\" from Transfer-Encoding\n\n19.4.7 MHTML and Line Length Limitations\n\n   HTTP implementations which share code with MHTML [45] implementations\n   need to be aware of MIME line length limitations. Since HTTP does not\n   have this limitation, HTTP does not fold long lines. MHTML messages\n   being transported by HTTP follow all conventions of MHTML, including\n   line length limitations and folding, canonicalization, etc., since\n   HTTP transports all message-bodies as payload (see section 3.7.2) and\n   does not interpret the content or any MIME header lines that might be\n   contained therein.\n\n19.5 Additional Features\n\n   RFC 1945 and RFC 2068 document protocol elements used by some\n   existing HTTP implementations, but not consistently and correctly\n   across most HTTP/1.1 applications. Implementors are advised to be\n   aware of these features, but cannot rely upon their presence in, or\n   interoperability with, other HTTP/1.1 applications. Some of these\n\n\n\nFielding, et al.            Standards Track                   [Page 169]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   describe proposed experimental features, and some describe features\n   that experimental deployment found lacking that are now addressed in\n   the base HTTP/1.1 specification.\n\n   A number of other headers, such as Content-Disposition and Title,\n   from SMTP and MIME are also often implemented (see RFC 2076 [37]).\n\n19.5.1 Content-Disposition\n\n   The Content-Disposition response-header field has been proposed as a\n   means for the origin server to suggest a default filename if the user\n   requests that the content is saved to a file. This usage is derived\n   from the definition of Content-Disposition in RFC 1806 [35].\n\n        content-disposition = \"Content-Disposition\" \":\"\n                              disposition-type *( \";\" disposition-parm )\n        disposition-type = \"attachment\" | disp-extension-token\n        disposition-parm = filename-parm | disp-extension-parm\n        filename-parm = \"filename\" \"=\" quoted-string\n        disp-extension-token = token\n        disp-extension-parm = token \"=\" ( token | quoted-string )\n\n   An example is\n\n        Content-Disposition: attachment; filename=\"fname.ext\"\n\n   The receiving user agent SHOULD NOT respect any directory path\n   information present in the filename-parm parameter, which is the only\n   parameter believed to apply to HTTP implementations at this time. The\n   filename SHOULD be treated as a terminal component only.\n\n   If this header is used in a response with the application/octet-\n   stream content-type, the implied suggestion is that the user agent\n   should not display the response, but directly enter a `save response\n   as...' dialog.\n\n   See section 15.5 for Content-Disposition security issues.\n\n19.6 Compatibility with Previous Versions\n\n   It is beyond the scope of a protocol specification to mandate\n   compliance with previous versions. HTTP/1.1 was deliberately\n   designed, however, to make supporting previous versions easy. It is\n   worth noting that, at the time of composing this specification\n   (1996), we would expect commercial HTTP/1.1 servers to:"
      },
      {
        "chunk_id": "rfc_http_chunk_110",
        "original_index": 110,
        "content": "- recognize the format of the Request-Line for HTTP/0.9, 1.0, and\n        1.1 requests;\n\n\n\nFielding, et al.            Standards Track                   [Page 170]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - understand any valid request in the format of HTTP/0.9, 1.0, or\n        1.1;\n\n      - respond appropriately with a message in the same major version\n        used by the client.\n\n   And we would expect HTTP/1.1 clients to:\n\n      - recognize the format of the Status-Line for HTTP/1.0 and 1.1\n        responses;\n\n      - understand any valid response in the format of HTTP/0.9, 1.0, or\n        1.1.\n\n   For most implementations of HTTP/1.0, each connection is established\n   by the client prior to the request and closed by the server after\n   sending the response. Some implementations implement the Keep-Alive\n   version of persistent connections described in section 19.7.1 of RFC\n   2068 [33].\n\n19.6.1 Changes from HTTP/1.0\n\n   This section summarizes major differences between versions HTTP/1.0\n   and HTTP/1.1.\n\n19.6.1.1 Changes to Simplify Multi-homed Web Servers and Conserve IP\n         Addresses\n\n   The requirements that clients and servers support the Host request-\n   header, report an error if the Host request-header (section 14.23) is\n   missing from an HTTP/1.1 request, and accept absolute URIs (section\n   5.1.2) are among the most important changes defined by this\n   specification.\n\n   Older HTTP/1.0 clients assumed a one-to-one relationship of IP\n   addresses and servers; there was no other established mechanism for\n   distinguishing the intended server of a request than the IP address\n   to which that request was directed. The changes outlined above will\n   allow the Internet, once older HTTP clients are no longer common, to\n   support multiple Web sites from a single IP address, greatly\n   simplifying large operational Web servers, where allocation of many\n   IP addresses to a single host has created serious problems. The\n   Internet will also be able to recover the IP addresses that have been\n   allocated for the sole purpose of allowing special-purpose domain\n   names to be used in root-level HTTP URLs. Given the rate of growth of\n   the Web, and the number of servers already deployed, it is extremely\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 171]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   important that all implementations of HTTP (including updates to\n   existing HTTP/1.0 applications) correctly implement these\n   requirements:\n\n      - Both clients and servers MUST support the Host request-header.\n\n      - A client that sends an HTTP/1.1 request MUST send a Host header.\n\n      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1\n        request does not include a Host request-header.\n\n      - Servers MUST accept absolute URIs.\n\n19.6.2 Compatibility with HTTP/1.0 Persistent Connections\n\n   Some clients and servers might wish to be compatible with some\n   previous implementations of persistent connections in HTTP/1.0\n   clients and servers. Persistent connections in HTTP/1.0 are\n   explicitly negotiated as they are not the default behavior. HTTP/1.0\n   experimental implementations of persistent connections are faulty,\n   and the new facilities in HTTP/1.1 are designed to rectify these\n   problems. The problem was that some existing 1.0 clients may be\n   sending Keep-Alive to a proxy server that doesn't understand\n   Connection, which would then erroneously forward it to the next\n   inbound server, which would establish the Keep-Alive connection and\n   result in a hung HTTP/1.0 proxy waiting for the close on the\n   response. The result is that HTTP/1.0 clients must be prevented from\n   using Keep-Alive when talking to proxies."
      },
      {
        "chunk_id": "rfc_http_chunk_111",
        "original_index": 111,
        "content": "However, talking to proxies is the most important use of persistent\n   connections, so that prohibition is clearly unacceptable. Therefore,\n   we need some other mechanism for indicating a persistent connection\n   is desired, which is safe to use even when talking to an old proxy\n   that ignores Connection. Persistent connections are the default for\n   HTTP/1.1 messages; we introduce a new keyword (Connection: close) for\n   declaring non-persistence. See section 14.10.\n\n   The original HTTP/1.0 form of persistent connections (the Connection:\n   Keep-Alive and Keep-Alive header) is documented in RFC 2068. [33]\n\n19.6.3 Changes from RFC 2068\n\n   This specification has been carefully audited to correct and\n   disambiguate key word usage; RFC 2068 had many problems in respect to\n   the conventions laid out in RFC 2119 [34].\n\n   Clarified which error code should be used for inbound server failures\n   (e.g. DNS failures). (Section 10.5.5).\n\n\n\nFielding, et al.            Standards Track                   [Page 172]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   CREATE had a race that required an Etag be sent when a resource is\n   first created. (Section 10.2.2).\n\n   Content-Base was deleted from the specification: it was not\n   implemented widely, and there is no simple, safe way to introduce it\n   without a robust extension mechanism. In addition, it is used in a\n   similar, but not identical fashion in MHTML [45].\n\n   Transfer-coding and message lengths all interact in ways that\n   required fixing exactly when chunked encoding is used (to allow for\n   transfer encoding that may not be self delimiting); it was important\n   to straighten out exactly how message lengths are computed. (Sections\n   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)\n\n   A content-coding of \"identity\" was introduced, to solve problems\n   discovered in caching. (section 3.5)\n\n   Quality Values of zero should indicate that \"I don't want something\"\n   to allow clients to refuse a representation. (Section 3.9)\n\n   The use and interpretation of HTTP version numbers has been clarified\n   by RFC 2145. Require proxies to upgrade requests to highest protocol\n   version they support to deal with problems discovered in HTTP/1.0\n   implementations (Section 3.1)\n\n   Charset wildcarding is introduced to avoid explosion of character set\n   names in accept headers. (Section 14.2)\n\n   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage\n   was introduced to add this missing case. (Sections 13.4, 14.8, 14.9,\n   14.9.3)\n\n   The Cache-Control: max-age directive was not properly defined for\n   responses. (Section 14.9.3)\n\n   There are situations where a server (especially a proxy) does not\n   know the full length of a response but is capable of serving a\n   byterange request. We therefore need a mechanism to allow byteranges\n   with a content-range not indicating the full length of the message.\n   (Section 14.16)\n\n   Range request responses would become very verbose if all meta-data\n   were always returned; by allowing the server to only send needed\n   headers in a 206 response, this problem can be avoided. (Section\n   10.2.7, 13.5.3, and 14.27)\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 173]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Fix problem with unsatisfiable range requests; there are two cases:\n   syntactic problems, and range doesn't exist in the document. The 416\n   status code was needed to resolve this ambiguity needed to indicate\n   an error for a byte range request that falls outside of the actual\n   contents of a document. (Section 10.4.17, 14.16)\n\n   Rewrite of message transmission requirements to make it much harder\n   for implementors to get it wrong, as the consequences of errors here\n   can have significant impact on the Internet, and to deal with the\n   following problems:"
      },
      {
        "chunk_id": "rfc_http_chunk_112",
        "original_index": 112,
        "content": "1. Changing \"HTTP/1.1 or later\" to \"HTTP/1.1\", in contexts where\n         this was incorrectly placing a requirement on the behavior of\n         an implementation of a future version of HTTP/1.x\n\n      2. Made it clear that user-agents should retry requests, not\n         \"clients\" in general.\n\n      3. Converted requirements for clients to ignore unexpected 100\n         (Continue) responses, and for proxies to forward 100 responses,\n         into a general requirement for 1xx responses.\n\n      4. Modified some TCP-specific language, to make it clearer that\n         non-TCP transports are possible for HTTP.\n\n      5. Require that the origin server MUST NOT wait for the request\n         body before it sends a required 100 (Continue) response.\n\n      6. Allow, rather than require, a server to omit 100 (Continue) if\n         it has already seen some of the request body.\n\n      7. Allow servers to defend against denial-of-service attacks and\n         broken clients.\n\n   This change adds the Expect header and 417 status code. The message\n   transmission requirements fixes are in sections 8.2, 10.4.18,\n   8.1.2.2, 13.11, and 14.20.\n\n   Proxies should be able to add Content-Length when appropriate.\n   (Section 13.5.2)\n\n   Clean up confusion between 403 and 404 responses. (Section 10.4.4,\n   10.4.5, and 10.4.11)\n\n   Warnings could be cached incorrectly, or not updated appropriately.\n   (Section 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning\n   also needed to be a general header, as PUT or other methods may have\n   need for it in requests.\n\n\n\nFielding, et al.            Standards Track                   [Page 174]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Transfer-coding had significant problems, particularly with\n   interactions with chunked encoding. The solution is that transfer-\n   codings become as full fledged as content-codings. This involves\n   adding an IANA registry for transfer-codings (separate from content\n   codings), a new header field (TE) and enabling trailer headers in the\n   future. Transfer encoding is a major performance benefit, so it was\n   worth fixing [39]. TE also solves another, obscure, downward\n   interoperability problem that could have occurred due to interactions\n   between authentication trailers, chunked encoding and HTTP/1.0\n   clients.(Section 3.6, 3.6.1, and 14.39)\n\n   The PATCH, LINK, UNLINK methods were defined but not commonly\n   implemented in previous versions of this specification. See RFC 2068\n   [33].\n\n   The Alternates, Content-Version, Derived-From, Link, URI, Public and\n   Content-Base header fields were defined in previous versions of this\n   specification, but not commonly implemented. See RFC 2068 [33].\n\n20 Index\n\n   Please see the PostScript version of this RFC for the INDEX.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 175]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n21.  Full Copyright Statement\n\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n\n   This document and translations of it may be copied and furnished to\n   others, and derivative works that comment on or otherwise explain it\n   or assist in its implementation may be prepared, copied, published\n   and distributed, in whole or in part, without restriction of any\n   kind, provided that the above copyright notice and this paragraph are\n   included on all such copies and derivative works.  However, this\n   document itself may not be modified in any way, such as by removing\n   the copyright notice or references to the Internet Society or other\n   Internet organizations, except as needed for the purpose of\n   developing Internet standards in which case the procedures for\n   copyrights defined in the Internet Standards process must be\n   followed, or as required to translate it into languages other than\n   English."
      },
      {
        "chunk_id": "rfc_http_chunk_113",
        "original_index": 113,
        "content": "The limited permissions granted above are perpetual and will not be\n   revoked by the Internet Society or its successors or assigns.\n\n   This document and the information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\nAcknowledgement\n\n   Funding for the RFC Editor function is currently provided by the\n   Internet Society.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 176]"
      }
    ]
  },
  {
    "doc_id": "rfc_json",
    "original_uuid": "ee1a",
    "content": "\n\n\n\n\n\nInternet Engineering Task Force (IETF)                      T. Bray, Ed.\nRequest for Comments: 8259                                    Textuality\nObsoletes: 7159                                            December 2017\nCategory: Standards Track\nISSN: 2070-1721\n\n\n     The JavaScript Object Notation (JSON) Data Interchange Format\n\nAbstract\n\n   JavaScript Object Notation (JSON) is a lightweight, text-based,\n   language-independent data interchange format.  It was derived from\n   the ECMAScript Programming Language Standard.  JSON defines a small\n   set of formatting rules for the portable representation of structured\n   data.\n\n   This document removes inconsistencies with other specifications of\n   JSON, repairs specification errors, and offers experience-based\n   interoperability guidance.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8259.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 1]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nCopyright Notice\n\n   Copyright (c) 2017 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(s) controlling the copyright in some of this\n   material may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 2]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nTable of Contents\n\n   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n     1.1.  Conventions Used in This Document . . . . . . . . . . . .   4\n     1.2.  Specifications of JSON  . . . . . . . . . . . . . . . . .   4\n     1.3.  Introduction to This Revision . . . . . . . . . . . . . .   5\n   2.  JSON Grammar  . . . . . . . . . . . . . . . . . . . . . . . .   5\n   3.  Values  . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n   4.  Objects . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n   5.  Arrays  . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n   6.  Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n   7.  Strings . . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n   8.  String and Character Issues . . . . . . . . . . . . . . . . .   9\n     8.1.  Character Encoding  . . . . . . . . . . . . . . . . . . .   9\n     8.2.  Unicode Characters  . . . . . . . . . . . . . . . . . . .  10\n     8.3.  String Comparison . . . . . . . . . . . . . . . . . . . .  10\n   9.  Parsers . . . . . . . . . . . . . . . . . . . . . . . . . . .  10\n   10. Generators  . . . . . . . . . . . . . . . . . . . . . . . . .  10\n   11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  11\n   12. Security Considerations . . . . . . . . . . . . . . . . . . .  12\n   13. Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  12\n   14. References  . . . . . . . . . . . . . . . . . . . . . . . . .  14\n     14.1.  Normative References . . . . . . . . . . . . . . . . . .  14\n     14.2.  Informative References . . . . . . . . . . . . . . . . .  14\n   Appendix A.  Changes from RFC 7159  . . . . . . . . . . . . . . .  16\n   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  16\n   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  16\n\n1.  Introduction\n\n   JavaScript Object Notation (JSON) is a text format for the\n   serialization of structured data.  It is derived from the object\n   literals of JavaScript, as defined in the ECMAScript Programming\n   Language Standard, Third Edition [ECMA-262].\n\n   JSON can represent four primitive types (strings, numbers, booleans,\n   and null) and two structured types (objects and arrays).\n\n   A string is a sequence of zero or more Unicode characters [UNICODE].\n   Note that this citation references the latest version of Unicode\n   rather than a specific release.  It is not expected that future\n   changes in the Unicode specification will impact the syntax of JSON.\n\n   An object is an unordered collection of zero or more name/value\n   pairs, where a name is a string and a value is a string, number,\n   boolean, null, object, or array.\n\n   An array is an ordered sequence of zero or more values.\n\n\n\nBray                         Standards Track                    [Page 3]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   The terms \"object\" and \"array\" come from the conventions of\n   JavaScript.\n\n   JSON's design goals were for it to be minimal, portable, textual, and\n   a subset of JavaScript.\n\n1.1.  Conventions Used in This Document\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described in BCP\n   14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals, as shown here.\n\n   The grammatical rules in this document are to be interpreted as\n   described in [RFC5234].\n\n1.2.  Specifications of JSON\n\n   This document replaces [RFC7159].  [RFC7159] obsoleted [RFC4627],\n   which originally described JSON and registered the media type\n   \"application/json\".\n\n   JSON is also described in [ECMA-404].\n\n   The reference to ECMA-404 in the previous sentence is normative, not\n   with the usual meaning that implementors need to consult it in order\n   to understand this document, but to emphasize that there are no\n   inconsistencies in the definition of the term \"JSON text\" in any of\n   its specifications.  Note, however, that ECMA-404 allows several\n   practices that this specification recommends avoiding in the\n   interests of maximal interoperability.\n\n   The intent is that the grammar is the same between the two documents,\n   although different descriptions are used.  If there is a difference\n   found between them, ECMA and the IETF will work together to update\n   both documents.\n\n   If an error is found with either document, the other should be\n   examined to see if it has a similar error; if it does, it should be\n   fixed, if possible.\n\n   If either document is changed in the future, ECMA and the IETF will\n   work together to ensure that the two documents stay aligned through\n   the change.\n\n\n\n\n\n\nBray                         Standards Track                    [Page 4]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n1.3.  Introduction to This Revision\n\n   In the years since the publication of RFC 4627, JSON has found very\n   wide use.  This experience has revealed certain patterns that, while\n   allowed by its specifications, have caused interoperability problems.\n\n   Also, a small number of errata have been reported regarding RFC 4627\n   (see RFC Errata IDs 607 [Err607] and 3607 [Err3607]) and regarding\n   RFC 7159 (see RFC Errata IDs 3915 [Err3915], 4264 [Err4264], 4336\n   [Err4336], and 4388 [Err4388]).\n\n   This document's goal is to apply the errata, remove inconsistencies\n   with other specifications of JSON, and highlight practices that can\n   lead to interoperability problems.\n\n2.  JSON Grammar\n\n   A JSON text is a sequence of tokens.  The set of tokens includes six\n   structural characters, strings, numbers, and three literal names.\n\n   A JSON text is a serialized value.  Note that certain previous\n   specifications of JSON constrained a JSON text to be an object or an\n   array.  Implementations that generate only objects or arrays where a\n   JSON text is called for will be interoperable in the sense that all\n   implementations will accept these as conforming JSON texts.\n\n      JSON-text = ws value ws\n\n   These are the six structural characters:\n\n      begin-array     = ws %x5B ws  ; [ left square bracket\n\n      begin-object    = ws %x7B ws  ; { left curly bracket\n\n      end-array       = ws %x5D ws  ; ] right square bracket\n\n      end-object      = ws %x7D ws  ; } right curly bracket\n\n      name-separator  = ws %x3A ws  ; : colon\n\n      value-separator = ws %x2C ws  ; , comma\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 5]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   Insignificant whitespace is allowed before or after any of the six\n   structural characters.\n\n      ws = *(\n              %x20 /              ; Space\n              %x09 /              ; Horizontal tab\n              %x0A /              ; Line feed or New line\n              %x0D )              ; Carriage return\n\n3.  Values\n\n   A JSON value MUST be an object, array, number, or string, or one of\n   the following three literal names:\n\n      false\n      null\n      true\n\n   The literal names MUST be lowercase.  No other literal names are\n   allowed.\n\n      value = false / null / true / object / array / number / string\n\n      false = %x66.61.6c.73.65   ; false\n\n      null  = %x6e.75.6c.6c      ; null\n\n      true  = %x74.72.75.65      ; true\n\n4.  Objects\n\n   An object structure is represented as a pair of curly brackets\n   surrounding zero or more name/value pairs (or members).  A name is a\n   string.  A single colon comes after each name, separating the name\n   from the value.  A single comma separates a value from a following\n   name.  The names within an object SHOULD be unique.\n\n      object = begin-object [ member *( value-separator member ) ]\n               end-object\n\n      member = string name-separator value\n\n   An object whose names are all unique is interoperable in the sense\n   that all software implementations receiving that object will agree on\n   the name-value mappings.  When the names within an object are not\n   unique, the behavior of software that receives such an object is\n   unpredictable.  Many implementations report the last name/value pair\n   only.  Other implementations report an error or fail to parse the\n\n\n\nBray                         Standards Track                    [Page 6]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   object, and some implementations report all of the name/value pairs,\n   including duplicates.\n\n   JSON parsing libraries have been observed to differ as to whether or\n   not they make the ordering of object members visible to calling\n   software.  Implementations whose behavior does not depend on member\n   ordering will be interoperable in the sense that they will not be\n   affected by these differences.\n\n5.  Arrays\n\n   An array structure is represented as square brackets surrounding zero\n   or more values (or elements).  Elements are separated by commas.\n\n   array = begin-array [ value *( value-separator value ) ] end-array\n\n   There is no requirement that the values in an array be of the same\n   type.\n\n6.  Numbers\n\n   The representation of numbers is similar to that used in most\n   programming languages.  A number is represented in base 10 using\n   decimal digits.  It contains an integer component that may be\n   prefixed with an optional minus sign, which may be followed by a\n   fraction part and/or an exponent part.  Leading zeros are not\n   allowed.\n\n   A fraction part is a decimal point followed by one or more digits.\n\n   An exponent part begins with the letter E in uppercase or lowercase,\n   which may be followed by a plus or minus sign.  The E and optional\n   sign are followed by one or more digits.\n\n   Numeric values that cannot be represented in the grammar below (such\n   as Infinity and NaN) are not permitted.\n\n      number = [ minus ] int [ frac ] [ exp ]\n\n      decimal-point = %x2E       ; .\n\n      digit1-9 = %x31-39         ; 1-9\n\n      e = %x65 / %x45            ; e E\n\n      exp = e [ minus / plus ] 1*DIGIT\n\n      frac = decimal-point 1*DIGIT\n\n\n\nBray                         Standards Track                    [Page 7]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n      int = zero / ( digit1-9 *DIGIT )\n\n      minus = %x2D               ; -\n\n      plus = %x2B                ; +\n\n      zero = %x30                ; 0\n\n   This specification allows implementations to set limits on the range\n   and precision of numbers accepted.  Since software that implements\n   IEEE 754 binary64 (double precision) numbers [IEEE754] is generally\n   available and widely used, good interoperability can be achieved by\n   implementations that expect no more precision or range than these\n   provide, in the sense that implementations will approximate JSON\n   numbers within the expected precision.  A JSON number such as 1E400\n   or 3.141592653589793238462643383279 may indicate potential\n   interoperability problems, since it suggests that the software that\n   created it expects receiving software to have greater capabilities\n   for numeric magnitude and precision than is widely available.\n\n   Note that when such software is used, numbers that are integers and\n   are in the range [-(2**53)+1, (2**53)-1] are interoperable in the\n   sense that implementations will agree exactly on their numeric\n   values.\n\n7.  Strings\n\n   The representation of strings is similar to conventions used in the C\n   family of programming languages.  A string begins and ends with\n   quotation marks.  All Unicode characters may be placed within the\n   quotation marks, except for the characters that MUST be escaped:\n   quotation mark, reverse solidus, and the control characters (U+0000\n   through U+001F).\n\n   Any character may be escaped.  If the character is in the Basic\n   Multilingual Plane (U+0000 through U+FFFF), then it may be\n   represented as a six-character sequence: a reverse solidus, followed\n   by the lowercase letter u, followed by four hexadecimal digits that\n   encode the character's code point.  The hexadecimal letters A through\n   F can be uppercase or lowercase.  So, for example, a string\n   containing only a single reverse solidus character may be represented\n   as \"\\u005C\".\n\n   Alternatively, there are two-character sequence escape\n   representations of some popular characters.  So, for example, a\n   string containing only a single reverse solidus character may be\n   represented more compactly as \"\\\\\".\n\n\n\n\nBray                         Standards Track                    [Page 8]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   To escape an extended character that is not in the Basic Multilingual\n   Plane, the character is represented as a 12-character sequence,\n   encoding the UTF-16 surrogate pair.  So, for example, a string\n   containing only the G clef character (U+1D11E) may be represented as\n   \"\\uD834\\uDD1E\".\n\n      string = quotation-mark *char quotation-mark\n\n      char = unescaped /\n          escape (\n              %x22 /          ; \"    quotation mark  U+0022\n              %x5C /          ; \\    reverse solidus U+005C\n              %x2F /          ; /    solidus         U+002F\n              %x62 /          ; b    backspace       U+0008\n              %x66 /          ; f    form feed       U+000C\n              %x6E /          ; n    line feed       U+000A\n              %x72 /          ; r    carriage return U+000D\n              %x74 /          ; t    tab             U+0009\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\n\n      escape = %x5C              ; \\\n\n      quotation-mark = %x22      ; \"\n\n      unescaped = %x20-21 / %x23-5B / %x5D-10FFFF\n\n8.  String and Character Issues\n\n8.1.  Character Encoding\n\n   JSON text exchanged between systems that are not part of a closed\n   ecosystem MUST be encoded using UTF-8 [RFC3629].\n\n   Previous specifications of JSON have not required the use of UTF-8\n   when transmitting JSON text.  However, the vast majority of JSON-\n   based software implementations have chosen to use the UTF-8 encoding,\n   to the extent that it is the only encoding that achieves\n   interoperability.\n\n   Implementations MUST NOT add a byte order mark (U+FEFF) to the\n   beginning of a networked-transmitted JSON text.  In the interests of\n   interoperability, implementations that parse JSON texts MAY ignore\n   the presence of a byte order mark rather than treating it as an\n   error.\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 9]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n8.2.  Unicode Characters\n\n   When all the strings represented in a JSON text are composed entirely\n   of Unicode characters [UNICODE] (however escaped), then that JSON\n   text is interoperable in the sense that all software implementations\n   that parse it will agree on the contents of names and of string\n   values in objects and arrays.\n\n   However, the ABNF in this specification allows member names and\n   string values to contain bit sequences that cannot encode Unicode\n   characters; for example, \"\\uDEAD\" (a single unpaired UTF-16\n   surrogate).  Instances of this have been observed, for example, when\n   a library truncates a UTF-16 string without checking whether the\n   truncation split a surrogate pair.  The behavior of software that\n   receives JSON texts containing such values is unpredictable; for\n   example, implementations might return different values for the length\n   of a string value or even suffer fatal runtime exceptions.\n\n8.3.  String Comparison\n\n   Software implementations are typically required to test names of\n   object members for equality.  Implementations that transform the\n   textual representation into sequences of Unicode code units and then\n   perform the comparison numerically, code unit by code unit, are\n   interoperable in the sense that implementations will agree in all\n   cases on equality or inequality of two strings.  For example,\n   implementations that compare strings with escaped characters\n   unconverted may incorrectly find that \"a\\\\b\" and \"a\\u005Cb\" are not\n   equal.\n\n9.  Parsers\n\n   A JSON parser transforms a JSON text into another representation.  A\n   JSON parser MUST accept all texts that conform to the JSON grammar.\n   A JSON parser MAY accept non-JSON forms or extensions.\n\n   An implementation may set limits on the size of texts that it\n   accepts.  An implementation may set limits on the maximum depth of\n   nesting.  An implementation may set limits on the range and precision\n   of numbers.  An implementation may set limits on the length and\n   character contents of strings.\n\n10.  Generators\n\n   A JSON generator produces JSON text.  The resulting text MUST\n   strictly conform to the JSON grammar.\n\n\n\n\n\nBray                         Standards Track                   [Page 10]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n11.  IANA Considerations\n\n   The media type for JSON text is application/json.\n\n   Type name:  application\n\n   Subtype name:  json\n\n   Required parameters:  n/a\n\n   Optional parameters:  n/a\n\n   Encoding considerations:  binary\n\n   Security considerations:  See RFC 8259, Section 12\n\n   Interoperability considerations:  Described in RFC 8259\n\n   Published specification:  RFC 8259\n\n   Applications that use this media type:\n      JSON has been used to exchange data between applications written\n      in all of these programming languages: ActionScript, C, C#,\n      Clojure, ColdFusion, Common Lisp, E, Erlang, Go, Java, JavaScript,\n      Lua, Objective CAML, Perl, PHP, Python, Rebol, Ruby, Scala, and\n      Scheme.\n\n   Additional information:\n      Magic number(s): n/a\n      File extension(s): .json\n      Macintosh file type code(s): TEXT\n\n   Person & email address to contact for further information:\n      IESG\n      <iesg@ietf.org>\n\n   Intended usage:  COMMON\n\n   Restrictions on usage:  none\n\n   Author:\n      Douglas Crockford\n      <douglas@crockford.com>\n\n   Change controller:\n      IESG\n      <iesg@ietf.org>\n\n\n\n\nBray                         Standards Track                   [Page 11]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   Note:  No \"charset\" parameter is defined for this registration.\n      Adding one really has no effect on compliant recipients.\n\n12.  Security Considerations\n\n   Generally, there are security issues with scripting languages.  JSON\n   is a subset of JavaScript but excludes assignment and invocation.\n\n   Since JSON's syntax is borrowed from JavaScript, it is possible to\n   use that language's \"eval()\" function to parse most JSON texts (but\n   not all; certain characters such as U+2028 LINE SEPARATOR and U+2029\n   PARAGRAPH SEPARATOR are legal in JSON but not JavaScript).  This\n   generally constitutes an unacceptable security risk, since the text\n   could contain executable code along with data declarations.  The same\n   consideration applies to the use of eval()-like functions in any\n   other programming language in which JSON texts conform to that\n   language's syntax.\n\n13.  Examples\n\n   This is a JSON object:\n\n      {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n          }\n      }\n\n   Its Image member is an object whose Thumbnail member is an object and\n   whose IDs member is an array of numbers.\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 12]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   This is a JSON array containing two objects:\n\n      [\n        {\n           \"precision\": \"zip\",\n           \"Latitude\":  37.7668,\n           \"Longitude\": -122.3959,\n           \"Address\":   \"\",\n           \"City\":      \"SAN FRANCISCO\",\n           \"State\":     \"CA\",\n           \"Zip\":       \"94107\",\n           \"Country\":   \"US\"\n        },\n        {\n           \"precision\": \"zip\",\n           \"Latitude\":  37.371991,\n           \"Longitude\": -122.026020,\n           \"Address\":   \"\",\n           \"City\":      \"SUNNYVALE\",\n           \"State\":     \"CA\",\n           \"Zip\":       \"94085\",\n           \"Country\":   \"US\"\n        }\n      ]\n\n   Here are three small JSON texts containing only values:\n\n   \"Hello world!\"\n\n   42\n\n   true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 13]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n14.  References\n\n14.1.  Normative References\n\n   [ECMA-404] Ecma International, \"The JSON Data Interchange Format\",\n              Standard ECMA-404,\n              <http://www.ecma-international.org/publications/\n              standards/Ecma-404.htm>.\n\n   [IEEE754]  IEEE, \"IEEE Standard for Floating-Point Arithmetic\",\n              IEEE 754.\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n              2003, <https://www.rfc-editor.org/info/rfc3629>.\n\n   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234, January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n\n   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n\n   [UNICODE]  The Unicode Consortium, \"The Unicode Standard\",\n              <http://www.unicode.org/versions/latest/>.\n\n14.2.  Informative References\n\n   [ECMA-262] Ecma International, \"ECMAScript Language Specification\",\n              Standard ECMA-262, Third Edition, December 1999,\n              <http://www.ecma-international.org/publications/files/\n              ECMA-ST-ARCH/\n              ECMA-262,%203rd%20edition,%20December%201999.pdf>.\n\n   [Err3607]  RFC Errata, Erratum ID 3607, RFC 4627,\n              <https://www.rfc-editor.org/errata/eid3607>.\n\n   [Err3915]  RFC Errata, Erratum ID 3915, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid3915>.\n\n\n\n\n\nBray                         Standards Track                   [Page 14]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   [Err4264]  RFC Errata, Erratum ID 4264, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4264>.\n\n   [Err4336]  RFC Errata, Erratum ID 4336, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4336>.\n\n   [Err4388]  RFC Errata, Erratum ID 4388, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4388>.\n\n   [Err607]   RFC Errata, Erratum ID 607, RFC 4627,\n              <https://www.rfc-editor.org/errata/eid607>.\n\n   [RFC4627]  Crockford, D., \"The application/json Media Type for\n              JavaScript Object Notation (JSON)\", RFC 4627,\n              DOI 10.17487/RFC4627, July 2006,\n              <https://www.rfc-editor.org/info/rfc4627>.\n\n   [RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n              Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March\n              2014, <https://www.rfc-editor.org/info/rfc7159>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 15]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nAppendix A.  Changes from RFC 7159\n\n   This section lists changes between this document and the text in\n   RFC 7159.\n\n   o  Section 1.2 has been updated to reflect the removal of a JSON\n      specification from ECMA-262, to make ECMA-404 a normative\n      reference, and to explain the particular meaning of \"normative\".\n\n   o  Section 1.3 has been updated to reflect errata filed against\n      RFC 7159, not RFC 4627.\n\n   o  Section 8.1 was changed to require the use of UTF-8 when\n      transmitted over a network.\n\n   o  Section 12 has been updated to increase the precision of the\n      description of the security risk that follows from using the\n      ECMAScript \"eval()\" function.\n\n   o  Section 14.1 has been updated to include ECMA-404 as a normative\n      reference.\n\n   o  Section 14.2 has been updated to remove ECMA-404, update the\n      version of ECMA-262, and refresh the errata list.\n\nContributors\n\n   RFC 4627 was written by Douglas Crockford.  This document was\n   constructed by making a relatively small number of changes to that\n   document; thus, the vast majority of the text here is his.\n\nAuthor's Address\n\n   Tim Bray (editor)\n   Textuality\n\n   Email: tbray@textuality.com\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 16]\n\f\n",
    "chunks": [
      {
        "chunk_id": "rfc_json_chunk_0",
        "original_index": 0,
        "content": "Internet Engineering Task Force (IETF)                      T. Bray, Ed.\nRequest for Comments: 8259                                    Textuality\nObsoletes: 7159                                            December 2017\nCategory: Standards Track\nISSN: 2070-1721\n\n\n     The JavaScript Object Notation (JSON) Data Interchange Format\n\nAbstract\n\n   JavaScript Object Notation (JSON) is a lightweight, text-based,\n   language-independent data interchange format.  It was derived from\n   the ECMAScript Programming Language Standard.  JSON defines a small\n   set of formatting rules for the portable representation of structured\n   data.\n\n   This document removes inconsistencies with other specifications of\n   JSON, repairs specification errors, and offers experience-based\n   interoperability guidance.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8259.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 1]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nCopyright Notice\n\n   Copyright (c) 2017 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(s) controlling the copyright in some of this\n   material may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 2]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nTable of Contents"
      },
      {
        "chunk_id": "rfc_json_chunk_1",
        "original_index": 1,
        "content": "Bray                         Standards Track                    [Page 2]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nTable of Contents\n\n   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n     1.1.  Conventions Used in This Document . . . . . . . . . . . .   4\n     1.2.  Specifications of JSON  . . . . . . . . . . . . . . . . .   4\n     1.3.  Introduction to This Revision . . . . . . . . . . . . . .   5\n   2.  JSON Grammar  . . . . . . . . . . . . . . . . . . . . . . . .   5\n   3.  Values  . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n   4.  Objects . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n   5.  Arrays  . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n   6.  Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n   7.  Strings . . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n   8.  String and Character Issues . . . . . . . . . . . . . . . . .   9\n     8.1.  Character Encoding  . . . . . . . . . . . . . . . . . . .   9\n     8.2.  Unicode Characters  . . . . . . . . . . . . . . . . . . .  10\n     8.3.  String Comparison . . . . . . . . . . . . . . . . . . . .  10\n   9.  Parsers . . . . . . . . . . . . . . . . . . . . . . . . . . .  10\n   10. Generators  . . . . . . . . . . . . . . . . . . . . . . . . .  10\n   11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  11\n   12. Security Considerations . . . . . . . . . . . . . . . . . . .  12\n   13. Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  12\n   14. References  . . . . . . . . . . . . . . . . . . . . . . . . .  14\n     14.1.  Normative References . . . . . . . . . . . . . . . . . .  14\n     14.2.  Informative References . . . . . . . . . . . . . . . . .  14\n   Appendix A.  Changes from RFC 7159  . . . . . . . . . . . . . . .  16\n   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  16\n   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  16\n\n1.  Introduction\n\n   JavaScript Object Notation (JSON) is a text format for the\n   serialization of structured data.  It is derived from the object\n   literals of JavaScript, as defined in the ECMAScript Programming\n   Language Standard, Third Edition [ECMA-262].\n\n   JSON can represent four primitive types (strings, numbers, booleans,\n   and null) and two structured types (objects and arrays).\n\n   A string is a sequence of zero or more Unicode characters [UNICODE].\n   Note that this citation references the latest version of Unicode\n   rather than a specific release.  It is not expected that future\n   changes in the Unicode specification will impact the syntax of JSON.\n\n   An object is an unordered collection of zero or more name/value\n   pairs, where a name is a string and a value is a string, number,\n   boolean, null, object, or array.\n\n   An array is an ordered sequence of zero or more values.\n\n\n\nBray                         Standards Track                    [Page 3]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   The terms \"object\" and \"array\" come from the conventions of\n   JavaScript.\n\n   JSON's design goals were for it to be minimal, portable, textual, and\n   a subset of JavaScript.\n\n1.1.  Conventions Used in This Document\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described in BCP\n   14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals, as shown here.\n\n   The grammatical rules in this document are to be interpreted as\n   described in [RFC5234].\n\n1.2.  Specifications of JSON\n\n   This document replaces [RFC7159].  [RFC7159] obsoleted [RFC4627],\n   which originally described JSON and registered the media type\n   \"application/json\".\n\n   JSON is also described in [ECMA-404]."
      },
      {
        "chunk_id": "rfc_json_chunk_2",
        "original_index": 2,
        "content": "This document replaces [RFC7159].  [RFC7159] obsoleted [RFC4627],\n   which originally described JSON and registered the media type\n   \"application/json\".\n\n   JSON is also described in [ECMA-404].\n\n   The reference to ECMA-404 in the previous sentence is normative, not\n   with the usual meaning that implementors need to consult it in order\n   to understand this document, but to emphasize that there are no\n   inconsistencies in the definition of the term \"JSON text\" in any of\n   its specifications.  Note, however, that ECMA-404 allows several\n   practices that this specification recommends avoiding in the\n   interests of maximal interoperability.\n\n   The intent is that the grammar is the same between the two documents,\n   although different descriptions are used.  If there is a difference\n   found between them, ECMA and the IETF will work together to update\n   both documents.\n\n   If an error is found with either document, the other should be\n   examined to see if it has a similar error; if it does, it should be\n   fixed, if possible.\n\n   If either document is changed in the future, ECMA and the IETF will\n   work together to ensure that the two documents stay aligned through\n   the change.\n\n\n\n\n\n\nBray                         Standards Track                    [Page 4]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n1.3.  Introduction to This Revision\n\n   In the years since the publication of RFC 4627, JSON has found very\n   wide use.  This experience has revealed certain patterns that, while\n   allowed by its specifications, have caused interoperability problems.\n\n   Also, a small number of errata have been reported regarding RFC 4627\n   (see RFC Errata IDs 607 [Err607] and 3607 [Err3607]) and regarding\n   RFC 7159 (see RFC Errata IDs 3915 [Err3915], 4264 [Err4264], 4336\n   [Err4336], and 4388 [Err4388]).\n\n   This document's goal is to apply the errata, remove inconsistencies\n   with other specifications of JSON, and highlight practices that can\n   lead to interoperability problems.\n\n2.  JSON Grammar\n\n   A JSON text is a sequence of tokens.  The set of tokens includes six\n   structural characters, strings, numbers, and three literal names.\n\n   A JSON text is a serialized value.  Note that certain previous\n   specifications of JSON constrained a JSON text to be an object or an\n   array.  Implementations that generate only objects or arrays where a\n   JSON text is called for will be interoperable in the sense that all\n   implementations will accept these as conforming JSON texts.\n\n      JSON-text = ws value ws\n\n   These are the six structural characters:\n\n      begin-array     = ws %x5B ws  ; [ left square bracket\n\n      begin-object    = ws %x7B ws  ; { left curly bracket\n\n      end-array       = ws %x5D ws  ; ] right square bracket\n\n      end-object      = ws %x7D ws  ; } right curly bracket\n\n      name-separator  = ws %x3A ws  ; : colon\n\n      value-separator = ws %x2C ws  ; , comma\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 5]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   Insignificant whitespace is allowed before or after any of the six\n   structural characters.\n\n      ws = *(\n              %x20 /              ; Space\n              %x09 /              ; Horizontal tab\n              %x0A /              ; Line feed or New line\n              %x0D )              ; Carriage return\n\n3.  Values\n\n   A JSON value MUST be an object, array, number, or string, or one of\n   the following three literal names:\n\n      false\n      null\n      true\n\n   The literal names MUST be lowercase.  No other literal names are\n   allowed.\n\n      value = false / null / true / object / array / number / string\n\n      false = %x66.61.6c.73.65   ; false\n\n      null  = %x6e.75.6c.6c      ; null\n\n      true  = %x74.72.75.65      ; true\n\n4.  Objects"
      },
      {
        "chunk_id": "rfc_json_chunk_3",
        "original_index": 3,
        "content": "false = %x66.61.6c.73.65   ; false\n\n      null  = %x6e.75.6c.6c      ; null\n\n      true  = %x74.72.75.65      ; true\n\n4.  Objects\n\n   An object structure is represented as a pair of curly brackets\n   surrounding zero or more name/value pairs (or members).  A name is a\n   string.  A single colon comes after each name, separating the name\n   from the value.  A single comma separates a value from a following\n   name.  The names within an object SHOULD be unique.\n\n      object = begin-object [ member *( value-separator member ) ]\n               end-object\n\n      member = string name-separator value\n\n   An object whose names are all unique is interoperable in the sense\n   that all software implementations receiving that object will agree on\n   the name-value mappings.  When the names within an object are not\n   unique, the behavior of software that receives such an object is\n   unpredictable.  Many implementations report the last name/value pair\n   only.  Other implementations report an error or fail to parse the\n\n\n\nBray                         Standards Track                    [Page 6]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   object, and some implementations report all of the name/value pairs,\n   including duplicates.\n\n   JSON parsing libraries have been observed to differ as to whether or\n   not they make the ordering of object members visible to calling\n   software.  Implementations whose behavior does not depend on member\n   ordering will be interoperable in the sense that they will not be\n   affected by these differences.\n\n5.  Arrays\n\n   An array structure is represented as square brackets surrounding zero\n   or more values (or elements).  Elements are separated by commas.\n\n   array = begin-array [ value *( value-separator value ) ] end-array\n\n   There is no requirement that the values in an array be of the same\n   type.\n\n6.  Numbers\n\n   The representation of numbers is similar to that used in most\n   programming languages.  A number is represented in base 10 using\n   decimal digits.  It contains an integer component that may be\n   prefixed with an optional minus sign, which may be followed by a\n   fraction part and/or an exponent part.  Leading zeros are not\n   allowed.\n\n   A fraction part is a decimal point followed by one or more digits.\n\n   An exponent part begins with the letter E in uppercase or lowercase,\n   which may be followed by a plus or minus sign.  The E and optional\n   sign are followed by one or more digits.\n\n   Numeric values that cannot be represented in the grammar below (such\n   as Infinity and NaN) are not permitted.\n\n      number = [ minus ] int [ frac ] [ exp ]\n\n      decimal-point = %x2E       ; .\n\n      digit1-9 = %x31-39         ; 1-9\n\n      e = %x65 / %x45            ; e E\n\n      exp = e [ minus / plus ] 1*DIGIT\n\n      frac = decimal-point 1*DIGIT\n\n\n\nBray                         Standards Track                    [Page 7]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n      int = zero / ( digit1-9 *DIGIT )\n\n      minus = %x2D               ; -\n\n      plus = %x2B                ; +\n\n      zero = %x30                ; 0\n\n   This specification allows implementations to set limits on the range\n   and precision of numbers accepted.  Since software that implements\n   IEEE 754 binary64 (double precision) numbers [IEEE754] is generally\n   available and widely used, good interoperability can be achieved by\n   implementations that expect no more precision or range than these\n   provide, in the sense that implementations will approximate JSON\n   numbers within the expected precision.  A JSON number such as 1E400\n   or 3.141592653589793238462643383279 may indicate potential\n   interoperability problems, since it suggests that the software that\n   created it expects receiving software to have greater capabilities\n   for numeric magnitude and precision than is widely available."
      },
      {
        "chunk_id": "rfc_json_chunk_4",
        "original_index": 4,
        "content": "Note that when such software is used, numbers that are integers and\n   are in the range [-(2**53)+1, (2**53)-1] are interoperable in the\n   sense that implementations will agree exactly on their numeric\n   values.\n\n7.  Strings\n\n   The representation of strings is similar to conventions used in the C\n   family of programming languages.  A string begins and ends with\n   quotation marks.  All Unicode characters may be placed within the\n   quotation marks, except for the characters that MUST be escaped:\n   quotation mark, reverse solidus, and the control characters (U+0000\n   through U+001F).\n\n   Any character may be escaped.  If the character is in the Basic\n   Multilingual Plane (U+0000 through U+FFFF), then it may be\n   represented as a six-character sequence: a reverse solidus, followed\n   by the lowercase letter u, followed by four hexadecimal digits that\n   encode the character's code point.  The hexadecimal letters A through\n   F can be uppercase or lowercase.  So, for example, a string\n   containing only a single reverse solidus character may be represented\n   as \"\\u005C\".\n\n   Alternatively, there are two-character sequence escape\n   representations of some popular characters.  So, for example, a\n   string containing only a single reverse solidus character may be\n   represented more compactly as \"\\\\\".\n\n\n\n\nBray                         Standards Track                    [Page 8]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   To escape an extended character that is not in the Basic Multilingual\n   Plane, the character is represented as a 12-character sequence,\n   encoding the UTF-16 surrogate pair.  So, for example, a string\n   containing only the G clef character (U+1D11E) may be represented as\n   \"\\uD834\\uDD1E\".\n\n      string = quotation-mark *char quotation-mark\n\n      char = unescaped /\n          escape (\n              %x22 /          ; \"    quotation mark  U+0022\n              %x5C /          ; \\    reverse solidus U+005C\n              %x2F /          ; /    solidus         U+002F\n              %x62 /          ; b    backspace       U+0008\n              %x66 /          ; f    form feed       U+000C\n              %x6E /          ; n    line feed       U+000A\n              %x72 /          ; r    carriage return U+000D\n              %x74 /          ; t    tab             U+0009\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\n\n      escape = %x5C              ; \\\n\n      quotation-mark = %x22      ; \"\n\n      unescaped = %x20-21 / %x23-5B / %x5D-10FFFF\n\n8.  String and Character Issues\n\n8.1.  Character Encoding\n\n   JSON text exchanged between systems that are not part of a closed\n   ecosystem MUST be encoded using UTF-8 [RFC3629].\n\n   Previous specifications of JSON have not required the use of UTF-8\n   when transmitting JSON text.  However, the vast majority of JSON-\n   based software implementations have chosen to use the UTF-8 encoding,\n   to the extent that it is the only encoding that achieves\n   interoperability.\n\n   Implementations MUST NOT add a byte order mark (U+FEFF) to the\n   beginning of a networked-transmitted JSON text.  In the interests of\n   interoperability, implementations that parse JSON texts MAY ignore\n   the presence of a byte order mark rather than treating it as an\n   error.\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 9]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n8.2.  Unicode Characters\n\n   When all the strings represented in a JSON text are composed entirely\n   of Unicode characters [UNICODE] (however escaped), then that JSON\n   text is interoperable in the sense that all software implementations\n   that parse it will agree on the contents of names and of string\n   values in objects and arrays."
      },
      {
        "chunk_id": "rfc_json_chunk_5",
        "original_index": 5,
        "content": "However, the ABNF in this specification allows member names and\n   string values to contain bit sequences that cannot encode Unicode\n   characters; for example, \"\\uDEAD\" (a single unpaired UTF-16\n   surrogate).  Instances of this have been observed, for example, when\n   a library truncates a UTF-16 string without checking whether the\n   truncation split a surrogate pair.  The behavior of software that\n   receives JSON texts containing such values is unpredictable; for\n   example, implementations might return different values for the length\n   of a string value or even suffer fatal runtime exceptions.\n\n8.3.  String Comparison\n\n   Software implementations are typically required to test names of\n   object members for equality.  Implementations that transform the\n   textual representation into sequences of Unicode code units and then\n   perform the comparison numerically, code unit by code unit, are\n   interoperable in the sense that implementations will agree in all\n   cases on equality or inequality of two strings.  For example,\n   implementations that compare strings with escaped characters\n   unconverted may incorrectly find that \"a\\\\b\" and \"a\\u005Cb\" are not\n   equal.\n\n9.  Parsers\n\n   A JSON parser transforms a JSON text into another representation.  A\n   JSON parser MUST accept all texts that conform to the JSON grammar.\n   A JSON parser MAY accept non-JSON forms or extensions.\n\n   An implementation may set limits on the size of texts that it\n   accepts.  An implementation may set limits on the maximum depth of\n   nesting.  An implementation may set limits on the range and precision\n   of numbers.  An implementation may set limits on the length and\n   character contents of strings.\n\n10.  Generators\n\n   A JSON generator produces JSON text.  The resulting text MUST\n   strictly conform to the JSON grammar.\n\n\n\n\n\nBray                         Standards Track                   [Page 10]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n11.  IANA Considerations\n\n   The media type for JSON text is application/json.\n\n   Type name:  application\n\n   Subtype name:  json\n\n   Required parameters:  n/a\n\n   Optional parameters:  n/a\n\n   Encoding considerations:  binary\n\n   Security considerations:  See RFC 8259, Section 12\n\n   Interoperability considerations:  Described in RFC 8259\n\n   Published specification:  RFC 8259\n\n   Applications that use this media type:\n      JSON has been used to exchange data between applications written\n      in all of these programming languages: ActionScript, C, C#,\n      Clojure, ColdFusion, Common Lisp, E, Erlang, Go, Java, JavaScript,\n      Lua, Objective CAML, Perl, PHP, Python, Rebol, Ruby, Scala, and\n      Scheme.\n\n   Additional information:\n      Magic number(s): n/a\n      File extension(s): .json\n      Macintosh file type code(s): TEXT\n\n   Person & email address to contact for further information:\n      IESG\n      <iesg@ietf.org>\n\n   Intended usage:  COMMON\n\n   Restrictions on usage:  none\n\n   Author:\n      Douglas Crockford\n      <douglas@crockford.com>\n\n   Change controller:\n      IESG\n      <iesg@ietf.org>\n\n\n\n\nBray                         Standards Track                   [Page 11]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   Note:  No \"charset\" parameter is defined for this registration.\n      Adding one really has no effect on compliant recipients.\n\n12.  Security Considerations\n\n   Generally, there are security issues with scripting languages.  JSON\n   is a subset of JavaScript but excludes assignment and invocation."
      },
      {
        "chunk_id": "rfc_json_chunk_6",
        "original_index": 6,
        "content": "12.  Security Considerations\n\n   Generally, there are security issues with scripting languages.  JSON\n   is a subset of JavaScript but excludes assignment and invocation.\n\n   Since JSON's syntax is borrowed from JavaScript, it is possible to\n   use that language's \"eval()\" function to parse most JSON texts (but\n   not all; certain characters such as U+2028 LINE SEPARATOR and U+2029\n   PARAGRAPH SEPARATOR are legal in JSON but not JavaScript).  This\n   generally constitutes an unacceptable security risk, since the text\n   could contain executable code along with data declarations.  The same\n   consideration applies to the use of eval()-like functions in any\n   other programming language in which JSON texts conform to that\n   language's syntax.\n\n13.  Examples\n\n   This is a JSON object:\n\n      {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n          }\n      }\n\n   Its Image member is an object whose Thumbnail member is an object and\n   whose IDs member is an array of numbers.\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 12]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   This is a JSON array containing two objects:\n\n      [\n        {\n           \"precision\": \"zip\",\n           \"Latitude\":  37.7668,\n           \"Longitude\": -122.3959,\n           \"Address\":   \"\",\n           \"City\":      \"SAN FRANCISCO\",\n           \"State\":     \"CA\",\n           \"Zip\":       \"94107\",\n           \"Country\":   \"US\"\n        },\n        {\n           \"precision\": \"zip\",\n           \"Latitude\":  37.371991,\n           \"Longitude\": -122.026020,\n           \"Address\":   \"\",\n           \"City\":      \"SUNNYVALE\",\n           \"State\":     \"CA\",\n           \"Zip\":       \"94085\",\n           \"Country\":   \"US\"\n        }\n      ]\n\n   Here are three small JSON texts containing only values:\n\n   \"Hello world!\"\n\n   42\n\n   true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 13]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n14.  References\n\n14.1.  Normative References\n\n   [ECMA-404] Ecma International, \"The JSON Data Interchange Format\",\n              Standard ECMA-404,\n              <http://www.ecma-international.org/publications/\n              standards/Ecma-404.htm>.\n\n   [IEEE754]  IEEE, \"IEEE Standard for Floating-Point Arithmetic\",\n              IEEE 754.\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n              2003, <https://www.rfc-editor.org/info/rfc3629>.\n\n   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234, January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n\n   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n\n   [UNICODE]  The Unicode Consortium, \"The Unicode Standard\",\n              <http://www.unicode.org/versions/latest/>.\n\n14.2.  Informative References"
      },
      {
        "chunk_id": "rfc_json_chunk_7",
        "original_index": 7,
        "content": "[UNICODE]  The Unicode Consortium, \"The Unicode Standard\",\n              <http://www.unicode.org/versions/latest/>.\n\n14.2.  Informative References\n\n   [ECMA-262] Ecma International, \"ECMAScript Language Specification\",\n              Standard ECMA-262, Third Edition, December 1999,\n              <http://www.ecma-international.org/publications/files/\n              ECMA-ST-ARCH/\n              ECMA-262,%203rd%20edition,%20December%201999.pdf>.\n\n   [Err3607]  RFC Errata, Erratum ID 3607, RFC 4627,\n              <https://www.rfc-editor.org/errata/eid3607>.\n\n   [Err3915]  RFC Errata, Erratum ID 3915, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid3915>.\n\n\n\n\n\nBray                         Standards Track                   [Page 14]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   [Err4264]  RFC Errata, Erratum ID 4264, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4264>.\n\n   [Err4336]  RFC Errata, Erratum ID 4336, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4336>.\n\n   [Err4388]  RFC Errata, Erratum ID 4388, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4388>.\n\n   [Err607]   RFC Errata, Erratum ID 607, RFC 4627,\n              <https://www.rfc-editor.org/errata/eid607>.\n\n   [RFC4627]  Crockford, D., \"The application/json Media Type for\n              JavaScript Object Notation (JSON)\", RFC 4627,\n              DOI 10.17487/RFC4627, July 2006,\n              <https://www.rfc-editor.org/info/rfc4627>.\n\n   [RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n              Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March\n              2014, <https://www.rfc-editor.org/info/rfc7159>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 15]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nAppendix A.  Changes from RFC 7159\n\n   This section lists changes between this document and the text in\n   RFC 7159.\n\n   o  Section 1.2 has been updated to reflect the removal of a JSON\n      specification from ECMA-262, to make ECMA-404 a normative\n      reference, and to explain the particular meaning of \"normative\".\n\n   o  Section 1.3 has been updated to reflect errata filed against\n      RFC 7159, not RFC 4627.\n\n   o  Section 8.1 was changed to require the use of UTF-8 when\n      transmitted over a network.\n\n   o  Section 12 has been updated to increase the precision of the\n      description of the security risk that follows from using the\n      ECMAScript \"eval()\" function.\n\n   o  Section 14.1 has been updated to include ECMA-404 as a normative\n      reference.\n\n   o  Section 14.2 has been updated to remove ECMA-404, update the\n      version of ECMA-262, and refresh the errata list.\n\nContributors\n\n   RFC 4627 was written by Douglas Crockford.  This document was\n   constructed by making a relatively small number of changes to that\n   document; thus, the vast majority of the text here is his.\n\nAuthor's Address\n\n   Tim Bray (editor)\n   Textuality\n\n   Email: tbray@textuality.com\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 16]"
      }
    ]
  },
  {
    "doc_id": "rfc_oauth",
    "original_uuid": "38b2",
    "content": "\n\n\n\n\n\nInternet Engineering Task Force (IETF)                     D. Hardt, Ed.\nRequest for Comments: 6749                                     Microsoft\nObsoletes: 5849                                             October 2012\nCategory: Standards Track\nISSN: 2070-1721\n\n\n                 The OAuth 2.0 Authorization Framework\n\nAbstract\n\n   The OAuth 2.0 authorization framework enables a third-party\n   application to obtain limited access to an HTTP service, either on\n   behalf of a resource owner by orchestrating an approval interaction\n   between the resource owner and the HTTP service, or by allowing the\n   third-party application to obtain access on its own behalf.  This\n   specification replaces and obsoletes the OAuth 1.0 protocol described\n   in RFC 5849.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 5741.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6749.\n\nCopyright Notice\n\n   Copyright (c) 2012 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\n\n\n\nHardt                        Standards Track                    [Page 1]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nTable of Contents\n\n   1. Introduction ....................................................4\n      1.1. Roles ......................................................6\n      1.2. Protocol Flow ..............................................7\n      1.3. Authorization Grant ........................................8\n           1.3.1. Authorization Code ..................................8\n           1.3.2. Implicit ............................................8\n           1.3.3. Resource Owner Password Credentials .................9\n           1.3.4. Client Credentials ..................................9\n      1.4. Access Token ..............................................10\n      1.5. Refresh Token .............................................10\n      1.6. TLS Version ...............................................12\n      1.7. HTTP Redirections .........................................12\n      1.8. Interoperability ..........................................12\n      1.9. Notational Conventions ....................................13\n   2. Client Registration ............................................13\n      2.1. Client Types ..............................................14\n      2.2. Client Identifier .........................................15\n      2.3. Client Authentication .....................................16\n           2.3.1. Client Password ....................................16\n           2.3.2. Other Authentication Methods .......................17\n      2.4. Unregistered Clients ......................................17\n   3. Protocol Endpoints .............................................18\n      3.1. Authorization Endpoint ....................................18\n           3.1.1. Response Type ......................................19\n           3.1.2. Redirection Endpoint ...............................19\n      3.2. Token Endpoint ............................................21\n           3.2.1. Client Authentication ..............................22\n      3.3. Access Token Scope ........................................23\n   4. Obtaining Authorization ........................................23\n      4.1. Authorization Code Grant ..................................24\n           4.1.1. Authorization Request ..............................25\n           4.1.2. Authorization Response .............................26\n           4.1.3. Access Token Request ...............................29\n           4.1.4. Access Token Response ..............................30\n      4.2. Implicit Grant ............................................31\n           4.2.1. Authorization Request ..............................33\n           4.2.2. Access Token Response ..............................35\n      4.3. Resource Owner Password Credentials Grant .................37\n           4.3.1. Authorization Request and Response .................39\n           4.3.2. Access Token Request ...............................39\n           4.3.3. Access Token Response ..............................40\n      4.4. Client Credentials Grant ..................................40\n           4.4.1. Authorization Request and Response .................41\n           4.4.2. Access Token Request ...............................41\n           4.4.3. Access Token Response ..............................42\n      4.5. Extension Grants ..........................................42\n\n\n\nHardt                        Standards Track                    [Page 2]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   5. Issuing an Access Token ........................................43\n      5.1. Successful Response .......................................43\n      5.2. Error Response ............................................45\n   6. Refreshing an Access Token .....................................47\n   7. Accessing Protected Resources ..................................48\n      7.1. Access Token Types ........................................49\n      7.2. Error Response ............................................49\n   8. Extensibility ..................................................50\n      8.1. Defining Access Token Types ...............................50\n      8.2. Defining New Endpoint Parameters ..........................50\n      8.3. Defining New Authorization Grant Types ....................51\n      8.4. Defining New Authorization Endpoint Response Types ........51\n      8.5. Defining Additional Error Codes ...........................51\n   9. Native Applications ............................................52\n   10. Security Considerations .......................................53\n      10.1. Client Authentication ....................................53\n      10.2. Client Impersonation .....................................54\n      10.3. Access Tokens ............................................55\n      10.4. Refresh Tokens ...........................................55\n      10.5. Authorization Codes ......................................56\n      10.6. Authorization Code Redirection URI Manipulation ..........56\n      10.7. Resource Owner Password Credentials ......................57\n      10.8. Request Confidentiality ..................................58\n      10.9. Ensuring Endpoint Authenticity ...........................58\n      10.10. Credentials-Guessing Attacks ............................58\n      10.11. Phishing Attacks ........................................58\n      10.12. Cross-Site Request Forgery ..............................59\n      10.13. Clickjacking ............................................60\n      10.14. Code Injection and Input Validation .....................60\n      10.15. Open Redirectors ........................................60\n      10.16. Misuse of Access Token to Impersonate Resource\n             Owner in Implicit Flow ..................................61\n   11. IANA Considerations ...........................................62\n      11.1. OAuth Access Token Types Registry ........................62\n           11.1.1. Registration Template .............................62\n      11.2. OAuth Parameters Registry ................................63\n           11.2.1. Registration Template .............................63\n           11.2.2. Initial Registry Contents .........................64\n      11.3. OAuth Authorization Endpoint Response Types Registry .....66\n           11.3.1. Registration Template .............................66\n           11.3.2. Initial Registry Contents .........................67\n      11.4. OAuth Extensions Error Registry ..........................67\n           11.4.1. Registration Template .............................68\n   12. References ....................................................68\n      12.1. Normative References .....................................68\n      12.2. Informative References ...................................70\n\n\n\n\n\nHardt                        Standards Track                    [Page 3]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Appendix A. Augmented Backus-Naur Form (ABNF) Syntax ..............71\n     A.1.  \"client_id\" Syntax ........................................71\n     A.2.  \"client_secret\" Syntax ....................................71\n     A.3.  \"response_type\" Syntax ....................................71\n     A.4.  \"scope\" Syntax ............................................72\n     A.5.  \"state\" Syntax ............................................72\n     A.6.  \"redirect_uri\" Syntax .....................................72\n     A.7.  \"error\" Syntax ............................................72\n     A.8.  \"error_description\" Syntax ................................72\n     A.9.  \"error_uri\" Syntax ........................................72\n     A.10. \"grant_type\" Syntax .......................................73\n     A.11. \"code\" Syntax .............................................73\n     A.12. \"access_token\" Syntax .....................................73\n     A.13. \"token_type\" Syntax .......................................73\n     A.14. \"expires_in\" Syntax .......................................73\n     A.15. \"username\" Syntax .........................................73\n     A.16. \"password\" Syntax .........................................73\n     A.17. \"refresh_token\" Syntax ....................................74\n     A.18. Endpoint Parameter Syntax .................................74\n   Appendix B. Use of application/x-www-form-urlencoded Media Type ...74\n   Appendix C. Acknowledgements ......................................75\n\n1.  Introduction\n\n   In the traditional client-server authentication model, the client\n   requests an access-restricted resource (protected resource) on the\n   server by authenticating with the server using the resource owner's\n   credentials.  In order to provide third-party applications access to\n   restricted resources, the resource owner shares its credentials with\n   the third party.  This creates several problems and limitations:\n\n   o  Third-party applications are required to store the resource\n      owner's credentials for future use, typically a password in\n      clear-text.\n\n   o  Servers are required to support password authentication, despite\n      the security weaknesses inherent in passwords.\n\n   o  Third-party applications gain overly broad access to the resource\n      owner's protected resources, leaving resource owners without any\n      ability to restrict duration or access to a limited subset of\n      resources.\n\n   o  Resource owners cannot revoke access to an individual third party\n      without revoking access to all third parties, and must do so by\n      changing the third party's password.\n\n\n\n\n\nHardt                        Standards Track                    [Page 4]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   o  Compromise of any third-party application results in compromise of\n      the end-user's password and all of the data protected by that\n      password.\n\n   OAuth addresses these issues by introducing an authorization layer\n   and separating the role of the client from that of the resource\n   owner.  In OAuth, the client requests access to resources controlled\n   by the resource owner and hosted by the resource server, and is\n   issued a different set of credentials than those of the resource\n   owner.\n\n   Instead of using the resource owner's credentials to access protected\n   resources, the client obtains an access token -- a string denoting a\n   specific scope, lifetime, and other access attributes.  Access tokens\n   are issued to third-party clients by an authorization server with the\n   approval of the resource owner.  The client uses the access token to\n   access the protected resources hosted by the resource server.\n\n   For example, an end-user (resource owner) can grant a printing\n   service (client) access to her protected photos stored at a photo-\n   sharing service (resource server), without sharing her username and\n   password with the printing service.  Instead, she authenticates\n   directly with a server trusted by the photo-sharing service\n   (authorization server), which issues the printing service delegation-\n   specific credentials (access token).\n\n   This specification is designed for use with HTTP ([RFC2616]).  The\n   use of OAuth over any protocol other than HTTP is out of scope.\n\n   The OAuth 1.0 protocol ([RFC5849]), published as an informational\n   document, was the result of a small ad hoc community effort.  This\n   Standards Track specification builds on the OAuth 1.0 deployment\n   experience, as well as additional use cases and extensibility\n   requirements gathered from the wider IETF community.  The OAuth 2.0\n   protocol is not backward compatible with OAuth 1.0.  The two versions\n   may co-exist on the network, and implementations may choose to\n   support both.  However, it is the intention of this specification\n   that new implementations support OAuth 2.0 as specified in this\n   document and that OAuth 1.0 is used only to support existing\n   deployments.  The OAuth 2.0 protocol shares very few implementation\n   details with the OAuth 1.0 protocol.  Implementers familiar with\n   OAuth 1.0 should approach this document without any assumptions as to\n   its structure and details.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 5]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.1.  Roles\n\n   OAuth defines four roles:\n\n   resource owner\n      An entity capable of granting access to a protected resource.\n      When the resource owner is a person, it is referred to as an\n      end-user.\n\n   resource server\n      The server hosting the protected resources, capable of accepting\n      and responding to protected resource requests using access tokens.\n\n   client\n      An application making protected resource requests on behalf of the\n      resource owner and with its authorization.  The term \"client\" does\n      not imply any particular implementation characteristics (e.g.,\n      whether the application executes on a server, a desktop, or other\n      devices).\n\n   authorization server\n      The server issuing access tokens to the client after successfully\n      authenticating the resource owner and obtaining authorization.\n\n   The interaction between the authorization server and resource server\n   is beyond the scope of this specification.  The authorization server\n   may be the same server as the resource server or a separate entity.\n   A single authorization server may issue access tokens accepted by\n   multiple resource servers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 6]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.2.  Protocol Flow\n\n     +--------+                               +---------------+\n     |        |--(A)- Authorization Request ->|   Resource    |\n     |        |                               |     Owner     |\n     |        |<-(B)-- Authorization Grant ---|               |\n     |        |                               +---------------+\n     |        |\n     |        |                               +---------------+\n     |        |--(C)-- Authorization Grant -->| Authorization |\n     | Client |                               |     Server    |\n     |        |<-(D)----- Access Token -------|               |\n     |        |                               +---------------+\n     |        |\n     |        |                               +---------------+\n     |        |--(E)----- Access Token ------>|    Resource   |\n     |        |                               |     Server    |\n     |        |<-(F)--- Protected Resource ---|               |\n     +--------+                               +---------------+\n\n                     Figure 1: Abstract Protocol Flow\n\n   The abstract OAuth 2.0 flow illustrated in Figure 1 describes the\n   interaction between the four roles and includes the following steps:\n\n   (A)  The client requests authorization from the resource owner.  The\n        authorization request can be made directly to the resource owner\n        (as shown), or preferably indirectly via the authorization\n        server as an intermediary.\n\n   (B)  The client receives an authorization grant, which is a\n        credential representing the resource owner's authorization,\n        expressed using one of four grant types defined in this\n        specification or using an extension grant type.  The\n        authorization grant type depends on the method used by the\n        client to request authorization and the types supported by the\n        authorization server.\n\n   (C)  The client requests an access token by authenticating with the\n        authorization server and presenting the authorization grant.\n\n   (D)  The authorization server authenticates the client and validates\n        the authorization grant, and if valid, issues an access token.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 7]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (E)  The client requests the protected resource from the resource\n        server and authenticates by presenting the access token.\n\n   (F)  The resource server validates the access token, and if valid,\n        serves the request.\n\n   The preferred method for the client to obtain an authorization grant\n   from the resource owner (depicted in steps (A) and (B)) is to use the\n   authorization server as an intermediary, which is illustrated in\n   Figure 3 in Section 4.1.\n\n1.3.  Authorization Grant\n\n   An authorization grant is a credential representing the resource\n   owner's authorization (to access its protected resources) used by the\n   client to obtain an access token.  This specification defines four\n   grant types -- authorization code, implicit, resource owner password\n   credentials, and client credentials -- as well as an extensibility\n   mechanism for defining additional types.\n\n1.3.1.  Authorization Code\n\n   The authorization code is obtained by using an authorization server\n   as an intermediary between the client and resource owner.  Instead of\n   requesting authorization directly from the resource owner, the client\n   directs the resource owner to an authorization server (via its\n   user-agent as defined in [RFC2616]), which in turn directs the\n   resource owner back to the client with the authorization code.\n\n   Before directing the resource owner back to the client with the\n   authorization code, the authorization server authenticates the\n   resource owner and obtains authorization.  Because the resource owner\n   only authenticates with the authorization server, the resource\n   owner's credentials are never shared with the client.\n\n   The authorization code provides a few important security benefits,\n   such as the ability to authenticate the client, as well as the\n   transmission of the access token directly to the client without\n   passing it through the resource owner's user-agent and potentially\n   exposing it to others, including the resource owner.\n\n1.3.2.  Implicit\n\n   The implicit grant is a simplified authorization code flow optimized\n   for clients implemented in a browser using a scripting language such\n   as JavaScript.  In the implicit flow, instead of issuing the client\n   an authorization code, the client is issued an access token directly\n\n\n\n\nHardt                        Standards Track                    [Page 8]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (as the result of the resource owner authorization).  The grant type\n   is implicit, as no intermediate credentials (such as an authorization\n   code) are issued (and later used to obtain an access token).\n\n   When issuing an access token during the implicit grant flow, the\n   authorization server does not authenticate the client.  In some\n   cases, the client identity can be verified via the redirection URI\n   used to deliver the access token to the client.  The access token may\n   be exposed to the resource owner or other applications with access to\n   the resource owner's user-agent.\n\n   Implicit grants improve the responsiveness and efficiency of some\n   clients (such as a client implemented as an in-browser application),\n   since it reduces the number of round trips required to obtain an\n   access token.  However, this convenience should be weighed against\n   the security implications of using implicit grants, such as those\n   described in Sections 10.3 and 10.16, especially when the\n   authorization code grant type is available.\n\n1.3.3.  Resource Owner Password Credentials\n\n   The resource owner password credentials (i.e., username and password)\n   can be used directly as an authorization grant to obtain an access\n   token.  The credentials should only be used when there is a high\n   degree of trust between the resource owner and the client (e.g., the\n   client is part of the device operating system or a highly privileged\n   application), and when other authorization grant types are not\n   available (such as an authorization code).\n\n   Even though this grant type requires direct client access to the\n   resource owner credentials, the resource owner credentials are used\n   for a single request and are exchanged for an access token.  This\n   grant type can eliminate the need for the client to store the\n   resource owner credentials for future use, by exchanging the\n   credentials with a long-lived access token or refresh token.\n\n1.3.4.  Client Credentials\n\n   The client credentials (or other forms of client authentication) can\n   be used as an authorization grant when the authorization scope is\n   limited to the protected resources under the control of the client,\n   or to protected resources previously arranged with the authorization\n   server.  Client credentials are used as an authorization grant\n   typically when the client is acting on its own behalf (the client is\n   also the resource owner) or is requesting access to protected\n   resources based on an authorization previously arranged with the\n   authorization server.\n\n\n\n\nHardt                        Standards Track                    [Page 9]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.4.  Access Token\n\n   Access tokens are credentials used to access protected resources.  An\n   access token is a string representing an authorization issued to the\n   client.  The string is usually opaque to the client.  Tokens\n   represent specific scopes and durations of access, granted by the\n   resource owner, and enforced by the resource server and authorization\n   server.\n\n   The token may denote an identifier used to retrieve the authorization\n   information or may self-contain the authorization information in a\n   verifiable manner (i.e., a token string consisting of some data and a\n   signature).  Additional authentication credentials, which are beyond\n   the scope of this specification, may be required in order for the\n   client to use a token.\n\n   The access token provides an abstraction layer, replacing different\n   authorization constructs (e.g., username and password) with a single\n   token understood by the resource server.  This abstraction enables\n   issuing access tokens more restrictive than the authorization grant\n   used to obtain them, as well as removing the resource server's need\n   to understand a wide range of authentication methods.\n\n   Access tokens can have different formats, structures, and methods of\n   utilization (e.g., cryptographic properties) based on the resource\n   server security requirements.  Access token attributes and the\n   methods used to access protected resources are beyond the scope of\n   this specification and are defined by companion specifications such\n   as [RFC6750].\n\n1.5.  Refresh Token\n\n   Refresh tokens are credentials used to obtain access tokens.  Refresh\n   tokens are issued to the client by the authorization server and are\n   used to obtain a new access token when the current access token\n   becomes invalid or expires, or to obtain additional access tokens\n   with identical or narrower scope (access tokens may have a shorter\n   lifetime and fewer permissions than authorized by the resource\n   owner).  Issuing a refresh token is optional at the discretion of the\n   authorization server.  If the authorization server issues a refresh\n   token, it is included when issuing an access token (i.e., step (D) in\n   Figure 1).\n\n   A refresh token is a string representing the authorization granted to\n   the client by the resource owner.  The string is usually opaque to\n   the client.  The token denotes an identifier used to retrieve the\n\n\n\n\n\nHardt                        Standards Track                   [Page 10]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   authorization information.  Unlike access tokens, refresh tokens are\n   intended for use only with authorization servers and are never sent\n   to resource servers.\n\n  +--------+                                           +---------------+\n  |        |--(A)------- Authorization Grant --------->|               |\n  |        |                                           |               |\n  |        |<-(B)----------- Access Token -------------|               |\n  |        |               & Refresh Token             |               |\n  |        |                                           |               |\n  |        |                            +----------+   |               |\n  |        |--(C)---- Access Token ---->|          |   |               |\n  |        |                            |          |   |               |\n  |        |<-(D)- Protected Resource --| Resource |   | Authorization |\n  | Client |                            |  Server  |   |     Server    |\n  |        |--(E)---- Access Token ---->|          |   |               |\n  |        |                            |          |   |               |\n  |        |<-(F)- Invalid Token Error -|          |   |               |\n  |        |                            +----------+   |               |\n  |        |                                           |               |\n  |        |--(G)----------- Refresh Token ----------->|               |\n  |        |                                           |               |\n  |        |<-(H)----------- Access Token -------------|               |\n  +--------+           & Optional Refresh Token        +---------------+\n\n               Figure 2: Refreshing an Expired Access Token\n\n   The flow illustrated in Figure 2 includes the following steps:\n\n   (A)  The client requests an access token by authenticating with the\n        authorization server and presenting an authorization grant.\n\n   (B)  The authorization server authenticates the client and validates\n        the authorization grant, and if valid, issues an access token\n        and a refresh token.\n\n   (C)  The client makes a protected resource request to the resource\n        server by presenting the access token.\n\n   (D)  The resource server validates the access token, and if valid,\n        serves the request.\n\n   (E)  Steps (C) and (D) repeat until the access token expires.  If the\n        client knows the access token expired, it skips to step (G);\n        otherwise, it makes another protected resource request.\n\n   (F)  Since the access token is invalid, the resource server returns\n        an invalid token error.\n\n\n\nHardt                        Standards Track                   [Page 11]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (G)  The client requests a new access token by authenticating with\n        the authorization server and presenting the refresh token.  The\n        client authentication requirements are based on the client type\n        and on the authorization server policies.\n\n   (H)  The authorization server authenticates the client and validates\n        the refresh token, and if valid, issues a new access token (and,\n        optionally, a new refresh token).\n\n   Steps (C), (D), (E), and (F) are outside the scope of this\n   specification, as described in Section 7.\n\n1.6.  TLS Version\n\n   Whenever Transport Layer Security (TLS) is used by this\n   specification, the appropriate version (or versions) of TLS will vary\n   over time, based on the widespread deployment and known security\n   vulnerabilities.  At the time of this writing, TLS version 1.2\n   [RFC5246] is the most recent version, but has a very limited\n   deployment base and might not be readily available for\n   implementation.  TLS version 1.0 [RFC2246] is the most widely\n   deployed version and will provide the broadest interoperability.\n\n   Implementations MAY also support additional transport-layer security\n   mechanisms that meet their security requirements.\n\n1.7.  HTTP Redirections\n\n   This specification makes extensive use of HTTP redirections, in which\n   the client or the authorization server directs the resource owner's\n   user-agent to another destination.  While the examples in this\n   specification show the use of the HTTP 302 status code, any other\n   method available via the user-agent to accomplish this redirection is\n   allowed and is considered to be an implementation detail.\n\n1.8.  Interoperability\n\n   OAuth 2.0 provides a rich authorization framework with well-defined\n   security properties.  However, as a rich and highly extensible\n   framework with many optional components, on its own, this\n   specification is likely to produce a wide range of non-interoperable\n   implementations.\n\n   In addition, this specification leaves a few required components\n   partially or fully undefined (e.g., client registration,\n   authorization server capabilities, endpoint discovery).  Without\n\n\n\n\n\nHardt                        Standards Track                   [Page 12]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   these components, clients must be manually and specifically\n   configured against a specific authorization server and resource\n   server in order to interoperate.\n\n   This framework was designed with the clear expectation that future\n   work will define prescriptive profiles and extensions necessary to\n   achieve full web-scale interoperability.\n\n1.9.  Notational Conventions\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   specification are to be interpreted as described in [RFC2119].\n\n   This specification uses the Augmented Backus-Naur Form (ABNF)\n   notation of [RFC5234].  Additionally, the rule URI-reference is\n   included from \"Uniform Resource Identifier (URI): Generic Syntax\"\n   [RFC3986].\n\n   Certain security-related terms are to be understood in the sense\n   defined in [RFC4949].  These terms include, but are not limited to,\n   \"attack\", \"authentication\", \"authorization\", \"certificate\",\n   \"confidentiality\", \"credential\", \"encryption\", \"identity\", \"sign\",\n   \"signature\", \"trust\", \"validate\", and \"verify\".\n\n   Unless otherwise noted, all the protocol parameter names and values\n   are case sensitive.\n\n2.  Client Registration\n\n   Before initiating the protocol, the client registers with the\n   authorization server.  The means through which the client registers\n   with the authorization server are beyond the scope of this\n   specification but typically involve end-user interaction with an HTML\n   registration form.\n\n   Client registration does not require a direct interaction between the\n   client and the authorization server.  When supported by the\n   authorization server, registration can rely on other means for\n   establishing trust and obtaining the required client properties\n   (e.g., redirection URI, client type).  For example, registration can\n   be accomplished using a self-issued or third-party-issued assertion,\n   or by the authorization server performing client discovery using a\n   trusted channel.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 13]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   When registering a client, the client developer SHALL:\n\n   o  specify the client type as described in Section 2.1,\n\n   o  provide its client redirection URIs as described in Section 3.1.2,\n      and\n\n   o  include any other information required by the authorization server\n      (e.g., application name, website, description, logo image, the\n      acceptance of legal terms).\n\n2.1.  Client Types\n\n   OAuth defines two client types, based on their ability to\n   authenticate securely with the authorization server (i.e., ability to\n   maintain the confidentiality of their client credentials):\n\n   confidential\n      Clients capable of maintaining the confidentiality of their\n      credentials (e.g., client implemented on a secure server with\n      restricted access to the client credentials), or capable of secure\n      client authentication using other means.\n\n   public\n      Clients incapable of maintaining the confidentiality of their\n      credentials (e.g., clients executing on the device used by the\n      resource owner, such as an installed native application or a web\n      browser-based application), and incapable of secure client\n      authentication via any other means.\n\n   The client type designation is based on the authorization server's\n   definition of secure authentication and its acceptable exposure\n   levels of client credentials.  The authorization server SHOULD NOT\n   make assumptions about the client type.\n\n   A client may be implemented as a distributed set of components, each\n   with a different client type and security context (e.g., a\n   distributed client with both a confidential server-based component\n   and a public browser-based component).  If the authorization server\n   does not provide support for such clients or does not provide\n   guidance with regard to their registration, the client SHOULD\n   register each component as a separate client.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 14]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   This specification has been designed around the following client\n   profiles:\n\n   web application\n      A web application is a confidential client running on a web\n      server.  Resource owners access the client via an HTML user\n      interface rendered in a user-agent on the device used by the\n      resource owner.  The client credentials as well as any access\n      token issued to the client are stored on the web server and are\n      not exposed to or accessible by the resource owner.\n\n   user-agent-based application\n      A user-agent-based application is a public client in which the\n      client code is downloaded from a web server and executes within a\n      user-agent (e.g., web browser) on the device used by the resource\n      owner.  Protocol data and credentials are easily accessible (and\n      often visible) to the resource owner.  Since such applications\n      reside within the user-agent, they can make seamless use of the\n      user-agent capabilities when requesting authorization.\n\n   native application\n      A native application is a public client installed and executed on\n      the device used by the resource owner.  Protocol data and\n      credentials are accessible to the resource owner.  It is assumed\n      that any client authentication credentials included in the\n      application can be extracted.  On the other hand, dynamically\n      issued credentials such as access tokens or refresh tokens can\n      receive an acceptable level of protection.  At a minimum, these\n      credentials are protected from hostile servers with which the\n      application may interact.  On some platforms, these credentials\n      might be protected from other applications residing on the same\n      device.\n\n2.2.  Client Identifier\n\n   The authorization server issues the registered client a client\n   identifier -- a unique string representing the registration\n   information provided by the client.  The client identifier is not a\n   secret; it is exposed to the resource owner and MUST NOT be used\n   alone for client authentication.  The client identifier is unique to\n   the authorization server.\n\n   The client identifier string size is left undefined by this\n   specification.  The client should avoid making assumptions about the\n   identifier size.  The authorization server SHOULD document the size\n   of any identifier it issues.\n\n\n\n\n\nHardt                        Standards Track                   [Page 15]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n2.3.  Client Authentication\n\n   If the client type is confidential, the client and authorization\n   server establish a client authentication method suitable for the\n   security requirements of the authorization server.  The authorization\n   server MAY accept any form of client authentication meeting its\n   security requirements.\n\n   Confidential clients are typically issued (or establish) a set of\n   client credentials used for authenticating with the authorization\n   server (e.g., password, public/private key pair).\n\n   The authorization server MAY establish a client authentication method\n   with public clients.  However, the authorization server MUST NOT rely\n   on public client authentication for the purpose of identifying the\n   client.\n\n   The client MUST NOT use more than one authentication method in each\n   request.\n\n2.3.1.  Client Password\n\n   Clients in possession of a client password MAY use the HTTP Basic\n   authentication scheme as defined in [RFC2617] to authenticate with\n   the authorization server.  The client identifier is encoded using the\n   \"application/x-www-form-urlencoded\" encoding algorithm per\n   Appendix B, and the encoded value is used as the username; the client\n   password is encoded using the same algorithm and used as the\n   password.  The authorization server MUST support the HTTP Basic\n   authentication scheme for authenticating clients that were issued a\n   client password.\n\n   For example (with extra line breaks for display purposes only):\n\n     Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n\n   Alternatively, the authorization server MAY support including the\n   client credentials in the request-body using the following\n   parameters:\n\n   client_id\n         REQUIRED.  The client identifier issued to the client during\n         the registration process described by Section 2.2.\n\n   client_secret\n         REQUIRED.  The client secret.  The client MAY omit the\n         parameter if the client secret is an empty string.\n\n\n\n\nHardt                        Standards Track                   [Page 16]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Including the client credentials in the request-body using the two\n   parameters is NOT RECOMMENDED and SHOULD be limited to clients unable\n   to directly utilize the HTTP Basic authentication scheme (or other\n   password-based HTTP authentication schemes).  The parameters can only\n   be transmitted in the request-body and MUST NOT be included in the\n   request URI.\n\n   For example, a request to refresh an access token (Section 6) using\n   the body parameters (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n     &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n\n   The authorization server MUST require the use of TLS as described in\n   Section 1.6 when sending requests using password authentication.\n\n   Since this client authentication method involves a password, the\n   authorization server MUST protect any endpoint utilizing it against\n   brute force attacks.\n\n2.3.2.  Other Authentication Methods\n\n   The authorization server MAY support any suitable HTTP authentication\n   scheme matching its security requirements.  When using other\n   authentication methods, the authorization server MUST define a\n   mapping between the client identifier (registration record) and\n   authentication scheme.\n\n2.4.  Unregistered Clients\n\n   This specification does not exclude the use of unregistered clients.\n   However, the use of such clients is beyond the scope of this\n   specification and requires additional security analysis and review of\n   its interoperability impact.\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 17]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.  Protocol Endpoints\n\n   The authorization process utilizes two authorization server endpoints\n   (HTTP resources):\n\n   o  Authorization endpoint - used by the client to obtain\n      authorization from the resource owner via user-agent redirection.\n\n   o  Token endpoint - used by the client to exchange an authorization\n      grant for an access token, typically with client authentication.\n\n   As well as one client endpoint:\n\n   o  Redirection endpoint - used by the authorization server to return\n      responses containing authorization credentials to the client via\n      the resource owner user-agent.\n\n   Not every authorization grant type utilizes both endpoints.\n   Extension grant types MAY define additional endpoints as needed.\n\n3.1.  Authorization Endpoint\n\n   The authorization endpoint is used to interact with the resource\n   owner and obtain an authorization grant.  The authorization server\n   MUST first verify the identity of the resource owner.  The way in\n   which the authorization server authenticates the resource owner\n   (e.g., username and password login, session cookies) is beyond the\n   scope of this specification.\n\n   The means through which the client obtains the location of the\n   authorization endpoint are beyond the scope of this specification,\n   but the location is typically provided in the service documentation.\n\n   The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n   formatted (per Appendix B) query component ([RFC3986] Section 3.4),\n   which MUST be retained when adding additional query parameters.  The\n   endpoint URI MUST NOT include a fragment component.\n\n   Since requests to the authorization endpoint result in user\n   authentication and the transmission of clear-text credentials (in the\n   HTTP response), the authorization server MUST require the use of TLS\n   as described in Section 1.6 when sending requests to the\n   authorization endpoint.\n\n   The authorization server MUST support the use of the HTTP \"GET\"\n   method [RFC2616] for the authorization endpoint and MAY support the\n   use of the \"POST\" method as well.\n\n\n\n\nHardt                        Standards Track                   [Page 18]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Parameters sent without a value MUST be treated as if they were\n   omitted from the request.  The authorization server MUST ignore\n   unrecognized request parameters.  Request and response parameters\n   MUST NOT be included more than once.\n\n3.1.1.  Response Type\n\n   The authorization endpoint is used by the authorization code grant\n   type and implicit grant type flows.  The client informs the\n   authorization server of the desired grant type using the following\n   parameter:\n\n   response_type\n         REQUIRED.  The value MUST be one of \"code\" for requesting an\n         authorization code as described by Section 4.1.1, \"token\" for\n         requesting an access token (implicit grant) as described by\n         Section 4.2.1, or a registered extension value as described by\n         Section 8.4.\n\n   Extension response types MAY contain a space-delimited (%x20) list of\n   values, where the order of values does not matter (e.g., response\n   type \"a b\" is the same as \"b a\").  The meaning of such composite\n   response types is defined by their respective specifications.\n\n   If an authorization request is missing the \"response_type\" parameter,\n   or if the response type is not understood, the authorization server\n   MUST return an error response as described in Section 4.1.2.1.\n\n3.1.2.  Redirection Endpoint\n\n   After completing its interaction with the resource owner, the\n   authorization server directs the resource owner's user-agent back to\n   the client.  The authorization server redirects the user-agent to the\n   client's redirection endpoint previously established with the\n   authorization server during the client registration process or when\n   making the authorization request.\n\n   The redirection endpoint URI MUST be an absolute URI as defined by\n   [RFC3986] Section 4.3.  The endpoint URI MAY include an\n   \"application/x-www-form-urlencoded\" formatted (per Appendix B) query\n   component ([RFC3986] Section 3.4), which MUST be retained when adding\n   additional query parameters.  The endpoint URI MUST NOT include a\n   fragment component.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 19]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.1.2.1.  Endpoint Request Confidentiality\n\n   The redirection endpoint SHOULD require the use of TLS as described\n   in Section 1.6 when the requested response type is \"code\" or \"token\",\n   or when the redirection request will result in the transmission of\n   sensitive credentials over an open network.  This specification does\n   not mandate the use of TLS because at the time of this writing,\n   requiring clients to deploy TLS is a significant hurdle for many\n   client developers.  If TLS is not available, the authorization server\n   SHOULD warn the resource owner about the insecure endpoint prior to\n   redirection (e.g., display a message during the authorization\n   request).\n\n   Lack of transport-layer security can have a severe impact on the\n   security of the client and the protected resources it is authorized\n   to access.  The use of transport-layer security is particularly\n   critical when the authorization process is used as a form of\n   delegated end-user authentication by the client (e.g., third-party\n   sign-in service).\n\n3.1.2.2.  Registration Requirements\n\n   The authorization server MUST require the following clients to\n   register their redirection endpoint:\n\n   o  Public clients.\n\n   o  Confidential clients utilizing the implicit grant type.\n\n   The authorization server SHOULD require all clients to register their\n   redirection endpoint prior to utilizing the authorization endpoint.\n\n   The authorization server SHOULD require the client to provide the\n   complete redirection URI (the client MAY use the \"state\" request\n   parameter to achieve per-request customization).  If requiring the\n   registration of the complete redirection URI is not possible, the\n   authorization server SHOULD require the registration of the URI\n   scheme, authority, and path (allowing the client to dynamically vary\n   only the query component of the redirection URI when requesting\n   authorization).\n\n   The authorization server MAY allow the client to register multiple\n   redirection endpoints.\n\n   Lack of a redirection URI registration requirement can enable an\n   attacker to use the authorization endpoint as an open redirector as\n   described in Section 10.15.\n\n\n\n\nHardt                        Standards Track                   [Page 20]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.1.2.3.  Dynamic Configuration\n\n   If multiple redirection URIs have been registered, if only part of\n   the redirection URI has been registered, or if no redirection URI has\n   been registered, the client MUST include a redirection URI with the\n   authorization request using the \"redirect_uri\" request parameter.\n\n   When a redirection URI is included in an authorization request, the\n   authorization server MUST compare and match the value received\n   against at least one of the registered redirection URIs (or URI\n   components) as defined in [RFC3986] Section 6, if any redirection\n   URIs were registered.  If the client registration included the full\n   redirection URI, the authorization server MUST compare the two URIs\n   using simple string comparison as defined in [RFC3986] Section 6.2.1.\n\n3.1.2.4.  Invalid Endpoint\n\n   If an authorization request fails validation due to a missing,\n   invalid, or mismatching redirection URI, the authorization server\n   SHOULD inform the resource owner of the error and MUST NOT\n   automatically redirect the user-agent to the invalid redirection URI.\n\n3.1.2.5.  Endpoint Content\n\n   The redirection request to the client's endpoint typically results in\n   an HTML document response, processed by the user-agent.  If the HTML\n   response is served directly as the result of the redirection request,\n   any script included in the HTML document will execute with full\n   access to the redirection URI and the credentials it contains.\n\n   The client SHOULD NOT include any third-party scripts (e.g., third-\n   party analytics, social plug-ins, ad networks) in the redirection\n   endpoint response.  Instead, it SHOULD extract the credentials from\n   the URI and redirect the user-agent again to another endpoint without\n   exposing the credentials (in the URI or elsewhere).  If third-party\n   scripts are included, the client MUST ensure that its own scripts\n   (used to extract and remove the credentials from the URI) will\n   execute first.\n\n3.2.  Token Endpoint\n\n   The token endpoint is used by the client to obtain an access token by\n   presenting its authorization grant or refresh token.  The token\n   endpoint is used with every authorization grant except for the\n   implicit grant type (since an access token is issued directly).\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 21]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The means through which the client obtains the location of the token\n   endpoint are beyond the scope of this specification, but the location\n   is typically provided in the service documentation.\n\n   The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n   formatted (per Appendix B) query component ([RFC3986] Section 3.4),\n   which MUST be retained when adding additional query parameters.  The\n   endpoint URI MUST NOT include a fragment component.\n\n   Since requests to the token endpoint result in the transmission of\n   clear-text credentials (in the HTTP request and response), the\n   authorization server MUST require the use of TLS as described in\n   Section 1.6 when sending requests to the token endpoint.\n\n   The client MUST use the HTTP \"POST\" method when making access token\n   requests.\n\n   Parameters sent without a value MUST be treated as if they were\n   omitted from the request.  The authorization server MUST ignore\n   unrecognized request parameters.  Request and response parameters\n   MUST NOT be included more than once.\n\n3.2.1.  Client Authentication\n\n   Confidential clients or other clients issued client credentials MUST\n   authenticate with the authorization server as described in\n   Section 2.3 when making requests to the token endpoint.  Client\n   authentication is used for:\n\n   o  Enforcing the binding of refresh tokens and authorization codes to\n      the client they were issued to.  Client authentication is critical\n      when an authorization code is transmitted to the redirection\n      endpoint over an insecure channel or when the redirection URI has\n      not been registered in full.\n\n   o  Recovering from a compromised client by disabling the client or\n      changing its credentials, thus preventing an attacker from abusing\n      stolen refresh tokens.  Changing a single set of client\n      credentials is significantly faster than revoking an entire set of\n      refresh tokens.\n\n   o  Implementing authentication management best practices, which\n      require periodic credential rotation.  Rotation of an entire set\n      of refresh tokens can be challenging, while rotation of a single\n      set of client credentials is significantly easier.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 22]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   A client MAY use the \"client_id\" request parameter to identify itself\n   when sending requests to the token endpoint.  In the\n   \"authorization_code\" \"grant_type\" request to the token endpoint, an\n   unauthenticated client MUST send its \"client_id\" to prevent itself\n   from inadvertently accepting a code intended for a client with a\n   different \"client_id\".  This protects the client from substitution of\n   the authentication code.  (It provides no additional security for the\n   protected resource.)\n\n3.3.  Access Token Scope\n\n   The authorization and token endpoints allow the client to specify the\n   scope of the access request using the \"scope\" request parameter.  In\n   turn, the authorization server uses the \"scope\" response parameter to\n   inform the client of the scope of the access token issued.\n\n   The value of the scope parameter is expressed as a list of space-\n   delimited, case-sensitive strings.  The strings are defined by the\n   authorization server.  If the value contains multiple space-delimited\n   strings, their order does not matter, and each string adds an\n   additional access range to the requested scope.\n\n     scope       = scope-token *( SP scope-token )\n     scope-token = 1*( %x21 / %x23-5B / %x5D-7E )\n\n   The authorization server MAY fully or partially ignore the scope\n   requested by the client, based on the authorization server policy or\n   the resource owner's instructions.  If the issued access token scope\n   is different from the one requested by the client, the authorization\n   server MUST include the \"scope\" response parameter to inform the\n   client of the actual scope granted.\n\n   If the client omits the scope parameter when requesting\n   authorization, the authorization server MUST either process the\n   request using a pre-defined default value or fail the request\n   indicating an invalid scope.  The authorization server SHOULD\n   document its scope requirements and default value (if defined).\n\n4.  Obtaining Authorization\n\n   To request an access token, the client obtains authorization from the\n   resource owner.  The authorization is expressed in the form of an\n   authorization grant, which the client uses to request the access\n   token.  OAuth defines four grant types: authorization code, implicit,\n   resource owner password credentials, and client credentials.  It also\n   provides an extension mechanism for defining additional grant types.\n\n\n\n\n\nHardt                        Standards Track                   [Page 23]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.1.  Authorization Code Grant\n\n   The authorization code grant type is used to obtain both access\n   tokens and refresh tokens and is optimized for confidential clients.\n   Since this is a redirection-based flow, the client must be capable of\n   interacting with the resource owner's user-agent (typically a web\n   browser) and capable of receiving incoming requests (via redirection)\n   from the authorization server.\n\n     +----------+\n     | Resource |\n     |   Owner  |\n     |          |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier      +---------------+\n     |         -+----(A)-- & Redirection URI ---->|               |\n     |  User-   |                                 | Authorization |\n     |  Agent  -+----(B)-- User authenticates --->|     Server    |\n     |          |                                 |               |\n     |         -+----(C)-- Authorization Code ---<|               |\n     +-|----|---+                                 +---------------+\n       |    |                                         ^      v\n      (A)  (C)                                        |      |\n       |    |                                         |      |\n       ^    v                                         |      |\n     +---------+                                      |      |\n     |         |>---(D)-- Authorization Code ---------'      |\n     |  Client |          & Redirection URI                  |\n     |         |                                             |\n     |         |<---(E)----- Access Token -------------------'\n     +---------+       (w/ Optional Refresh Token)\n\n   Note: The lines illustrating steps (A), (B), and (C) are broken into\n   two parts as they pass through the user-agent.\n\n                     Figure 3: Authorization Code Flow\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 24]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The flow illustrated in Figure 3 includes the following steps:\n\n   (A)  The client initiates the flow by directing the resource owner's\n        user-agent to the authorization endpoint.  The client includes\n        its client identifier, requested scope, local state, and a\n        redirection URI to which the authorization server will send the\n        user-agent back once access is granted (or denied).\n\n   (B)  The authorization server authenticates the resource owner (via\n        the user-agent) and establishes whether the resource owner\n        grants or denies the client's access request.\n\n   (C)  Assuming the resource owner grants access, the authorization\n        server redirects the user-agent back to the client using the\n        redirection URI provided earlier (in the request or during\n        client registration).  The redirection URI includes an\n        authorization code and any local state provided by the client\n        earlier.\n\n   (D)  The client requests an access token from the authorization\n        server's token endpoint by including the authorization code\n        received in the previous step.  When making the request, the\n        client authenticates with the authorization server.  The client\n        includes the redirection URI used to obtain the authorization\n        code for verification.\n\n   (E)  The authorization server authenticates the client, validates the\n        authorization code, and ensures that the redirection URI\n        received matches the URI used to redirect the client in\n        step (C).  If valid, the authorization server responds back with\n        an access token and, optionally, a refresh token.\n\n4.1.1.  Authorization Request\n\n   The client constructs the request URI by adding the following\n   parameters to the query component of the authorization endpoint URI\n   using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   response_type\n         REQUIRED.  Value MUST be set to \"code\".\n\n   client_id\n         REQUIRED.  The client identifier as described in Section 2.2.\n\n   redirect_uri\n         OPTIONAL.  As described in Section 3.1.2.\n\n\n\n\n\nHardt                        Standards Track                   [Page 25]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   state\n         RECOMMENDED.  An opaque value used by the client to maintain\n         state between the request and callback.  The authorization\n         server includes this value when redirecting the user-agent back\n         to the client.  The parameter SHOULD be used for preventing\n         cross-site request forgery as described in Section 10.12.\n\n   The client directs the resource owner to the constructed URI using an\n   HTTP redirection response, or by other means available to it via the\n   user-agent.\n\n   For example, the client directs the user-agent to make the following\n   HTTP request using TLS (with extra line breaks for display purposes\n   only):\n\n    GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n    Host: server.example.com\n\n   The authorization server validates the request to ensure that all\n   required parameters are present and valid.  If the request is valid,\n   the authorization server authenticates the resource owner and obtains\n   an authorization decision (by asking the resource owner or by\n   establishing approval via other means).\n\n   When a decision is established, the authorization server directs the\n   user-agent to the provided client redirection URI using an HTTP\n   redirection response, or by other means available to it via the\n   user-agent.\n\n4.1.2.  Authorization Response\n\n   If the resource owner grants the access request, the authorization\n   server issues an authorization code and delivers it to the client by\n   adding the following parameters to the query component of the\n   redirection URI using the \"application/x-www-form-urlencoded\" format,\n   per Appendix B:\n\n   code\n         REQUIRED.  The authorization code generated by the\n         authorization server.  The authorization code MUST expire\n         shortly after it is issued to mitigate the risk of leaks.  A\n         maximum authorization code lifetime of 10 minutes is\n         RECOMMENDED.  The client MUST NOT use the authorization code\n\n\n\nHardt                        Standards Track                   [Page 26]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         more than once.  If an authorization code is used more than\n         once, the authorization server MUST deny the request and SHOULD\n         revoke (when possible) all tokens previously issued based on\n         that authorization code.  The authorization code is bound to\n         the client identifier and redirection URI.\n\n   state\n         REQUIRED if the \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n     HTTP/1.1 302 Found\n     Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n               &state=xyz\n\n   The client MUST ignore unrecognized response parameters.  The\n   authorization code string size is left undefined by this\n   specification.  The client should avoid making assumptions about code\n   value sizes.  The authorization server SHOULD document the size of\n   any value it issues.\n\n4.1.2.1.  Error Response\n\n   If the request fails due to a missing, invalid, or mismatching\n   redirection URI, or if the client identifier is missing or invalid,\n   the authorization server SHOULD inform the resource owner of the\n   error and MUST NOT automatically redirect the user-agent to the\n   invalid redirection URI.\n\n   If the resource owner denies the access request or if the request\n   fails for reasons other than a missing or invalid redirection URI,\n   the authorization server informs the client by adding the following\n   parameters to the query component of the redirection URI using the\n   \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               invalid parameter value, includes a parameter more than\n               once, or is otherwise malformed.\n\n\n\n\n\nHardt                        Standards Track                   [Page 27]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         unauthorized_client\n               The client is not authorized to request an authorization\n               code using this method.\n\n         access_denied\n               The resource owner or authorization server denied the\n               request.\n\n         unsupported_response_type\n               The authorization server does not support obtaining an\n               authorization code using this method.\n\n         invalid_scope\n               The requested scope is invalid, unknown, or malformed.\n\n         server_error\n               The authorization server encountered an unexpected\n               condition that prevented it from fulfilling the request.\n               (This error code is needed because a 500 Internal Server\n               Error HTTP status code cannot be returned to the client\n               via an HTTP redirect.)\n\n         temporarily_unavailable\n               The authorization server is currently unable to handle\n               the request due to a temporary overloading or maintenance\n               of the server.  (This error code is needed because a 503\n               Service Unavailable HTTP status code cannot be returned\n               to the client via an HTTP redirect.)\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n\n\n\n\nHardt                        Standards Track                   [Page 28]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   state\n         REQUIRED if a \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n   HTTP/1.1 302 Found\n   Location: https://client.example.com/cb?error=access_denied&state=xyz\n\n4.1.3.  Access Token Request\n\n   The client makes a request to the token endpoint by sending the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"authorization_code\".\n\n   code\n         REQUIRED.  The authorization code received from the\n         authorization server.\n\n   redirect_uri\n         REQUIRED, if the \"redirect_uri\" parameter was included in the\n         authorization request as described in Section 4.1.1, and their\n         values MUST be identical.\n\n   client_id\n         REQUIRED, if the client is not authenticating with the\n         authorization server as described in Section 3.2.1.\n\n   If the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 29]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, the client makes the following HTTP request using TLS\n   (with extra line breaks for display purposes only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n     &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included,\n\n   o  ensure that the authorization code was issued to the authenticated\n      confidential client, or if the client is public, ensure that the\n      code was issued to \"client_id\" in the request,\n\n   o  verify that the authorization code is valid, and\n\n   o  ensure that the \"redirect_uri\" parameter is present if the\n      \"redirect_uri\" parameter was included in the initial authorization\n      request as described in Section 4.1.1, and if included ensure that\n      their values are identical.\n\n4.1.4.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request client\n   authentication failed or is invalid, the authorization server returns\n   an error response as described in Section 5.2.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 30]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n4.2.  Implicit Grant\n\n   The implicit grant type is used to obtain access tokens (it does not\n   support the issuance of refresh tokens) and is optimized for public\n   clients known to operate a particular redirection URI.  These clients\n   are typically implemented in a browser using a scripting language\n   such as JavaScript.\n\n   Since this is a redirection-based flow, the client must be capable of\n   interacting with the resource owner's user-agent (typically a web\n   browser) and capable of receiving incoming requests (via redirection)\n   from the authorization server.\n\n   Unlike the authorization code grant type, in which the client makes\n   separate requests for authorization and for an access token, the\n   client receives the access token as the result of the authorization\n   request.\n\n   The implicit grant type does not include client authentication, and\n   relies on the presence of the resource owner and the registration of\n   the redirection URI.  Because the access token is encoded into the\n   redirection URI, it may be exposed to the resource owner and other\n   applications residing on the same device.\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 31]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n     +----------+\n     | Resource |\n     |  Owner   |\n     |          |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier     +---------------+\n     |         -+----(A)-- & Redirection URI --->|               |\n     |  User-   |                                | Authorization |\n     |  Agent  -|----(B)-- User authenticates -->|     Server    |\n     |          |                                |               |\n     |          |<---(C)--- Redirection URI ----<|               |\n     |          |          with Access Token     +---------------+\n     |          |            in Fragment\n     |          |                                +---------------+\n     |          |----(D)--- Redirection URI ---->|   Web-Hosted  |\n     |          |          without Fragment      |     Client    |\n     |          |                                |    Resource   |\n     |     (F)  |<---(E)------- Script ---------<|               |\n     |          |                                +---------------+\n     +-|--------+\n       |    |\n      (A)  (G) Access Token\n       |    |\n       ^    v\n     +---------+\n     |         |\n     |  Client |\n     |         |\n     +---------+\n\n   Note: The lines illustrating steps (A) and (B) are broken into two\n   parts as they pass through the user-agent.\n\n                       Figure 4: Implicit Grant Flow\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 32]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The flow illustrated in Figure 4 includes the following steps:\n\n   (A)  The client initiates the flow by directing the resource owner's\n        user-agent to the authorization endpoint.  The client includes\n        its client identifier, requested scope, local state, and a\n        redirection URI to which the authorization server will send the\n        user-agent back once access is granted (or denied).\n\n   (B)  The authorization server authenticates the resource owner (via\n        the user-agent) and establishes whether the resource owner\n        grants or denies the client's access request.\n\n   (C)  Assuming the resource owner grants access, the authorization\n        server redirects the user-agent back to the client using the\n        redirection URI provided earlier.  The redirection URI includes\n        the access token in the URI fragment.\n\n   (D)  The user-agent follows the redirection instructions by making a\n        request to the web-hosted client resource (which does not\n        include the fragment per [RFC2616]).  The user-agent retains the\n        fragment information locally.\n\n   (E)  The web-hosted client resource returns a web page (typically an\n        HTML document with an embedded script) capable of accessing the\n        full redirection URI including the fragment retained by the\n        user-agent, and extracting the access token (and other\n        parameters) contained in the fragment.\n\n   (F)  The user-agent executes the script provided by the web-hosted\n        client resource locally, which extracts the access token.\n\n   (G)  The user-agent passes the access token to the client.\n\n   See Sections 1.3.2 and 9 for background on using the implicit grant.\n   See Sections 10.3 and 10.16 for important security considerations\n   when using the implicit grant.\n\n4.2.1.  Authorization Request\n\n   The client constructs the request URI by adding the following\n   parameters to the query component of the authorization endpoint URI\n   using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   response_type\n         REQUIRED.  Value MUST be set to \"token\".\n\n   client_id\n         REQUIRED.  The client identifier as described in Section 2.2.\n\n\n\nHardt                        Standards Track                   [Page 33]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   redirect_uri\n         OPTIONAL.  As described in Section 3.1.2.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   state\n         RECOMMENDED.  An opaque value used by the client to maintain\n         state between the request and callback.  The authorization\n         server includes this value when redirecting the user-agent back\n         to the client.  The parameter SHOULD be used for preventing\n         cross-site request forgery as described in Section 10.12.\n\n   The client directs the resource owner to the constructed URI using an\n   HTTP redirection response, or by other means available to it via the\n   user-agent.\n\n   For example, the client directs the user-agent to make the following\n   HTTP request using TLS (with extra line breaks for display purposes\n   only):\n\n    GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz\n        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n    Host: server.example.com\n\n   The authorization server validates the request to ensure that all\n   required parameters are present and valid.  The authorization server\n   MUST verify that the redirection URI to which it will redirect the\n   access token matches a redirection URI registered by the client as\n   described in Section 3.1.2.\n\n   If the request is valid, the authorization server authenticates the\n   resource owner and obtains an authorization decision (by asking the\n   resource owner or by establishing approval via other means).\n\n   When a decision is established, the authorization server directs the\n   user-agent to the provided client redirection URI using an HTTP\n   redirection response, or by other means available to it via the\n   user-agent.\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 34]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.2.2.  Access Token Response\n\n   If the resource owner grants the access request, the authorization\n   server issues an access token and delivers it to the client by adding\n   the following parameters to the fragment component of the redirection\n   URI using the \"application/x-www-form-urlencoded\" format, per\n   Appendix B:\n\n   access_token\n         REQUIRED.  The access token issued by the authorization server.\n\n   token_type\n         REQUIRED.  The type of the token issued as described in\n         Section 7.1.  Value is case insensitive.\n\n   expires_in\n         RECOMMENDED.  The lifetime in seconds of the access token.  For\n         example, the value \"3600\" denotes that the access token will\n         expire in one hour from the time the response was generated.\n         If omitted, the authorization server SHOULD provide the\n         expiration time via other means or document the default value.\n\n   scope\n         OPTIONAL, if identical to the scope requested by the client;\n         otherwise, REQUIRED.  The scope of the access token as\n         described by Section 3.3.\n\n   state\n         REQUIRED if the \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   The authorization server MUST NOT issue a refresh token.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response (with extra line breaks for\n   display purposes only):\n\n     HTTP/1.1 302 Found\n     Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\n               &state=xyz&token_type=example&expires_in=3600\n\n   Developers should note that some user-agents do not support the\n   inclusion of a fragment component in the HTTP \"Location\" response\n   header field.  Such clients will require using other methods for\n   redirecting the client than a 3xx redirection response -- for\n   example, returning an HTML page that includes a 'continue' button\n   with an action linked to the redirection URI.\n\n\n\nHardt                        Standards Track                   [Page 35]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The client MUST ignore unrecognized response parameters.  The access\n   token string size is left undefined by this specification.  The\n   client should avoid making assumptions about value sizes.  The\n   authorization server SHOULD document the size of any value it issues.\n\n4.2.2.1.  Error Response\n\n   If the request fails due to a missing, invalid, or mismatching\n   redirection URI, or if the client identifier is missing or invalid,\n   the authorization server SHOULD inform the resource owner of the\n   error and MUST NOT automatically redirect the user-agent to the\n   invalid redirection URI.\n\n   If the resource owner denies the access request or if the request\n   fails for reasons other than a missing or invalid redirection URI,\n   the authorization server informs the client by adding the following\n   parameters to the fragment component of the redirection URI using the\n   \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               invalid parameter value, includes a parameter more than\n               once, or is otherwise malformed.\n\n         unauthorized_client\n               The client is not authorized to request an access token\n               using this method.\n\n         access_denied\n               The resource owner or authorization server denied the\n               request.\n\n         unsupported_response_type\n               The authorization server does not support obtaining an\n               access token using this method.\n\n         invalid_scope\n               The requested scope is invalid, unknown, or malformed.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 36]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         server_error\n               The authorization server encountered an unexpected\n               condition that prevented it from fulfilling the request.\n               (This error code is needed because a 500 Internal Server\n               Error HTTP status code cannot be returned to the client\n               via an HTTP redirect.)\n\n         temporarily_unavailable\n               The authorization server is currently unable to handle\n               the request due to a temporary overloading or maintenance\n               of the server.  (This error code is needed because a 503\n               Service Unavailable HTTP status code cannot be returned\n               to the client via an HTTP redirect.)\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n   state\n         REQUIRED if a \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n   HTTP/1.1 302 Found\n   Location: https://client.example.com/cb#error=access_denied&state=xyz\n\n4.3.  Resource Owner Password Credentials Grant\n\n   The resource owner password credentials grant type is suitable in\n   cases where the resource owner has a trust relationship with the\n   client, such as the device operating system or a highly privileged\n\n\n\nHardt                        Standards Track                   [Page 37]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   application.  The authorization server should take special care when\n   enabling this grant type and only allow it when other flows are not\n   viable.\n\n   This grant type is suitable for clients capable of obtaining the\n   resource owner's credentials (username and password, typically using\n   an interactive form).  It is also used to migrate existing clients\n   using direct authentication schemes such as HTTP Basic or Digest\n   authentication to OAuth by converting the stored credentials to an\n   access token.\n\n     +----------+\n     | Resource |\n     |  Owner   |\n     |          |\n     +----------+\n          v\n          |    Resource Owner\n         (A) Password Credentials\n          |\n          v\n     +---------+                                  +---------------+\n     |         |>--(B)---- Resource Owner ------->|               |\n     |         |         Password Credentials     | Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(C)---- Access Token ---------<|               |\n     |         |    (w/ Optional Refresh Token)   |               |\n     +---------+                                  +---------------+\n\n            Figure 5: Resource Owner Password Credentials Flow\n\n   The flow illustrated in Figure 5 includes the following steps:\n\n   (A)  The resource owner provides the client with its username and\n        password.\n\n   (B)  The client requests an access token from the authorization\n        server's token endpoint by including the credentials received\n        from the resource owner.  When making the request, the client\n        authenticates with the authorization server.\n\n   (C)  The authorization server authenticates the client and validates\n        the resource owner credentials, and if valid, issues an access\n        token.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 38]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.3.1.  Authorization Request and Response\n\n   The method through which the client obtains the resource owner\n   credentials is beyond the scope of this specification.  The client\n   MUST discard the credentials once an access token has been obtained.\n\n4.3.2.  Access Token Request\n\n   The client makes a request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"password\".\n\n   username\n         REQUIRED.  The resource owner username.\n\n   password\n         REQUIRED.  The resource owner password.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   If the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=password&username=johndoe&password=A3ddj3w\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 39]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included, and\n\n   o  validate the resource owner password credentials using its\n      existing password validation algorithm.\n\n   Since this access token request utilizes the resource owner's\n   password, the authorization server MUST protect the endpoint against\n   brute force attacks (e.g., using rate-limitation or generating\n   alerts).\n\n4.3.3.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n4.4.  Client Credentials Grant\n\n   The client can request an access token using only its client\n   credentials (or other supported means of authentication) when the\n   client is requesting access to the protected resources under its\n   control, or those of another resource owner that have been previously\n   arranged with the authorization server (the method of which is beyond\n   the scope of this specification).\n\n\n\n\nHardt                        Standards Track                   [Page 40]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The client credentials grant type MUST only be used by confidential\n   clients.\n\n     +---------+                                  +---------------+\n     |         |                                  |               |\n     |         |>--(A)- Client Authentication --->| Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(B)---- Access Token ---------<|               |\n     |         |                                  |               |\n     +---------+                                  +---------------+\n\n                     Figure 6: Client Credentials Flow\n\n   The flow illustrated in Figure 6 includes the following steps:\n\n   (A)  The client authenticates with the authorization server and\n        requests an access token from the token endpoint.\n\n   (B)  The authorization server authenticates the client, and if valid,\n        issues an access token.\n\n4.4.1.  Authorization Request and Response\n\n   Since the client authentication is used as the authorization grant,\n   no additional authorization request is needed.\n\n4.4.2.  Access Token Request\n\n   The client makes a request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"client_credentials\".\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   The client MUST authenticate with the authorization server as\n   described in Section 3.2.1.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 41]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=client_credentials\n\n   The authorization server MUST authenticate the client.\n\n4.4.3.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token as described in\n   Section 5.1.  A refresh token SHOULD NOT be included.  If the request\n   failed client authentication or is invalid, the authorization server\n   returns an error response as described in Section 5.2.\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"example_parameter\":\"example_value\"\n     }\n\n4.5.  Extension Grants\n\n   The client uses an extension grant type by specifying the grant type\n   using an absolute URI (defined by the authorization server) as the\n   value of the \"grant_type\" parameter of the token endpoint, and by\n   adding any additional parameters necessary.\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 42]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, to request an access token using a Security Assertion\n   Markup Language (SAML) 2.0 assertion grant type as defined by\n   [OAuth-SAML2], the client could make the following HTTP request using\n   TLS (with extra line breaks for display purposes only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-\n     bearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU\n     [...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n5.  Issuing an Access Token\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n5.1.  Successful Response\n\n   The authorization server issues an access token and optional refresh\n   token, and constructs the response by adding the following parameters\n   to the entity-body of the HTTP response with a 200 (OK) status code:\n\n   access_token\n         REQUIRED.  The access token issued by the authorization server.\n\n   token_type\n         REQUIRED.  The type of the token issued as described in\n         Section 7.1.  Value is case insensitive.\n\n   expires_in\n         RECOMMENDED.  The lifetime in seconds of the access token.  For\n         example, the value \"3600\" denotes that the access token will\n         expire in one hour from the time the response was generated.\n         If omitted, the authorization server SHOULD provide the\n         expiration time via other means or document the default value.\n\n\n\n\n\nHardt                        Standards Track                   [Page 43]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   refresh_token\n         OPTIONAL.  The refresh token, which can be used to obtain new\n         access tokens using the same authorization grant as described\n         in Section 6.\n\n   scope\n         OPTIONAL, if identical to the scope requested by the client;\n         otherwise, REQUIRED.  The scope of the access token as\n         described by Section 3.3.\n\n   The parameters are included in the entity-body of the HTTP response\n   using the \"application/json\" media type as defined by [RFC4627].  The\n   parameters are serialized into a JavaScript Object Notation (JSON)\n   structure by adding each parameter at the highest structure level.\n   Parameter names and string values are included as JSON strings.\n   Numerical values are included as JSON numbers.  The order of\n   parameters does not matter and can vary.\n\n   The authorization server MUST include the HTTP \"Cache-Control\"\n   response header field [RFC2616] with a value of \"no-store\" in any\n   response containing tokens, credentials, or other sensitive\n   information, as well as the \"Pragma\" response header field [RFC2616]\n   with a value of \"no-cache\".\n\n   For example:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n   The client MUST ignore unrecognized value names in the response.  The\n   sizes of tokens and other values received from the authorization\n   server are left undefined.  The client should avoid making\n   assumptions about value sizes.  The authorization server SHOULD\n   document the size of any value it issues.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 44]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n5.2.  Error Response\n\n   The authorization server responds with an HTTP 400 (Bad Request)\n   status code (unless specified otherwise) and includes the following\n   parameters with the response:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               unsupported parameter value (other than grant type),\n               repeats a parameter, includes multiple credentials,\n               utilizes more than one mechanism for authenticating the\n               client, or is otherwise malformed.\n\n         invalid_client\n               Client authentication failed (e.g., unknown client, no\n               client authentication included, or unsupported\n               authentication method).  The authorization server MAY\n               return an HTTP 401 (Unauthorized) status code to indicate\n               which HTTP authentication schemes are supported.  If the\n               client attempted to authenticate via the \"Authorization\"\n               request header field, the authorization server MUST\n               respond with an HTTP 401 (Unauthorized) status code and\n               include the \"WWW-Authenticate\" response header field\n               matching the authentication scheme used by the client.\n\n         invalid_grant\n               The provided authorization grant (e.g., authorization\n               code, resource owner credentials) or refresh token is\n               invalid, expired, revoked, does not match the redirection\n               URI used in the authorization request, or was issued to\n               another client.\n\n         unauthorized_client\n               The authenticated client is not authorized to use this\n               authorization grant type.\n\n         unsupported_grant_type\n               The authorization grant type is not supported by the\n               authorization server.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 45]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         invalid_scope\n               The requested scope is invalid, unknown, malformed, or\n               exceeds the scope granted by the resource owner.\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n   The parameters are included in the entity-body of the HTTP response\n   using the \"application/json\" media type as defined by [RFC4627].  The\n   parameters are serialized into a JSON structure by adding each\n   parameter at the highest structure level.  Parameter names and string\n   values are included as JSON strings.  Numerical values are included\n   as JSON numbers.  The order of parameters does not matter and can\n   vary.\n\n   For example:\n\n     HTTP/1.1 400 Bad Request\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"error\":\"invalid_request\"\n     }\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 46]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n6.  Refreshing an Access Token\n\n   If the authorization server issued a refresh token to the client, the\n   client makes a refresh request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"refresh_token\".\n\n   refresh_token\n         REQUIRED.  The refresh token issued to the client.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.  The requested scope MUST NOT include any scope\n         not originally granted by the resource owner, and if omitted is\n         treated as equal to the scope originally granted by the\n         resource owner.\n\n   Because refresh tokens are typically long-lasting credentials used to\n   request additional access tokens, the refresh token is bound to the\n   client to which it was issued.  If the client type is confidential or\n   the client was issued client credentials (or assigned other\n   authentication requirements), the client MUST authenticate with the\n   authorization server as described in Section 3.2.1.\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 47]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included and\n      ensure that the refresh token was issued to the authenticated\n      client, and\n\n   o  validate the refresh token.\n\n   If valid and authorized, the authorization server issues an access\n   token as described in Section 5.1.  If the request failed\n   verification or is invalid, the authorization server returns an error\n   response as described in Section 5.2.\n\n   The authorization server MAY issue a new refresh token, in which case\n   the client MUST discard the old refresh token and replace it with the\n   new refresh token.  The authorization server MAY revoke the old\n   refresh token after issuing a new refresh token to the client.  If a\n   new refresh token is issued, the refresh token scope MUST be\n   identical to that of the refresh token included by the client in the\n   request.\n\n7.  Accessing Protected Resources\n\n   The client accesses protected resources by presenting the access\n   token to the resource server.  The resource server MUST validate the\n   access token and ensure that it has not expired and that its scope\n   covers the requested resource.  The methods used by the resource\n   server to validate the access token (as well as any error responses)\n   are beyond the scope of this specification but generally involve an\n   interaction or coordination between the resource server and the\n   authorization server.\n\n   The method in which the client utilizes the access token to\n   authenticate with the resource server depends on the type of access\n   token issued by the authorization server.  Typically, it involves\n   using the HTTP \"Authorization\" request header field [RFC2617] with an\n   authentication scheme defined by the specification of the access\n   token type used, such as [RFC6750].\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 48]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n7.1.  Access Token Types\n\n   The access token type provides the client with the information\n   required to successfully utilize the access token to make a protected\n   resource request (along with type-specific attributes).  The client\n   MUST NOT use an access token if it does not understand the token\n   type.\n\n   For example, the \"bearer\" token type defined in [RFC6750] is utilized\n   by simply including the access token string in the request:\n\n     GET /resource/1 HTTP/1.1\n     Host: example.com\n     Authorization: Bearer mF_9.B5f-4.1JqM\n\n   while the \"mac\" token type defined in [OAuth-HTTP-MAC] is utilized by\n   issuing a Message Authentication Code (MAC) key together with the\n   access token that is used to sign certain components of the HTTP\n   requests:\n\n     GET /resource/1 HTTP/1.1\n     Host: example.com\n     Authorization: MAC id=\"h480djs93hd8\",\n                        nonce=\"274312:dj83hs9s\",\n                        mac=\"kDZvddkndxvhGRXZhvuDjEWhGeE=\"\n\n   The above examples are provided for illustration purposes only.\n   Developers are advised to consult the [RFC6750] and [OAuth-HTTP-MAC]\n   specifications before use.\n\n   Each access token type definition specifies the additional attributes\n   (if any) sent to the client together with the \"access_token\" response\n   parameter.  It also defines the HTTP authentication method used to\n   include the access token when making a protected resource request.\n\n7.2.  Error Response\n\n   If a resource access request fails, the resource server SHOULD inform\n   the client of the error.  While the specifics of such error responses\n   are beyond the scope of this specification, this document establishes\n   a common registry in Section 11.4 for error values to be shared among\n   OAuth token authentication schemes.\n\n   New authentication schemes designed primarily for OAuth token\n   authentication SHOULD define a mechanism for providing an error\n   status code to the client, in which the error values allowed are\n   registered in the error registry established by this specification.\n\n\n\n\nHardt                        Standards Track                   [Page 49]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Such schemes MAY limit the set of valid error codes to a subset of\n   the registered values.  If the error code is returned using a named\n   parameter, the parameter name SHOULD be \"error\".\n\n   Other schemes capable of being used for OAuth token authentication,\n   but not primarily designed for that purpose, MAY bind their error\n   values to the registry in the same manner.\n\n   New authentication schemes MAY choose to also specify the use of the\n   \"error_description\" and \"error_uri\" parameters to return error\n   information in a manner parallel to their usage in this\n   specification.\n\n8.  Extensibility\n\n8.1.  Defining Access Token Types\n\n   Access token types can be defined in one of two ways: registered in\n   the Access Token Types registry (following the procedures in\n   Section 11.1), or by using a unique absolute URI as its name.\n\n   Types utilizing a URI name SHOULD be limited to vendor-specific\n   implementations that are not commonly applicable, and are specific to\n   the implementation details of the resource server where they are\n   used.\n\n   All other types MUST be registered.  Type names MUST conform to the\n   type-name ABNF.  If the type definition includes a new HTTP\n   authentication scheme, the type name SHOULD be identical to the HTTP\n   authentication scheme name (as defined by [RFC2617]).  The token type\n   \"example\" is reserved for use in examples.\n\n     type-name  = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\n8.2.  Defining New Endpoint Parameters\n\n   New request or response parameters for use with the authorization\n   endpoint or the token endpoint are defined and registered in the\n   OAuth Parameters registry following the procedure in Section 11.2.\n\n   Parameter names MUST conform to the param-name ABNF, and parameter\n   values syntax MUST be well-defined (e.g., using ABNF, or a reference\n   to the syntax of an existing parameter).\n\n     param-name  = 1*name-char\n     name-char   = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\n\n\n\nHardt                        Standards Track                   [Page 50]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Unregistered vendor-specific parameter extensions that are not\n   commonly applicable and that are specific to the implementation\n   details of the authorization server where they are used SHOULD\n   utilize a vendor-specific prefix that is not likely to conflict with\n   other registered values (e.g., begin with 'companyname_').\n\n8.3.  Defining New Authorization Grant Types\n\n   New authorization grant types can be defined by assigning them a\n   unique absolute URI for use with the \"grant_type\" parameter.  If the\n   extension grant type requires additional token endpoint parameters,\n   they MUST be registered in the OAuth Parameters registry as described\n   by Section 11.2.\n\n8.4.  Defining New Authorization Endpoint Response Types\n\n   New response types for use with the authorization endpoint are\n   defined and registered in the Authorization Endpoint Response Types\n   registry following the procedure in Section 11.3.  Response type\n   names MUST conform to the response-type ABNF.\n\n     response-type  = response-name *( SP response-name )\n     response-name  = 1*response-char\n     response-char  = \"_\" / DIGIT / ALPHA\n\n   If a response type contains one or more space characters (%x20), it\n   is compared as a space-delimited list of values in which the order of\n   values does not matter.  Only one order of values can be registered,\n   which covers all other arrangements of the same set of values.\n\n   For example, the response type \"token code\" is left undefined by this\n   specification.  However, an extension can define and register the\n   \"token code\" response type.  Once registered, the same combination\n   cannot be registered as \"code token\", but both values can be used to\n   denote the same response type.\n\n8.5.  Defining Additional Error Codes\n\n   In cases where protocol extensions (i.e., access token types,\n   extension parameters, or extension grant types) require additional\n   error codes to be used with the authorization code grant error\n   response (Section 4.1.2.1), the implicit grant error response\n   (Section 4.2.2.1), the token error response (Section 5.2), or the\n   resource access error response (Section 7.2), such error codes MAY be\n   defined.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 51]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Extension error codes MUST be registered (following the procedures in\n   Section 11.4) if the extension they are used in conjunction with is a\n   registered access token type, a registered endpoint parameter, or an\n   extension grant type.  Error codes used with unregistered extensions\n   MAY be registered.\n\n   Error codes MUST conform to the error ABNF and SHOULD be prefixed by\n   an identifying name when possible.  For example, an error identifying\n   an invalid value set to the extension parameter \"example\" SHOULD be\n   named \"example_invalid\".\n\n     error      = 1*error-char\n     error-char = %x20-21 / %x23-5B / %x5D-7E\n\n9.  Native Applications\n\n   Native applications are clients installed and executed on the device\n   used by the resource owner (i.e., desktop application, native mobile\n   application).  Native applications require special consideration\n   related to security, platform capabilities, and overall end-user\n   experience.\n\n   The authorization endpoint requires interaction between the client\n   and the resource owner's user-agent.  Native applications can invoke\n   an external user-agent or embed a user-agent within the application.\n   For example:\n\n   o  External user-agent - the native application can capture the\n      response from the authorization server using a redirection URI\n      with a scheme registered with the operating system to invoke the\n      client as the handler, manual copy-and-paste of the credentials,\n      running a local web server, installing a user-agent extension, or\n      by providing a redirection URI identifying a server-hosted\n      resource under the client's control, which in turn makes the\n      response available to the native application.\n\n   o  Embedded user-agent - the native application obtains the response\n      by directly communicating with the embedded user-agent by\n      monitoring state changes emitted during the resource load, or\n      accessing the user-agent's cookies storage.\n\n   When choosing between an external or embedded user-agent, developers\n   should consider the following:\n\n   o  An external user-agent may improve completion rate, as the\n      resource owner may already have an active session with the\n      authorization server, removing the need to re-authenticate.  It\n      provides a familiar end-user experience and functionality.  The\n\n\n\nHardt                        Standards Track                   [Page 52]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n      resource owner may also rely on user-agent features or extensions\n      to assist with authentication (e.g., password manager, 2-factor\n      device reader).\n\n   o  An embedded user-agent may offer improved usability, as it removes\n      the need to switch context and open new windows.\n\n   o  An embedded user-agent poses a security challenge because resource\n      owners are authenticating in an unidentified window without access\n      to the visual protections found in most external user-agents.  An\n      embedded user-agent educates end-users to trust unidentified\n      requests for authentication (making phishing attacks easier to\n      execute).\n\n   When choosing between the implicit grant type and the authorization\n   code grant type, the following should be considered:\n\n   o  Native applications that use the authorization code grant type\n      SHOULD do so without using client credentials, due to the native\n      application's inability to keep client credentials confidential.\n\n   o  When using the implicit grant type flow, a refresh token is not\n      returned, which requires repeating the authorization process once\n      the access token expires.\n\n10.  Security Considerations\n\n   As a flexible and extensible framework, OAuth's security\n   considerations depend on many factors.  The following sections\n   provide implementers with security guidelines focused on the three\n   client profiles described in Section 2.1: web application,\n   user-agent-based application, and native application.\n\n   A comprehensive OAuth security model and analysis, as well as\n   background for the protocol design, is provided by\n   [OAuth-THREATMODEL].\n\n10.1.  Client Authentication\n\n   The authorization server establishes client credentials with web\n   application clients for the purpose of client authentication.  The\n   authorization server is encouraged to consider stronger client\n   authentication means than a client password.  Web application clients\n   MUST ensure confidentiality of client passwords and other client\n   credentials.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 53]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST NOT issue client passwords or other\n   client credentials to native application or user-agent-based\n   application clients for the purpose of client authentication.  The\n   authorization server MAY issue a client password or other credentials\n   for a specific installation of a native application client on a\n   specific device.\n\n   When client authentication is not possible, the authorization server\n   SHOULD employ other means to validate the client's identity -- for\n   example, by requiring the registration of the client redirection URI\n   or enlisting the resource owner to confirm identity.  A valid\n   redirection URI is not sufficient to verify the client's identity\n   when asking for resource owner authorization but can be used to\n   prevent delivering credentials to a counterfeit client after\n   obtaining resource owner authorization.\n\n   The authorization server must consider the security implications of\n   interacting with unauthenticated clients and take measures to limit\n   the potential exposure of other credentials (e.g., refresh tokens)\n   issued to such clients.\n\n10.2.  Client Impersonation\n\n   A malicious client can impersonate another client and obtain access\n   to protected resources if the impersonated client fails to, or is\n   unable to, keep its client credentials confidential.\n\n   The authorization server MUST authenticate the client whenever\n   possible.  If the authorization server cannot authenticate the client\n   due to the client's nature, the authorization server MUST require the\n   registration of any redirection URI used for receiving authorization\n   responses and SHOULD utilize other means to protect resource owners\n   from such potentially malicious clients.  For example, the\n   authorization server can engage the resource owner to assist in\n   identifying the client and its origin.\n\n   The authorization server SHOULD enforce explicit resource owner\n   authentication and provide the resource owner with information about\n   the client and the requested authorization scope and lifetime.  It is\n   up to the resource owner to review the information in the context of\n   the current client and to authorize or deny the request.\n\n   The authorization server SHOULD NOT process repeated authorization\n   requests automatically (without active resource owner interaction)\n   without authenticating the client or relying on other measures to\n   ensure that the repeated request comes from the original client and\n   not an impersonator.\n\n\n\n\nHardt                        Standards Track                   [Page 54]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.3.  Access Tokens\n\n   Access token credentials (as well as any confidential access token\n   attributes) MUST be kept confidential in transit and storage, and\n   only shared among the authorization server, the resource servers the\n   access token is valid for, and the client to whom the access token is\n   issued.  Access token credentials MUST only be transmitted using TLS\n   as described in Section 1.6 with server authentication as defined by\n   [RFC2818].\n\n   When using the implicit grant type, the access token is transmitted\n   in the URI fragment, which can expose it to unauthorized parties.\n\n   The authorization server MUST ensure that access tokens cannot be\n   generated, modified, or guessed to produce valid access tokens by\n   unauthorized parties.\n\n   The client SHOULD request access tokens with the minimal scope\n   necessary.  The authorization server SHOULD take the client identity\n   into account when choosing how to honor the requested scope and MAY\n   issue an access token with less rights than requested.\n\n   This specification does not provide any methods for the resource\n   server to ensure that an access token presented to it by a given\n   client was issued to that client by the authorization server.\n\n10.4.  Refresh Tokens\n\n   Authorization servers MAY issue refresh tokens to web application\n   clients and native application clients.\n\n   Refresh tokens MUST be kept confidential in transit and storage, and\n   shared only among the authorization server and the client to whom the\n   refresh tokens were issued.  The authorization server MUST maintain\n   the binding between a refresh token and the client to whom it was\n   issued.  Refresh tokens MUST only be transmitted using TLS as\n   described in Section 1.6 with server authentication as defined by\n   [RFC2818].\n\n   The authorization server MUST verify the binding between the refresh\n   token and client identity whenever the client identity can be\n   authenticated.  When client authentication is not possible, the\n   authorization server SHOULD deploy other means to detect refresh\n   token abuse.\n\n   For example, the authorization server could employ refresh token\n   rotation in which a new refresh token is issued with every access\n   token refresh response.  The previous refresh token is invalidated\n\n\n\nHardt                        Standards Track                   [Page 55]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   but retained by the authorization server.  If a refresh token is\n   compromised and subsequently used by both the attacker and the\n   legitimate client, one of them will present an invalidated refresh\n   token, which will inform the authorization server of the breach.\n\n   The authorization server MUST ensure that refresh tokens cannot be\n   generated, modified, or guessed to produce valid refresh tokens by\n   unauthorized parties.\n\n10.5.  Authorization Codes\n\n   The transmission of authorization codes SHOULD be made over a secure\n   channel, and the client SHOULD require the use of TLS with its\n   redirection URI if the URI identifies a network resource.  Since\n   authorization codes are transmitted via user-agent redirections, they\n   could potentially be disclosed through user-agent history and HTTP\n   referrer headers.\n\n   Authorization codes operate as plaintext bearer credentials, used to\n   verify that the resource owner who granted authorization at the\n   authorization server is the same resource owner returning to the\n   client to complete the process.  Therefore, if the client relies on\n   the authorization code for its own resource owner authentication, the\n   client redirection endpoint MUST require the use of TLS.\n\n   Authorization codes MUST be short lived and single-use.  If the\n   authorization server observes multiple attempts to exchange an\n   authorization code for an access token, the authorization server\n   SHOULD attempt to revoke all access tokens already granted based on\n   the compromised authorization code.\n\n   If the client can be authenticated, the authorization servers MUST\n   authenticate the client and ensure that the authorization code was\n   issued to the same client.\n\n10.6.  Authorization Code Redirection URI Manipulation\n\n   When requesting authorization using the authorization code grant\n   type, the client can specify a redirection URI via the \"redirect_uri\"\n   parameter.  If an attacker can manipulate the value of the\n   redirection URI, it can cause the authorization server to redirect\n   the resource owner user-agent to a URI under the control of the\n   attacker with the authorization code.\n\n   An attacker can create an account at a legitimate client and initiate\n   the authorization flow.  When the attacker's user-agent is sent to\n   the authorization server to grant access, the attacker grabs the\n   authorization URI provided by the legitimate client and replaces the\n\n\n\nHardt                        Standards Track                   [Page 56]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   client's redirection URI with a URI under the control of the\n   attacker.  The attacker then tricks the victim into following the\n   manipulated link to authorize access to the legitimate client.\n\n   Once at the authorization server, the victim is prompted with a\n   normal, valid request on behalf of a legitimate and trusted client,\n   and authorizes the request.  The victim is then redirected to an\n   endpoint under the control of the attacker with the authorization\n   code.  The attacker completes the authorization flow by sending the\n   authorization code to the client using the original redirection URI\n   provided by the client.  The client exchanges the authorization code\n   with an access token and links it to the attacker's client account,\n   which can now gain access to the protected resources authorized by\n   the victim (via the client).\n\n   In order to prevent such an attack, the authorization server MUST\n   ensure that the redirection URI used to obtain the authorization code\n   is identical to the redirection URI provided when exchanging the\n   authorization code for an access token.  The authorization server\n   MUST require public clients and SHOULD require confidential clients\n   to register their redirection URIs.  If a redirection URI is provided\n   in the request, the authorization server MUST validate it against the\n   registered value.\n\n10.7.  Resource Owner Password Credentials\n\n   The resource owner password credentials grant type is often used for\n   legacy or migration reasons.  It reduces the overall risk of storing\n   usernames and passwords by the client but does not eliminate the need\n   to expose highly privileged credentials to the client.\n\n   This grant type carries a higher risk than other grant types because\n   it maintains the password anti-pattern this protocol seeks to avoid.\n   The client could abuse the password, or the password could\n   unintentionally be disclosed to an attacker (e.g., via log files or\n   other records kept by the client).\n\n   Additionally, because the resource owner does not have control over\n   the authorization process (the resource owner's involvement ends when\n   it hands over its credentials to the client), the client can obtain\n   access tokens with a broader scope than desired by the resource\n   owner.  The authorization server should consider the scope and\n   lifetime of access tokens issued via this grant type.\n\n   The authorization server and client SHOULD minimize use of this grant\n   type and utilize other grant types whenever possible.\n\n\n\n\n\nHardt                        Standards Track                   [Page 57]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.8.  Request Confidentiality\n\n   Access tokens, refresh tokens, resource owner passwords, and client\n   credentials MUST NOT be transmitted in the clear.  Authorization\n   codes SHOULD NOT be transmitted in the clear.\n\n   The \"state\" and \"scope\" parameters SHOULD NOT include sensitive\n   client or resource owner information in plain text, as they can be\n   transmitted over insecure channels or stored insecurely.\n\n10.9.  Ensuring Endpoint Authenticity\n\n   In order to prevent man-in-the-middle attacks, the authorization\n   server MUST require the use of TLS with server authentication as\n   defined by [RFC2818] for any request sent to the authorization and\n   token endpoints.  The client MUST validate the authorization server's\n   TLS certificate as defined by [RFC6125] and in accordance with its\n   requirements for server identity authentication.\n\n10.10.  Credentials-Guessing Attacks\n\n   The authorization server MUST prevent attackers from guessing access\n   tokens, authorization codes, refresh tokens, resource owner\n   passwords, and client credentials.\n\n   The probability of an attacker guessing generated tokens (and other\n   credentials not intended for handling by end-users) MUST be less than\n   or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).\n\n   The authorization server MUST utilize other means to protect\n   credentials intended for end-user usage.\n\n10.11.  Phishing Attacks\n\n   Wide deployment of this and similar protocols may cause end-users to\n   become inured to the practice of being redirected to websites where\n   they are asked to enter their passwords.  If end-users are not\n   careful to verify the authenticity of these websites before entering\n   their credentials, it will be possible for attackers to exploit this\n   practice to steal resource owners' passwords.\n\n   Service providers should attempt to educate end-users about the risks\n   phishing attacks pose and should provide mechanisms that make it easy\n   for end-users to confirm the authenticity of their sites.  Client\n   developers should consider the security implications of how they\n   interact with the user-agent (e.g., external, embedded), and the\n   ability of the end-user to verify the authenticity of the\n   authorization server.\n\n\n\nHardt                        Standards Track                   [Page 58]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   To reduce the risk of phishing attacks, the authorization servers\n   MUST require the use of TLS on every endpoint used for end-user\n   interaction.\n\n10.12.  Cross-Site Request Forgery\n\n   Cross-site request forgery (CSRF) is an exploit in which an attacker\n   causes the user-agent of a victim end-user to follow a malicious URI\n   (e.g., provided to the user-agent as a misleading link, image, or\n   redirection) to a trusting server (usually established via the\n   presence of a valid session cookie).\n\n   A CSRF attack against the client's redirection URI allows an attacker\n   to inject its own authorization code or access token, which can\n   result in the client using an access token associated with the\n   attacker's protected resources rather than the victim's (e.g., save\n   the victim's bank account information to a protected resource\n   controlled by the attacker).\n\n   The client MUST implement CSRF protection for its redirection URI.\n   This is typically accomplished by requiring any request sent to the\n   redirection URI endpoint to include a value that binds the request to\n   the user-agent's authenticated state (e.g., a hash of the session\n   cookie used to authenticate the user-agent).  The client SHOULD\n   utilize the \"state\" request parameter to deliver this value to the\n   authorization server when making an authorization request.\n\n   Once authorization has been obtained from the end-user, the\n   authorization server redirects the end-user's user-agent back to the\n   client with the required binding value contained in the \"state\"\n   parameter.  The binding value enables the client to verify the\n   validity of the request by matching the binding value to the\n   user-agent's authenticated state.  The binding value used for CSRF\n   protection MUST contain a non-guessable value (as described in\n   Section 10.10), and the user-agent's authenticated state (e.g.,\n   session cookie, HTML5 local storage) MUST be kept in a location\n   accessible only to the client and the user-agent (i.e., protected by\n   same-origin policy).\n\n   A CSRF attack against the authorization server's authorization\n   endpoint can result in an attacker obtaining end-user authorization\n   for a malicious client without involving or alerting the end-user.\n\n   The authorization server MUST implement CSRF protection for its\n   authorization endpoint and ensure that a malicious client cannot\n   obtain authorization without the awareness and explicit consent of\n   the resource owner.\n\n\n\n\nHardt                        Standards Track                   [Page 59]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.13.  Clickjacking\n\n   In a clickjacking attack, an attacker registers a legitimate client\n   and then constructs a malicious site in which it loads the\n   authorization server's authorization endpoint web page in a\n   transparent iframe overlaid on top of a set of dummy buttons, which\n   are carefully constructed to be placed directly under important\n   buttons on the authorization page.  When an end-user clicks a\n   misleading visible button, the end-user is actually clicking an\n   invisible button on the authorization page (such as an \"Authorize\"\n   button).  This allows an attacker to trick a resource owner into\n   granting its client access without the end-user's knowledge.\n\n   To prevent this form of attack, native applications SHOULD use\n   external browsers instead of embedding browsers within the\n   application when requesting end-user authorization.  For most newer\n   browsers, avoidance of iframes can be enforced by the authorization\n   server using the (non-standard) \"x-frame-options\" header.  This\n   header can have two values, \"deny\" and \"sameorigin\", which will block\n   any framing, or framing by sites with a different origin,\n   respectively.  For older browsers, JavaScript frame-busting\n   techniques can be used but may not be effective in all browsers.\n\n10.14.  Code Injection and Input Validation\n\n   A code injection attack occurs when an input or otherwise external\n   variable is used by an application unsanitized and causes\n   modification to the application logic.  This may allow an attacker to\n   gain access to the application device or its data, cause denial of\n   service, or introduce a wide range of malicious side-effects.\n\n   The authorization server and client MUST sanitize (and validate when\n   possible) any value received -- in particular, the value of the\n   \"state\" and \"redirect_uri\" parameters.\n\n10.15.  Open Redirectors\n\n   The authorization server, authorization endpoint, and client\n   redirection endpoint can be improperly configured and operate as open\n   redirectors.  An open redirector is an endpoint using a parameter to\n   automatically redirect a user-agent to the location specified by the\n   parameter value without any validation.\n\n   Open redirectors can be used in phishing attacks, or by an attacker\n   to get end-users to visit malicious sites by using the URI authority\n   component of a familiar and trusted destination.  In addition, if the\n   authorization server allows the client to register only part of the\n   redirection URI, an attacker can use an open redirector operated by\n\n\n\nHardt                        Standards Track                   [Page 60]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   the client to construct a redirection URI that will pass the\n   authorization server validation but will send the authorization code\n   or access token to an endpoint under the control of the attacker.\n\n10.16.  Misuse of Access Token to Impersonate Resource Owner in Implicit\n        Flow\n\n   For public clients using implicit flows, this specification does not\n   provide any method for the client to determine what client an access\n   token was issued to.\n\n   A resource owner may willingly delegate access to a resource by\n   granting an access token to an attacker's malicious client.  This may\n   be due to phishing or some other pretext.  An attacker may also steal\n   a token via some other mechanism.  An attacker may then attempt to\n   impersonate the resource owner by providing the access token to a\n   legitimate public client.\n\n   In the implicit flow (response_type=token), the attacker can easily\n   switch the token in the response from the authorization server,\n   replacing the real access token with the one previously issued to the\n   attacker.\n\n   Servers communicating with native applications that rely on being\n   passed an access token in the back channel to identify the user of\n   the client may be similarly compromised by an attacker creating a\n   compromised application that can inject arbitrary stolen access\n   tokens.\n\n   Any public client that makes the assumption that only the resource\n   owner can present it with a valid access token for the resource is\n   vulnerable to this type of attack.\n\n   This type of attack may expose information about the resource owner\n   at the legitimate client to the attacker (malicious client).  This\n   will also allow the attacker to perform operations at the legitimate\n   client with the same permissions as the resource owner who originally\n   granted the access token or authorization code.\n\n   Authenticating resource owners to clients is out of scope for this\n   specification.  Any specification that uses the authorization process\n   as a form of delegated end-user authentication to the client (e.g.,\n   third-party sign-in service) MUST NOT use the implicit flow without\n   additional security mechanisms that would enable the client to\n   determine if the access token was issued for its use (e.g., audience-\n   restricting the access token).\n\n\n\n\n\nHardt                        Standards Track                   [Page 61]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.  IANA Considerations\n\n11.1.  OAuth Access Token Types Registry\n\n   This specification establishes the OAuth Access Token Types registry.\n\n   Access token types are registered with a Specification Required\n   ([RFC5226]) after a two-week review period on the\n   oauth-ext-review@ietf.org mailing list, on the advice of one or more\n   Designated Experts.  However, to allow for the allocation of values\n   prior to publication, the Designated Expert(s) may approve\n   registration once they are satisfied that such a specification will\n   be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for access token type: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.1.1.  Registration Template\n\n   Type name:\n      The name requested (e.g., \"example\").\n\n   Additional Token Endpoint Response Parameters:\n      Additional response parameters returned together with the\n      \"access_token\" parameter.  New parameters MUST be separately\n      registered in the OAuth Parameters registry as described by\n      Section 11.2.\n\n   HTTP Authentication Scheme(s):\n      The HTTP authentication scheme name(s), if any, used to\n      authenticate protected resource requests using access tokens of\n      this type.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n\n\nHardt                        Standards Track                   [Page 62]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Specification document(s):\n      Reference to the document(s) that specify the parameter,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n11.2.  OAuth Parameters Registry\n\n   This specification establishes the OAuth Parameters registry.\n\n   Additional parameters for inclusion in the authorization endpoint\n   request, the authorization endpoint response, the token endpoint\n   request, or the token endpoint response are registered with a\n   Specification Required ([RFC5226]) after a two-week review period on\n   the oauth-ext-review@ietf.org mailing list, on the advice of one or\n   more Designated Experts.  However, to allow for the allocation of\n   values prior to publication, the Designated Expert(s) may approve\n   registration once they are satisfied that such a specification will\n   be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for parameter: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.2.1.  Registration Template\n\n   Parameter name:\n      The name requested (e.g., \"example\").\n\n   Parameter usage location:\n      The location(s) where parameter can be used.  The possible\n      locations are authorization request, authorization response, token\n      request, or token response.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n\n\nHardt                        Standards Track                   [Page 63]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Specification document(s):\n      Reference to the document(s) that specify the parameter,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n11.2.2.  Initial Registry Contents\n\n   The OAuth Parameters registry's initial contents are:\n\n   o  Parameter name: client_id\n   o  Parameter usage location: authorization request, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: client_secret\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: response_type\n   o  Parameter usage location: authorization request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: redirect_uri\n   o  Parameter usage location: authorization request, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: scope\n   o  Parameter usage location: authorization request, authorization\n      response, token request, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: state\n   o  Parameter usage location: authorization request, authorization\n      response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: code\n   o  Parameter usage location: authorization response, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n\n\n\n\nHardt                        Standards Track                   [Page 64]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   o  Parameter name: error_description\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: error_uri\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: grant_type\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: access_token\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: token_type\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: expires_in\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: username\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: password\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: refresh_token\n   o  Parameter usage location: token request, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 65]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.3.  OAuth Authorization Endpoint Response Types Registry\n\n   This specification establishes the OAuth Authorization Endpoint\n   Response Types registry.\n\n   Additional response types for use with the authorization endpoint are\n   registered with a Specification Required ([RFC5226]) after a two-week\n   review period on the oauth-ext-review@ietf.org mailing list, on the\n   advice of one or more Designated Experts.  However, to allow for the\n   allocation of values prior to publication, the Designated Expert(s)\n   may approve registration once they are satisfied that such a\n   specification will be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for response type: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.3.1.  Registration Template\n\n   Response type name:\n      The name requested (e.g., \"example\").\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n   Specification document(s):\n      Reference to the document(s) that specify the type, preferably\n      including a URI that can be used to retrieve a copy of the\n      document(s).  An indication of the relevant sections may also be\n      included but is not required.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 66]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.3.2.  Initial Registry Contents\n\n   The OAuth Authorization Endpoint Response Types registry's initial\n   contents are:\n\n   o  Response type name: code\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Response type name: token\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n11.4.  OAuth Extensions Error Registry\n\n   This specification establishes the OAuth Extensions Error registry.\n\n   Additional error codes used together with other protocol extensions\n   (i.e., extension grant types, access token types, or extension\n   parameters) are registered with a Specification Required ([RFC5226])\n   after a two-week review period on the oauth-ext-review@ietf.org\n   mailing list, on the advice of one or more Designated Experts.\n   However, to allow for the allocation of values prior to publication,\n   the Designated Expert(s) may approve registration once they are\n   satisfied that such a specification will be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for error code: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 67]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.4.1.  Registration Template\n\n   Error name:\n      The name requested (e.g., \"example\").  Values for the error name\n      MUST NOT include characters outside the set %x20-21 / %x23-5B /\n      %x5D-7E.\n\n   Error usage location:\n      The location(s) where the error can be used.  The possible\n      locations are authorization code grant error response\n      (Section 4.1.2.1), implicit grant error response\n      (Section 4.2.2.1), token error response (Section 5.2), or resource\n      access error response (Section 7.2).\n\n   Related protocol extension:\n      The name of the extension grant type, access token type, or\n      extension parameter that the error code is used in conjunction\n      with.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n   Specification document(s):\n      Reference to the document(s) that specify the error code,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n12.  References\n\n12.1.  Normative References\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\n   [RFC2246]  Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\",\n              RFC 2246, January 1999.\n\n   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n\n   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n              Leach, P., Luotonen, A., and L. Stewart, \"HTTP\n              Authentication: Basic and Digest Access Authentication\",\n              RFC 2617, June 1999.\n\n\n\nHardt                        Standards Track                   [Page 68]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.\n\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of\n              ISO 10646\", STD 63, RFC 3629, November 2003.\n\n   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, January 2005.\n\n   [RFC4627]  Crockford, D., \"The application/json Media Type for\n              JavaScript Object Notation (JSON)\", RFC 4627, July 2006.\n\n   [RFC4949]  Shirey, R., \"Internet Security Glossary, Version 2\",\n              RFC 4949, August 2007.\n\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n\n   [RFC5234]  Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n\n   [RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification of Domain-Based Application Service Identity\n              within Internet Public Key Infrastructure Using X.509\n              (PKIX) Certificates in the Context of Transport Layer\n              Security (TLS)\", RFC 6125, March 2011.\n\n   [USASCII]  American National Standards Institute, \"Coded Character\n              Set -- 7-bit American Standard Code for Information\n              Interchange\", ANSI X3.4, 1986.\n\n   [W3C.REC-html401-19991224]\n              Raggett, D., Le Hors, A., and I. Jacobs, \"HTML 4.01\n              Specification\", World Wide Web Consortium\n              Recommendation REC-html401-19991224, December 1999,\n              <http://www.w3.org/TR/1999/REC-html401-19991224>.\n\n   [W3C.REC-xml-20081126]\n              Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,\n              and F. Yergeau, \"Extensible Markup Language (XML) 1.0\n              (Fifth Edition)\", World Wide Web Consortium\n               Recommendation REC-xml-20081126, November 2008,\n              <http://www.w3.org/TR/2008/REC-xml-20081126>.\n\n\n\n\nHardt                        Standards Track                   [Page 69]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n12.2.  Informative References\n\n   [OAuth-HTTP-MAC]\n              Hammer-Lahav, E., Ed., \"HTTP Authentication: MAC Access\n              Authentication\", Work in Progress, February 2012.\n\n   [OAuth-SAML2]\n              Campbell, B. and C. Mortimore, \"SAML 2.0 Bearer Assertion\n              Profiles for OAuth 2.0\", Work in Progress, September 2012.\n\n   [OAuth-THREATMODEL]\n              Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \"OAuth 2.0\n              Threat Model and Security Considerations\", Work\n              in Progress, October 2012.\n\n   [OAuth-WRAP]\n              Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, \"OAuth\n              Web Resource Authorization Profiles\", Work in Progress,\n              January 2010.\n\n   [RFC5849]  Hammer-Lahav, E., \"The OAuth 1.0 Protocol\", RFC 5849,\n              April 2010.\n\n   [RFC6750]  Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization\n              Framework: Bearer Token Usage\", RFC 6750, October 2012.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 70]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nAppendix A.  Augmented Backus-Naur Form (ABNF) Syntax\n\n   This section provides Augmented Backus-Naur Form (ABNF) syntax\n   descriptions for the elements defined in this specification using the\n   notation of [RFC5234].  The ABNF below is defined in terms of Unicode\n   code points [W3C.REC-xml-20081126]; these characters are typically\n   encoded in UTF-8.  Elements are presented in the order first defined.\n\n   Some of the definitions that follow use the \"URI-reference\"\n   definition from [RFC3986].\n\n   Some of the definitions that follow use these common definitions:\n\n     VSCHAR     = %x20-7E\n     NQCHAR     = %x21 / %x23-5B / %x5D-7E\n     NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E\n     UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /\n                         %xE000-FFFD / %x10000-10FFFF\n\n   (The UNICODECHARNOCRLF definition is based upon the Char definition\n   in Section 2.2 of [W3C.REC-xml-20081126], but omitting the Carriage\n   Return and Linefeed characters.)\n\nA.1.  \"client_id\" Syntax\n\n   The \"client_id\" element is defined in Section 2.3.1:\n\n     client-id     = *VSCHAR\n\nA.2.  \"client_secret\" Syntax\n\n   The \"client_secret\" element is defined in Section 2.3.1:\n\n     client-secret = *VSCHAR\n\nA.3.  \"response_type\" Syntax\n\n   The \"response_type\" element is defined in Sections 3.1.1 and 8.4:\n\n     response-type = response-name *( SP response-name )\n     response-name = 1*response-char\n     response-char = \"_\" / DIGIT / ALPHA\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 71]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.4.  \"scope\" Syntax\n\n   The \"scope\" element is defined in Section 3.3:\n\n     scope       = scope-token *( SP scope-token )\n     scope-token = 1*NQCHAR\n\nA.5.  \"state\" Syntax\n\n   The \"state\" element is defined in Sections 4.1.1, 4.1.2, 4.1.2.1,\n   4.2.1, 4.2.2, and 4.2.2.1:\n\n     state      = 1*VSCHAR\n\nA.6.  \"redirect_uri\" Syntax\n\n   The \"redirect_uri\" element is defined in Sections 4.1.1, 4.1.3,\n   and 4.2.1:\n\n     redirect-uri      = URI-reference\n\nA.7.  \"error\" Syntax\n\n   The \"error\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\n   7.2, and 8.5:\n\n     error             = 1*NQSCHAR\n\nA.8.  \"error_description\" Syntax\n\n   The \"error_description\" element is defined in Sections 4.1.2.1,\n   4.2.2.1, 5.2, and 7.2:\n\n     error-description = 1*NQSCHAR\n\nA.9.  \"error_uri\" Syntax\n\n   The \"error_uri\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\n   and 7.2:\n\n     error-uri         = URI-reference\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 72]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.10.  \"grant_type\" Syntax\n\n   The \"grant_type\" element is defined in Sections 4.1.3, 4.3.2, 4.4.2,\n   4.5, and 6:\n\n     grant-type = grant-name / URI-reference\n     grant-name = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nA.11.  \"code\" Syntax\n\n   The \"code\" element is defined in Section 4.1.3:\n\n     code       = 1*VSCHAR\n\nA.12.  \"access_token\" Syntax\n\n   The \"access_token\" element is defined in Sections 4.2.2 and 5.1:\n\n     access-token = 1*VSCHAR\n\nA.13.  \"token_type\" Syntax\n\n   The \"token_type\" element is defined in Sections 4.2.2, 5.1, and 8.1:\n\n     token-type = type-name / URI-reference\n     type-name  = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nA.14.  \"expires_in\" Syntax\n\n   The \"expires_in\" element is defined in Sections 4.2.2 and 5.1:\n\n     expires-in = 1*DIGIT\n\nA.15.  \"username\" Syntax\n\n   The \"username\" element is defined in Section 4.3.2:\n\n     username = *UNICODECHARNOCRLF\n\nA.16.  \"password\" Syntax\n\n   The \"password\" element is defined in Section 4.3.2:\n\n     password = *UNICODECHARNOCRLF\n\n\n\n\n\nHardt                        Standards Track                   [Page 73]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.17.  \"refresh_token\" Syntax\n\n   The \"refresh_token\" element is defined in Sections 5.1 and 6:\n\n     refresh-token = 1*VSCHAR\n\nA.18.  Endpoint Parameter Syntax\n\n   The syntax for new endpoint parameters is defined in Section 8.2:\n\n     param-name = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nAppendix B.  Use of application/x-www-form-urlencoded Media Type\n\n   At the time of publication of this specification, the\n   \"application/x-www-form-urlencoded\" media type was defined in\n   Section 17.13.4 of [W3C.REC-html401-19991224] but not registered in\n   the IANA MIME Media Types registry\n   (<http://www.iana.org/assignments/media-types>).  Furthermore, that\n   definition is incomplete, as it does not consider non-US-ASCII\n   characters.\n\n   To address this shortcoming when generating payloads using this media\n   type, names and values MUST be encoded using the UTF-8 character\n   encoding scheme [RFC3629] first; the resulting octet sequence then\n   needs to be further encoded using the escaping rules defined in\n   [W3C.REC-html401-19991224].\n\n   When parsing data from a payload using this media type, the names and\n   values resulting from reversing the name/value encoding consequently\n   need to be treated as octet sequences, to be decoded using the UTF-8\n   character encoding scheme.\n\n   For example, the value consisting of the six Unicode code points\n   (1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN),\n   (3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN),\n   (5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN) would be encoded\n   into the octet sequence below (using hexadecimal notation):\n\n     20 25 26 2B C2 A3 E2 82 AC\n\n   and then represented in the payload as:\n\n     +%25%26%2B%C2%A3%E2%82%AC\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 74]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nAppendix C.  Acknowledgements\n\n   The initial OAuth 2.0 protocol specification was edited by David\n   Recordon, based on two previous publications: the OAuth 1.0 community\n   specification [RFC5849], and OAuth WRAP (OAuth Web Resource\n   Authorization Profiles) [OAuth-WRAP].  Eran Hammer then edited many\n   of the intermediate drafts that evolved into this RFC.  The Security\n   Considerations section was drafted by Torsten Lodderstedt, Mark\n   McGloin, Phil Hunt, Anthony Nadalin, and John Bradley.  The section\n   on use of the \"application/x-www-form-urlencoded\" media type was\n   drafted by Julian Reschke.  The ABNF section was drafted by Michael\n   B. Jones.\n\n   The OAuth 1.0 community specification was edited by Eran Hammer and\n   authored by Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M.\n   Conlan, Blaine Cook, Leah Culver, Breno de Medeiros, Brian Eaton,\n   Kellan Elliott-McCrea, Larry Halff, Eran Hammer, Ben Laurie, Chris\n   Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,\n   Jonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.\n\n   The OAuth WRAP specification was edited by Dick Hardt and authored by\n   Brian Eaton, Yaron Y. Goland, Dick Hardt, and Allen Tom.\n\n   This specification is the work of the OAuth Working Group, which\n   includes dozens of active and dedicated participants.  In particular,\n   the following individuals contributed ideas, feedback, and wording\n   that shaped and formed the final specification:\n\n   Michael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden\n   Bell, John Bradley, Marcos Caceres, Brian Campbell, Scott Cantor,\n   Blaine Cook, Roger Crew, Leah Culver, Bill de hOra, Andre DeMarre,\n   Brian Eaton, Wesley Eddy, Wolter Eldering, Brian Ellin, Igor\n   Faynberg, George Fletcher, Tim Freeman, Luca Frosini, Evan Gilbert,\n   Yaron Y. Goland, Brent Goldman, Kristoffer Gronowski, Eran Hammer,\n   Dick Hardt, Justin Hart, Craig Heath, Phil Hunt, Michael B. Jones,\n   Terry Jones, John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara,\n   Rasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Casey Lucas, Paul\n   Madsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin,\n   Laurence Miao, William Mills, Chuck Mortimore, Anthony Nadalin,\n   Julian Reschke, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob\n   Sayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov,\n   Justin Smith, Haibin Song, Niv Steingarten, Christian Stuebner,\n   Jeremy Suriel, Paul Tarjan, Christopher Thomas, Henry S. Thompson,\n   Allen Tom, Franklin Tse, Nick Walker, Shane Weeden, and Skylar\n   Woodward.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 75]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   This document was produced under the chairmanship of Blaine Cook,\n   Peter Saint-Andre, Hannes Tschofenig, Barry Leiba, and Derek Atkins.\n   The area directors included Lisa Dusseault, Peter Saint-Andre, and\n   Stephen Farrell.\n\nAuthor's Address\n\n   Dick Hardt (editor)\n   Microsoft\n\n   EMail: dick.hardt@gmail.com\n   URI:   http://dickhardt.org/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 76]\n\f\n",
    "chunks": [
      {
        "chunk_id": "rfc_oauth_chunk_0",
        "original_index": 0,
        "content": "Internet Engineering Task Force (IETF)                     D. Hardt, Ed.\nRequest for Comments: 6749                                     Microsoft\nObsoletes: 5849                                             October 2012\nCategory: Standards Track\nISSN: 2070-1721\n\n\n                 The OAuth 2.0 Authorization Framework\n\nAbstract\n\n   The OAuth 2.0 authorization framework enables a third-party\n   application to obtain limited access to an HTTP service, either on\n   behalf of a resource owner by orchestrating an approval interaction\n   between the resource owner and the HTTP service, or by allowing the\n   third-party application to obtain access on its own behalf.  This\n   specification replaces and obsoletes the OAuth 1.0 protocol described\n   in RFC 5849.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 5741.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6749.\n\nCopyright Notice\n\n   Copyright (c) 2012 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\n\n\n\nHardt                        Standards Track                    [Page 1]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nTable of Contents"
      },
      {
        "chunk_id": "rfc_oauth_chunk_1",
        "original_index": 1,
        "content": "Hardt                        Standards Track                    [Page 1]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nTable of Contents\n\n   1. Introduction ....................................................4\n      1.1. Roles ......................................................6\n      1.2. Protocol Flow ..............................................7\n      1.3. Authorization Grant ........................................8\n           1.3.1. Authorization Code ..................................8\n           1.3.2. Implicit ............................................8\n           1.3.3. Resource Owner Password Credentials .................9\n           1.3.4. Client Credentials ..................................9\n      1.4. Access Token ..............................................10\n      1.5. Refresh Token .............................................10\n      1.6. TLS Version ...............................................12\n      1.7. HTTP Redirections .........................................12\n      1.8. Interoperability ..........................................12\n      1.9. Notational Conventions ....................................13\n   2. Client Registration ............................................13\n      2.1. Client Types ..............................................14\n      2.2. Client Identifier .........................................15\n      2.3. Client Authentication .....................................16\n           2.3.1. Client Password ....................................16\n           2.3.2. Other Authentication Methods .......................17\n      2.4. Unregistered Clients ......................................17\n   3. Protocol Endpoints .............................................18\n      3.1. Authorization Endpoint ....................................18\n           3.1.1. Response Type ......................................19\n           3.1.2. Redirection Endpoint ...............................19\n      3.2. Token Endpoint ............................................21\n           3.2.1. Client Authentication ..............................22\n      3.3. Access Token Scope ........................................23\n   4. Obtaining Authorization ........................................23\n      4.1. Authorization Code Grant ..................................24\n           4.1.1. Authorization Request ..............................25\n           4.1.2. Authorization Response .............................26\n           4.1.3. Access Token Request ...............................29\n           4.1.4. Access Token Response ..............................30\n      4.2. Implicit Grant ............................................31\n           4.2.1. Authorization Request ..............................33\n           4.2.2. Access Token Response ..............................35\n      4.3. Resource Owner Password Credentials Grant .................37\n           4.3.1. Authorization Request and Response .................39\n           4.3.2. Access Token Request ...............................39\n           4.3.3. Access Token Response ..............................40\n      4.4. Client Credentials Grant ..................................40\n           4.4.1. Authorization Request and Response .................41\n           4.4.2. Access Token Request ...............................41\n           4.4.3. Access Token Response ..............................42\n      4.5. Extension Grants ..........................................42\n\n\n\nHardt                        Standards Track                    [Page 2]\n\f\nRFC 6749                        OAuth 2.0                   October 2012"
      },
      {
        "chunk_id": "rfc_oauth_chunk_2",
        "original_index": 2,
        "content": "Hardt                        Standards Track                    [Page 2]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   5. Issuing an Access Token ........................................43\n      5.1. Successful Response .......................................43\n      5.2. Error Response ............................................45\n   6. Refreshing an Access Token .....................................47\n   7. Accessing Protected Resources ..................................48\n      7.1. Access Token Types ........................................49\n      7.2. Error Response ............................................49\n   8. Extensibility ..................................................50\n      8.1. Defining Access Token Types ...............................50\n      8.2. Defining New Endpoint Parameters ..........................50\n      8.3. Defining New Authorization Grant Types ....................51\n      8.4. Defining New Authorization Endpoint Response Types ........51\n      8.5. Defining Additional Error Codes ...........................51\n   9. Native Applications ............................................52\n   10. Security Considerations .......................................53\n      10.1. Client Authentication ....................................53\n      10.2. Client Impersonation .....................................54\n      10.3. Access Tokens ............................................55\n      10.4. Refresh Tokens ...........................................55\n      10.5. Authorization Codes ......................................56\n      10.6. Authorization Code Redirection URI Manipulation ..........56\n      10.7. Resource Owner Password Credentials ......................57\n      10.8. Request Confidentiality ..................................58\n      10.9. Ensuring Endpoint Authenticity ...........................58\n      10.10. Credentials-Guessing Attacks ............................58\n      10.11. Phishing Attacks ........................................58\n      10.12. Cross-Site Request Forgery ..............................59\n      10.13. Clickjacking ............................................60\n      10.14. Code Injection and Input Validation .....................60\n      10.15. Open Redirectors ........................................60\n      10.16. Misuse of Access Token to Impersonate Resource\n             Owner in Implicit Flow ..................................61\n   11. IANA Considerations ...........................................62\n      11.1. OAuth Access Token Types Registry ........................62\n           11.1.1. Registration Template .............................62\n      11.2. OAuth Parameters Registry ................................63\n           11.2.1. Registration Template .............................63\n           11.2.2. Initial Registry Contents .........................64\n      11.3. OAuth Authorization Endpoint Response Types Registry .....66\n           11.3.1. Registration Template .............................66\n           11.3.2. Initial Registry Contents .........................67\n      11.4. OAuth Extensions Error Registry ..........................67\n           11.4.1. Registration Template .............................68\n   12. References ....................................................68\n      12.1. Normative References .....................................68\n      12.2. Informative References ...................................70\n\n\n\n\n\nHardt                        Standards Track                    [Page 3]\n\f\nRFC 6749                        OAuth 2.0                   October 2012"
      },
      {
        "chunk_id": "rfc_oauth_chunk_3",
        "original_index": 3,
        "content": "Hardt                        Standards Track                    [Page 3]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Appendix A. Augmented Backus-Naur Form (ABNF) Syntax ..............71\n     A.1.  \"client_id\" Syntax ........................................71\n     A.2.  \"client_secret\" Syntax ....................................71\n     A.3.  \"response_type\" Syntax ....................................71\n     A.4.  \"scope\" Syntax ............................................72\n     A.5.  \"state\" Syntax ............................................72\n     A.6.  \"redirect_uri\" Syntax .....................................72\n     A.7.  \"error\" Syntax ............................................72\n     A.8.  \"error_description\" Syntax ................................72\n     A.9.  \"error_uri\" Syntax ........................................72\n     A.10. \"grant_type\" Syntax .......................................73\n     A.11. \"code\" Syntax .............................................73\n     A.12. \"access_token\" Syntax .....................................73\n     A.13. \"token_type\" Syntax .......................................73\n     A.14. \"expires_in\" Syntax .......................................73\n     A.15. \"username\" Syntax .........................................73\n     A.16. \"password\" Syntax .........................................73\n     A.17. \"refresh_token\" Syntax ....................................74\n     A.18. Endpoint Parameter Syntax .................................74\n   Appendix B. Use of application/x-www-form-urlencoded Media Type ...74\n   Appendix C. Acknowledgements ......................................75\n\n1.  Introduction\n\n   In the traditional client-server authentication model, the client\n   requests an access-restricted resource (protected resource) on the\n   server by authenticating with the server using the resource owner's\n   credentials.  In order to provide third-party applications access to\n   restricted resources, the resource owner shares its credentials with\n   the third party.  This creates several problems and limitations:\n\n   o  Third-party applications are required to store the resource\n      owner's credentials for future use, typically a password in\n      clear-text.\n\n   o  Servers are required to support password authentication, despite\n      the security weaknesses inherent in passwords.\n\n   o  Third-party applications gain overly broad access to the resource\n      owner's protected resources, leaving resource owners without any\n      ability to restrict duration or access to a limited subset of\n      resources.\n\n   o  Resource owners cannot revoke access to an individual third party\n      without revoking access to all third parties, and must do so by\n      changing the third party's password.\n\n\n\n\n\nHardt                        Standards Track                    [Page 4]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   o  Compromise of any third-party application results in compromise of\n      the end-user's password and all of the data protected by that\n      password.\n\n   OAuth addresses these issues by introducing an authorization layer\n   and separating the role of the client from that of the resource\n   owner.  In OAuth, the client requests access to resources controlled\n   by the resource owner and hosted by the resource server, and is\n   issued a different set of credentials than those of the resource\n   owner.\n\n   Instead of using the resource owner's credentials to access protected\n   resources, the client obtains an access token -- a string denoting a\n   specific scope, lifetime, and other access attributes.  Access tokens\n   are issued to third-party clients by an authorization server with the\n   approval of the resource owner.  The client uses the access token to\n   access the protected resources hosted by the resource server."
      },
      {
        "chunk_id": "rfc_oauth_chunk_4",
        "original_index": 4,
        "content": "For example, an end-user (resource owner) can grant a printing\n   service (client) access to her protected photos stored at a photo-\n   sharing service (resource server), without sharing her username and\n   password with the printing service.  Instead, she authenticates\n   directly with a server trusted by the photo-sharing service\n   (authorization server), which issues the printing service delegation-\n   specific credentials (access token).\n\n   This specification is designed for use with HTTP ([RFC2616]).  The\n   use of OAuth over any protocol other than HTTP is out of scope.\n\n   The OAuth 1.0 protocol ([RFC5849]), published as an informational\n   document, was the result of a small ad hoc community effort.  This\n   Standards Track specification builds on the OAuth 1.0 deployment\n   experience, as well as additional use cases and extensibility\n   requirements gathered from the wider IETF community.  The OAuth 2.0\n   protocol is not backward compatible with OAuth 1.0.  The two versions\n   may co-exist on the network, and implementations may choose to\n   support both.  However, it is the intention of this specification\n   that new implementations support OAuth 2.0 as specified in this\n   document and that OAuth 1.0 is used only to support existing\n   deployments.  The OAuth 2.0 protocol shares very few implementation\n   details with the OAuth 1.0 protocol.  Implementers familiar with\n   OAuth 1.0 should approach this document without any assumptions as to\n   its structure and details.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 5]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.1.  Roles\n\n   OAuth defines four roles:\n\n   resource owner\n      An entity capable of granting access to a protected resource.\n      When the resource owner is a person, it is referred to as an\n      end-user.\n\n   resource server\n      The server hosting the protected resources, capable of accepting\n      and responding to protected resource requests using access tokens.\n\n   client\n      An application making protected resource requests on behalf of the\n      resource owner and with its authorization.  The term \"client\" does\n      not imply any particular implementation characteristics (e.g.,\n      whether the application executes on a server, a desktop, or other\n      devices).\n\n   authorization server\n      The server issuing access tokens to the client after successfully\n      authenticating the resource owner and obtaining authorization.\n\n   The interaction between the authorization server and resource server\n   is beyond the scope of this specification.  The authorization server\n   may be the same server as the resource server or a separate entity.\n   A single authorization server may issue access tokens accepted by\n   multiple resource servers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 6]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.2.  Protocol Flow"
      },
      {
        "chunk_id": "rfc_oauth_chunk_5",
        "original_index": 5,
        "content": "Hardt                        Standards Track                    [Page 6]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.2.  Protocol Flow\n\n     +--------+                               +---------------+\n     |        |--(A)- Authorization Request ->|   Resource    |\n     |        |                               |     Owner     |\n     |        |<-(B)-- Authorization Grant ---|               |\n     |        |                               +---------------+\n     |        |\n     |        |                               +---------------+\n     |        |--(C)-- Authorization Grant -->| Authorization |\n     | Client |                               |     Server    |\n     |        |<-(D)----- Access Token -------|               |\n     |        |                               +---------------+\n     |        |\n     |        |                               +---------------+\n     |        |--(E)----- Access Token ------>|    Resource   |\n     |        |                               |     Server    |\n     |        |<-(F)--- Protected Resource ---|               |\n     +--------+                               +---------------+\n\n                     Figure 1: Abstract Protocol Flow\n\n   The abstract OAuth 2.0 flow illustrated in Figure 1 describes the\n   interaction between the four roles and includes the following steps:\n\n   (A)  The client requests authorization from the resource owner.  The\n        authorization request can be made directly to the resource owner\n        (as shown), or preferably indirectly via the authorization\n        server as an intermediary.\n\n   (B)  The client receives an authorization grant, which is a\n        credential representing the resource owner's authorization,\n        expressed using one of four grant types defined in this\n        specification or using an extension grant type.  The\n        authorization grant type depends on the method used by the\n        client to request authorization and the types supported by the\n        authorization server.\n\n   (C)  The client requests an access token by authenticating with the\n        authorization server and presenting the authorization grant.\n\n   (D)  The authorization server authenticates the client and validates\n        the authorization grant, and if valid, issues an access token.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 7]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (E)  The client requests the protected resource from the resource\n        server and authenticates by presenting the access token.\n\n   (F)  The resource server validates the access token, and if valid,\n        serves the request.\n\n   The preferred method for the client to obtain an authorization grant\n   from the resource owner (depicted in steps (A) and (B)) is to use the\n   authorization server as an intermediary, which is illustrated in\n   Figure 3 in Section 4.1.\n\n1.3.  Authorization Grant\n\n   An authorization grant is a credential representing the resource\n   owner's authorization (to access its protected resources) used by the\n   client to obtain an access token.  This specification defines four\n   grant types -- authorization code, implicit, resource owner password\n   credentials, and client credentials -- as well as an extensibility\n   mechanism for defining additional types.\n\n1.3.1.  Authorization Code\n\n   The authorization code is obtained by using an authorization server\n   as an intermediary between the client and resource owner.  Instead of\n   requesting authorization directly from the resource owner, the client\n   directs the resource owner to an authorization server (via its\n   user-agent as defined in [RFC2616]), which in turn directs the\n   resource owner back to the client with the authorization code."
      },
      {
        "chunk_id": "rfc_oauth_chunk_6",
        "original_index": 6,
        "content": "Before directing the resource owner back to the client with the\n   authorization code, the authorization server authenticates the\n   resource owner and obtains authorization.  Because the resource owner\n   only authenticates with the authorization server, the resource\n   owner's credentials are never shared with the client.\n\n   The authorization code provides a few important security benefits,\n   such as the ability to authenticate the client, as well as the\n   transmission of the access token directly to the client without\n   passing it through the resource owner's user-agent and potentially\n   exposing it to others, including the resource owner.\n\n1.3.2.  Implicit\n\n   The implicit grant is a simplified authorization code flow optimized\n   for clients implemented in a browser using a scripting language such\n   as JavaScript.  In the implicit flow, instead of issuing the client\n   an authorization code, the client is issued an access token directly\n\n\n\n\nHardt                        Standards Track                    [Page 8]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (as the result of the resource owner authorization).  The grant type\n   is implicit, as no intermediate credentials (such as an authorization\n   code) are issued (and later used to obtain an access token).\n\n   When issuing an access token during the implicit grant flow, the\n   authorization server does not authenticate the client.  In some\n   cases, the client identity can be verified via the redirection URI\n   used to deliver the access token to the client.  The access token may\n   be exposed to the resource owner or other applications with access to\n   the resource owner's user-agent.\n\n   Implicit grants improve the responsiveness and efficiency of some\n   clients (such as a client implemented as an in-browser application),\n   since it reduces the number of round trips required to obtain an\n   access token.  However, this convenience should be weighed against\n   the security implications of using implicit grants, such as those\n   described in Sections 10.3 and 10.16, especially when the\n   authorization code grant type is available.\n\n1.3.3.  Resource Owner Password Credentials\n\n   The resource owner password credentials (i.e., username and password)\n   can be used directly as an authorization grant to obtain an access\n   token.  The credentials should only be used when there is a high\n   degree of trust between the resource owner and the client (e.g., the\n   client is part of the device operating system or a highly privileged\n   application), and when other authorization grant types are not\n   available (such as an authorization code).\n\n   Even though this grant type requires direct client access to the\n   resource owner credentials, the resource owner credentials are used\n   for a single request and are exchanged for an access token.  This\n   grant type can eliminate the need for the client to store the\n   resource owner credentials for future use, by exchanging the\n   credentials with a long-lived access token or refresh token.\n\n1.3.4.  Client Credentials\n\n   The client credentials (or other forms of client authentication) can\n   be used as an authorization grant when the authorization scope is\n   limited to the protected resources under the control of the client,\n   or to protected resources previously arranged with the authorization\n   server.  Client credentials are used as an authorization grant\n   typically when the client is acting on its own behalf (the client is\n   also the resource owner) or is requesting access to protected\n   resources based on an authorization previously arranged with the\n   authorization server.\n\n\n\n\nHardt                        Standards Track                    [Page 9]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.4.  Access Token"
      },
      {
        "chunk_id": "rfc_oauth_chunk_7",
        "original_index": 7,
        "content": "Hardt                        Standards Track                    [Page 9]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.4.  Access Token\n\n   Access tokens are credentials used to access protected resources.  An\n   access token is a string representing an authorization issued to the\n   client.  The string is usually opaque to the client.  Tokens\n   represent specific scopes and durations of access, granted by the\n   resource owner, and enforced by the resource server and authorization\n   server.\n\n   The token may denote an identifier used to retrieve the authorization\n   information or may self-contain the authorization information in a\n   verifiable manner (i.e., a token string consisting of some data and a\n   signature).  Additional authentication credentials, which are beyond\n   the scope of this specification, may be required in order for the\n   client to use a token.\n\n   The access token provides an abstraction layer, replacing different\n   authorization constructs (e.g., username and password) with a single\n   token understood by the resource server.  This abstraction enables\n   issuing access tokens more restrictive than the authorization grant\n   used to obtain them, as well as removing the resource server's need\n   to understand a wide range of authentication methods.\n\n   Access tokens can have different formats, structures, and methods of\n   utilization (e.g., cryptographic properties) based on the resource\n   server security requirements.  Access token attributes and the\n   methods used to access protected resources are beyond the scope of\n   this specification and are defined by companion specifications such\n   as [RFC6750].\n\n1.5.  Refresh Token\n\n   Refresh tokens are credentials used to obtain access tokens.  Refresh\n   tokens are issued to the client by the authorization server and are\n   used to obtain a new access token when the current access token\n   becomes invalid or expires, or to obtain additional access tokens\n   with identical or narrower scope (access tokens may have a shorter\n   lifetime and fewer permissions than authorized by the resource\n   owner).  Issuing a refresh token is optional at the discretion of the\n   authorization server.  If the authorization server issues a refresh\n   token, it is included when issuing an access token (i.e., step (D) in\n   Figure 1).\n\n   A refresh token is a string representing the authorization granted to\n   the client by the resource owner.  The string is usually opaque to\n   the client.  The token denotes an identifier used to retrieve the\n\n\n\n\n\nHardt                        Standards Track                   [Page 10]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   authorization information.  Unlike access tokens, refresh tokens are\n   intended for use only with authorization servers and are never sent\n   to resource servers."
      },
      {
        "chunk_id": "rfc_oauth_chunk_8",
        "original_index": 8,
        "content": "authorization information.  Unlike access tokens, refresh tokens are\n   intended for use only with authorization servers and are never sent\n   to resource servers.\n\n  +--------+                                           +---------------+\n  |        |--(A)------- Authorization Grant --------->|               |\n  |        |                                           |               |\n  |        |<-(B)----------- Access Token -------------|               |\n  |        |               & Refresh Token             |               |\n  |        |                                           |               |\n  |        |                            +----------+   |               |\n  |        |--(C)---- Access Token ---->|          |   |               |\n  |        |                            |          |   |               |\n  |        |<-(D)- Protected Resource --| Resource |   | Authorization |\n  | Client |                            |  Server  |   |     Server    |\n  |        |--(E)---- Access Token ---->|          |   |               |\n  |        |                            |          |   |               |\n  |        |<-(F)- Invalid Token Error -|          |   |               |\n  |        |                            +----------+   |               |\n  |        |                                           |               |\n  |        |--(G)----------- Refresh Token ----------->|               |\n  |        |                                           |               |\n  |        |<-(H)----------- Access Token -------------|               |\n  +--------+           & Optional Refresh Token        +---------------+\n\n               Figure 2: Refreshing an Expired Access Token\n\n   The flow illustrated in Figure 2 includes the following steps:\n\n   (A)  The client requests an access token by authenticating with the\n        authorization server and presenting an authorization grant.\n\n   (B)  The authorization server authenticates the client and validates\n        the authorization grant, and if valid, issues an access token\n        and a refresh token.\n\n   (C)  The client makes a protected resource request to the resource\n        server by presenting the access token.\n\n   (D)  The resource server validates the access token, and if valid,\n        serves the request.\n\n   (E)  Steps (C) and (D) repeat until the access token expires.  If the\n        client knows the access token expired, it skips to step (G);\n        otherwise, it makes another protected resource request.\n\n   (F)  Since the access token is invalid, the resource server returns\n        an invalid token error.\n\n\n\nHardt                        Standards Track                   [Page 11]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (G)  The client requests a new access token by authenticating with\n        the authorization server and presenting the refresh token.  The\n        client authentication requirements are based on the client type\n        and on the authorization server policies.\n\n   (H)  The authorization server authenticates the client and validates\n        the refresh token, and if valid, issues a new access token (and,\n        optionally, a new refresh token).\n\n   Steps (C), (D), (E), and (F) are outside the scope of this\n   specification, as described in Section 7.\n\n1.6.  TLS Version\n\n   Whenever Transport Layer Security (TLS) is used by this\n   specification, the appropriate version (or versions) of TLS will vary\n   over time, based on the widespread deployment and known security\n   vulnerabilities.  At the time of this writing, TLS version 1.2\n   [RFC5246] is the most recent version, but has a very limited\n   deployment base and might not be readily available for\n   implementation.  TLS version 1.0 [RFC2246] is the most widely\n   deployed version and will provide the broadest interoperability.\n\n   Implementations MAY also support additional transport-layer security\n   mechanisms that meet their security requirements."
      },
      {
        "chunk_id": "rfc_oauth_chunk_9",
        "original_index": 9,
        "content": "Implementations MAY also support additional transport-layer security\n   mechanisms that meet their security requirements.\n\n1.7.  HTTP Redirections\n\n   This specification makes extensive use of HTTP redirections, in which\n   the client or the authorization server directs the resource owner's\n   user-agent to another destination.  While the examples in this\n   specification show the use of the HTTP 302 status code, any other\n   method available via the user-agent to accomplish this redirection is\n   allowed and is considered to be an implementation detail.\n\n1.8.  Interoperability\n\n   OAuth 2.0 provides a rich authorization framework with well-defined\n   security properties.  However, as a rich and highly extensible\n   framework with many optional components, on its own, this\n   specification is likely to produce a wide range of non-interoperable\n   implementations.\n\n   In addition, this specification leaves a few required components\n   partially or fully undefined (e.g., client registration,\n   authorization server capabilities, endpoint discovery).  Without\n\n\n\n\n\nHardt                        Standards Track                   [Page 12]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   these components, clients must be manually and specifically\n   configured against a specific authorization server and resource\n   server in order to interoperate.\n\n   This framework was designed with the clear expectation that future\n   work will define prescriptive profiles and extensions necessary to\n   achieve full web-scale interoperability.\n\n1.9.  Notational Conventions\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   specification are to be interpreted as described in [RFC2119].\n\n   This specification uses the Augmented Backus-Naur Form (ABNF)\n   notation of [RFC5234].  Additionally, the rule URI-reference is\n   included from \"Uniform Resource Identifier (URI): Generic Syntax\"\n   [RFC3986].\n\n   Certain security-related terms are to be understood in the sense\n   defined in [RFC4949].  These terms include, but are not limited to,\n   \"attack\", \"authentication\", \"authorization\", \"certificate\",\n   \"confidentiality\", \"credential\", \"encryption\", \"identity\", \"sign\",\n   \"signature\", \"trust\", \"validate\", and \"verify\".\n\n   Unless otherwise noted, all the protocol parameter names and values\n   are case sensitive.\n\n2.  Client Registration\n\n   Before initiating the protocol, the client registers with the\n   authorization server.  The means through which the client registers\n   with the authorization server are beyond the scope of this\n   specification but typically involve end-user interaction with an HTML\n   registration form.\n\n   Client registration does not require a direct interaction between the\n   client and the authorization server.  When supported by the\n   authorization server, registration can rely on other means for\n   establishing trust and obtaining the required client properties\n   (e.g., redirection URI, client type).  For example, registration can\n   be accomplished using a self-issued or third-party-issued assertion,\n   or by the authorization server performing client discovery using a\n   trusted channel.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 13]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   When registering a client, the client developer SHALL:\n\n   o  specify the client type as described in Section 2.1,\n\n   o  provide its client redirection URIs as described in Section 3.1.2,\n      and\n\n   o  include any other information required by the authorization server\n      (e.g., application name, website, description, logo image, the\n      acceptance of legal terms).\n\n2.1.  Client Types"
      },
      {
        "chunk_id": "rfc_oauth_chunk_10",
        "original_index": 10,
        "content": "o  include any other information required by the authorization server\n      (e.g., application name, website, description, logo image, the\n      acceptance of legal terms).\n\n2.1.  Client Types\n\n   OAuth defines two client types, based on their ability to\n   authenticate securely with the authorization server (i.e., ability to\n   maintain the confidentiality of their client credentials):\n\n   confidential\n      Clients capable of maintaining the confidentiality of their\n      credentials (e.g., client implemented on a secure server with\n      restricted access to the client credentials), or capable of secure\n      client authentication using other means.\n\n   public\n      Clients incapable of maintaining the confidentiality of their\n      credentials (e.g., clients executing on the device used by the\n      resource owner, such as an installed native application or a web\n      browser-based application), and incapable of secure client\n      authentication via any other means.\n\n   The client type designation is based on the authorization server's\n   definition of secure authentication and its acceptable exposure\n   levels of client credentials.  The authorization server SHOULD NOT\n   make assumptions about the client type.\n\n   A client may be implemented as a distributed set of components, each\n   with a different client type and security context (e.g., a\n   distributed client with both a confidential server-based component\n   and a public browser-based component).  If the authorization server\n   does not provide support for such clients or does not provide\n   guidance with regard to their registration, the client SHOULD\n   register each component as a separate client.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 14]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   This specification has been designed around the following client\n   profiles:\n\n   web application\n      A web application is a confidential client running on a web\n      server.  Resource owners access the client via an HTML user\n      interface rendered in a user-agent on the device used by the\n      resource owner.  The client credentials as well as any access\n      token issued to the client are stored on the web server and are\n      not exposed to or accessible by the resource owner.\n\n   user-agent-based application\n      A user-agent-based application is a public client in which the\n      client code is downloaded from a web server and executes within a\n      user-agent (e.g., web browser) on the device used by the resource\n      owner.  Protocol data and credentials are easily accessible (and\n      often visible) to the resource owner.  Since such applications\n      reside within the user-agent, they can make seamless use of the\n      user-agent capabilities when requesting authorization.\n\n   native application\n      A native application is a public client installed and executed on\n      the device used by the resource owner.  Protocol data and\n      credentials are accessible to the resource owner.  It is assumed\n      that any client authentication credentials included in the\n      application can be extracted.  On the other hand, dynamically\n      issued credentials such as access tokens or refresh tokens can\n      receive an acceptable level of protection.  At a minimum, these\n      credentials are protected from hostile servers with which the\n      application may interact.  On some platforms, these credentials\n      might be protected from other applications residing on the same\n      device.\n\n2.2.  Client Identifier\n\n   The authorization server issues the registered client a client\n   identifier -- a unique string representing the registration\n   information provided by the client.  The client identifier is not a\n   secret; it is exposed to the resource owner and MUST NOT be used\n   alone for client authentication.  The client identifier is unique to\n   the authorization server."
      },
      {
        "chunk_id": "rfc_oauth_chunk_11",
        "original_index": 11,
        "content": "The client identifier string size is left undefined by this\n   specification.  The client should avoid making assumptions about the\n   identifier size.  The authorization server SHOULD document the size\n   of any identifier it issues.\n\n\n\n\n\nHardt                        Standards Track                   [Page 15]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n2.3.  Client Authentication\n\n   If the client type is confidential, the client and authorization\n   server establish a client authentication method suitable for the\n   security requirements of the authorization server.  The authorization\n   server MAY accept any form of client authentication meeting its\n   security requirements.\n\n   Confidential clients are typically issued (or establish) a set of\n   client credentials used for authenticating with the authorization\n   server (e.g., password, public/private key pair).\n\n   The authorization server MAY establish a client authentication method\n   with public clients.  However, the authorization server MUST NOT rely\n   on public client authentication for the purpose of identifying the\n   client.\n\n   The client MUST NOT use more than one authentication method in each\n   request.\n\n2.3.1.  Client Password\n\n   Clients in possession of a client password MAY use the HTTP Basic\n   authentication scheme as defined in [RFC2617] to authenticate with\n   the authorization server.  The client identifier is encoded using the\n   \"application/x-www-form-urlencoded\" encoding algorithm per\n   Appendix B, and the encoded value is used as the username; the client\n   password is encoded using the same algorithm and used as the\n   password.  The authorization server MUST support the HTTP Basic\n   authentication scheme for authenticating clients that were issued a\n   client password.\n\n   For example (with extra line breaks for display purposes only):\n\n     Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n\n   Alternatively, the authorization server MAY support including the\n   client credentials in the request-body using the following\n   parameters:\n\n   client_id\n         REQUIRED.  The client identifier issued to the client during\n         the registration process described by Section 2.2.\n\n   client_secret\n         REQUIRED.  The client secret.  The client MAY omit the\n         parameter if the client secret is an empty string.\n\n\n\n\nHardt                        Standards Track                   [Page 16]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Including the client credentials in the request-body using the two\n   parameters is NOT RECOMMENDED and SHOULD be limited to clients unable\n   to directly utilize the HTTP Basic authentication scheme (or other\n   password-based HTTP authentication schemes).  The parameters can only\n   be transmitted in the request-body and MUST NOT be included in the\n   request URI.\n\n   For example, a request to refresh an access token (Section 6) using\n   the body parameters (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n     &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n\n   The authorization server MUST require the use of TLS as described in\n   Section 1.6 when sending requests using password authentication.\n\n   Since this client authentication method involves a password, the\n   authorization server MUST protect any endpoint utilizing it against\n   brute force attacks.\n\n2.3.2.  Other Authentication Methods\n\n   The authorization server MAY support any suitable HTTP authentication\n   scheme matching its security requirements.  When using other\n   authentication methods, the authorization server MUST define a\n   mapping between the client identifier (registration record) and\n   authentication scheme.\n\n2.4.  Unregistered Clients"
      },
      {
        "chunk_id": "rfc_oauth_chunk_12",
        "original_index": 12,
        "content": "2.4.  Unregistered Clients\n\n   This specification does not exclude the use of unregistered clients.\n   However, the use of such clients is beyond the scope of this\n   specification and requires additional security analysis and review of\n   its interoperability impact.\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 17]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.  Protocol Endpoints\n\n   The authorization process utilizes two authorization server endpoints\n   (HTTP resources):\n\n   o  Authorization endpoint - used by the client to obtain\n      authorization from the resource owner via user-agent redirection.\n\n   o  Token endpoint - used by the client to exchange an authorization\n      grant for an access token, typically with client authentication.\n\n   As well as one client endpoint:\n\n   o  Redirection endpoint - used by the authorization server to return\n      responses containing authorization credentials to the client via\n      the resource owner user-agent.\n\n   Not every authorization grant type utilizes both endpoints.\n   Extension grant types MAY define additional endpoints as needed.\n\n3.1.  Authorization Endpoint\n\n   The authorization endpoint is used to interact with the resource\n   owner and obtain an authorization grant.  The authorization server\n   MUST first verify the identity of the resource owner.  The way in\n   which the authorization server authenticates the resource owner\n   (e.g., username and password login, session cookies) is beyond the\n   scope of this specification.\n\n   The means through which the client obtains the location of the\n   authorization endpoint are beyond the scope of this specification,\n   but the location is typically provided in the service documentation.\n\n   The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n   formatted (per Appendix B) query component ([RFC3986] Section 3.4),\n   which MUST be retained when adding additional query parameters.  The\n   endpoint URI MUST NOT include a fragment component.\n\n   Since requests to the authorization endpoint result in user\n   authentication and the transmission of clear-text credentials (in the\n   HTTP response), the authorization server MUST require the use of TLS\n   as described in Section 1.6 when sending requests to the\n   authorization endpoint.\n\n   The authorization server MUST support the use of the HTTP \"GET\"\n   method [RFC2616] for the authorization endpoint and MAY support the\n   use of the \"POST\" method as well.\n\n\n\n\nHardt                        Standards Track                   [Page 18]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Parameters sent without a value MUST be treated as if they were\n   omitted from the request.  The authorization server MUST ignore\n   unrecognized request parameters.  Request and response parameters\n   MUST NOT be included more than once.\n\n3.1.1.  Response Type\n\n   The authorization endpoint is used by the authorization code grant\n   type and implicit grant type flows.  The client informs the\n   authorization server of the desired grant type using the following\n   parameter:\n\n   response_type\n         REQUIRED.  The value MUST be one of \"code\" for requesting an\n         authorization code as described by Section 4.1.1, \"token\" for\n         requesting an access token (implicit grant) as described by\n         Section 4.2.1, or a registered extension value as described by\n         Section 8.4.\n\n   Extension response types MAY contain a space-delimited (%x20) list of\n   values, where the order of values does not matter (e.g., response\n   type \"a b\" is the same as \"b a\").  The meaning of such composite\n   response types is defined by their respective specifications.\n\n   If an authorization request is missing the \"response_type\" parameter,\n   or if the response type is not understood, the authorization server\n   MUST return an error response as described in Section 4.1.2.1."
      },
      {
        "chunk_id": "rfc_oauth_chunk_13",
        "original_index": 13,
        "content": "3.1.2.  Redirection Endpoint\n\n   After completing its interaction with the resource owner, the\n   authorization server directs the resource owner's user-agent back to\n   the client.  The authorization server redirects the user-agent to the\n   client's redirection endpoint previously established with the\n   authorization server during the client registration process or when\n   making the authorization request.\n\n   The redirection endpoint URI MUST be an absolute URI as defined by\n   [RFC3986] Section 4.3.  The endpoint URI MAY include an\n   \"application/x-www-form-urlencoded\" formatted (per Appendix B) query\n   component ([RFC3986] Section 3.4), which MUST be retained when adding\n   additional query parameters.  The endpoint URI MUST NOT include a\n   fragment component.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 19]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.1.2.1.  Endpoint Request Confidentiality\n\n   The redirection endpoint SHOULD require the use of TLS as described\n   in Section 1.6 when the requested response type is \"code\" or \"token\",\n   or when the redirection request will result in the transmission of\n   sensitive credentials over an open network.  This specification does\n   not mandate the use of TLS because at the time of this writing,\n   requiring clients to deploy TLS is a significant hurdle for many\n   client developers.  If TLS is not available, the authorization server\n   SHOULD warn the resource owner about the insecure endpoint prior to\n   redirection (e.g., display a message during the authorization\n   request).\n\n   Lack of transport-layer security can have a severe impact on the\n   security of the client and the protected resources it is authorized\n   to access.  The use of transport-layer security is particularly\n   critical when the authorization process is used as a form of\n   delegated end-user authentication by the client (e.g., third-party\n   sign-in service).\n\n3.1.2.2.  Registration Requirements\n\n   The authorization server MUST require the following clients to\n   register their redirection endpoint:\n\n   o  Public clients.\n\n   o  Confidential clients utilizing the implicit grant type.\n\n   The authorization server SHOULD require all clients to register their\n   redirection endpoint prior to utilizing the authorization endpoint.\n\n   The authorization server SHOULD require the client to provide the\n   complete redirection URI (the client MAY use the \"state\" request\n   parameter to achieve per-request customization).  If requiring the\n   registration of the complete redirection URI is not possible, the\n   authorization server SHOULD require the registration of the URI\n   scheme, authority, and path (allowing the client to dynamically vary\n   only the query component of the redirection URI when requesting\n   authorization).\n\n   The authorization server MAY allow the client to register multiple\n   redirection endpoints.\n\n   Lack of a redirection URI registration requirement can enable an\n   attacker to use the authorization endpoint as an open redirector as\n   described in Section 10.15.\n\n\n\n\nHardt                        Standards Track                   [Page 20]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.1.2.3.  Dynamic Configuration\n\n   If multiple redirection URIs have been registered, if only part of\n   the redirection URI has been registered, or if no redirection URI has\n   been registered, the client MUST include a redirection URI with the\n   authorization request using the \"redirect_uri\" request parameter."
      },
      {
        "chunk_id": "rfc_oauth_chunk_14",
        "original_index": 14,
        "content": "When a redirection URI is included in an authorization request, the\n   authorization server MUST compare and match the value received\n   against at least one of the registered redirection URIs (or URI\n   components) as defined in [RFC3986] Section 6, if any redirection\n   URIs were registered.  If the client registration included the full\n   redirection URI, the authorization server MUST compare the two URIs\n   using simple string comparison as defined in [RFC3986] Section 6.2.1.\n\n3.1.2.4.  Invalid Endpoint\n\n   If an authorization request fails validation due to a missing,\n   invalid, or mismatching redirection URI, the authorization server\n   SHOULD inform the resource owner of the error and MUST NOT\n   automatically redirect the user-agent to the invalid redirection URI.\n\n3.1.2.5.  Endpoint Content\n\n   The redirection request to the client's endpoint typically results in\n   an HTML document response, processed by the user-agent.  If the HTML\n   response is served directly as the result of the redirection request,\n   any script included in the HTML document will execute with full\n   access to the redirection URI and the credentials it contains.\n\n   The client SHOULD NOT include any third-party scripts (e.g., third-\n   party analytics, social plug-ins, ad networks) in the redirection\n   endpoint response.  Instead, it SHOULD extract the credentials from\n   the URI and redirect the user-agent again to another endpoint without\n   exposing the credentials (in the URI or elsewhere).  If third-party\n   scripts are included, the client MUST ensure that its own scripts\n   (used to extract and remove the credentials from the URI) will\n   execute first.\n\n3.2.  Token Endpoint\n\n   The token endpoint is used by the client to obtain an access token by\n   presenting its authorization grant or refresh token.  The token\n   endpoint is used with every authorization grant except for the\n   implicit grant type (since an access token is issued directly).\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 21]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The means through which the client obtains the location of the token\n   endpoint are beyond the scope of this specification, but the location\n   is typically provided in the service documentation.\n\n   The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n   formatted (per Appendix B) query component ([RFC3986] Section 3.4),\n   which MUST be retained when adding additional query parameters.  The\n   endpoint URI MUST NOT include a fragment component.\n\n   Since requests to the token endpoint result in the transmission of\n   clear-text credentials (in the HTTP request and response), the\n   authorization server MUST require the use of TLS as described in\n   Section 1.6 when sending requests to the token endpoint.\n\n   The client MUST use the HTTP \"POST\" method when making access token\n   requests.\n\n   Parameters sent without a value MUST be treated as if they were\n   omitted from the request.  The authorization server MUST ignore\n   unrecognized request parameters.  Request and response parameters\n   MUST NOT be included more than once.\n\n3.2.1.  Client Authentication\n\n   Confidential clients or other clients issued client credentials MUST\n   authenticate with the authorization server as described in\n   Section 2.3 when making requests to the token endpoint.  Client\n   authentication is used for:\n\n   o  Enforcing the binding of refresh tokens and authorization codes to\n      the client they were issued to.  Client authentication is critical\n      when an authorization code is transmitted to the redirection\n      endpoint over an insecure channel or when the redirection URI has\n      not been registered in full."
      },
      {
        "chunk_id": "rfc_oauth_chunk_15",
        "original_index": 15,
        "content": "o  Recovering from a compromised client by disabling the client or\n      changing its credentials, thus preventing an attacker from abusing\n      stolen refresh tokens.  Changing a single set of client\n      credentials is significantly faster than revoking an entire set of\n      refresh tokens.\n\n   o  Implementing authentication management best practices, which\n      require periodic credential rotation.  Rotation of an entire set\n      of refresh tokens can be challenging, while rotation of a single\n      set of client credentials is significantly easier.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 22]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   A client MAY use the \"client_id\" request parameter to identify itself\n   when sending requests to the token endpoint.  In the\n   \"authorization_code\" \"grant_type\" request to the token endpoint, an\n   unauthenticated client MUST send its \"client_id\" to prevent itself\n   from inadvertently accepting a code intended for a client with a\n   different \"client_id\".  This protects the client from substitution of\n   the authentication code.  (It provides no additional security for the\n   protected resource.)\n\n3.3.  Access Token Scope\n\n   The authorization and token endpoints allow the client to specify the\n   scope of the access request using the \"scope\" request parameter.  In\n   turn, the authorization server uses the \"scope\" response parameter to\n   inform the client of the scope of the access token issued.\n\n   The value of the scope parameter is expressed as a list of space-\n   delimited, case-sensitive strings.  The strings are defined by the\n   authorization server.  If the value contains multiple space-delimited\n   strings, their order does not matter, and each string adds an\n   additional access range to the requested scope.\n\n     scope       = scope-token *( SP scope-token )\n     scope-token = 1*( %x21 / %x23-5B / %x5D-7E )\n\n   The authorization server MAY fully or partially ignore the scope\n   requested by the client, based on the authorization server policy or\n   the resource owner's instructions.  If the issued access token scope\n   is different from the one requested by the client, the authorization\n   server MUST include the \"scope\" response parameter to inform the\n   client of the actual scope granted.\n\n   If the client omits the scope parameter when requesting\n   authorization, the authorization server MUST either process the\n   request using a pre-defined default value or fail the request\n   indicating an invalid scope.  The authorization server SHOULD\n   document its scope requirements and default value (if defined).\n\n4.  Obtaining Authorization\n\n   To request an access token, the client obtains authorization from the\n   resource owner.  The authorization is expressed in the form of an\n   authorization grant, which the client uses to request the access\n   token.  OAuth defines four grant types: authorization code, implicit,\n   resource owner password credentials, and client credentials.  It also\n   provides an extension mechanism for defining additional grant types.\n\n\n\n\n\nHardt                        Standards Track                   [Page 23]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.1.  Authorization Code Grant\n\n   The authorization code grant type is used to obtain both access\n   tokens and refresh tokens and is optimized for confidential clients.\n   Since this is a redirection-based flow, the client must be capable of\n   interacting with the resource owner's user-agent (typically a web\n   browser) and capable of receiving incoming requests (via redirection)\n   from the authorization server."
      },
      {
        "chunk_id": "rfc_oauth_chunk_16",
        "original_index": 16,
        "content": "+----------+\n     | Resource |\n     |   Owner  |\n     |          |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier      +---------------+\n     |         -+----(A)-- & Redirection URI ---->|               |\n     |  User-   |                                 | Authorization |\n     |  Agent  -+----(B)-- User authenticates --->|     Server    |\n     |          |                                 |               |\n     |         -+----(C)-- Authorization Code ---<|               |\n     +-|----|---+                                 +---------------+\n       |    |                                         ^      v\n      (A)  (C)                                        |      |\n       |    |                                         |      |\n       ^    v                                         |      |\n     +---------+                                      |      |\n     |         |>---(D)-- Authorization Code ---------'      |\n     |  Client |          & Redirection URI                  |\n     |         |                                             |\n     |         |<---(E)----- Access Token -------------------'\n     +---------+       (w/ Optional Refresh Token)\n\n   Note: The lines illustrating steps (A), (B), and (C) are broken into\n   two parts as they pass through the user-agent.\n\n                     Figure 3: Authorization Code Flow\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 24]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The flow illustrated in Figure 3 includes the following steps:\n\n   (A)  The client initiates the flow by directing the resource owner's\n        user-agent to the authorization endpoint.  The client includes\n        its client identifier, requested scope, local state, and a\n        redirection URI to which the authorization server will send the\n        user-agent back once access is granted (or denied).\n\n   (B)  The authorization server authenticates the resource owner (via\n        the user-agent) and establishes whether the resource owner\n        grants or denies the client's access request.\n\n   (C)  Assuming the resource owner grants access, the authorization\n        server redirects the user-agent back to the client using the\n        redirection URI provided earlier (in the request or during\n        client registration).  The redirection URI includes an\n        authorization code and any local state provided by the client\n        earlier.\n\n   (D)  The client requests an access token from the authorization\n        server's token endpoint by including the authorization code\n        received in the previous step.  When making the request, the\n        client authenticates with the authorization server.  The client\n        includes the redirection URI used to obtain the authorization\n        code for verification.\n\n   (E)  The authorization server authenticates the client, validates the\n        authorization code, and ensures that the redirection URI\n        received matches the URI used to redirect the client in\n        step (C).  If valid, the authorization server responds back with\n        an access token and, optionally, a refresh token.\n\n4.1.1.  Authorization Request\n\n   The client constructs the request URI by adding the following\n   parameters to the query component of the authorization endpoint URI\n   using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   response_type\n         REQUIRED.  Value MUST be set to \"code\".\n\n   client_id\n         REQUIRED.  The client identifier as described in Section 2.2.\n\n   redirect_uri\n         OPTIONAL.  As described in Section 3.1.2.\n\n\n\n\n\nHardt                        Standards Track                   [Page 25]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3."
      },
      {
        "chunk_id": "rfc_oauth_chunk_17",
        "original_index": 17,
        "content": "scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   state\n         RECOMMENDED.  An opaque value used by the client to maintain\n         state between the request and callback.  The authorization\n         server includes this value when redirecting the user-agent back\n         to the client.  The parameter SHOULD be used for preventing\n         cross-site request forgery as described in Section 10.12.\n\n   The client directs the resource owner to the constructed URI using an\n   HTTP redirection response, or by other means available to it via the\n   user-agent.\n\n   For example, the client directs the user-agent to make the following\n   HTTP request using TLS (with extra line breaks for display purposes\n   only):\n\n    GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n    Host: server.example.com\n\n   The authorization server validates the request to ensure that all\n   required parameters are present and valid.  If the request is valid,\n   the authorization server authenticates the resource owner and obtains\n   an authorization decision (by asking the resource owner or by\n   establishing approval via other means).\n\n   When a decision is established, the authorization server directs the\n   user-agent to the provided client redirection URI using an HTTP\n   redirection response, or by other means available to it via the\n   user-agent.\n\n4.1.2.  Authorization Response\n\n   If the resource owner grants the access request, the authorization\n   server issues an authorization code and delivers it to the client by\n   adding the following parameters to the query component of the\n   redirection URI using the \"application/x-www-form-urlencoded\" format,\n   per Appendix B:\n\n   code\n         REQUIRED.  The authorization code generated by the\n         authorization server.  The authorization code MUST expire\n         shortly after it is issued to mitigate the risk of leaks.  A\n         maximum authorization code lifetime of 10 minutes is\n         RECOMMENDED.  The client MUST NOT use the authorization code\n\n\n\nHardt                        Standards Track                   [Page 26]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         more than once.  If an authorization code is used more than\n         once, the authorization server MUST deny the request and SHOULD\n         revoke (when possible) all tokens previously issued based on\n         that authorization code.  The authorization code is bound to\n         the client identifier and redirection URI.\n\n   state\n         REQUIRED if the \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n     HTTP/1.1 302 Found\n     Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n               &state=xyz\n\n   The client MUST ignore unrecognized response parameters.  The\n   authorization code string size is left undefined by this\n   specification.  The client should avoid making assumptions about code\n   value sizes.  The authorization server SHOULD document the size of\n   any value it issues.\n\n4.1.2.1.  Error Response\n\n   If the request fails due to a missing, invalid, or mismatching\n   redirection URI, or if the client identifier is missing or invalid,\n   the authorization server SHOULD inform the resource owner of the\n   error and MUST NOT automatically redirect the user-agent to the\n   invalid redirection URI."
      },
      {
        "chunk_id": "rfc_oauth_chunk_18",
        "original_index": 18,
        "content": "If the resource owner denies the access request or if the request\n   fails for reasons other than a missing or invalid redirection URI,\n   the authorization server informs the client by adding the following\n   parameters to the query component of the redirection URI using the\n   \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               invalid parameter value, includes a parameter more than\n               once, or is otherwise malformed.\n\n\n\n\n\nHardt                        Standards Track                   [Page 27]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         unauthorized_client\n               The client is not authorized to request an authorization\n               code using this method.\n\n         access_denied\n               The resource owner or authorization server denied the\n               request.\n\n         unsupported_response_type\n               The authorization server does not support obtaining an\n               authorization code using this method.\n\n         invalid_scope\n               The requested scope is invalid, unknown, or malformed.\n\n         server_error\n               The authorization server encountered an unexpected\n               condition that prevented it from fulfilling the request.\n               (This error code is needed because a 500 Internal Server\n               Error HTTP status code cannot be returned to the client\n               via an HTTP redirect.)\n\n         temporarily_unavailable\n               The authorization server is currently unable to handle\n               the request due to a temporary overloading or maintenance\n               of the server.  (This error code is needed because a 503\n               Service Unavailable HTTP status code cannot be returned\n               to the client via an HTTP redirect.)\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n\n\n\n\nHardt                        Standards Track                   [Page 28]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   state\n         REQUIRED if a \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n   HTTP/1.1 302 Found\n   Location: https://client.example.com/cb?error=access_denied&state=xyz\n\n4.1.3.  Access Token Request\n\n   The client makes a request to the token endpoint by sending the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"authorization_code\".\n\n   code\n         REQUIRED.  The authorization code received from the\n         authorization server."
      },
      {
        "chunk_id": "rfc_oauth_chunk_19",
        "original_index": 19,
        "content": "grant_type\n         REQUIRED.  Value MUST be set to \"authorization_code\".\n\n   code\n         REQUIRED.  The authorization code received from the\n         authorization server.\n\n   redirect_uri\n         REQUIRED, if the \"redirect_uri\" parameter was included in the\n         authorization request as described in Section 4.1.1, and their\n         values MUST be identical.\n\n   client_id\n         REQUIRED, if the client is not authenticating with the\n         authorization server as described in Section 3.2.1.\n\n   If the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 29]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, the client makes the following HTTP request using TLS\n   (with extra line breaks for display purposes only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n     &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included,\n\n   o  ensure that the authorization code was issued to the authenticated\n      confidential client, or if the client is public, ensure that the\n      code was issued to \"client_id\" in the request,\n\n   o  verify that the authorization code is valid, and\n\n   o  ensure that the \"redirect_uri\" parameter is present if the\n      \"redirect_uri\" parameter was included in the initial authorization\n      request as described in Section 4.1.1, and if included ensure that\n      their values are identical.\n\n4.1.4.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request client\n   authentication failed or is invalid, the authorization server returns\n   an error response as described in Section 5.2.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 30]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n4.2.  Implicit Grant\n\n   The implicit grant type is used to obtain access tokens (it does not\n   support the issuance of refresh tokens) and is optimized for public\n   clients known to operate a particular redirection URI.  These clients\n   are typically implemented in a browser using a scripting language\n   such as JavaScript.\n\n   Since this is a redirection-based flow, the client must be capable of\n   interacting with the resource owner's user-agent (typically a web\n   browser) and capable of receiving incoming requests (via redirection)\n   from the authorization server.\n\n   Unlike the authorization code grant type, in which the client makes\n   separate requests for authorization and for an access token, the\n   client receives the access token as the result of the authorization\n   request."
      },
      {
        "chunk_id": "rfc_oauth_chunk_20",
        "original_index": 20,
        "content": "The implicit grant type does not include client authentication, and\n   relies on the presence of the resource owner and the registration of\n   the redirection URI.  Because the access token is encoded into the\n   redirection URI, it may be exposed to the resource owner and other\n   applications residing on the same device.\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 31]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n     +----------+\n     | Resource |\n     |  Owner   |\n     |          |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier     +---------------+\n     |         -+----(A)-- & Redirection URI --->|               |\n     |  User-   |                                | Authorization |\n     |  Agent  -|----(B)-- User authenticates -->|     Server    |\n     |          |                                |               |\n     |          |<---(C)--- Redirection URI ----<|               |\n     |          |          with Access Token     +---------------+\n     |          |            in Fragment\n     |          |                                +---------------+\n     |          |----(D)--- Redirection URI ---->|   Web-Hosted  |\n     |          |          without Fragment      |     Client    |\n     |          |                                |    Resource   |\n     |     (F)  |<---(E)------- Script ---------<|               |\n     |          |                                +---------------+\n     +-|--------+\n       |    |\n      (A)  (G) Access Token\n       |    |\n       ^    v\n     +---------+\n     |         |\n     |  Client |\n     |         |\n     +---------+\n\n   Note: The lines illustrating steps (A) and (B) are broken into two\n   parts as they pass through the user-agent.\n\n                       Figure 4: Implicit Grant Flow\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 32]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The flow illustrated in Figure 4 includes the following steps:\n\n   (A)  The client initiates the flow by directing the resource owner's\n        user-agent to the authorization endpoint.  The client includes\n        its client identifier, requested scope, local state, and a\n        redirection URI to which the authorization server will send the\n        user-agent back once access is granted (or denied).\n\n   (B)  The authorization server authenticates the resource owner (via\n        the user-agent) and establishes whether the resource owner\n        grants or denies the client's access request.\n\n   (C)  Assuming the resource owner grants access, the authorization\n        server redirects the user-agent back to the client using the\n        redirection URI provided earlier.  The redirection URI includes\n        the access token in the URI fragment.\n\n   (D)  The user-agent follows the redirection instructions by making a\n        request to the web-hosted client resource (which does not\n        include the fragment per [RFC2616]).  The user-agent retains the\n        fragment information locally.\n\n   (E)  The web-hosted client resource returns a web page (typically an\n        HTML document with an embedded script) capable of accessing the\n        full redirection URI including the fragment retained by the\n        user-agent, and extracting the access token (and other\n        parameters) contained in the fragment.\n\n   (F)  The user-agent executes the script provided by the web-hosted\n        client resource locally, which extracts the access token.\n\n   (G)  The user-agent passes the access token to the client.\n\n   See Sections 1.3.2 and 9 for background on using the implicit grant.\n   See Sections 10.3 and 10.16 for important security considerations\n   when using the implicit grant.\n\n4.2.1.  Authorization Request"
      },
      {
        "chunk_id": "rfc_oauth_chunk_21",
        "original_index": 21,
        "content": "4.2.1.  Authorization Request\n\n   The client constructs the request URI by adding the following\n   parameters to the query component of the authorization endpoint URI\n   using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   response_type\n         REQUIRED.  Value MUST be set to \"token\".\n\n   client_id\n         REQUIRED.  The client identifier as described in Section 2.2.\n\n\n\nHardt                        Standards Track                   [Page 33]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   redirect_uri\n         OPTIONAL.  As described in Section 3.1.2.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   state\n         RECOMMENDED.  An opaque value used by the client to maintain\n         state between the request and callback.  The authorization\n         server includes this value when redirecting the user-agent back\n         to the client.  The parameter SHOULD be used for preventing\n         cross-site request forgery as described in Section 10.12.\n\n   The client directs the resource owner to the constructed URI using an\n   HTTP redirection response, or by other means available to it via the\n   user-agent.\n\n   For example, the client directs the user-agent to make the following\n   HTTP request using TLS (with extra line breaks for display purposes\n   only):\n\n    GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz\n        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n    Host: server.example.com\n\n   The authorization server validates the request to ensure that all\n   required parameters are present and valid.  The authorization server\n   MUST verify that the redirection URI to which it will redirect the\n   access token matches a redirection URI registered by the client as\n   described in Section 3.1.2.\n\n   If the request is valid, the authorization server authenticates the\n   resource owner and obtains an authorization decision (by asking the\n   resource owner or by establishing approval via other means).\n\n   When a decision is established, the authorization server directs the\n   user-agent to the provided client redirection URI using an HTTP\n   redirection response, or by other means available to it via the\n   user-agent.\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 34]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.2.2.  Access Token Response\n\n   If the resource owner grants the access request, the authorization\n   server issues an access token and delivers it to the client by adding\n   the following parameters to the fragment component of the redirection\n   URI using the \"application/x-www-form-urlencoded\" format, per\n   Appendix B:\n\n   access_token\n         REQUIRED.  The access token issued by the authorization server.\n\n   token_type\n         REQUIRED.  The type of the token issued as described in\n         Section 7.1.  Value is case insensitive.\n\n   expires_in\n         RECOMMENDED.  The lifetime in seconds of the access token.  For\n         example, the value \"3600\" denotes that the access token will\n         expire in one hour from the time the response was generated.\n         If omitted, the authorization server SHOULD provide the\n         expiration time via other means or document the default value.\n\n   scope\n         OPTIONAL, if identical to the scope requested by the client;\n         otherwise, REQUIRED.  The scope of the access token as\n         described by Section 3.3.\n\n   state\n         REQUIRED if the \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   The authorization server MUST NOT issue a refresh token.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response (with extra line breaks for\n   display purposes only):"
      },
      {
        "chunk_id": "rfc_oauth_chunk_22",
        "original_index": 22,
        "content": "For example, the authorization server redirects the user-agent by\n   sending the following HTTP response (with extra line breaks for\n   display purposes only):\n\n     HTTP/1.1 302 Found\n     Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\n               &state=xyz&token_type=example&expires_in=3600\n\n   Developers should note that some user-agents do not support the\n   inclusion of a fragment component in the HTTP \"Location\" response\n   header field.  Such clients will require using other methods for\n   redirecting the client than a 3xx redirection response -- for\n   example, returning an HTML page that includes a 'continue' button\n   with an action linked to the redirection URI.\n\n\n\nHardt                        Standards Track                   [Page 35]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The client MUST ignore unrecognized response parameters.  The access\n   token string size is left undefined by this specification.  The\n   client should avoid making assumptions about value sizes.  The\n   authorization server SHOULD document the size of any value it issues.\n\n4.2.2.1.  Error Response\n\n   If the request fails due to a missing, invalid, or mismatching\n   redirection URI, or if the client identifier is missing or invalid,\n   the authorization server SHOULD inform the resource owner of the\n   error and MUST NOT automatically redirect the user-agent to the\n   invalid redirection URI.\n\n   If the resource owner denies the access request or if the request\n   fails for reasons other than a missing or invalid redirection URI,\n   the authorization server informs the client by adding the following\n   parameters to the fragment component of the redirection URI using the\n   \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               invalid parameter value, includes a parameter more than\n               once, or is otherwise malformed.\n\n         unauthorized_client\n               The client is not authorized to request an access token\n               using this method.\n\n         access_denied\n               The resource owner or authorization server denied the\n               request.\n\n         unsupported_response_type\n               The authorization server does not support obtaining an\n               access token using this method.\n\n         invalid_scope\n               The requested scope is invalid, unknown, or malformed.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 36]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         server_error\n               The authorization server encountered an unexpected\n               condition that prevented it from fulfilling the request.\n               (This error code is needed because a 500 Internal Server\n               Error HTTP status code cannot be returned to the client\n               via an HTTP redirect.)\n\n         temporarily_unavailable\n               The authorization server is currently unable to handle\n               the request due to a temporary overloading or maintenance\n               of the server.  (This error code is needed because a 503\n               Service Unavailable HTTP status code cannot be returned\n               to the client via an HTTP redirect.)\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E."
      },
      {
        "chunk_id": "rfc_oauth_chunk_23",
        "original_index": 23,
        "content": "error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n   state\n         REQUIRED if a \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n   HTTP/1.1 302 Found\n   Location: https://client.example.com/cb#error=access_denied&state=xyz\n\n4.3.  Resource Owner Password Credentials Grant\n\n   The resource owner password credentials grant type is suitable in\n   cases where the resource owner has a trust relationship with the\n   client, such as the device operating system or a highly privileged\n\n\n\nHardt                        Standards Track                   [Page 37]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   application.  The authorization server should take special care when\n   enabling this grant type and only allow it when other flows are not\n   viable.\n\n   This grant type is suitable for clients capable of obtaining the\n   resource owner's credentials (username and password, typically using\n   an interactive form).  It is also used to migrate existing clients\n   using direct authentication schemes such as HTTP Basic or Digest\n   authentication to OAuth by converting the stored credentials to an\n   access token.\n\n     +----------+\n     | Resource |\n     |  Owner   |\n     |          |\n     +----------+\n          v\n          |    Resource Owner\n         (A) Password Credentials\n          |\n          v\n     +---------+                                  +---------------+\n     |         |>--(B)---- Resource Owner ------->|               |\n     |         |         Password Credentials     | Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(C)---- Access Token ---------<|               |\n     |         |    (w/ Optional Refresh Token)   |               |\n     +---------+                                  +---------------+\n\n            Figure 5: Resource Owner Password Credentials Flow\n\n   The flow illustrated in Figure 5 includes the following steps:\n\n   (A)  The resource owner provides the client with its username and\n        password.\n\n   (B)  The client requests an access token from the authorization\n        server's token endpoint by including the credentials received\n        from the resource owner.  When making the request, the client\n        authenticates with the authorization server.\n\n   (C)  The authorization server authenticates the client and validates\n        the resource owner credentials, and if valid, issues an access\n        token.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 38]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.3.1.  Authorization Request and Response\n\n   The method through which the client obtains the resource owner\n   credentials is beyond the scope of this specification.  The client\n   MUST discard the credentials once an access token has been obtained.\n\n4.3.2.  Access Token Request\n\n   The client makes a request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"password\".\n\n   username\n         REQUIRED.  The resource owner username.\n\n   password\n         REQUIRED.  The resource owner password.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3."
      },
      {
        "chunk_id": "rfc_oauth_chunk_24",
        "original_index": 24,
        "content": "password\n         REQUIRED.  The resource owner password.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   If the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=password&username=johndoe&password=A3ddj3w\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 39]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included, and\n\n   o  validate the resource owner password credentials using its\n      existing password validation algorithm.\n\n   Since this access token request utilizes the resource owner's\n   password, the authorization server MUST protect the endpoint against\n   brute force attacks (e.g., using rate-limitation or generating\n   alerts).\n\n4.3.3.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n4.4.  Client Credentials Grant\n\n   The client can request an access token using only its client\n   credentials (or other supported means of authentication) when the\n   client is requesting access to the protected resources under its\n   control, or those of another resource owner that have been previously\n   arranged with the authorization server (the method of which is beyond\n   the scope of this specification).\n\n\n\n\nHardt                        Standards Track                   [Page 40]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The client credentials grant type MUST only be used by confidential\n   clients.\n\n     +---------+                                  +---------------+\n     |         |                                  |               |\n     |         |>--(A)- Client Authentication --->| Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(B)---- Access Token ---------<|               |\n     |         |                                  |               |\n     +---------+                                  +---------------+\n\n                     Figure 6: Client Credentials Flow\n\n   The flow illustrated in Figure 6 includes the following steps:\n\n   (A)  The client authenticates with the authorization server and\n        requests an access token from the token endpoint.\n\n   (B)  The authorization server authenticates the client, and if valid,\n        issues an access token.\n\n4.4.1.  Authorization Request and Response\n\n   Since the client authentication is used as the authorization grant,\n   no additional authorization request is needed.\n\n4.4.2.  Access Token Request"
      },
      {
        "chunk_id": "rfc_oauth_chunk_25",
        "original_index": 25,
        "content": "4.4.1.  Authorization Request and Response\n\n   Since the client authentication is used as the authorization grant,\n   no additional authorization request is needed.\n\n4.4.2.  Access Token Request\n\n   The client makes a request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"client_credentials\".\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   The client MUST authenticate with the authorization server as\n   described in Section 3.2.1.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 41]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=client_credentials\n\n   The authorization server MUST authenticate the client.\n\n4.4.3.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token as described in\n   Section 5.1.  A refresh token SHOULD NOT be included.  If the request\n   failed client authentication or is invalid, the authorization server\n   returns an error response as described in Section 5.2.\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"example_parameter\":\"example_value\"\n     }\n\n4.5.  Extension Grants\n\n   The client uses an extension grant type by specifying the grant type\n   using an absolute URI (defined by the authorization server) as the\n   value of the \"grant_type\" parameter of the token endpoint, and by\n   adding any additional parameters necessary.\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 42]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, to request an access token using a Security Assertion\n   Markup Language (SAML) 2.0 assertion grant type as defined by\n   [OAuth-SAML2], the client could make the following HTTP request using\n   TLS (with extra line breaks for display purposes only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-\n     bearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU\n     [...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n5.  Issuing an Access Token\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n5.1.  Successful Response\n\n   The authorization server issues an access token and optional refresh\n   token, and constructs the response by adding the following parameters\n   to the entity-body of the HTTP response with a 200 (OK) status code:\n\n   access_token\n         REQUIRED.  The access token issued by the authorization server."
      },
      {
        "chunk_id": "rfc_oauth_chunk_26",
        "original_index": 26,
        "content": "access_token\n         REQUIRED.  The access token issued by the authorization server.\n\n   token_type\n         REQUIRED.  The type of the token issued as described in\n         Section 7.1.  Value is case insensitive.\n\n   expires_in\n         RECOMMENDED.  The lifetime in seconds of the access token.  For\n         example, the value \"3600\" denotes that the access token will\n         expire in one hour from the time the response was generated.\n         If omitted, the authorization server SHOULD provide the\n         expiration time via other means or document the default value.\n\n\n\n\n\nHardt                        Standards Track                   [Page 43]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   refresh_token\n         OPTIONAL.  The refresh token, which can be used to obtain new\n         access tokens using the same authorization grant as described\n         in Section 6.\n\n   scope\n         OPTIONAL, if identical to the scope requested by the client;\n         otherwise, REQUIRED.  The scope of the access token as\n         described by Section 3.3.\n\n   The parameters are included in the entity-body of the HTTP response\n   using the \"application/json\" media type as defined by [RFC4627].  The\n   parameters are serialized into a JavaScript Object Notation (JSON)\n   structure by adding each parameter at the highest structure level.\n   Parameter names and string values are included as JSON strings.\n   Numerical values are included as JSON numbers.  The order of\n   parameters does not matter and can vary.\n\n   The authorization server MUST include the HTTP \"Cache-Control\"\n   response header field [RFC2616] with a value of \"no-store\" in any\n   response containing tokens, credentials, or other sensitive\n   information, as well as the \"Pragma\" response header field [RFC2616]\n   with a value of \"no-cache\".\n\n   For example:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n   The client MUST ignore unrecognized value names in the response.  The\n   sizes of tokens and other values received from the authorization\n   server are left undefined.  The client should avoid making\n   assumptions about value sizes.  The authorization server SHOULD\n   document the size of any value it issues.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 44]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n5.2.  Error Response\n\n   The authorization server responds with an HTTP 400 (Bad Request)\n   status code (unless specified otherwise) and includes the following\n   parameters with the response:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               unsupported parameter value (other than grant type),\n               repeats a parameter, includes multiple credentials,\n               utilizes more than one mechanism for authenticating the\n               client, or is otherwise malformed."
      },
      {
        "chunk_id": "rfc_oauth_chunk_27",
        "original_index": 27,
        "content": "invalid_client\n               Client authentication failed (e.g., unknown client, no\n               client authentication included, or unsupported\n               authentication method).  The authorization server MAY\n               return an HTTP 401 (Unauthorized) status code to indicate\n               which HTTP authentication schemes are supported.  If the\n               client attempted to authenticate via the \"Authorization\"\n               request header field, the authorization server MUST\n               respond with an HTTP 401 (Unauthorized) status code and\n               include the \"WWW-Authenticate\" response header field\n               matching the authentication scheme used by the client.\n\n         invalid_grant\n               The provided authorization grant (e.g., authorization\n               code, resource owner credentials) or refresh token is\n               invalid, expired, revoked, does not match the redirection\n               URI used in the authorization request, or was issued to\n               another client.\n\n         unauthorized_client\n               The authenticated client is not authorized to use this\n               authorization grant type.\n\n         unsupported_grant_type\n               The authorization grant type is not supported by the\n               authorization server.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 45]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         invalid_scope\n               The requested scope is invalid, unknown, malformed, or\n               exceeds the scope granted by the resource owner.\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n   The parameters are included in the entity-body of the HTTP response\n   using the \"application/json\" media type as defined by [RFC4627].  The\n   parameters are serialized into a JSON structure by adding each\n   parameter at the highest structure level.  Parameter names and string\n   values are included as JSON strings.  Numerical values are included\n   as JSON numbers.  The order of parameters does not matter and can\n   vary.\n\n   For example:\n\n     HTTP/1.1 400 Bad Request\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"error\":\"invalid_request\"\n     }\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 46]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n6.  Refreshing an Access Token\n\n   If the authorization server issued a refresh token to the client, the\n   client makes a refresh request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"refresh_token\".\n\n   refresh_token\n         REQUIRED.  The refresh token issued to the client."
      },
      {
        "chunk_id": "rfc_oauth_chunk_28",
        "original_index": 28,
        "content": "grant_type\n         REQUIRED.  Value MUST be set to \"refresh_token\".\n\n   refresh_token\n         REQUIRED.  The refresh token issued to the client.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.  The requested scope MUST NOT include any scope\n         not originally granted by the resource owner, and if omitted is\n         treated as equal to the scope originally granted by the\n         resource owner.\n\n   Because refresh tokens are typically long-lasting credentials used to\n   request additional access tokens, the refresh token is bound to the\n   client to which it was issued.  If the client type is confidential or\n   the client was issued client credentials (or assigned other\n   authentication requirements), the client MUST authenticate with the\n   authorization server as described in Section 3.2.1.\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 47]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included and\n      ensure that the refresh token was issued to the authenticated\n      client, and\n\n   o  validate the refresh token.\n\n   If valid and authorized, the authorization server issues an access\n   token as described in Section 5.1.  If the request failed\n   verification or is invalid, the authorization server returns an error\n   response as described in Section 5.2.\n\n   The authorization server MAY issue a new refresh token, in which case\n   the client MUST discard the old refresh token and replace it with the\n   new refresh token.  The authorization server MAY revoke the old\n   refresh token after issuing a new refresh token to the client.  If a\n   new refresh token is issued, the refresh token scope MUST be\n   identical to that of the refresh token included by the client in the\n   request.\n\n7.  Accessing Protected Resources\n\n   The client accesses protected resources by presenting the access\n   token to the resource server.  The resource server MUST validate the\n   access token and ensure that it has not expired and that its scope\n   covers the requested resource.  The methods used by the resource\n   server to validate the access token (as well as any error responses)\n   are beyond the scope of this specification but generally involve an\n   interaction or coordination between the resource server and the\n   authorization server.\n\n   The method in which the client utilizes the access token to\n   authenticate with the resource server depends on the type of access\n   token issued by the authorization server.  Typically, it involves\n   using the HTTP \"Authorization\" request header field [RFC2617] with an\n   authentication scheme defined by the specification of the access\n   token type used, such as [RFC6750].\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 48]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n7.1.  Access Token Types\n\n   The access token type provides the client with the information\n   required to successfully utilize the access token to make a protected\n   resource request (along with type-specific attributes).  The client\n   MUST NOT use an access token if it does not understand the token\n   type."
      },
      {
        "chunk_id": "rfc_oauth_chunk_29",
        "original_index": 29,
        "content": "For example, the \"bearer\" token type defined in [RFC6750] is utilized\n   by simply including the access token string in the request:\n\n     GET /resource/1 HTTP/1.1\n     Host: example.com\n     Authorization: Bearer mF_9.B5f-4.1JqM\n\n   while the \"mac\" token type defined in [OAuth-HTTP-MAC] is utilized by\n   issuing a Message Authentication Code (MAC) key together with the\n   access token that is used to sign certain components of the HTTP\n   requests:\n\n     GET /resource/1 HTTP/1.1\n     Host: example.com\n     Authorization: MAC id=\"h480djs93hd8\",\n                        nonce=\"274312:dj83hs9s\",\n                        mac=\"kDZvddkndxvhGRXZhvuDjEWhGeE=\"\n\n   The above examples are provided for illustration purposes only.\n   Developers are advised to consult the [RFC6750] and [OAuth-HTTP-MAC]\n   specifications before use.\n\n   Each access token type definition specifies the additional attributes\n   (if any) sent to the client together with the \"access_token\" response\n   parameter.  It also defines the HTTP authentication method used to\n   include the access token when making a protected resource request.\n\n7.2.  Error Response\n\n   If a resource access request fails, the resource server SHOULD inform\n   the client of the error.  While the specifics of such error responses\n   are beyond the scope of this specification, this document establishes\n   a common registry in Section 11.4 for error values to be shared among\n   OAuth token authentication schemes.\n\n   New authentication schemes designed primarily for OAuth token\n   authentication SHOULD define a mechanism for providing an error\n   status code to the client, in which the error values allowed are\n   registered in the error registry established by this specification.\n\n\n\n\nHardt                        Standards Track                   [Page 49]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Such schemes MAY limit the set of valid error codes to a subset of\n   the registered values.  If the error code is returned using a named\n   parameter, the parameter name SHOULD be \"error\".\n\n   Other schemes capable of being used for OAuth token authentication,\n   but not primarily designed for that purpose, MAY bind their error\n   values to the registry in the same manner.\n\n   New authentication schemes MAY choose to also specify the use of the\n   \"error_description\" and \"error_uri\" parameters to return error\n   information in a manner parallel to their usage in this\n   specification.\n\n8.  Extensibility\n\n8.1.  Defining Access Token Types\n\n   Access token types can be defined in one of two ways: registered in\n   the Access Token Types registry (following the procedures in\n   Section 11.1), or by using a unique absolute URI as its name.\n\n   Types utilizing a URI name SHOULD be limited to vendor-specific\n   implementations that are not commonly applicable, and are specific to\n   the implementation details of the resource server where they are\n   used.\n\n   All other types MUST be registered.  Type names MUST conform to the\n   type-name ABNF.  If the type definition includes a new HTTP\n   authentication scheme, the type name SHOULD be identical to the HTTP\n   authentication scheme name (as defined by [RFC2617]).  The token type\n   \"example\" is reserved for use in examples.\n\n     type-name  = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\n8.2.  Defining New Endpoint Parameters\n\n   New request or response parameters for use with the authorization\n   endpoint or the token endpoint are defined and registered in the\n   OAuth Parameters registry following the procedure in Section 11.2.\n\n   Parameter names MUST conform to the param-name ABNF, and parameter\n   values syntax MUST be well-defined (e.g., using ABNF, or a reference\n   to the syntax of an existing parameter).\n\n     param-name  = 1*name-char\n     name-char   = \"-\" / \".\" / \"_\" / DIGIT / ALPHA"
      },
      {
        "chunk_id": "rfc_oauth_chunk_30",
        "original_index": 30,
        "content": "param-name  = 1*name-char\n     name-char   = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\n\n\n\nHardt                        Standards Track                   [Page 50]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Unregistered vendor-specific parameter extensions that are not\n   commonly applicable and that are specific to the implementation\n   details of the authorization server where they are used SHOULD\n   utilize a vendor-specific prefix that is not likely to conflict with\n   other registered values (e.g., begin with 'companyname_').\n\n8.3.  Defining New Authorization Grant Types\n\n   New authorization grant types can be defined by assigning them a\n   unique absolute URI for use with the \"grant_type\" parameter.  If the\n   extension grant type requires additional token endpoint parameters,\n   they MUST be registered in the OAuth Parameters registry as described\n   by Section 11.2.\n\n8.4.  Defining New Authorization Endpoint Response Types\n\n   New response types for use with the authorization endpoint are\n   defined and registered in the Authorization Endpoint Response Types\n   registry following the procedure in Section 11.3.  Response type\n   names MUST conform to the response-type ABNF.\n\n     response-type  = response-name *( SP response-name )\n     response-name  = 1*response-char\n     response-char  = \"_\" / DIGIT / ALPHA\n\n   If a response type contains one or more space characters (%x20), it\n   is compared as a space-delimited list of values in which the order of\n   values does not matter.  Only one order of values can be registered,\n   which covers all other arrangements of the same set of values.\n\n   For example, the response type \"token code\" is left undefined by this\n   specification.  However, an extension can define and register the\n   \"token code\" response type.  Once registered, the same combination\n   cannot be registered as \"code token\", but both values can be used to\n   denote the same response type.\n\n8.5.  Defining Additional Error Codes\n\n   In cases where protocol extensions (i.e., access token types,\n   extension parameters, or extension grant types) require additional\n   error codes to be used with the authorization code grant error\n   response (Section 4.1.2.1), the implicit grant error response\n   (Section 4.2.2.1), the token error response (Section 5.2), or the\n   resource access error response (Section 7.2), such error codes MAY be\n   defined.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 51]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Extension error codes MUST be registered (following the procedures in\n   Section 11.4) if the extension they are used in conjunction with is a\n   registered access token type, a registered endpoint parameter, or an\n   extension grant type.  Error codes used with unregistered extensions\n   MAY be registered.\n\n   Error codes MUST conform to the error ABNF and SHOULD be prefixed by\n   an identifying name when possible.  For example, an error identifying\n   an invalid value set to the extension parameter \"example\" SHOULD be\n   named \"example_invalid\".\n\n     error      = 1*error-char\n     error-char = %x20-21 / %x23-5B / %x5D-7E\n\n9.  Native Applications\n\n   Native applications are clients installed and executed on the device\n   used by the resource owner (i.e., desktop application, native mobile\n   application).  Native applications require special consideration\n   related to security, platform capabilities, and overall end-user\n   experience.\n\n   The authorization endpoint requires interaction between the client\n   and the resource owner's user-agent.  Native applications can invoke\n   an external user-agent or embed a user-agent within the application.\n   For example:"
      },
      {
        "chunk_id": "rfc_oauth_chunk_31",
        "original_index": 31,
        "content": "o  External user-agent - the native application can capture the\n      response from the authorization server using a redirection URI\n      with a scheme registered with the operating system to invoke the\n      client as the handler, manual copy-and-paste of the credentials,\n      running a local web server, installing a user-agent extension, or\n      by providing a redirection URI identifying a server-hosted\n      resource under the client's control, which in turn makes the\n      response available to the native application.\n\n   o  Embedded user-agent - the native application obtains the response\n      by directly communicating with the embedded user-agent by\n      monitoring state changes emitted during the resource load, or\n      accessing the user-agent's cookies storage.\n\n   When choosing between an external or embedded user-agent, developers\n   should consider the following:\n\n   o  An external user-agent may improve completion rate, as the\n      resource owner may already have an active session with the\n      authorization server, removing the need to re-authenticate.  It\n      provides a familiar end-user experience and functionality.  The\n\n\n\nHardt                        Standards Track                   [Page 52]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n      resource owner may also rely on user-agent features or extensions\n      to assist with authentication (e.g., password manager, 2-factor\n      device reader).\n\n   o  An embedded user-agent may offer improved usability, as it removes\n      the need to switch context and open new windows.\n\n   o  An embedded user-agent poses a security challenge because resource\n      owners are authenticating in an unidentified window without access\n      to the visual protections found in most external user-agents.  An\n      embedded user-agent educates end-users to trust unidentified\n      requests for authentication (making phishing attacks easier to\n      execute).\n\n   When choosing between the implicit grant type and the authorization\n   code grant type, the following should be considered:\n\n   o  Native applications that use the authorization code grant type\n      SHOULD do so without using client credentials, due to the native\n      application's inability to keep client credentials confidential.\n\n   o  When using the implicit grant type flow, a refresh token is not\n      returned, which requires repeating the authorization process once\n      the access token expires.\n\n10.  Security Considerations\n\n   As a flexible and extensible framework, OAuth's security\n   considerations depend on many factors.  The following sections\n   provide implementers with security guidelines focused on the three\n   client profiles described in Section 2.1: web application,\n   user-agent-based application, and native application.\n\n   A comprehensive OAuth security model and analysis, as well as\n   background for the protocol design, is provided by\n   [OAuth-THREATMODEL].\n\n10.1.  Client Authentication\n\n   The authorization server establishes client credentials with web\n   application clients for the purpose of client authentication.  The\n   authorization server is encouraged to consider stronger client\n   authentication means than a client password.  Web application clients\n   MUST ensure confidentiality of client passwords and other client\n   credentials.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 53]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST NOT issue client passwords or other\n   client credentials to native application or user-agent-based\n   application clients for the purpose of client authentication.  The\n   authorization server MAY issue a client password or other credentials\n   for a specific installation of a native application client on a\n   specific device."
      },
      {
        "chunk_id": "rfc_oauth_chunk_32",
        "original_index": 32,
        "content": "When client authentication is not possible, the authorization server\n   SHOULD employ other means to validate the client's identity -- for\n   example, by requiring the registration of the client redirection URI\n   or enlisting the resource owner to confirm identity.  A valid\n   redirection URI is not sufficient to verify the client's identity\n   when asking for resource owner authorization but can be used to\n   prevent delivering credentials to a counterfeit client after\n   obtaining resource owner authorization.\n\n   The authorization server must consider the security implications of\n   interacting with unauthenticated clients and take measures to limit\n   the potential exposure of other credentials (e.g., refresh tokens)\n   issued to such clients.\n\n10.2.  Client Impersonation\n\n   A malicious client can impersonate another client and obtain access\n   to protected resources if the impersonated client fails to, or is\n   unable to, keep its client credentials confidential.\n\n   The authorization server MUST authenticate the client whenever\n   possible.  If the authorization server cannot authenticate the client\n   due to the client's nature, the authorization server MUST require the\n   registration of any redirection URI used for receiving authorization\n   responses and SHOULD utilize other means to protect resource owners\n   from such potentially malicious clients.  For example, the\n   authorization server can engage the resource owner to assist in\n   identifying the client and its origin.\n\n   The authorization server SHOULD enforce explicit resource owner\n   authentication and provide the resource owner with information about\n   the client and the requested authorization scope and lifetime.  It is\n   up to the resource owner to review the information in the context of\n   the current client and to authorize or deny the request.\n\n   The authorization server SHOULD NOT process repeated authorization\n   requests automatically (without active resource owner interaction)\n   without authenticating the client or relying on other measures to\n   ensure that the repeated request comes from the original client and\n   not an impersonator.\n\n\n\n\nHardt                        Standards Track                   [Page 54]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.3.  Access Tokens\n\n   Access token credentials (as well as any confidential access token\n   attributes) MUST be kept confidential in transit and storage, and\n   only shared among the authorization server, the resource servers the\n   access token is valid for, and the client to whom the access token is\n   issued.  Access token credentials MUST only be transmitted using TLS\n   as described in Section 1.6 with server authentication as defined by\n   [RFC2818].\n\n   When using the implicit grant type, the access token is transmitted\n   in the URI fragment, which can expose it to unauthorized parties.\n\n   The authorization server MUST ensure that access tokens cannot be\n   generated, modified, or guessed to produce valid access tokens by\n   unauthorized parties.\n\n   The client SHOULD request access tokens with the minimal scope\n   necessary.  The authorization server SHOULD take the client identity\n   into account when choosing how to honor the requested scope and MAY\n   issue an access token with less rights than requested.\n\n   This specification does not provide any methods for the resource\n   server to ensure that an access token presented to it by a given\n   client was issued to that client by the authorization server.\n\n10.4.  Refresh Tokens\n\n   Authorization servers MAY issue refresh tokens to web application\n   clients and native application clients."
      },
      {
        "chunk_id": "rfc_oauth_chunk_33",
        "original_index": 33,
        "content": "10.4.  Refresh Tokens\n\n   Authorization servers MAY issue refresh tokens to web application\n   clients and native application clients.\n\n   Refresh tokens MUST be kept confidential in transit and storage, and\n   shared only among the authorization server and the client to whom the\n   refresh tokens were issued.  The authorization server MUST maintain\n   the binding between a refresh token and the client to whom it was\n   issued.  Refresh tokens MUST only be transmitted using TLS as\n   described in Section 1.6 with server authentication as defined by\n   [RFC2818].\n\n   The authorization server MUST verify the binding between the refresh\n   token and client identity whenever the client identity can be\n   authenticated.  When client authentication is not possible, the\n   authorization server SHOULD deploy other means to detect refresh\n   token abuse.\n\n   For example, the authorization server could employ refresh token\n   rotation in which a new refresh token is issued with every access\n   token refresh response.  The previous refresh token is invalidated\n\n\n\nHardt                        Standards Track                   [Page 55]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   but retained by the authorization server.  If a refresh token is\n   compromised and subsequently used by both the attacker and the\n   legitimate client, one of them will present an invalidated refresh\n   token, which will inform the authorization server of the breach.\n\n   The authorization server MUST ensure that refresh tokens cannot be\n   generated, modified, or guessed to produce valid refresh tokens by\n   unauthorized parties.\n\n10.5.  Authorization Codes\n\n   The transmission of authorization codes SHOULD be made over a secure\n   channel, and the client SHOULD require the use of TLS with its\n   redirection URI if the URI identifies a network resource.  Since\n   authorization codes are transmitted via user-agent redirections, they\n   could potentially be disclosed through user-agent history and HTTP\n   referrer headers.\n\n   Authorization codes operate as plaintext bearer credentials, used to\n   verify that the resource owner who granted authorization at the\n   authorization server is the same resource owner returning to the\n   client to complete the process.  Therefore, if the client relies on\n   the authorization code for its own resource owner authentication, the\n   client redirection endpoint MUST require the use of TLS.\n\n   Authorization codes MUST be short lived and single-use.  If the\n   authorization server observes multiple attempts to exchange an\n   authorization code for an access token, the authorization server\n   SHOULD attempt to revoke all access tokens already granted based on\n   the compromised authorization code.\n\n   If the client can be authenticated, the authorization servers MUST\n   authenticate the client and ensure that the authorization code was\n   issued to the same client.\n\n10.6.  Authorization Code Redirection URI Manipulation\n\n   When requesting authorization using the authorization code grant\n   type, the client can specify a redirection URI via the \"redirect_uri\"\n   parameter.  If an attacker can manipulate the value of the\n   redirection URI, it can cause the authorization server to redirect\n   the resource owner user-agent to a URI under the control of the\n   attacker with the authorization code.\n\n   An attacker can create an account at a legitimate client and initiate\n   the authorization flow.  When the attacker's user-agent is sent to\n   the authorization server to grant access, the attacker grabs the\n   authorization URI provided by the legitimate client and replaces the\n\n\n\nHardt                        Standards Track                   [Page 56]\n\f\nRFC 6749                        OAuth 2.0                   October 2012"
      },
      {
        "chunk_id": "rfc_oauth_chunk_34",
        "original_index": 34,
        "content": "Hardt                        Standards Track                   [Page 56]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   client's redirection URI with a URI under the control of the\n   attacker.  The attacker then tricks the victim into following the\n   manipulated link to authorize access to the legitimate client.\n\n   Once at the authorization server, the victim is prompted with a\n   normal, valid request on behalf of a legitimate and trusted client,\n   and authorizes the request.  The victim is then redirected to an\n   endpoint under the control of the attacker with the authorization\n   code.  The attacker completes the authorization flow by sending the\n   authorization code to the client using the original redirection URI\n   provided by the client.  The client exchanges the authorization code\n   with an access token and links it to the attacker's client account,\n   which can now gain access to the protected resources authorized by\n   the victim (via the client).\n\n   In order to prevent such an attack, the authorization server MUST\n   ensure that the redirection URI used to obtain the authorization code\n   is identical to the redirection URI provided when exchanging the\n   authorization code for an access token.  The authorization server\n   MUST require public clients and SHOULD require confidential clients\n   to register their redirection URIs.  If a redirection URI is provided\n   in the request, the authorization server MUST validate it against the\n   registered value.\n\n10.7.  Resource Owner Password Credentials\n\n   The resource owner password credentials grant type is often used for\n   legacy or migration reasons.  It reduces the overall risk of storing\n   usernames and passwords by the client but does not eliminate the need\n   to expose highly privileged credentials to the client.\n\n   This grant type carries a higher risk than other grant types because\n   it maintains the password anti-pattern this protocol seeks to avoid.\n   The client could abuse the password, or the password could\n   unintentionally be disclosed to an attacker (e.g., via log files or\n   other records kept by the client).\n\n   Additionally, because the resource owner does not have control over\n   the authorization process (the resource owner's involvement ends when\n   it hands over its credentials to the client), the client can obtain\n   access tokens with a broader scope than desired by the resource\n   owner.  The authorization server should consider the scope and\n   lifetime of access tokens issued via this grant type.\n\n   The authorization server and client SHOULD minimize use of this grant\n   type and utilize other grant types whenever possible.\n\n\n\n\n\nHardt                        Standards Track                   [Page 57]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.8.  Request Confidentiality\n\n   Access tokens, refresh tokens, resource owner passwords, and client\n   credentials MUST NOT be transmitted in the clear.  Authorization\n   codes SHOULD NOT be transmitted in the clear.\n\n   The \"state\" and \"scope\" parameters SHOULD NOT include sensitive\n   client or resource owner information in plain text, as they can be\n   transmitted over insecure channels or stored insecurely.\n\n10.9.  Ensuring Endpoint Authenticity\n\n   In order to prevent man-in-the-middle attacks, the authorization\n   server MUST require the use of TLS with server authentication as\n   defined by [RFC2818] for any request sent to the authorization and\n   token endpoints.  The client MUST validate the authorization server's\n   TLS certificate as defined by [RFC6125] and in accordance with its\n   requirements for server identity authentication.\n\n10.10.  Credentials-Guessing Attacks\n\n   The authorization server MUST prevent attackers from guessing access\n   tokens, authorization codes, refresh tokens, resource owner\n   passwords, and client credentials."
      },
      {
        "chunk_id": "rfc_oauth_chunk_35",
        "original_index": 35,
        "content": "The authorization server MUST prevent attackers from guessing access\n   tokens, authorization codes, refresh tokens, resource owner\n   passwords, and client credentials.\n\n   The probability of an attacker guessing generated tokens (and other\n   credentials not intended for handling by end-users) MUST be less than\n   or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).\n\n   The authorization server MUST utilize other means to protect\n   credentials intended for end-user usage.\n\n10.11.  Phishing Attacks\n\n   Wide deployment of this and similar protocols may cause end-users to\n   become inured to the practice of being redirected to websites where\n   they are asked to enter their passwords.  If end-users are not\n   careful to verify the authenticity of these websites before entering\n   their credentials, it will be possible for attackers to exploit this\n   practice to steal resource owners' passwords.\n\n   Service providers should attempt to educate end-users about the risks\n   phishing attacks pose and should provide mechanisms that make it easy\n   for end-users to confirm the authenticity of their sites.  Client\n   developers should consider the security implications of how they\n   interact with the user-agent (e.g., external, embedded), and the\n   ability of the end-user to verify the authenticity of the\n   authorization server.\n\n\n\nHardt                        Standards Track                   [Page 58]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   To reduce the risk of phishing attacks, the authorization servers\n   MUST require the use of TLS on every endpoint used for end-user\n   interaction.\n\n10.12.  Cross-Site Request Forgery\n\n   Cross-site request forgery (CSRF) is an exploit in which an attacker\n   causes the user-agent of a victim end-user to follow a malicious URI\n   (e.g., provided to the user-agent as a misleading link, image, or\n   redirection) to a trusting server (usually established via the\n   presence of a valid session cookie).\n\n   A CSRF attack against the client's redirection URI allows an attacker\n   to inject its own authorization code or access token, which can\n   result in the client using an access token associated with the\n   attacker's protected resources rather than the victim's (e.g., save\n   the victim's bank account information to a protected resource\n   controlled by the attacker).\n\n   The client MUST implement CSRF protection for its redirection URI.\n   This is typically accomplished by requiring any request sent to the\n   redirection URI endpoint to include a value that binds the request to\n   the user-agent's authenticated state (e.g., a hash of the session\n   cookie used to authenticate the user-agent).  The client SHOULD\n   utilize the \"state\" request parameter to deliver this value to the\n   authorization server when making an authorization request.\n\n   Once authorization has been obtained from the end-user, the\n   authorization server redirects the end-user's user-agent back to the\n   client with the required binding value contained in the \"state\"\n   parameter.  The binding value enables the client to verify the\n   validity of the request by matching the binding value to the\n   user-agent's authenticated state.  The binding value used for CSRF\n   protection MUST contain a non-guessable value (as described in\n   Section 10.10), and the user-agent's authenticated state (e.g.,\n   session cookie, HTML5 local storage) MUST be kept in a location\n   accessible only to the client and the user-agent (i.e., protected by\n   same-origin policy).\n\n   A CSRF attack against the authorization server's authorization\n   endpoint can result in an attacker obtaining end-user authorization\n   for a malicious client without involving or alerting the end-user."
      },
      {
        "chunk_id": "rfc_oauth_chunk_36",
        "original_index": 36,
        "content": "The authorization server MUST implement CSRF protection for its\n   authorization endpoint and ensure that a malicious client cannot\n   obtain authorization without the awareness and explicit consent of\n   the resource owner.\n\n\n\n\nHardt                        Standards Track                   [Page 59]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.13.  Clickjacking\n\n   In a clickjacking attack, an attacker registers a legitimate client\n   and then constructs a malicious site in which it loads the\n   authorization server's authorization endpoint web page in a\n   transparent iframe overlaid on top of a set of dummy buttons, which\n   are carefully constructed to be placed directly under important\n   buttons on the authorization page.  When an end-user clicks a\n   misleading visible button, the end-user is actually clicking an\n   invisible button on the authorization page (such as an \"Authorize\"\n   button).  This allows an attacker to trick a resource owner into\n   granting its client access without the end-user's knowledge.\n\n   To prevent this form of attack, native applications SHOULD use\n   external browsers instead of embedding browsers within the\n   application when requesting end-user authorization.  For most newer\n   browsers, avoidance of iframes can be enforced by the authorization\n   server using the (non-standard) \"x-frame-options\" header.  This\n   header can have two values, \"deny\" and \"sameorigin\", which will block\n   any framing, or framing by sites with a different origin,\n   respectively.  For older browsers, JavaScript frame-busting\n   techniques can be used but may not be effective in all browsers.\n\n10.14.  Code Injection and Input Validation\n\n   A code injection attack occurs when an input or otherwise external\n   variable is used by an application unsanitized and causes\n   modification to the application logic.  This may allow an attacker to\n   gain access to the application device or its data, cause denial of\n   service, or introduce a wide range of malicious side-effects.\n\n   The authorization server and client MUST sanitize (and validate when\n   possible) any value received -- in particular, the value of the\n   \"state\" and \"redirect_uri\" parameters.\n\n10.15.  Open Redirectors\n\n   The authorization server, authorization endpoint, and client\n   redirection endpoint can be improperly configured and operate as open\n   redirectors.  An open redirector is an endpoint using a parameter to\n   automatically redirect a user-agent to the location specified by the\n   parameter value without any validation.\n\n   Open redirectors can be used in phishing attacks, or by an attacker\n   to get end-users to visit malicious sites by using the URI authority\n   component of a familiar and trusted destination.  In addition, if the\n   authorization server allows the client to register only part of the\n   redirection URI, an attacker can use an open redirector operated by\n\n\n\nHardt                        Standards Track                   [Page 60]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   the client to construct a redirection URI that will pass the\n   authorization server validation but will send the authorization code\n   or access token to an endpoint under the control of the attacker.\n\n10.16.  Misuse of Access Token to Impersonate Resource Owner in Implicit\n        Flow\n\n   For public clients using implicit flows, this specification does not\n   provide any method for the client to determine what client an access\n   token was issued to.\n\n   A resource owner may willingly delegate access to a resource by\n   granting an access token to an attacker's malicious client.  This may\n   be due to phishing or some other pretext.  An attacker may also steal\n   a token via some other mechanism.  An attacker may then attempt to\n   impersonate the resource owner by providing the access token to a\n   legitimate public client."
      },
      {
        "chunk_id": "rfc_oauth_chunk_37",
        "original_index": 37,
        "content": "In the implicit flow (response_type=token), the attacker can easily\n   switch the token in the response from the authorization server,\n   replacing the real access token with the one previously issued to the\n   attacker.\n\n   Servers communicating with native applications that rely on being\n   passed an access token in the back channel to identify the user of\n   the client may be similarly compromised by an attacker creating a\n   compromised application that can inject arbitrary stolen access\n   tokens.\n\n   Any public client that makes the assumption that only the resource\n   owner can present it with a valid access token for the resource is\n   vulnerable to this type of attack.\n\n   This type of attack may expose information about the resource owner\n   at the legitimate client to the attacker (malicious client).  This\n   will also allow the attacker to perform operations at the legitimate\n   client with the same permissions as the resource owner who originally\n   granted the access token or authorization code.\n\n   Authenticating resource owners to clients is out of scope for this\n   specification.  Any specification that uses the authorization process\n   as a form of delegated end-user authentication to the client (e.g.,\n   third-party sign-in service) MUST NOT use the implicit flow without\n   additional security mechanisms that would enable the client to\n   determine if the access token was issued for its use (e.g., audience-\n   restricting the access token).\n\n\n\n\n\nHardt                        Standards Track                   [Page 61]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.  IANA Considerations\n\n11.1.  OAuth Access Token Types Registry\n\n   This specification establishes the OAuth Access Token Types registry.\n\n   Access token types are registered with a Specification Required\n   ([RFC5226]) after a two-week review period on the\n   oauth-ext-review@ietf.org mailing list, on the advice of one or more\n   Designated Experts.  However, to allow for the allocation of values\n   prior to publication, the Designated Expert(s) may approve\n   registration once they are satisfied that such a specification will\n   be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for access token type: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.1.1.  Registration Template\n\n   Type name:\n      The name requested (e.g., \"example\").\n\n   Additional Token Endpoint Response Parameters:\n      Additional response parameters returned together with the\n      \"access_token\" parameter.  New parameters MUST be separately\n      registered in the OAuth Parameters registry as described by\n      Section 11.2.\n\n   HTTP Authentication Scheme(s):\n      The HTTP authentication scheme name(s), if any, used to\n      authenticate protected resource requests using access tokens of\n      this type.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n\n\nHardt                        Standards Track                   [Page 62]\n\f\nRFC 6749                        OAuth 2.0                   October 2012"
      },
      {
        "chunk_id": "rfc_oauth_chunk_38",
        "original_index": 38,
        "content": "Hardt                        Standards Track                   [Page 62]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Specification document(s):\n      Reference to the document(s) that specify the parameter,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n11.2.  OAuth Parameters Registry\n\n   This specification establishes the OAuth Parameters registry.\n\n   Additional parameters for inclusion in the authorization endpoint\n   request, the authorization endpoint response, the token endpoint\n   request, or the token endpoint response are registered with a\n   Specification Required ([RFC5226]) after a two-week review period on\n   the oauth-ext-review@ietf.org mailing list, on the advice of one or\n   more Designated Experts.  However, to allow for the allocation of\n   values prior to publication, the Designated Expert(s) may approve\n   registration once they are satisfied that such a specification will\n   be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for parameter: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.2.1.  Registration Template\n\n   Parameter name:\n      The name requested (e.g., \"example\").\n\n   Parameter usage location:\n      The location(s) where parameter can be used.  The possible\n      locations are authorization request, authorization response, token\n      request, or token response.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n\n\nHardt                        Standards Track                   [Page 63]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Specification document(s):\n      Reference to the document(s) that specify the parameter,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n11.2.2.  Initial Registry Contents\n\n   The OAuth Parameters registry's initial contents are:\n\n   o  Parameter name: client_id\n   o  Parameter usage location: authorization request, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: client_secret\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: response_type\n   o  Parameter usage location: authorization request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: redirect_uri\n   o  Parameter usage location: authorization request, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: scope\n   o  Parameter usage location: authorization request, authorization\n      response, token request, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: state\n   o  Parameter usage location: authorization request, authorization\n      response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749"
      },
      {
        "chunk_id": "rfc_oauth_chunk_39",
        "original_index": 39,
        "content": "o  Parameter name: state\n   o  Parameter usage location: authorization request, authorization\n      response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: code\n   o  Parameter usage location: authorization response, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n\n\n\n\nHardt                        Standards Track                   [Page 64]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   o  Parameter name: error_description\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: error_uri\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: grant_type\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: access_token\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: token_type\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: expires_in\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: username\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: password\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: refresh_token\n   o  Parameter usage location: token request, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 65]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.3.  OAuth Authorization Endpoint Response Types Registry\n\n   This specification establishes the OAuth Authorization Endpoint\n   Response Types registry.\n\n   Additional response types for use with the authorization endpoint are\n   registered with a Specification Required ([RFC5226]) after a two-week\n   review period on the oauth-ext-review@ietf.org mailing list, on the\n   advice of one or more Designated Experts.  However, to allow for the\n   allocation of values prior to publication, the Designated Expert(s)\n   may approve registration once they are satisfied that such a\n   specification will be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for response type: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.3.1.  Registration Template\n\n   Response type name:\n      The name requested (e.g., \"example\").\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included."
      },
      {
        "chunk_id": "rfc_oauth_chunk_40",
        "original_index": 40,
        "content": "Specification document(s):\n      Reference to the document(s) that specify the type, preferably\n      including a URI that can be used to retrieve a copy of the\n      document(s).  An indication of the relevant sections may also be\n      included but is not required.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 66]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.3.2.  Initial Registry Contents\n\n   The OAuth Authorization Endpoint Response Types registry's initial\n   contents are:\n\n   o  Response type name: code\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Response type name: token\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n11.4.  OAuth Extensions Error Registry\n\n   This specification establishes the OAuth Extensions Error registry.\n\n   Additional error codes used together with other protocol extensions\n   (i.e., extension grant types, access token types, or extension\n   parameters) are registered with a Specification Required ([RFC5226])\n   after a two-week review period on the oauth-ext-review@ietf.org\n   mailing list, on the advice of one or more Designated Experts.\n   However, to allow for the allocation of values prior to publication,\n   the Designated Expert(s) may approve registration once they are\n   satisfied that such a specification will be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for error code: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 67]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.4.1.  Registration Template\n\n   Error name:\n      The name requested (e.g., \"example\").  Values for the error name\n      MUST NOT include characters outside the set %x20-21 / %x23-5B /\n      %x5D-7E.\n\n   Error usage location:\n      The location(s) where the error can be used.  The possible\n      locations are authorization code grant error response\n      (Section 4.1.2.1), implicit grant error response\n      (Section 4.2.2.1), token error response (Section 5.2), or resource\n      access error response (Section 7.2).\n\n   Related protocol extension:\n      The name of the extension grant type, access token type, or\n      extension parameter that the error code is used in conjunction\n      with.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n   Specification document(s):\n      Reference to the document(s) that specify the error code,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n12.  References\n\n12.1.  Normative References\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\n   [RFC2246]  Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\",\n              RFC 2246, January 1999.\n\n   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999."
      },
      {
        "chunk_id": "rfc_oauth_chunk_41",
        "original_index": 41,
        "content": "[RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n              Leach, P., Luotonen, A., and L. Stewart, \"HTTP\n              Authentication: Basic and Digest Access Authentication\",\n              RFC 2617, June 1999.\n\n\n\nHardt                        Standards Track                   [Page 68]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.\n\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of\n              ISO 10646\", STD 63, RFC 3629, November 2003.\n\n   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, January 2005.\n\n   [RFC4627]  Crockford, D., \"The application/json Media Type for\n              JavaScript Object Notation (JSON)\", RFC 4627, July 2006.\n\n   [RFC4949]  Shirey, R., \"Internet Security Glossary, Version 2\",\n              RFC 4949, August 2007.\n\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n\n   [RFC5234]  Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n\n   [RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification of Domain-Based Application Service Identity\n              within Internet Public Key Infrastructure Using X.509\n              (PKIX) Certificates in the Context of Transport Layer\n              Security (TLS)\", RFC 6125, March 2011.\n\n   [USASCII]  American National Standards Institute, \"Coded Character\n              Set -- 7-bit American Standard Code for Information\n              Interchange\", ANSI X3.4, 1986.\n\n   [W3C.REC-html401-19991224]\n              Raggett, D., Le Hors, A., and I. Jacobs, \"HTML 4.01\n              Specification\", World Wide Web Consortium\n              Recommendation REC-html401-19991224, December 1999,\n              <http://www.w3.org/TR/1999/REC-html401-19991224>.\n\n   [W3C.REC-xml-20081126]\n              Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,\n              and F. Yergeau, \"Extensible Markup Language (XML) 1.0\n              (Fifth Edition)\", World Wide Web Consortium\n               Recommendation REC-xml-20081126, November 2008,\n              <http://www.w3.org/TR/2008/REC-xml-20081126>.\n\n\n\n\nHardt                        Standards Track                   [Page 69]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n12.2.  Informative References\n\n   [OAuth-HTTP-MAC]\n              Hammer-Lahav, E., Ed., \"HTTP Authentication: MAC Access\n              Authentication\", Work in Progress, February 2012.\n\n   [OAuth-SAML2]\n              Campbell, B. and C. Mortimore, \"SAML 2.0 Bearer Assertion\n              Profiles for OAuth 2.0\", Work in Progress, September 2012.\n\n   [OAuth-THREATMODEL]\n              Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \"OAuth 2.0\n              Threat Model and Security Considerations\", Work\n              in Progress, October 2012.\n\n   [OAuth-WRAP]\n              Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, \"OAuth\n              Web Resource Authorization Profiles\", Work in Progress,\n              January 2010.\n\n   [RFC5849]  Hammer-Lahav, E., \"The OAuth 1.0 Protocol\", RFC 5849,\n              April 2010.\n\n   [RFC6750]  Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization\n              Framework: Bearer Token Usage\", RFC 6750, October 2012.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 70]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nAppendix A.  Augmented Backus-Naur Form (ABNF) Syntax"
      },
      {
        "chunk_id": "rfc_oauth_chunk_42",
        "original_index": 42,
        "content": "Appendix A.  Augmented Backus-Naur Form (ABNF) Syntax\n\n   This section provides Augmented Backus-Naur Form (ABNF) syntax\n   descriptions for the elements defined in this specification using the\n   notation of [RFC5234].  The ABNF below is defined in terms of Unicode\n   code points [W3C.REC-xml-20081126]; these characters are typically\n   encoded in UTF-8.  Elements are presented in the order first defined.\n\n   Some of the definitions that follow use the \"URI-reference\"\n   definition from [RFC3986].\n\n   Some of the definitions that follow use these common definitions:\n\n     VSCHAR     = %x20-7E\n     NQCHAR     = %x21 / %x23-5B / %x5D-7E\n     NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E\n     UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /\n                         %xE000-FFFD / %x10000-10FFFF\n\n   (The UNICODECHARNOCRLF definition is based upon the Char definition\n   in Section 2.2 of [W3C.REC-xml-20081126], but omitting the Carriage\n   Return and Linefeed characters.)\n\nA.1.  \"client_id\" Syntax\n\n   The \"client_id\" element is defined in Section 2.3.1:\n\n     client-id     = *VSCHAR\n\nA.2.  \"client_secret\" Syntax\n\n   The \"client_secret\" element is defined in Section 2.3.1:\n\n     client-secret = *VSCHAR\n\nA.3.  \"response_type\" Syntax\n\n   The \"response_type\" element is defined in Sections 3.1.1 and 8.4:\n\n     response-type = response-name *( SP response-name )\n     response-name = 1*response-char\n     response-char = \"_\" / DIGIT / ALPHA\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 71]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.4.  \"scope\" Syntax\n\n   The \"scope\" element is defined in Section 3.3:\n\n     scope       = scope-token *( SP scope-token )\n     scope-token = 1*NQCHAR\n\nA.5.  \"state\" Syntax\n\n   The \"state\" element is defined in Sections 4.1.1, 4.1.2, 4.1.2.1,\n   4.2.1, 4.2.2, and 4.2.2.1:\n\n     state      = 1*VSCHAR\n\nA.6.  \"redirect_uri\" Syntax\n\n   The \"redirect_uri\" element is defined in Sections 4.1.1, 4.1.3,\n   and 4.2.1:\n\n     redirect-uri      = URI-reference\n\nA.7.  \"error\" Syntax\n\n   The \"error\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\n   7.2, and 8.5:\n\n     error             = 1*NQSCHAR\n\nA.8.  \"error_description\" Syntax\n\n   The \"error_description\" element is defined in Sections 4.1.2.1,\n   4.2.2.1, 5.2, and 7.2:\n\n     error-description = 1*NQSCHAR\n\nA.9.  \"error_uri\" Syntax\n\n   The \"error_uri\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\n   and 7.2:\n\n     error-uri         = URI-reference\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 72]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.10.  \"grant_type\" Syntax\n\n   The \"grant_type\" element is defined in Sections 4.1.3, 4.3.2, 4.4.2,\n   4.5, and 6:\n\n     grant-type = grant-name / URI-reference\n     grant-name = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nA.11.  \"code\" Syntax\n\n   The \"code\" element is defined in Section 4.1.3:\n\n     code       = 1*VSCHAR\n\nA.12.  \"access_token\" Syntax\n\n   The \"access_token\" element is defined in Sections 4.2.2 and 5.1:\n\n     access-token = 1*VSCHAR\n\nA.13.  \"token_type\" Syntax\n\n   The \"token_type\" element is defined in Sections 4.2.2, 5.1, and 8.1:\n\n     token-type = type-name / URI-reference\n     type-name  = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nA.14.  \"expires_in\" Syntax\n\n   The \"expires_in\" element is defined in Sections 4.2.2 and 5.1:\n\n     expires-in = 1*DIGIT\n\nA.15.  \"username\" Syntax\n\n   The \"username\" element is defined in Section 4.3.2:\n\n     username = *UNICODECHARNOCRLF\n\nA.16.  \"password\" Syntax\n\n   The \"password\" element is defined in Section 4.3.2:\n\n     password = *UNICODECHARNOCRLF\n\n\n\n\n\nHardt                        Standards Track                   [Page 73]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.17.  \"refresh_token\" Syntax\n\n   The \"refresh_token\" element is defined in Sections 5.1 and 6:"
      },
      {
        "chunk_id": "rfc_oauth_chunk_43",
        "original_index": 43,
        "content": "A.17.  \"refresh_token\" Syntax\n\n   The \"refresh_token\" element is defined in Sections 5.1 and 6:\n\n     refresh-token = 1*VSCHAR\n\nA.18.  Endpoint Parameter Syntax\n\n   The syntax for new endpoint parameters is defined in Section 8.2:\n\n     param-name = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nAppendix B.  Use of application/x-www-form-urlencoded Media Type\n\n   At the time of publication of this specification, the\n   \"application/x-www-form-urlencoded\" media type was defined in\n   Section 17.13.4 of [W3C.REC-html401-19991224] but not registered in\n   the IANA MIME Media Types registry\n   (<http://www.iana.org/assignments/media-types>).  Furthermore, that\n   definition is incomplete, as it does not consider non-US-ASCII\n   characters.\n\n   To address this shortcoming when generating payloads using this media\n   type, names and values MUST be encoded using the UTF-8 character\n   encoding scheme [RFC3629] first; the resulting octet sequence then\n   needs to be further encoded using the escaping rules defined in\n   [W3C.REC-html401-19991224].\n\n   When parsing data from a payload using this media type, the names and\n   values resulting from reversing the name/value encoding consequently\n   need to be treated as octet sequences, to be decoded using the UTF-8\n   character encoding scheme.\n\n   For example, the value consisting of the six Unicode code points\n   (1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN),\n   (3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN),\n   (5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN) would be encoded\n   into the octet sequence below (using hexadecimal notation):\n\n     20 25 26 2B C2 A3 E2 82 AC\n\n   and then represented in the payload as:\n\n     +%25%26%2B%C2%A3%E2%82%AC\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 74]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nAppendix C.  Acknowledgements\n\n   The initial OAuth 2.0 protocol specification was edited by David\n   Recordon, based on two previous publications: the OAuth 1.0 community\n   specification [RFC5849], and OAuth WRAP (OAuth Web Resource\n   Authorization Profiles) [OAuth-WRAP].  Eran Hammer then edited many\n   of the intermediate drafts that evolved into this RFC.  The Security\n   Considerations section was drafted by Torsten Lodderstedt, Mark\n   McGloin, Phil Hunt, Anthony Nadalin, and John Bradley.  The section\n   on use of the \"application/x-www-form-urlencoded\" media type was\n   drafted by Julian Reschke.  The ABNF section was drafted by Michael\n   B. Jones.\n\n   The OAuth 1.0 community specification was edited by Eran Hammer and\n   authored by Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M.\n   Conlan, Blaine Cook, Leah Culver, Breno de Medeiros, Brian Eaton,\n   Kellan Elliott-McCrea, Larry Halff, Eran Hammer, Ben Laurie, Chris\n   Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,\n   Jonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.\n\n   The OAuth WRAP specification was edited by Dick Hardt and authored by\n   Brian Eaton, Yaron Y. Goland, Dick Hardt, and Allen Tom.\n\n   This specification is the work of the OAuth Working Group, which\n   includes dozens of active and dedicated participants.  In particular,\n   the following individuals contributed ideas, feedback, and wording\n   that shaped and formed the final specification:"
      },
      {
        "chunk_id": "rfc_oauth_chunk_44",
        "original_index": 44,
        "content": "Michael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden\n   Bell, John Bradley, Marcos Caceres, Brian Campbell, Scott Cantor,\n   Blaine Cook, Roger Crew, Leah Culver, Bill de hOra, Andre DeMarre,\n   Brian Eaton, Wesley Eddy, Wolter Eldering, Brian Ellin, Igor\n   Faynberg, George Fletcher, Tim Freeman, Luca Frosini, Evan Gilbert,\n   Yaron Y. Goland, Brent Goldman, Kristoffer Gronowski, Eran Hammer,\n   Dick Hardt, Justin Hart, Craig Heath, Phil Hunt, Michael B. Jones,\n   Terry Jones, John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara,\n   Rasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Casey Lucas, Paul\n   Madsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin,\n   Laurence Miao, William Mills, Chuck Mortimore, Anthony Nadalin,\n   Julian Reschke, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob\n   Sayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov,\n   Justin Smith, Haibin Song, Niv Steingarten, Christian Stuebner,\n   Jeremy Suriel, Paul Tarjan, Christopher Thomas, Henry S. Thompson,\n   Allen Tom, Franklin Tse, Nick Walker, Shane Weeden, and Skylar\n   Woodward.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 75]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   This document was produced under the chairmanship of Blaine Cook,\n   Peter Saint-Andre, Hannes Tschofenig, Barry Leiba, and Derek Atkins.\n   The area directors included Lisa Dusseault, Peter Saint-Andre, and\n   Stephen Farrell.\n\nAuthor's Address\n\n   Dick Hardt (editor)\n   Microsoft\n\n   EMail: dick.hardt@gmail.com\n   URI:   http://dickhardt.org/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 76]"
      }
    ]
  },
  {
    "doc_id": "rfc_standards_complete",
    "original_uuid": "5015",
    "content": "\n\n==================== RFC - HTTP ====================\n\n\n\n\n\n\n\nNetwork Working Group                                      R. Fielding\nRequest for Comments: 2616                                   UC Irvine\nObsoletes: 2068                                              J. Gettys\nCategory: Standards Track                                   Compaq/W3C\n                                                              J. Mogul\n                                                                Compaq\n                                                            H. Frystyk\n                                                               W3C/MIT\n                                                           L. Masinter\n                                                                 Xerox\n                                                              P. Leach\n                                                             Microsoft\n                                                        T. Berners-Lee\n                                                               W3C/MIT\n                                                             June 1999\n\n\n                Hypertext Transfer Protocol -- HTTP/1.1\n\nStatus of this Memo\n\n   This document specifies an Internet standards track protocol for the\n   Internet community, and requests discussion and suggestions for\n   improvements.  Please refer to the current edition of the \"Internet\n   Official Protocol Standards\" (STD 1) for the standardization state\n   and status of this protocol.  Distribution of this memo is unlimited.\n\nCopyright Notice\n\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n\nAbstract\n\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n   protocol for distributed, collaborative, hypermedia information\n   systems. It is a generic, stateless, protocol which can be used for\n   many tasks beyond its use for hypertext, such as name servers and\n   distributed object management systems, through extension of its\n   request methods, error codes and headers [47]. A feature of HTTP is\n   the typing and negotiation of data representation, allowing systems\n   to be built independently of the data being transferred.\n\n   HTTP has been in use by the World-Wide Web global information\n   initiative since 1990. This specification defines the protocol\n   referred to as \"HTTP/1.1\", and is an update to RFC 2068 [33].\n\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 1]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\nTable of Contents\n\n   1   Introduction ...................................................7\n   1.1    Purpose......................................................7\n   1.2   Requirements .................................................8\n   1.3   Terminology ..................................................8\n   1.4   Overall Operation ...........................................12\n   2   Notational Conventions and Generic Grammar ....................14\n   2.1   Augmented BNF ...............................................14\n   2.2   Basic Rules .................................................15\n   3   Protocol Parameters ...........................................17\n   3.1   HTTP Version ................................................17\n   3.2   Uniform Resource Identifiers ................................18\n   3.2.1    General Syntax ...........................................19\n   3.2.2    http URL .................................................19\n   3.2.3    URI Comparison ...........................................20\n   3.3   Date/Time Formats ...........................................20\n   3.3.1    Full Date ................................................20\n   3.3.2    Delta Seconds ............................................21\n   3.4   Character Sets ..............................................21\n   3.4.1    Missing Charset ..........................................22\n   3.5   Content Codings .............................................23\n   3.6   Transfer Codings ............................................24\n   3.6.1    Chunked Transfer Coding ..................................25\n   3.7   Media Types .................................................26\n   3.7.1    Canonicalization and Text Defaults .......................27\n   3.7.2    Multipart Types ..........................................27\n   3.8   Product Tokens ..............................................28\n   3.9   Quality Values ..............................................29\n   3.10  Language Tags ...............................................29\n   3.11  Entity Tags .................................................30\n   3.12  Range Units .................................................30\n   4   HTTP Message ..................................................31\n   4.1   Message Types ...............................................31\n   4.2   Message Headers .............................................31\n   4.3   Message Body ................................................32\n   4.4   Message Length ..............................................33\n   4.5   General Header Fields .......................................34\n   5   Request .......................................................35\n   5.1   Request-Line ................................................35\n   5.1.1    Method ...................................................36\n   5.1.2    Request-URI ..............................................36\n   5.2   The Resource Identified by a Request ........................38\n   5.3   Request Header Fields .......................................38\n   6   Response ......................................................39\n   6.1   Status-Line .................................................39\n   6.1.1    Status Code and Reason Phrase ............................39\n   6.2   Response Header Fields ......................................41\n\n\n\nFielding, et al.            Standards Track                     [Page 2]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   7   Entity ........................................................42\n   7.1   Entity Header Fields ........................................42\n   7.2   Entity Body .................................................43\n   7.2.1    Type .....................................................43\n   7.2.2    Entity Length ............................................43\n   8   Connections ...................................................44\n   8.1   Persistent Connections ......................................44\n   8.1.1    Purpose ..................................................44\n   8.1.2    Overall Operation ........................................45\n   8.1.3    Proxy Servers ............................................46\n   8.1.4    Practical Considerations .................................46\n   8.2   Message Transmission Requirements ...........................47\n   8.2.1    Persistent Connections and Flow Control ..................47\n   8.2.2    Monitoring Connections for Error Status Messages .........48\n   8.2.3    Use of the 100 (Continue) Status .........................48\n   8.2.4    Client Behavior if Server Prematurely Closes Connection ..50\n   9   Method Definitions ............................................51\n   9.1   Safe and Idempotent Methods .................................51\n   9.1.1    Safe Methods .............................................51\n   9.1.2    Idempotent Methods .......................................51\n   9.2   OPTIONS .....................................................52\n   9.3   GET .........................................................53\n   9.4   HEAD ........................................................54\n   9.5   POST ........................................................54\n   9.6   PUT .........................................................55\n   9.7   DELETE ......................................................56\n   9.8   TRACE .......................................................56\n   9.9   CONNECT .....................................................57\n   10   Status Code Definitions ......................................57\n   10.1  Informational 1xx ...........................................57\n   10.1.1   100 Continue .............................................58\n   10.1.2   101 Switching Protocols ..................................58\n   10.2  Successful 2xx ..............................................58\n   10.2.1   200 OK ...................................................58\n   10.2.2   201 Created ..............................................59\n   10.2.3   202 Accepted .............................................59\n   10.2.4   203 Non-Authoritative Information ........................59\n   10.2.5   204 No Content ...........................................60\n   10.2.6   205 Reset Content ........................................60\n   10.2.7   206 Partial Content ......................................60\n   10.3  Redirection 3xx .............................................61\n   10.3.1   300 Multiple Choices .....................................61\n   10.3.2   301 Moved Permanently ....................................62\n   10.3.3   302 Found ................................................62\n   10.3.4   303 See Other ............................................63\n   10.3.5   304 Not Modified .........................................63\n   10.3.6   305 Use Proxy ............................................64\n   10.3.7   306 (Unused) .............................................64\n\n\n\nFielding, et al.            Standards Track                     [Page 3]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   10.3.8   307 Temporary Redirect ...................................65\n   10.4  Client Error 4xx ............................................65\n   10.4.1    400 Bad Request .........................................65\n   10.4.2    401 Unauthorized ........................................66\n   10.4.3    402 Payment Required ....................................66\n   10.4.4    403 Forbidden ...........................................66\n   10.4.5    404 Not Found ...........................................66\n   10.4.6    405 Method Not Allowed ..................................66\n   10.4.7    406 Not Acceptable ......................................67\n   10.4.8    407 Proxy Authentication Required .......................67\n   10.4.9    408 Request Timeout .....................................67\n   10.4.10   409 Conflict ............................................67\n   10.4.11   410 Gone ................................................68\n   10.4.12   411 Length Required .....................................68\n   10.4.13   412 Precondition Failed .................................68\n   10.4.14   413 Request Entity Too Large ............................69\n   10.4.15   414 Request-URI Too Long ................................69\n   10.4.16   415 Unsupported Media Type ..............................69\n   10.4.17   416 Requested Range Not Satisfiable .....................69\n   10.4.18   417 Expectation Failed ..................................70\n   10.5  Server Error 5xx ............................................70\n   10.5.1   500 Internal Server Error ................................70\n   10.5.2   501 Not Implemented ......................................70\n   10.5.3   502 Bad Gateway ..........................................70\n   10.5.4   503 Service Unavailable ..................................70\n   10.5.5   504 Gateway Timeout ......................................71\n   10.5.6   505 HTTP Version Not Supported ...........................71\n   11   Access Authentication ........................................71\n   12   Content Negotiation ..........................................71\n   12.1  Server-driven Negotiation ...................................72\n   12.2  Agent-driven Negotiation ....................................73\n   12.3  Transparent Negotiation .....................................74\n   13   Caching in HTTP ..............................................74\n   13.1.1   Cache Correctness ........................................75\n   13.1.2   Warnings .................................................76\n   13.1.3   Cache-control Mechanisms .................................77\n   13.1.4   Explicit User Agent Warnings .............................78\n   13.1.5   Exceptions to the Rules and Warnings .....................78\n   13.1.6   Client-controlled Behavior ...............................79\n   13.2  Expiration Model ............................................79\n   13.2.1   Server-Specified Expiration ..............................79\n   13.2.2   Heuristic Expiration .....................................80\n   13.2.3   Age Calculations .........................................80\n   13.2.4   Expiration Calculations ..................................83\n   13.2.5   Disambiguating Expiration Values .........................84\n   13.2.6   Disambiguating Multiple Responses ........................84\n   13.3  Validation Model ............................................85\n   13.3.1   Last-Modified Dates ......................................86\n\n\n\nFielding, et al.            Standards Track                     [Page 4]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   13.3.2   Entity Tag Cache Validators ..............................86\n   13.3.3   Weak and Strong Validators ...............................86\n   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89\n   13.3.5   Non-validating Conditionals ..............................90\n   13.4  Response Cacheability .......................................91\n   13.5  Constructing Responses From Caches ..........................92\n   13.5.1   End-to-end and Hop-by-hop Headers ........................92\n   13.5.2   Non-modifiable Headers ...................................92\n   13.5.3   Combining Headers ........................................94\n   13.5.4   Combining Byte Ranges ....................................95\n   13.6  Caching Negotiated Responses ................................95\n   13.7  Shared and Non-Shared Caches ................................96\n   13.8  Errors or Incomplete Response Cache Behavior ................97\n   13.9  Side Effects of GET and HEAD ................................97\n   13.10   Invalidation After Updates or Deletions ...................97\n   13.11   Write-Through Mandatory ...................................98\n   13.12   Cache Replacement .........................................99\n   13.13   History Lists .............................................99\n   14   Header Field Definitions ....................................100\n   14.1  Accept .....................................................100\n   14.2  Accept-Charset .............................................102\n   14.3  Accept-Encoding ............................................102\n   14.4  Accept-Language ............................................104\n   14.5  Accept-Ranges ..............................................105\n   14.6  Age ........................................................106\n   14.7  Allow ......................................................106\n   14.8  Authorization ..............................................107\n   14.9  Cache-Control ..............................................108\n   14.9.1   What is Cacheable .......................................109\n   14.9.2   What May be Stored by Caches ............................110\n   14.9.3   Modifications of the Basic Expiration Mechanism .........111\n   14.9.4   Cache Revalidation and Reload Controls ..................113\n   14.9.5   No-Transform Directive ..................................115\n   14.9.6   Cache Control Extensions ................................116\n   14.10   Connection ...............................................117\n   14.11   Content-Encoding .........................................118\n   14.12   Content-Language .........................................118\n   14.13   Content-Length ...........................................119\n   14.14   Content-Location .........................................120\n   14.15   Content-MD5 ..............................................121\n   14.16   Content-Range ............................................122\n   14.17   Content-Type .............................................124\n   14.18   Date .....................................................124\n   14.18.1   Clockless Origin Server Operation ......................125\n   14.19   ETag .....................................................126\n   14.20   Expect ...................................................126\n   14.21   Expires ..................................................127\n   14.22   From .....................................................128\n\n\n\nFielding, et al.            Standards Track                     [Page 5]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   14.23   Host .....................................................128\n   14.24   If-Match .................................................129\n   14.25   If-Modified-Since ........................................130\n   14.26   If-None-Match ............................................132\n   14.27   If-Range .................................................133\n   14.28   If-Unmodified-Since ......................................134\n   14.29   Last-Modified ............................................134\n   14.30   Location .................................................135\n   14.31   Max-Forwards .............................................136\n   14.32   Pragma ...................................................136\n   14.33   Proxy-Authenticate .......................................137\n   14.34   Proxy-Authorization ......................................137\n   14.35   Range ....................................................138\n   14.35.1    Byte Ranges ...........................................138\n   14.35.2    Range Retrieval Requests ..............................139\n   14.36   Referer ..................................................140\n   14.37   Retry-After ..............................................141\n   14.38   Server ...................................................141\n   14.39   TE .......................................................142\n   14.40   Trailer ..................................................143\n   14.41  Transfer-Encoding..........................................143\n   14.42   Upgrade ..................................................144\n   14.43   User-Agent ...............................................145\n   14.44   Vary .....................................................145\n   14.45   Via ......................................................146\n   14.46   Warning ..................................................148\n   14.47   WWW-Authenticate .........................................150\n   15 Security Considerations .......................................150\n   15.1      Personal Information....................................151\n   15.1.1   Abuse of Server Log Information .........................151\n   15.1.2   Transfer of Sensitive Information .......................151\n   15.1.3   Encoding Sensitive Information in URI's .................152\n   15.1.4   Privacy Issues Connected to Accept Headers ..............152\n   15.2  Attacks Based On File and Path Names .......................153\n   15.3  DNS Spoofing ...............................................154\n   15.4  Location Headers and Spoofing ..............................154\n   15.5  Content-Disposition Issues .................................154\n   15.6  Authentication Credentials and Idle Clients ................155\n   15.7  Proxies and Caching ........................................155\n   15.7.1    Denial of Service Attacks on Proxies....................156\n   16   Acknowledgments .............................................156\n   17   References ..................................................158\n   18   Authors' Addresses ..........................................162\n   19   Appendices ..................................................164\n   19.1  Internet Media Type message/http and application/http ......164\n   19.2  Internet Media Type multipart/byteranges ...................165\n   19.3  Tolerant Applications ......................................166\n   19.4  Differences Between HTTP Entities and RFC 2045 Entities ....167\n\n\n\nFielding, et al.            Standards Track                     [Page 6]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   19.4.1   MIME-Version ............................................167\n   19.4.2   Conversion to Canonical Form ............................167\n   19.4.3   Conversion of Date Formats ..............................168\n   19.4.4   Introduction of Content-Encoding ........................168\n   19.4.5   No Content-Transfer-Encoding ............................168\n   19.4.6   Introduction of Transfer-Encoding .......................169\n   19.4.7   MHTML and Line Length Limitations .......................169\n   19.5  Additional Features ........................................169\n   19.5.1   Content-Disposition .....................................170\n   19.6  Compatibility with Previous Versions .......................170\n   19.6.1   Changes from HTTP/1.0 ...................................171\n   19.6.2   Compatibility with HTTP/1.0 Persistent Connections ......172\n   19.6.3   Changes from RFC 2068 ...................................172\n   20   Index .......................................................175\n   21   Full Copyright Statement ....................................176\n\n1 Introduction\n\n1.1 Purpose\n\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n   protocol for distributed, collaborative, hypermedia information\n   systems. HTTP has been in use by the World-Wide Web global\n   information initiative since 1990. The first version of HTTP,\n   referred to as HTTP/0.9, was a simple protocol for raw data transfer\n   across the Internet. HTTP/1.0, as defined by RFC 1945 [6], improved\n   the protocol by allowing messages to be in the format of MIME-like\n   messages, containing metainformation about the data transferred and\n   modifiers on the request/response semantics. However, HTTP/1.0 does\n   not sufficiently take into consideration the effects of hierarchical\n   proxies, caching, the need for persistent connections, or virtual\n   hosts. In addition, the proliferation of incompletely-implemented\n   applications calling themselves \"HTTP/1.0\" has necessitated a\n   protocol version change in order for two communicating applications\n   to determine each other's true capabilities.\n\n   This specification defines the protocol referred to as \"HTTP/1.1\".\n   This protocol includes more stringent requirements than HTTP/1.0 in\n   order to ensure reliable implementation of its features.\n\n   Practical information systems require more functionality than simple\n   retrieval, including search, front-end update, and annotation. HTTP\n   allows an open-ended set of methods and headers that indicate the\n   purpose of a request [47]. It builds on the discipline of reference\n   provided by the Uniform Resource Identifier (URI) [3], as a location\n   (URL) [4] or name (URN) [20], for indicating the resource to which a\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 7]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   method is to be applied. Messages are passed in a format similar to\n   that used by Internet mail [9] as defined by the Multipurpose\n   Internet Mail Extensions (MIME) [7].\n\n   HTTP is also used as a generic protocol for communication between\n   user agents and proxies/gateways to other Internet systems, including\n   those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2],\n   and WAIS [10] protocols. In this way, HTTP allows basic hypermedia\n   access to resources available from diverse applications.\n\n1.2 Requirements\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC 2119 [34].\n\n   An implementation is not compliant if it fails to satisfy one or more\n   of the MUST or REQUIRED level requirements for the protocols it\n   implements. An implementation that satisfies all the MUST or REQUIRED\n   level and all the SHOULD level requirements for its protocols is said\n   to be \"unconditionally compliant\"; one that satisfies all the MUST\n   level requirements but not all the SHOULD level requirements for its\n   protocols is said to be \"conditionally compliant.\"\n\n1.3 Terminology\n\n   This specification uses a number of terms to refer to the roles\n   played by participants in, and objects of, the HTTP communication.\n\n   connection\n      A transport layer virtual circuit established between two programs\n      for the purpose of communication.\n\n   message\n      The basic unit of HTTP communication, consisting of a structured\n      sequence of octets matching the syntax defined in section 4 and\n      transmitted via the connection.\n\n   request\n      An HTTP request message, as defined in section 5.\n\n   response\n      An HTTP response message, as defined in section 6.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 8]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   resource\n      A network data object or service that can be identified by a URI,\n      as defined in section 3.2. Resources may be available in multiple\n      representations (e.g. multiple languages, data formats, size, and\n      resolutions) or vary in other ways.\n\n   entity\n      The information transferred as the payload of a request or\n      response. An entity consists of metainformation in the form of\n      entity-header fields and content in the form of an entity-body, as\n      described in section 7.\n\n   representation\n      An entity included with a response that is subject to content\n      negotiation, as described in section 12. There may exist multiple\n      representations associated with a particular response status.\n\n   content negotiation\n      The mechanism for selecting the appropriate representation when\n      servicing a request, as described in section 12. The\n      representation of entities in any response can be negotiated\n      (including error responses).\n\n   variant\n      A resource may have one, or more than one, representation(s)\n      associated with it at any given instant. Each of these\n      representations is termed a `varriant'.  Use of the term `variant'\n      does not necessarily imply that the resource is subject to content\n      negotiation.\n\n   client\n      A program that establishes connections for the purpose of sending\n      requests.\n\n   user agent\n      The client which initiates a request. These are often browsers,\n      editors, spiders (web-traversing robots), or other end user tools.\n\n   server\n      An application program that accepts connections in order to\n      service requests by sending back responses. Any given program may\n      be capable of being both a client and a server; our use of these\n      terms refers only to the role being performed by the program for a\n      particular connection, rather than to the program's capabilities\n      in general. Likewise, any server may act as an origin server,\n      proxy, gateway, or tunnel, switching behavior based on the nature\n      of each request.\n\n\n\n\nFielding, et al.            Standards Track                     [Page 9]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   origin server\n      The server on which a given resource resides or is to be created.\n\n   proxy\n      An intermediary program which acts as both a server and a client\n      for the purpose of making requests on behalf of other clients.\n      Requests are serviced internally or by passing them on, with\n      possible translation, to other servers. A proxy MUST implement\n      both the client and server requirements of this specification. A\n      \"transparent proxy\" is a proxy that does not modify the request or\n      response beyond what is required for proxy authentication and\n      identification. A \"non-transparent proxy\" is a proxy that modifies\n      the request or response in order to provide some added service to\n      the user agent, such as group annotation services, media type\n      transformation, protocol reduction, or anonymity filtering. Except\n      where either transparent or non-transparent behavior is explicitly\n      stated, the HTTP proxy requirements apply to both types of\n      proxies.\n\n   gateway\n      A server which acts as an intermediary for some other server.\n      Unlike a proxy, a gateway receives requests as if it were the\n      origin server for the requested resource; the requesting client\n      may not be aware that it is communicating with a gateway.\n\n   tunnel\n      An intermediary program which is acting as a blind relay between\n      two connections. Once active, a tunnel is not considered a party\n      to the HTTP communication, though the tunnel may have been\n      initiated by an HTTP request. The tunnel ceases to exist when both\n      ends of the relayed connections are closed.\n\n   cache\n      A program's local store of response messages and the subsystem\n      that controls its message storage, retrieval, and deletion. A\n      cache stores cacheable responses in order to reduce the response\n      time and network bandwidth consumption on future, equivalent\n      requests. Any client or server may include a cache, though a cache\n      cannot be used by a server that is acting as a tunnel.\n\n   cacheable\n      A response is cacheable if a cache is allowed to store a copy of\n      the response message for use in answering subsequent requests. The\n      rules for determining the cacheability of HTTP responses are\n      defined in section 13. Even if a resource is cacheable, there may\n      be additional constraints on whether a cache can use the cached\n      copy for a particular request.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 10]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   first-hand\n      A response is first-hand if it comes directly and without\n      unnecessary delay from the origin server, perhaps via one or more\n      proxies. A response is also first-hand if its validity has just\n      been checked directly with the origin server.\n\n   explicit expiration time\n      The time at which the origin server intends that an entity should\n      no longer be returned by a cache without further validation.\n\n   heuristic expiration time\n      An expiration time assigned by a cache when no explicit expiration\n      time is available.\n\n   age\n      The age of a response is the time since it was sent by, or\n      successfully validated with, the origin server.\n\n   freshness lifetime\n      The length of time between the generation of a response and its\n      expiration time.\n\n   fresh\n      A response is fresh if its age has not yet exceeded its freshness\n      lifetime.\n\n   stale\n      A response is stale if its age has passed its freshness lifetime.\n\n   semantically transparent\n      A cache behaves in a \"semantically transparent\" manner, with\n      respect to a particular response, when its use affects neither the\n      requesting client nor the origin server, except to improve\n      performance. When a cache is semantically transparent, the client\n      receives exactly the same response (except for hop-by-hop headers)\n      that it would have received had its request been handled directly\n      by the origin server.\n\n   validator\n      A protocol element (e.g., an entity tag or a Last-Modified time)\n      that is used to find out whether a cache entry is an equivalent\n      copy of an entity.\n\n   upstream/downstream\n      Upstream and downstream describe the flow of a message: all\n      messages flow from upstream to downstream.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 11]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   inbound/outbound\n      Inbound and outbound refer to the request and response paths for\n      messages: \"inbound\" means \"traveling toward the origin server\",\n      and \"outbound\" means \"traveling toward the user agent\"\n\n1.4 Overall Operation\n\n   The HTTP protocol is a request/response protocol. A client sends a\n   request to the server in the form of a request method, URI, and\n   protocol version, followed by a MIME-like message containing request\n   modifiers, client information, and possible body content over a\n   connection with a server. The server responds with a status line,\n   including the message's protocol version and a success or error code,\n   followed by a MIME-like message containing server information, entity\n   metainformation, and possible entity-body content. The relationship\n   between HTTP and MIME is described in appendix 19.4.\n\n   Most HTTP communication is initiated by a user agent and consists of\n   a request to be applied to a resource on some origin server. In the\n   simplest case, this may be accomplished via a single connection (v)\n   between the user agent (UA) and the origin server (O).\n\n          request chain ------------------------>\n       UA -------------------v------------------- O\n          <----------------------- response chain\n\n   A more complicated situation occurs when one or more intermediaries\n   are present in the request/response chain. There are three common\n   forms of intermediary: proxy, gateway, and tunnel. A proxy is a\n   forwarding agent, receiving requests for a URI in its absolute form,\n   rewriting all or part of the message, and forwarding the reformatted\n   request toward the server identified by the URI. A gateway is a\n   receiving agent, acting as a layer above some other server(s) and, if\n   necessary, translating the requests to the underlying server's\n   protocol. A tunnel acts as a relay point between two connections\n   without changing the messages; tunnels are used when the\n   communication needs to pass through an intermediary (such as a\n   firewall) even when the intermediary cannot understand the contents\n   of the messages.\n\n          request chain -------------------------------------->\n       UA -----v----- A -----v----- B -----v----- C -----v----- O\n          <------------------------------------- response chain\n\n   The figure above shows three intermediaries (A, B, and C) between the\n   user agent and origin server. A request or response message that\n   travels the whole chain will pass through four separate connections.\n   This distinction is important because some HTTP communication options\n\n\n\nFielding, et al.            Standards Track                    [Page 12]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   may apply only to the connection with the nearest, non-tunnel\n   neighbor, only to the end-points of the chain, or to all connections\n   along the chain. Although the diagram is linear, each participant may\n   be engaged in multiple, simultaneous communications. For example, B\n   may be receiving requests from many clients other than A, and/or\n   forwarding requests to servers other than C, at the same time that it\n   is handling A's request.\n\n   Any party to the communication which is not acting as a tunnel may\n   employ an internal cache for handling requests. The effect of a cache\n   is that the request/response chain is shortened if one of the\n   participants along the chain has a cached response applicable to that\n   request. The following illustrates the resulting chain if B has a\n   cached copy of an earlier response from O (via C) for a request which\n   has not been cached by UA or A.\n\n          request chain ---------->\n       UA -----v----- A -----v----- B - - - - - - C - - - - - - O\n          <--------- response chain\n\n   Not all responses are usefully cacheable, and some requests may\n   contain modifiers which place special requirements on cache behavior.\n   HTTP requirements for cache behavior and cacheable responses are\n   defined in section 13.\n\n   In fact, there are a wide variety of architectures and configurations\n   of caches and proxies currently being experimented with or deployed\n   across the World Wide Web. These systems include national hierarchies\n   of proxy caches to save transoceanic bandwidth, systems that\n   broadcast or multicast cache entries, organizations that distribute\n   subsets of cached data via CD-ROM, and so on. HTTP systems are used\n   in corporate intranets over high-bandwidth links, and for access via\n   PDAs with low-power radio links and intermittent connectivity. The\n   goal of HTTP/1.1 is to support the wide diversity of configurations\n   already deployed while introducing protocol constructs that meet the\n   needs of those who build web applications that require high\n   reliability and, failing that, at least reliable indications of\n   failure.\n\n   HTTP communication usually takes place over TCP/IP connections. The\n   default port is TCP 80 [19], but other ports can be used. This does\n   not preclude HTTP from being implemented on top of any other protocol\n   on the Internet, or on other networks. HTTP only presumes a reliable\n   transport; any protocol that provides such guarantees can be used;\n   the mapping of the HTTP/1.1 request and response structures onto the\n   transport data units of the protocol in question is outside the scope\n   of this specification.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 13]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   In HTTP/1.0, most implementations used a new connection for each\n   request/response exchange. In HTTP/1.1, a connection may be used for\n   one or more request/response exchanges, although connections may be\n   closed for a variety of reasons (see section 8.1).\n\n2 Notational Conventions and Generic Grammar\n\n2.1 Augmented BNF\n\n   All of the mechanisms specified in this document are described in\n   both prose and an augmented Backus-Naur Form (BNF) similar to that\n   used by RFC 822 [9]. Implementors will need to be familiar with the\n   notation in order to understand this specification. The augmented BNF\n   includes the following constructs:\n\n   name = definition\n      The name of a rule is simply the name itself (without any\n      enclosing \"<\" and \">\") and is separated from its definition by the\n      equal \"=\" character. White space is only significant in that\n      indentation of continuation lines is used to indicate a rule\n      definition that spans more than one line. Certain basic rules are\n      in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle\n      brackets are used within definitions whenever their presence will\n      facilitate discerning the use of rule names.\n\n   \"literal\"\n      Quotation marks surround literal text. Unless stated otherwise,\n      the text is case-insensitive.\n\n   rule1 | rule2\n      Elements separated by a bar (\"|\") are alternatives, e.g., \"yes |\n      no\" will accept yes or no.\n\n   (rule1 rule2)\n      Elements enclosed in parentheses are treated as a single element.\n      Thus, \"(elem (foo | bar) elem)\" allows the token sequences \"elem\n      foo elem\" and \"elem bar elem\".\n\n   *rule\n      The character \"*\" preceding an element indicates repetition. The\n      full form is \"<n>*<m>element\" indicating at least <n> and at most\n      <m> occurrences of element. Default values are 0 and infinity so\n      that \"*(element)\" allows any number, including zero; \"1*element\"\n      requires at least one; and \"1*2element\" allows one or two.\n\n   [rule]\n      Square brackets enclose optional elements; \"[foo bar]\" is\n      equivalent to \"*1(foo bar)\".\n\n\n\nFielding, et al.            Standards Track                    [Page 14]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   N rule\n      Specific repetition: \"<n>(element)\" is equivalent to\n      \"<n>*<n>(element)\"; that is, exactly <n> occurrences of (element).\n      Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three\n      alphabetic characters.\n\n   #rule\n      A construct \"#\" is defined, similar to \"*\", for defining lists of\n      elements. The full form is \"<n>#<m>element\" indicating at least\n      <n> and at most <m> elements, each separated by one or more commas\n      (\",\") and OPTIONAL linear white space (LWS). This makes the usual\n      form of lists very easy; a rule such as\n         ( *LWS element *( *LWS \",\" *LWS element ))\n      can be shown as\n         1#element\n      Wherever this construct is used, null elements are allowed, but do\n      not contribute to the count of elements present. That is,\n      \"(element), , (element) \" is permitted, but counts as only two\n      elements. Therefore, where at least one element is required, at\n      least one non-null element MUST be present. Default values are 0\n      and infinity so that \"#element\" allows any number, including zero;\n      \"1#element\" requires at least one; and \"1#2element\" allows one or\n      two.\n\n   ; comment\n      A semi-colon, set off some distance to the right of rule text,\n      starts a comment that continues to the end of line. This is a\n      simple way of including useful notes in parallel with the\n      specifications.\n\n   implied *LWS\n      The grammar described by this specification is word-based. Except\n      where noted otherwise, linear white space (LWS) can be included\n      between any two adjacent words (token or quoted-string), and\n      between adjacent words and separators, without changing the\n      interpretation of a field. At least one delimiter (LWS and/or\n\n      separators) MUST exist between any two tokens (for the definition\n      of \"token\" below), since they would otherwise be interpreted as a\n      single token.\n\n2.2 Basic Rules\n\n   The following rules are used throughout this specification to\n   describe basic parsing constructs. The US-ASCII coded character set\n   is defined by ANSI X3.4-1986 [21].\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 15]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       OCTET          = <any 8-bit sequence of data>\n       CHAR           = <any US-ASCII character (octets 0 - 127)>\n       UPALPHA        = <any US-ASCII uppercase letter \"A\"..\"Z\">\n       LOALPHA        = <any US-ASCII lowercase letter \"a\"..\"z\">\n       ALPHA          = UPALPHA | LOALPHA\n       DIGIT          = <any US-ASCII digit \"0\"..\"9\">\n       CTL            = <any US-ASCII control character\n                        (octets 0 - 31) and DEL (127)>\n       CR             = <US-ASCII CR, carriage return (13)>\n       LF             = <US-ASCII LF, linefeed (10)>\n       SP             = <US-ASCII SP, space (32)>\n       HT             = <US-ASCII HT, horizontal-tab (9)>\n       <\">            = <US-ASCII double-quote mark (34)>\n\n   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all\n   protocol elements except the entity-body (see appendix 19.3 for\n   tolerant applications). The end-of-line marker within an entity-body\n   is defined by its associated media type, as described in section 3.7.\n\n       CRLF           = CR LF\n\n   HTTP/1.1 header field values can be folded onto multiple lines if the\n   continuation line begins with a space or horizontal tab. All linear\n   white space, including folding, has the same semantics as SP. A\n   recipient MAY replace any linear white space with a single SP before\n   interpreting the field value or forwarding the message downstream.\n\n       LWS            = [CRLF] 1*( SP | HT )\n\n   The TEXT rule is only used for descriptive field contents and values\n   that are not intended to be interpreted by the message parser. Words\n   of *TEXT MAY contain characters from character sets other than ISO-\n   8859-1 [22] only when encoded according to the rules of RFC 2047\n   [14].\n\n       TEXT           = <any OCTET except CTLs,\n                        but including LWS>\n\n   A CRLF is allowed in the definition of TEXT only as part of a header\n   field continuation. It is expected that the folding LWS will be\n   replaced with a single SP before interpretation of the TEXT value.\n\n   Hexadecimal numeric characters are used in several protocol elements.\n\n       HEX            = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n                      | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | DIGIT\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 16]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Many HTTP/1.1 header field values consist of words separated by LWS\n   or special characters. These special characters MUST be in a quoted\n   string to be used within a parameter value (as defined in section\n   3.6).\n\n       token          = 1*<any CHAR except CTLs or separators>\n       separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                      | \"{\" | \"}\" | SP | HT\n\n   Comments can be included in some HTTP header fields by surrounding\n   the comment text with parentheses. Comments are only allowed in\n   fields containing \"comment\" as part of their field value definition.\n   In all other fields, parentheses are considered part of the field\n   value.\n\n       comment        = \"(\" *( ctext | quoted-pair | comment ) \")\"\n       ctext          = <any TEXT excluding \"(\" and \")\">\n\n   A string of text is parsed as a single word if it is quoted using\n   double-quote marks.\n\n       quoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n       qdtext         = <any TEXT except <\">>\n\n   The backslash character (\"\\\") MAY be used as a single-character\n   quoting mechanism only within quoted-string and comment constructs.\n\n       quoted-pair    = \"\\\" CHAR\n\n3 Protocol Parameters\n\n3.1 HTTP Version\n\n   HTTP uses a \"<major>.<minor>\" numbering scheme to indicate versions\n   of the protocol. The protocol versioning policy is intended to allow\n   the sender to indicate the format of a message and its capacity for\n   understanding further HTTP communication, rather than the features\n   obtained via that communication. No change is made to the version\n   number for the addition of message components which do not affect\n   communication behavior or which only add to extensible field values.\n   The <minor> number is incremented when the changes made to the\n   protocol add features which do not change the general message parsing\n   algorithm, but which may add to the message semantics and imply\n   additional capabilities of the sender. The <major> number is\n   incremented when the format of a message within the protocol is\n   changed. See RFC 2145 [36] for a fuller explanation.\n\n\n\nFielding, et al.            Standards Track                    [Page 17]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The version of an HTTP message is indicated by an HTTP-Version field\n   in the first line of the message.\n\n       HTTP-Version   = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n\n   Note that the major and minor numbers MUST be treated as separate\n   integers and that each MAY be incremented higher than a single digit.\n   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is\n   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and\n   MUST NOT be sent.\n\n   An application that sends a request or response message that includes\n   HTTP-Version of \"HTTP/1.1\" MUST be at least conditionally compliant\n   with this specification. Applications that are at least conditionally\n   compliant with this specification SHOULD use an HTTP-Version of\n   \"HTTP/1.1\" in their messages, and MUST do so for any message that is\n   not compatible with HTTP/1.0. For more details on when to send\n   specific HTTP-Version values, see RFC 2145 [36].\n\n   The HTTP version of an application is the highest HTTP version for\n   which the application is at least conditionally compliant.\n\n   Proxy and gateway applications need to be careful when forwarding\n   messages in protocol versions different from that of the application.\n   Since the protocol version indicates the protocol capability of the\n   sender, a proxy/gateway MUST NOT send a message with a version\n   indicator which is greater than its actual version. If a higher\n   version request is received, the proxy/gateway MUST either downgrade\n   the request version, or respond with an error, or switch to tunnel\n   behavior.\n\n   Due to interoperability problems with HTTP/1.0 proxies discovered\n   since the publication of RFC 2068[33], caching proxies MUST, gateways\n   MAY, and tunnels MUST NOT upgrade the request to the highest version\n   they support. The proxy/gateway's response to that request MUST be in\n   the same major version as the request.\n\n      Note: Converting between versions of HTTP may involve modification\n      of header fields required or forbidden by the versions involved.\n\n3.2 Uniform Resource Identifiers\n\n   URIs have been known by many names: WWW addresses, Universal Document\n   Identifiers, Universal Resource Identifiers [3], and finally the\n   combination of Uniform Resource Locators (URL) [4] and Names (URN)\n   [20]. As far as HTTP is concerned, Uniform Resource Identifiers are\n   simply formatted strings which identify--via name, location, or any\n   other characteristic--a resource.\n\n\n\nFielding, et al.            Standards Track                    [Page 18]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.1 General Syntax\n\n   URIs in HTTP can be represented in absolute form or relative to some\n   known base URI [11], depending upon the context of their use. The two\n   forms are differentiated by the fact that absolute URIs always begin\n   with a scheme name followed by a colon. For definitive information on\n   URL syntax and semantics, see \"Uniform Resource Identifiers (URI):\n   Generic Syntax and Semantics,\" RFC 2396 [42] (which replaces RFCs\n   1738 [4] and RFC 1808 [11]). This specification adopts the\n   definitions of \"URI-reference\", \"absoluteURI\", \"relativeURI\", \"port\",\n   \"host\",\"abs_path\", \"rel_path\", and \"authority\" from that\n   specification.\n\n   The HTTP protocol does not place any a priori limit on the length of\n   a URI. Servers MUST be able to handle the URI of any resource they\n   serve, and SHOULD be able to handle URIs of unbounded length if they\n   provide GET-based forms that could generate such URIs. A server\n   SHOULD return 414 (Request-URI Too Long) status if a URI is longer\n   than the server can handle (see section 10.4.15).\n\n      Note: Servers ought to be cautious about depending on URI lengths\n      above 255 bytes, because some older client or proxy\n      implementations might not properly support these lengths.\n\n3.2.2 http URL\n\n   The \"http\" scheme is used to locate network resources via the HTTP\n   protocol. This section defines the scheme-specific syntax and\n   semantics for http URLs.\n\n   http_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query ]]\n\n   If the port is empty or not given, port 80 is assumed. The semantics\n   are that the identified resource is located at the server listening\n   for TCP connections on that port of that host, and the Request-URI\n   for the resource is abs_path (section 5.1.2). The use of IP addresses\n   in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]). If\n   the abs_path is not present in the URL, it MUST be given as \"/\" when\n   used as a Request-URI for a resource (section 5.1.2). If a proxy\n   receives a host name which is not a fully qualified domain name, it\n   MAY add its domain to the host name it received. If a proxy receives\n   a fully qualified domain name, the proxy MUST NOT change the host\n   name.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 19]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.3 URI Comparison\n\n   When comparing two URIs to decide if they match or not, a client\n   SHOULD use a case-sensitive octet-by-octet comparison of the entire\n   URIs, with these exceptions:\n\n      - A port that is empty or not given is equivalent to the default\n        port for that URI-reference;\n\n        - Comparisons of host names MUST be case-insensitive;\n\n        - Comparisons of scheme names MUST be case-insensitive;\n\n        - An empty abs_path is equivalent to an abs_path of \"/\".\n\n   Characters other than those in the \"reserved\" and \"unsafe\" sets (see\n   RFC 2396 [42]) are equivalent to their \"\"%\" HEX HEX\" encoding.\n\n   For example, the following three URIs are equivalent:\n\n      http://abc.com:80/~smith/home.html\n      http://ABC.com/%7Esmith/home.html\n      http://ABC.com:/%7esmith/home.html\n\n3.3 Date/Time Formats\n\n3.3.1 Full Date\n\n   HTTP applications have historically allowed three different formats\n   for the representation of date/time stamps:\n\n      Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n      Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036\n      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format\n\n   The first format is preferred as an Internet standard and represents\n   a fixed-length subset of that defined by RFC 1123 [8] (an update to\n   RFC 822 [9]). The second format is in common use, but is based on the\n   obsolete RFC 850 [12] date format and lacks a four-digit year.\n   HTTP/1.1 clients and servers that parse the date value MUST accept\n   all three formats (for compatibility with HTTP/1.0), though they MUST\n   only generate the RFC 1123 format for representing HTTP-date values\n   in header fields. See section 19.3 for further information.\n\n      Note: Recipients of date values are encouraged to be robust in\n      accepting date values that may have been sent by non-HTTP\n      applications, as is sometimes the case when retrieving or posting\n      messages via proxies/gateways to SMTP or NNTP.\n\n\n\nFielding, et al.            Standards Track                    [Page 20]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   All HTTP date/time stamps MUST be represented in Greenwich Mean Time\n   (GMT), without exception. For the purposes of HTTP, GMT is exactly\n   equal to UTC (Coordinated Universal Time). This is indicated in the\n   first two formats by the inclusion of \"GMT\" as the three-letter\n   abbreviation for time zone, and MUST be assumed when reading the\n   asctime format. HTTP-date is case sensitive and MUST NOT include\n   additional LWS beyond that specifically included as SP in the\n   grammar.\n\n       HTTP-date    = rfc1123-date | rfc850-date | asctime-date\n       rfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\n       rfc850-date  = weekday \",\" SP date2 SP time SP \"GMT\"\n       asctime-date = wkday SP date3 SP time SP 4DIGIT\n       date1        = 2DIGIT SP month SP 4DIGIT\n                      ; day month year (e.g., 02 Jun 1982)\n       date2        = 2DIGIT \"-\" month \"-\" 2DIGIT\n                      ; day-month-year (e.g., 02-Jun-82)\n       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n                      ; month day (e.g., Jun  2)\n       time         = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n                      ; 00:00:00 - 23:59:59\n       wkday        = \"Mon\" | \"Tue\" | \"Wed\"\n                    | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\n       weekday      = \"Monday\" | \"Tuesday\" | \"Wednesday\"\n                    | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\"\n       month        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n                    | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n                    | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n\n      Note: HTTP requirements for the date/time stamp format apply only\n      to their usage within the protocol stream. Clients and servers are\n      not required to use these formats for user presentation, request\n      logging, etc.\n\n3.3.2 Delta Seconds\n\n   Some HTTP header fields allow a time value to be specified as an\n   integer number of seconds, represented in decimal, after the time\n   that the message was received.\n\n       delta-seconds  = 1*DIGIT\n\n3.4 Character Sets\n\n   HTTP uses the same definition of the term \"character set\" as that\n   described for MIME:\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 21]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The term \"character set\" is used in this document to refer to a\n   method used with one or more tables to convert a sequence of octets\n   into a sequence of characters. Note that unconditional conversion in\n   the other direction is not required, in that not all characters may\n   be available in a given character set and a character set may provide\n   more than one sequence of octets to represent a particular character.\n   This definition is intended to allow various kinds of character\n   encoding, from simple single-table mappings such as US-ASCII to\n   complex table switching methods such as those that use ISO-2022's\n   techniques. However, the definition associated with a MIME character\n   set name MUST fully specify the mapping to be performed from octets\n   to characters. In particular, use of external profiling information\n   to determine the exact mapping is not permitted.\n\n      Note: This use of the term \"character set\" is more commonly\n      referred to as a \"character encoding.\" However, since HTTP and\n      MIME share the same registry, it is important that the terminology\n      also be shared.\n\n   HTTP character sets are identified by case-insensitive tokens. The\n   complete set of tokens is defined by the IANA Character Set registry\n   [19].\n\n       charset = token\n\n   Although HTTP allows an arbitrary token to be used as a charset\n   value, any token that has a predefined value within the IANA\n   Character Set registry [19] MUST represent the character set defined\n   by that registry. Applications SHOULD limit their use of character\n   sets to those defined by the IANA registry.\n\n   Implementors should be aware of IETF character set requirements [38]\n   [41].\n\n3.4.1 Missing Charset\n\n   Some HTTP/1.0 software has interpreted a Content-Type header without\n   charset parameter incorrectly to mean \"recipient should guess.\"\n   Senders wishing to defeat this behavior MAY include a charset\n   parameter even when the charset is ISO-8859-1 and SHOULD do so when\n   it is known that it will not confuse the recipient.\n\n   Unfortunately, some older HTTP/1.0 clients did not deal properly with\n   an explicit charset parameter. HTTP/1.1 recipients MUST respect the\n   charset label provided by the sender; and those user agents that have\n   a provision to \"guess\" a charset MUST use the charset from the\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 22]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   content-type field if they support that charset, rather than the\n   recipient's preference, when initially displaying a document. See\n   section 3.7.1.\n\n3.5 Content Codings\n\n   Content coding values indicate an encoding transformation that has\n   been or can be applied to an entity. Content codings are primarily\n   used to allow a document to be compressed or otherwise usefully\n   transformed without losing the identity of its underlying media type\n   and without loss of information. Frequently, the entity is stored in\n   coded form, transmitted directly, and only decoded by the recipient.\n\n       content-coding   = token\n\n   All content-coding values are case-insensitive. HTTP/1.1 uses\n   content-coding values in the Accept-Encoding (section 14.3) and\n   Content-Encoding (section 14.11) header fields. Although the value\n   describes the content-coding, what is more important is that it\n   indicates what decoding mechanism will be required to remove the\n   encoding.\n\n   The Internet Assigned Numbers Authority (IANA) acts as a registry for\n   content-coding value tokens. Initially, the registry contains the\n   following tokens:\n\n   gzip An encoding format produced by the file compression program\n        \"gzip\" (GNU zip) as described in RFC 1952 [25]. This format is a\n        Lempel-Ziv coding (LZ77) with a 32 bit CRC.\n\n   compress\n        The encoding format produced by the common UNIX file compression\n        program \"compress\". This format is an adaptive Lempel-Ziv-Welch\n        coding (LZW).\n\n        Use of program names for the identification of encoding formats\n        is not desirable and is discouraged for future encodings. Their\n        use here is representative of historical practice, not good\n        design. For compatibility with previous implementations of HTTP,\n        applications SHOULD consider \"x-gzip\" and \"x-compress\" to be\n        equivalent to \"gzip\" and \"compress\" respectively.\n\n   deflate\n        The \"zlib\" format defined in RFC 1950 [31] in combination with\n        the \"deflate\" compression mechanism described in RFC 1951 [29].\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 23]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   identity\n        The default (identity) encoding; the use of no transformation\n        whatsoever. This content-coding is used only in the Accept-\n        Encoding header, and SHOULD NOT be used in the Content-Encoding\n        header.\n\n   New content-coding value tokens SHOULD be registered; to allow\n   interoperability between clients and servers, specifications of the\n   content coding algorithms needed to implement a new value SHOULD be\n   publicly available and adequate for independent implementation, and\n   conform to the purpose of content coding defined in this section.\n\n3.6 Transfer Codings\n\n   Transfer-coding values are used to indicate an encoding\n   transformation that has been, can be, or may need to be applied to an\n   entity-body in order to ensure \"safe transport\" through the network.\n   This differs from a content coding in that the transfer-coding is a\n   property of the message, not of the original entity.\n\n       transfer-coding         = \"chunked\" | transfer-extension\n       transfer-extension      = token *( \";\" parameter )\n\n   Parameters are in  the form of attribute/value pairs.\n\n       parameter               = attribute \"=\" value\n       attribute               = token\n       value                   = token | quoted-string\n\n   All transfer-coding values are case-insensitive. HTTP/1.1 uses\n   transfer-coding values in the TE header field (section 14.39) and in\n   the Transfer-Encoding header field (section 14.41).\n\n   Whenever a transfer-coding is applied to a message-body, the set of\n   transfer-codings MUST include \"chunked\", unless the message is\n   terminated by closing the connection. When the \"chunked\" transfer-\n   coding is used, it MUST be the last transfer-coding applied to the\n   message-body. The \"chunked\" transfer-coding MUST NOT be applied more\n   than once to a message-body. These rules allow the recipient to\n   determine the transfer-length of the message (section 4.4).\n\n   Transfer-codings are analogous to the Content-Transfer-Encoding\n   values of MIME [7], which were designed to enable safe transport of\n   binary data over a 7-bit transport service. However, safe transport\n   has a different focus for an 8bit-clean transfer protocol. In HTTP,\n   the only unsafe characteristic of message-bodies is the difficulty in\n   determining the exact body length (section 7.2.2), or the desire to\n   encrypt data over a shared transport.\n\n\n\nFielding, et al.            Standards Track                    [Page 24]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Internet Assigned Numbers Authority (IANA) acts as a registry for\n   transfer-coding value tokens. Initially, the registry contains the\n   following tokens: \"chunked\" (section 3.6.1), \"identity\" (section\n   3.6.2), \"gzip\" (section 3.5), \"compress\" (section 3.5), and \"deflate\"\n   (section 3.5).\n\n   New transfer-coding value tokens SHOULD be registered in the same way\n   as new content-coding value tokens (section 3.5).\n\n   A server which receives an entity-body with a transfer-coding it does\n   not understand SHOULD return 501 (Unimplemented), and close the\n   connection. A server MUST NOT send transfer-codings to an HTTP/1.0\n   client.\n\n3.6.1 Chunked Transfer Coding\n\n   The chunked encoding modifies the body of a message in order to\n   transfer it as a series of chunks, each with its own size indicator,\n   followed by an OPTIONAL trailer containing entity-header fields. This\n   allows dynamically produced content to be transferred along with the\n   information necessary for the recipient to verify that it has\n   received the full message.\n\n       Chunked-Body   = *chunk\n                        last-chunk\n                        trailer\n                        CRLF\n\n       chunk          = chunk-size [ chunk-extension ] CRLF\n                        chunk-data CRLF\n       chunk-size     = 1*HEX\n       last-chunk     = 1*(\"0\") [ chunk-extension ] CRLF\n\n       chunk-extension= *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )\n       chunk-ext-name = token\n       chunk-ext-val  = token | quoted-string\n       chunk-data     = chunk-size(OCTET)\n       trailer        = *(entity-header CRLF)\n\n   The chunk-size field is a string of hex digits indicating the size of\n   the chunk. The chunked encoding is ended by any chunk whose size is\n   zero, followed by the trailer, which is terminated by an empty line.\n\n   The trailer allows the sender to include additional HTTP header\n   fields at the end of the message. The Trailer header field can be\n   used to indicate which header fields are included in a trailer (see\n   section 14.40).\n\n\n\n\nFielding, et al.            Standards Track                    [Page 25]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A server using chunked transfer-coding in a response MUST NOT use the\n   trailer for any header fields unless at least one of the following is\n   true:\n\n   a)the request included a TE header field that indicates \"trailers\" is\n     acceptable in the transfer-coding of the  response, as described in\n     section 14.39; or,\n\n   b)the server is the origin server for the response, the trailer\n     fields consist entirely of optional metadata, and the recipient\n     could use the message (in a manner acceptable to the origin server)\n     without receiving this metadata.  In other words, the origin server\n     is willing to accept the possibility that the trailer fields might\n     be silently discarded along the path to the client.\n\n   This requirement prevents an interoperability failure when the\n   message is being received by an HTTP/1.1 (or later) proxy and\n   forwarded to an HTTP/1.0 recipient. It avoids a situation where\n   compliance with the protocol would have necessitated a possibly\n   infinite buffer on the proxy.\n\n   An example process for decoding a Chunked-Body is presented in\n   appendix 19.4.6.\n\n   All HTTP/1.1 applications MUST be able to receive and decode the\n   \"chunked\" transfer-coding, and MUST ignore chunk-extension extensions\n   they do not understand.\n\n3.7 Media Types\n\n   HTTP uses Internet Media Types [17] in the Content-Type (section\n   14.17) and Accept (section 14.1) header fields in order to provide\n   open and extensible data typing and type negotiation.\n\n       media-type     = type \"/\" subtype *( \";\" parameter )\n       type           = token\n       subtype        = token\n\n   Parameters MAY follow the type/subtype in the form of attribute/value\n   pairs (as defined in section 3.6).\n\n   The type, subtype, and parameter attribute names are case-\n   insensitive. Parameter values might or might not be case-sensitive,\n   depending on the semantics of the parameter name. Linear white space\n   (LWS) MUST NOT be used between the type and subtype, nor between an\n   attribute and its value. The presence or absence of a parameter might\n   be significant to the processing of a media-type, depending on its\n   definition within the media type registry.\n\n\n\nFielding, et al.            Standards Track                    [Page 26]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Note that some older HTTP applications do not recognize media type\n   parameters. When sending data to older HTTP applications,\n   implementations SHOULD only use media type parameters when they are\n   required by that type/subtype definition.\n\n   Media-type values are registered with the Internet Assigned Number\n   Authority (IANA [19]). The media type registration process is\n   outlined in RFC 1590 [17]. Use of non-registered media types is\n   discouraged.\n\n3.7.1 Canonicalization and Text Defaults\n\n   Internet media types are registered with a canonical form. An\n   entity-body transferred via HTTP messages MUST be represented in the\n   appropriate canonical form prior to its transmission except for\n   \"text\" types, as defined in the next paragraph.\n\n   When in canonical form, media subtypes of the \"text\" type use CRLF as\n   the text line break. HTTP relaxes this requirement and allows the\n   transport of text media with plain CR or LF alone representing a line\n   break when it is done consistently for an entire entity-body. HTTP\n   applications MUST accept CRLF, bare CR, and bare LF as being\n   representative of a line break in text media received via HTTP. In\n   addition, if the text is represented in a character set that does not\n   use octets 13 and 10 for CR and LF respectively, as is the case for\n   some multi-byte character sets, HTTP allows the use of whatever octet\n   sequences are defined by that character set to represent the\n   equivalent of CR and LF for line breaks. This flexibility regarding\n   line breaks applies only to text media in the entity-body; a bare CR\n   or LF MUST NOT be substituted for CRLF within any of the HTTP control\n   structures (such as header fields and multipart boundaries).\n\n   If an entity-body is encoded with a content-coding, the underlying\n   data MUST be in a form defined above prior to being encoded.\n\n   The \"charset\" parameter is used with some media types to define the\n   character set (section 3.4) of the data. When no explicit charset\n   parameter is provided by the sender, media subtypes of the \"text\"\n   type are defined to have a default charset value of \"ISO-8859-1\" when\n   received via HTTP. Data in character sets other than \"ISO-8859-1\" or\n   its subsets MUST be labeled with an appropriate charset value. See\n   section 3.4.1 for compatibility problems.\n\n3.7.2 Multipart Types\n\n   MIME provides for a number of \"multipart\" types -- encapsulations of\n   one or more entities within a single message-body. All multipart\n   types share a common syntax, as defined in section 5.1.1 of RFC 2046\n\n\n\nFielding, et al.            Standards Track                    [Page 27]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [40], and MUST include a boundary parameter as part of the media type\n   value. The message body is itself a protocol element and MUST\n   therefore use only CRLF to represent line breaks between body-parts.\n   Unlike in RFC 2046, the epilogue of any multipart message MUST be\n   empty; HTTP applications MUST NOT transmit the epilogue (even if the\n   original multipart contains an epilogue). These restrictions exist in\n   order to preserve the self-delimiting nature of a multipart message-\n   body, wherein the \"end\" of the message-body is indicated by the\n   ending multipart boundary.\n\n   In general, HTTP treats a multipart message-body no differently than\n   any other media type: strictly as payload. The one exception is the\n   \"multipart/byteranges\" type (appendix 19.2) when it appears in a 206\n   (Partial Content) response, which will be interpreted by some HTTP\n   caching mechanisms as described in sections 13.5.4 and 14.16. In all\n   other cases, an HTTP user agent SHOULD follow the same or similar\n   behavior as a MIME user agent would upon receipt of a multipart type.\n   The MIME header fields within each body-part of a multipart message-\n   body do not have any significance to HTTP beyond that defined by\n   their MIME semantics.\n\n   In general, an HTTP user agent SHOULD follow the same or similar\n   behavior as a MIME user agent would upon receipt of a multipart type.\n   If an application receives an unrecognized multipart subtype, the\n   application MUST treat it as being equivalent to \"multipart/mixed\".\n\n      Note: The \"multipart/form-data\" type has been specifically defined\n      for carrying form data suitable for processing via the POST\n      request method, as described in RFC 1867 [15].\n\n3.8 Product Tokens\n\n   Product tokens are used to allow communicating applications to\n   identify themselves by software name and version. Most fields using\n   product tokens also allow sub-products which form a significant part\n   of the application to be listed, separated by white space. By\n   convention, the products are listed in order of their significance\n   for identifying the application.\n\n       product         = token [\"/\" product-version]\n       product-version = token\n\n   Examples:\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n       Server: Apache/0.8.4\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 28]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Product tokens SHOULD be short and to the point. They MUST NOT be\n   used for advertising or other non-essential information. Although any\n   token character MAY appear in a product-version, this token SHOULD\n   only be used for a version identifier (i.e., successive versions of\n   the same product SHOULD only differ in the product-version portion of\n   the product value).\n\n3.9 Quality Values\n\n   HTTP content negotiation (section 12) uses short \"floating point\"\n   numbers to indicate the relative importance (\"weight\") of various\n   negotiable parameters.  A weight is normalized to a real number in\n   the range 0 through 1, where 0 is the minimum and 1 the maximum\n   value. If a parameter has a quality value of 0, then content with\n   this parameter is `not acceptable' for the client. HTTP/1.1\n   applications MUST NOT generate more than three digits after the\n   decimal point. User configuration of these values SHOULD also be\n   limited in this fashion.\n\n       qvalue         = ( \"0\" [ \".\" 0*3DIGIT ] )\n                      | ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n   \"Quality values\" is a misnomer, since these values merely represent\n   relative degradation in desired quality.\n\n3.10 Language Tags\n\n   A language tag identifies a natural language spoken, written, or\n   otherwise conveyed by human beings for communication of information\n   to other human beings. Computer languages are explicitly excluded.\n   HTTP uses language tags within the Accept-Language and Content-\n   Language fields.\n\n   The syntax and registry of HTTP language tags is the same as that\n   defined by RFC 1766 [1]. In summary, a language tag is composed of 1\n   or more parts: A primary language tag and a possibly empty series of\n   subtags:\n\n        language-tag  = primary-tag *( \"-\" subtag )\n        primary-tag   = 1*8ALPHA\n        subtag        = 1*8ALPHA\n\n   White space is not allowed within the tag and all tags are case-\n   insensitive. The name space of language tags is administered by the\n   IANA. Example tags include:\n\n       en, en-US, en-cockney, i-cherokee, x-pig-latin\n\n\n\n\nFielding, et al.            Standards Track                    [Page 29]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   where any two-letter primary-tag is an ISO-639 language abbreviation\n   and any two-letter initial subtag is an ISO-3166 country code. (The\n   last three tags above are not registered tags; all but the last are\n   examples of tags which could be registered in future.)\n\n3.11 Entity Tags\n\n   Entity tags are used for comparing two or more entities from the same\n   requested resource. HTTP/1.1 uses entity tags in the ETag (section\n   14.19), If-Match (section 14.24), If-None-Match (section 14.26), and\n   If-Range (section 14.27) header fields. The definition of how they\n   are used and compared as cache validators is in section 13.3.3. An\n   entity tag consists of an opaque quoted string, possibly prefixed by\n   a weakness indicator.\n\n      entity-tag = [ weak ] opaque-tag\n      weak       = \"W/\"\n      opaque-tag = quoted-string\n\n   A \"strong entity tag\" MAY be shared by two entities of a resource\n   only if they are equivalent by octet equality.\n\n   A \"weak entity tag,\" indicated by the \"W/\" prefix, MAY be shared by\n   two entities of a resource only if the entities are equivalent and\n   could be substituted for each other with no significant change in\n   semantics. A weak entity tag can only be used for weak comparison.\n\n   An entity tag MUST be unique across all versions of all entities\n   associated with a particular resource. A given entity tag value MAY\n   be used for entities obtained by requests on different URIs. The use\n   of the same entity tag value in conjunction with entities obtained by\n   requests on different URIs does not imply the equivalence of those\n   entities.\n\n3.12 Range Units\n\n   HTTP/1.1 allows a client to request that only part (a range of) the\n   response entity be included within the response. HTTP/1.1 uses range\n   units in the Range (section 14.35) and Content-Range (section 14.16)\n   header fields. An entity can be broken down into subranges according\n   to various structural units.\n\n      range-unit       = bytes-unit | other-range-unit\n      bytes-unit       = \"bytes\"\n      other-range-unit = token\n\n   The only range unit defined by HTTP/1.1 is \"bytes\". HTTP/1.1\n   implementations MAY ignore ranges specified using other units.\n\n\n\nFielding, et al.            Standards Track                    [Page 30]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 has been designed to allow implementations of applications\n   that do not depend on knowledge of ranges.\n\n4 HTTP Message\n\n4.1 Message Types\n\n   HTTP messages consist of requests from client to server and responses\n   from server to client.\n\n       HTTP-message   = Request | Response     ; HTTP/1.1 messages\n\n   Request (section 5) and Response (section 6) messages use the generic\n   message format of RFC 822 [9] for transferring entities (the payload\n   of the message). Both types of message consist of a start-line, zero\n   or more header fields (also known as \"headers\"), an empty line (i.e.,\n   a line with nothing preceding the CRLF) indicating the end of the\n   header fields, and possibly a message-body.\n\n        generic-message = start-line\n                          *(message-header CRLF)\n                          CRLF\n                          [ message-body ]\n        start-line      = Request-Line | Status-Line\n\n   In the interest of robustness, servers SHOULD ignore any empty\n   line(s) received where a Request-Line is expected. In other words, if\n   the server is reading the protocol stream at the beginning of a\n   message and receives a CRLF first, it should ignore the CRLF.\n\n   Certain buggy HTTP/1.0 client implementations generate extra CRLF's\n   after a POST request. To restate what is explicitly forbidden by the\n   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an\n   extra CRLF.\n\n4.2 Message Headers\n\n   HTTP header fields, which include general-header (section 4.5),\n   request-header (section 5.3), response-header (section 6.2), and\n   entity-header (section 7.1) fields, follow the same generic format as\n   that given in Section 3.1 of RFC 822 [9]. Each header field consists\n   of a name followed by a colon (\":\") and the field value. Field names\n   are case-insensitive. The field value MAY be preceded by any amount\n   of LWS, though a single SP is preferred. Header fields can be\n   extended over multiple lines by preceding each extra line with at\n   least one SP or HT. Applications ought to follow \"common form\", where\n   one is known or indicated, when generating HTTP constructs, since\n   there might exist some implementations that fail to accept anything\n\n\n\nFielding, et al.            Standards Track                    [Page 31]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   beyond the common forms.\n\n       message-header = field-name \":\" [ field-value ]\n       field-name     = token\n       field-value    = *( field-content | LWS )\n       field-content  = <the OCTETs making up the field-value\n                        and consisting of either *TEXT or combinations\n                        of token, separators, and quoted-string>\n\n   The field-content does not include any leading or trailing LWS:\n   linear white space occurring before the first non-whitespace\n   character of the field-value or after the last non-whitespace\n   character of the field-value. Such leading or trailing LWS MAY be\n   removed without changing the semantics of the field value. Any LWS\n   that occurs between field-content MAY be replaced with a single SP\n   before interpreting the field value or forwarding the message\n   downstream.\n\n   The order in which header fields with differing field names are\n   received is not significant. However, it is \"good practice\" to send\n   general-header fields first, followed by request-header or response-\n   header fields, and ending with the entity-header fields.\n\n   Multiple message-header fields with the same field-name MAY be\n   present in a message if and only if the entire field-value for that\n   header field is defined as a comma-separated list [i.e., #(values)].\n   It MUST be possible to combine the multiple header fields into one\n   \"field-name: field-value\" pair, without changing the semantics of the\n   message, by appending each subsequent field-value to the first, each\n   separated by a comma. The order in which header fields with the same\n   field-name are received is therefore significant to the\n   interpretation of the combined field value, and thus a proxy MUST NOT\n   change the order of these field values when a message is forwarded.\n\n4.3 Message Body\n\n   The message-body (if any) of an HTTP message is used to carry the\n   entity-body associated with the request or response. The message-body\n   differs from the entity-body only when a transfer-coding has been\n   applied, as indicated by the Transfer-Encoding header field (section\n   14.41).\n\n       message-body = entity-body\n                    | <entity-body encoded as per Transfer-Encoding>\n\n   Transfer-Encoding MUST be used to indicate any transfer-codings\n   applied by an application to ensure safe and proper transfer of the\n   message. Transfer-Encoding is a property of the message, not of the\n\n\n\nFielding, et al.            Standards Track                    [Page 32]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   entity, and thus MAY be added or removed by any application along the\n   request/response chain. (However, section 3.6 places restrictions on\n   when certain transfer-codings may be used.)\n\n   The rules for when a message-body is allowed in a message differ for\n   requests and responses.\n\n   The presence of a message-body in a request is signaled by the\n   inclusion of a Content-Length or Transfer-Encoding header field in\n   the request's message-headers. A message-body MUST NOT be included in\n   a request if the specification of the request method (section 5.1.1)\n   does not allow sending an entity-body in requests. A server SHOULD\n   read and forward a message-body on any request; if the request method\n   does not include defined semantics for an entity-body, then the\n   message-body SHOULD be ignored when handling the request.\n\n   For response messages, whether or not a message-body is included with\n   a message is dependent on both the request method and the response\n   status code (section 6.1.1). All responses to the HEAD request method\n   MUST NOT include a message-body, even though the presence of entity-\n   header fields might lead one to believe they do. All 1xx\n   (informational), 204 (no content), and 304 (not modified) responses\n   MUST NOT include a message-body. All other responses do include a\n   message-body, although it MAY be of zero length.\n\n4.4 Message Length\n\n   The transfer-length of a message is the length of the message-body as\n   it appears in the message; that is, after any transfer-codings have\n   been applied. When a message-body is included with a message, the\n   transfer-length of that body is determined by one of the following\n   (in order of precedence):\n\n   1.Any response message which \"MUST NOT\" include a message-body (such\n     as the 1xx, 204, and 304 responses and any response to a HEAD\n     request) is always terminated by the first empty line after the\n     header fields, regardless of the entity-header fields present in\n     the message.\n\n   2.If a Transfer-Encoding header field (section 14.41) is present and\n     has any value other than \"identity\", then the transfer-length is\n     defined by use of the \"chunked\" transfer-coding (section 3.6),\n     unless the message is terminated by closing the connection.\n\n   3.If a Content-Length header field (section 14.13) is present, its\n     decimal value in OCTETs represents both the entity-length and the\n     transfer-length. The Content-Length header field MUST NOT be sent\n     if these two lengths are different (i.e., if a Transfer-Encoding\n\n\n\nFielding, et al.            Standards Track                    [Page 33]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n     header field is present). If a message is received with both a\n     Transfer-Encoding header field and a Content-Length header field,\n     the latter MUST be ignored.\n\n   4.If the message uses the media type \"multipart/byteranges\", and the\n     ransfer-length is not otherwise specified, then this self-\n     elimiting media type defines the transfer-length. This media type\n     UST NOT be used unless the sender knows that the recipient can arse\n     it; the presence in a request of a Range header with ultiple byte-\n     range specifiers from a 1.1 client implies that the lient can parse\n     multipart/byteranges responses.\n\n       A range header might be forwarded by a 1.0 proxy that does not\n       understand multipart/byteranges; in this case the server MUST\n       delimit the message using methods defined in items 1,3 or 5 of\n       this section.\n\n   5.By the server closing the connection. (Closing the connection\n     cannot be used to indicate the end of a request body, since that\n     would leave no possibility for the server to send back a response.)\n\n   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests\n   containing a message-body MUST include a valid Content-Length header\n   field unless the server is known to be HTTP/1.1 compliant. If a\n   request contains a message-body and a Content-Length is not given,\n   the server SHOULD respond with 400 (bad request) if it cannot\n   determine the length of the message, or with 411 (length required) if\n   it wishes to insist on receiving a valid Content-Length.\n\n   All HTTP/1.1 applications that receive entities MUST accept the\n   \"chunked\" transfer-coding (section 3.6), thus allowing this mechanism\n   to be used for messages when the message length cannot be determined\n   in advance.\n\n   Messages MUST NOT include both a Content-Length header field and a\n   non-identity transfer-coding. If the message does include a non-\n   identity transfer-coding, the Content-Length MUST be ignored.\n\n   When a Content-Length is given in a message where a message-body is\n   allowed, its field value MUST exactly match the number of OCTETs in\n   the message-body. HTTP/1.1 user agents MUST notify the user when an\n   invalid length is received and detected.\n\n4.5 General Header Fields\n\n   There are a few header fields which have general applicability for\n   both request and response messages, but which do not apply to the\n   entity being transferred. These header fields apply only to the\n\n\n\nFielding, et al.            Standards Track                    [Page 34]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   message being transmitted.\n\n       general-header = Cache-Control            ; Section 14.9\n                      | Connection               ; Section 14.10\n                      | Date                     ; Section 14.18\n                      | Pragma                   ; Section 14.32\n                      | Trailer                  ; Section 14.40\n                      | Transfer-Encoding        ; Section 14.41\n                      | Upgrade                  ; Section 14.42\n                      | Via                      ; Section 14.45\n                      | Warning                  ; Section 14.46\n\n   General-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields may be given the semantics of general\n   header fields if all parties in the communication recognize them to\n   be general-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n5 Request\n\n   A request message from a client to a server includes, within the\n   first line of that message, the method to be applied to the resource,\n   the identifier of the resource, and the protocol version in use.\n\n        Request       = Request-Line              ; Section 5.1\n                        *(( general-header        ; Section 4.5\n                         | request-header         ; Section 5.3\n                         | entity-header ) CRLF)  ; Section 7.1\n                        CRLF\n                        [ message-body ]          ; Section 4.3\n\n5.1 Request-Line\n\n   The Request-Line begins with a method token, followed by the\n   Request-URI and the protocol version, and ending with CRLF. The\n   elements are separated by SP characters. No CR or LF is allowed\n   except in the final CRLF sequence.\n\n        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 35]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n5.1.1 Method\n\n   The Method  token indicates the method to be performed on the\n   resource identified by the Request-URI. The method is case-sensitive.\n\n       Method         = \"OPTIONS\"                ; Section 9.2\n                      | \"GET\"                    ; Section 9.3\n                      | \"HEAD\"                   ; Section 9.4\n                      | \"POST\"                   ; Section 9.5\n                      | \"PUT\"                    ; Section 9.6\n                      | \"DELETE\"                 ; Section 9.7\n                      | \"TRACE\"                  ; Section 9.8\n                      | \"CONNECT\"                ; Section 9.9\n                      | extension-method\n       extension-method = token\n\n   The list of methods allowed by a resource can be specified in an\n   Allow header field (section 14.7). The return code of the response\n   always notifies the client whether a method is currently allowed on a\n   resource, since the set of allowed methods can change dynamically. An\n   origin server SHOULD return the status code 405 (Method Not Allowed)\n   if the method is known by the origin server but not allowed for the\n   requested resource, and 501 (Not Implemented) if the method is\n   unrecognized or not implemented by the origin server. The methods GET\n   and HEAD MUST be supported by all general-purpose servers. All other\n   methods are OPTIONAL; however, if the above methods are implemented,\n   they MUST be implemented with the same semantics as those specified\n   in section 9.\n\n5.1.2 Request-URI\n\n   The Request-URI is a Uniform Resource Identifier (section 3.2) and\n   identifies the resource upon which to apply the request.\n\n       Request-URI    = \"*\" | absoluteURI | abs_path | authority\n\n   The four options for Request-URI are dependent on the nature of the\n   request. The asterisk \"*\" means that the request does not apply to a\n   particular resource, but to the server itself, and is only allowed\n   when the method used does not necessarily apply to a resource. One\n   example would be\n\n       OPTIONS * HTTP/1.1\n\n   The absoluteURI form is REQUIRED when the request is being made to a\n   proxy. The proxy is requested to forward the request or service it\n   from a valid cache, and return the response. Note that the proxy MAY\n   forward the request on to another proxy or directly to the server\n\n\n\nFielding, et al.            Standards Track                    [Page 36]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   specified by the absoluteURI. In order to avoid request loops, a\n   proxy MUST be able to recognize all of its server names, including\n   any aliases, local variations, and the numeric IP address. An example\n   Request-Line would be:\n\n       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1\n\n   To allow for transition to absoluteURIs in all requests in future\n   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI\n   form in requests, even though HTTP/1.1 clients will only generate\n   them in requests to proxies.\n\n   The authority form is only used by the CONNECT method (section 9.9).\n\n   The most common form of Request-URI is that used to identify a\n   resource on an origin server or gateway. In this case the absolute\n   path of the URI MUST be transmitted (see section 3.2.1, abs_path) as\n   the Request-URI, and the network location of the URI (authority) MUST\n   be transmitted in a Host header field. For example, a client wishing\n   to retrieve the resource above directly from the origin server would\n   create a TCP connection to port 80 of the host \"www.w3.org\" and send\n   the lines:\n\n       GET /pub/WWW/TheProject.html HTTP/1.1\n       Host: www.w3.org\n\n   followed by the remainder of the Request. Note that the absolute path\n   cannot be empty; if none is present in the original URI, it MUST be\n   given as \"/\" (the server root).\n\n   The Request-URI is transmitted in the format specified in section\n   3.2.1. If the Request-URI is encoded using the \"% HEX HEX\" encoding\n   [42], the origin server MUST decode the Request-URI in order to\n   properly interpret the request. Servers SHOULD respond to invalid\n   Request-URIs with an appropriate status code.\n\n   A transparent proxy MUST NOT rewrite the \"abs_path\" part of the\n   received Request-URI when forwarding it to the next inbound server,\n   except as noted above to replace a null abs_path with \"/\".\n\n      Note: The \"no rewrite\" rule prevents the proxy from changing the\n      meaning of the request when the origin server is improperly using\n      a non-reserved URI character for a reserved purpose.  Implementors\n      should be aware that some pre-HTTP/1.1 proxies have been known to\n      rewrite the Request-URI.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 37]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n5.2 The Resource Identified by a Request\n\n   The exact resource identified by an Internet request is determined by\n   examining both the Request-URI and the Host header field.\n\n   An origin server that does not allow resources to differ by the\n   requested host MAY ignore the Host header field value when\n   determining the resource identified by an HTTP/1.1 request. (But see\n   section 19.6.1.1 for other requirements on Host support in HTTP/1.1.)\n\n   An origin server that does differentiate resources based on the host\n   requested (sometimes referred to as virtual hosts or vanity host\n   names) MUST use the following rules for determining the requested\n   resource on an HTTP/1.1 request:\n\n   1. If Request-URI is an absoluteURI, the host is part of the\n     Request-URI. Any Host header field value in the request MUST be\n     ignored.\n\n   2. If the Request-URI is not an absoluteURI, and the request includes\n     a Host header field, the host is determined by the Host header\n     field value.\n\n   3. If the host as determined by rule 1 or 2 is not a valid host on\n     the server, the response MUST be a 400 (Bad Request) error message.\n\n   Recipients of an HTTP/1.0 request that lacks a Host header field MAY\n   attempt to use heuristics (e.g., examination of the URI path for\n   something unique to a particular host) in order to determine what\n   exact resource is being requested.\n\n5.3 Request Header Fields\n\n   The request-header fields allow the client to pass additional\n   information about the request, and about the client itself, to the\n   server. These fields act as request modifiers, with semantics\n   equivalent to the parameters on a programming language method\n   invocation.\n\n       request-header = Accept                   ; Section 14.1\n                      | Accept-Charset           ; Section 14.2\n                      | Accept-Encoding          ; Section 14.3\n                      | Accept-Language          ; Section 14.4\n                      | Authorization            ; Section 14.8\n                      | Expect                   ; Section 14.20\n                      | From                     ; Section 14.22\n                      | Host                     ; Section 14.23\n                      | If-Match                 ; Section 14.24\n\n\n\nFielding, et al.            Standards Track                    [Page 38]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                      | If-Modified-Since        ; Section 14.25\n                      | If-None-Match            ; Section 14.26\n                      | If-Range                 ; Section 14.27\n                      | If-Unmodified-Since      ; Section 14.28\n                      | Max-Forwards             ; Section 14.31\n                      | Proxy-Authorization      ; Section 14.34\n                      | Range                    ; Section 14.35\n                      | Referer                  ; Section 14.36\n                      | TE                       ; Section 14.39\n                      | User-Agent               ; Section 14.43\n\n   Request-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields MAY be given the semantics of request-\n   header fields if all parties in the communication recognize them to\n   be request-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n6 Response\n\n   After receiving and interpreting a request message, a server responds\n   with an HTTP response message.\n\n       Response      = Status-Line               ; Section 6.1\n                       *(( general-header        ; Section 4.5\n                        | response-header        ; Section 6.2\n                        | entity-header ) CRLF)  ; Section 7.1\n                       CRLF\n                       [ message-body ]          ; Section 7.2\n\n6.1 Status-Line\n\n   The first line of a Response message is the Status-Line, consisting\n   of the protocol version followed by a numeric status code and its\n   associated textual phrase, with each element separated by SP\n   characters. No CR or LF is allowed except in the final CRLF sequence.\n\n       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n\n6.1.1 Status Code and Reason Phrase\n\n   The Status-Code element is a 3-digit integer result code of the\n   attempt to understand and satisfy the request. These codes are fully\n   defined in section 10. The Reason-Phrase is intended to give a short\n   textual description of the Status-Code. The Status-Code is intended\n   for use by automata and the Reason-Phrase is intended for the human\n   user. The client is not required to examine or display the Reason-\n   Phrase.\n\n\n\nFielding, et al.            Standards Track                    [Page 39]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The first digit of the Status-Code defines the class of response. The\n   last two digits do not have any categorization role. There are 5\n   values for the first digit:\n\n      - 1xx: Informational - Request received, continuing process\n\n      - 2xx: Success - The action was successfully received,\n        understood, and accepted\n\n      - 3xx: Redirection - Further action must be taken in order to\n        complete the request\n\n      - 4xx: Client Error - The request contains bad syntax or cannot\n        be fulfilled\n\n      - 5xx: Server Error - The server failed to fulfill an apparently\n        valid request\n\n   The individual values of the numeric status codes defined for\n   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are\n   presented below. The reason phrases listed here are only\n   recommendations -- they MAY be replaced by local equivalents without\n   affecting the protocol.\n\n      Status-Code    =\n            \"100\"  ; Section 10.1.1: Continue\n          | \"101\"  ; Section 10.1.2: Switching Protocols\n          | \"200\"  ; Section 10.2.1: OK\n          | \"201\"  ; Section 10.2.2: Created\n          | \"202\"  ; Section 10.2.3: Accepted\n          | \"203\"  ; Section 10.2.4: Non-Authoritative Information\n          | \"204\"  ; Section 10.2.5: No Content\n          | \"205\"  ; Section 10.2.6: Reset Content\n          | \"206\"  ; Section 10.2.7: Partial Content\n          | \"300\"  ; Section 10.3.1: Multiple Choices\n          | \"301\"  ; Section 10.3.2: Moved Permanently\n          | \"302\"  ; Section 10.3.3: Found\n          | \"303\"  ; Section 10.3.4: See Other\n          | \"304\"  ; Section 10.3.5: Not Modified\n          | \"305\"  ; Section 10.3.6: Use Proxy\n          | \"307\"  ; Section 10.3.8: Temporary Redirect\n          | \"400\"  ; Section 10.4.1: Bad Request\n          | \"401\"  ; Section 10.4.2: Unauthorized\n          | \"402\"  ; Section 10.4.3: Payment Required\n          | \"403\"  ; Section 10.4.4: Forbidden\n          | \"404\"  ; Section 10.4.5: Not Found\n          | \"405\"  ; Section 10.4.6: Method Not Allowed\n          | \"406\"  ; Section 10.4.7: Not Acceptable\n\n\n\nFielding, et al.            Standards Track                    [Page 40]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n          | \"407\"  ; Section 10.4.8: Proxy Authentication Required\n          | \"408\"  ; Section 10.4.9: Request Time-out\n          | \"409\"  ; Section 10.4.10: Conflict\n          | \"410\"  ; Section 10.4.11: Gone\n          | \"411\"  ; Section 10.4.12: Length Required\n          | \"412\"  ; Section 10.4.13: Precondition Failed\n          | \"413\"  ; Section 10.4.14: Request Entity Too Large\n          | \"414\"  ; Section 10.4.15: Request-URI Too Large\n          | \"415\"  ; Section 10.4.16: Unsupported Media Type\n          | \"416\"  ; Section 10.4.17: Requested range not satisfiable\n          | \"417\"  ; Section 10.4.18: Expectation Failed\n          | \"500\"  ; Section 10.5.1: Internal Server Error\n          | \"501\"  ; Section 10.5.2: Not Implemented\n          | \"502\"  ; Section 10.5.3: Bad Gateway\n          | \"503\"  ; Section 10.5.4: Service Unavailable\n          | \"504\"  ; Section 10.5.5: Gateway Time-out\n          | \"505\"  ; Section 10.5.6: HTTP Version not supported\n          | extension-code\n\n      extension-code = 3DIGIT\n      Reason-Phrase  = *<TEXT, excluding CR, LF>\n\n   HTTP status codes are extensible. HTTP applications are not required\n   to understand the meaning of all registered status codes, though such\n   understanding is obviously desirable. However, applications MUST\n   understand the class of any status code, as indicated by the first\n   digit, and treat any unrecognized response as being equivalent to the\n   x00 status code of that class, with the exception that an\n   unrecognized response MUST NOT be cached. For example, if an\n   unrecognized status code of 431 is received by the client, it can\n   safely assume that there was something wrong with its request and\n   treat the response as if it had received a 400 status code. In such\n   cases, user agents SHOULD present to the user the entity returned\n   with the response, since that entity is likely to include human-\n   readable information which will explain the unusual status.\n\n6.2 Response Header Fields\n\n   The response-header fields allow the server to pass additional\n   information about the response which cannot be placed in the Status-\n   Line. These header fields give information about the server and about\n   further access to the resource identified by the Request-URI.\n\n       response-header = Accept-Ranges           ; Section 14.5\n                       | Age                     ; Section 14.6\n                       | ETag                    ; Section 14.19\n                       | Location                ; Section 14.30\n                       | Proxy-Authenticate      ; Section 14.33\n\n\n\nFielding, et al.            Standards Track                    [Page 41]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                       | Retry-After             ; Section 14.37\n                       | Server                  ; Section 14.38\n                       | Vary                    ; Section 14.44\n                       | WWW-Authenticate        ; Section 14.47\n\n   Response-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields MAY be given the semantics of response-\n   header fields if all parties in the communication recognize them to\n   be response-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n7 Entity\n\n   Request and Response messages MAY transfer an entity if not otherwise\n   restricted by the request method or response status code. An entity\n   consists of entity-header fields and an entity-body, although some\n   responses will only include the entity-headers.\n\n   In this section, both sender and recipient refer to either the client\n   or the server, depending on who sends and who receives the entity.\n\n7.1 Entity Header Fields\n\n   Entity-header fields define metainformation about the entity-body or,\n   if no body is present, about the resource identified by the request.\n   Some of this metainformation is OPTIONAL; some might be REQUIRED by\n   portions of this specification.\n\n       entity-header  = Allow                    ; Section 14.7\n                      | Content-Encoding         ; Section 14.11\n                      | Content-Language         ; Section 14.12\n                      | Content-Length           ; Section 14.13\n                      | Content-Location         ; Section 14.14\n                      | Content-MD5              ; Section 14.15\n                      | Content-Range            ; Section 14.16\n                      | Content-Type             ; Section 14.17\n                      | Expires                  ; Section 14.21\n                      | Last-Modified            ; Section 14.29\n                      | extension-header\n\n       extension-header = message-header\n\n   The extension-header mechanism allows additional entity-header fields\n   to be defined without changing the protocol, but these fields cannot\n   be assumed to be recognizable by the recipient. Unrecognized header\n   fields SHOULD be ignored by the recipient and MUST be forwarded by\n   transparent proxies.\n\n\n\nFielding, et al.            Standards Track                    [Page 42]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n7.2 Entity Body\n\n   The entity-body (if any) sent with an HTTP request or response is in\n   a format and encoding defined by the entity-header fields.\n\n       entity-body    = *OCTET\n\n   An entity-body is only present in a message when a message-body is\n   present, as described in section 4.3. The entity-body is obtained\n   from the message-body by decoding any Transfer-Encoding that might\n   have been applied to ensure safe and proper transfer of the message.\n\n7.2.1 Type\n\n   When an entity-body is included with a message, the data type of that\n   body is determined via the header fields Content-Type and Content-\n   Encoding. These define a two-layer, ordered encoding model:\n\n       entity-body := Content-Encoding( Content-Type( data ) )\n\n   Content-Type specifies the media type of the underlying data.\n   Content-Encoding may be used to indicate any additional content\n   codings applied to the data, usually for the purpose of data\n   compression, that are a property of the requested resource. There is\n   no default encoding.\n\n   Any HTTP/1.1 message containing an entity-body SHOULD include a\n   Content-Type header field defining the media type of that body. If\n   and only if the media type is not given by a Content-Type field, the\n   recipient MAY attempt to guess the media type via inspection of its\n   content and/or the name extension(s) of the URI used to identify the\n   resource. If the media type remains unknown, the recipient SHOULD\n   treat it as type \"application/octet-stream\".\n\n7.2.2 Entity Length\n\n   The entity-length of a message is the length of the message-body\n   before any transfer-codings have been applied. Section 4.4 defines\n   how the transfer-length of a message-body is determined.\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 43]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8 Connections\n\n8.1 Persistent Connections\n\n8.1.1 Purpose\n\n   Prior to persistent connections, a separate TCP connection was\n   established to fetch each URL, increasing the load on HTTP servers\n   and causing congestion on the Internet. The use of inline images and\n   other associated data often require a client to make multiple\n   requests of the same server in a short amount of time. Analysis of\n   these performance problems and results from a prototype\n   implementation are available [26] [30]. Implementation experience and\n   measurements of actual HTTP/1.1 (RFC 2068) implementations show good\n   results [39]. Alternatives have also been explored, for example,\n   T/TCP [27].\n\n   Persistent HTTP connections have a number of advantages:\n\n      - By opening and closing fewer TCP connections, CPU time is saved\n        in routers and hosts (clients, servers, proxies, gateways,\n        tunnels, or caches), and memory used for TCP protocol control\n        blocks can be saved in hosts.\n\n      - HTTP requests and responses can be pipelined on a connection.\n        Pipelining allows a client to make multiple requests without\n        waiting for each response, allowing a single TCP connection to\n        be used much more efficiently, with much lower elapsed time.\n\n      - Network congestion is reduced by reducing the number of packets\n        caused by TCP opens, and by allowing TCP sufficient time to\n        determine the congestion state of the network.\n\n      - Latency on subsequent requests is reduced since there is no time\n        spent in TCP's connection opening handshake.\n\n      - HTTP can evolve more gracefully, since errors can be reported\n        without the penalty of closing the TCP connection. Clients using\n        future versions of HTTP might optimistically try a new feature,\n        but if communicating with an older server, retry with old\n        semantics after an error is reported.\n\n   HTTP implementations SHOULD implement persistent connections.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 44]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.1.2 Overall Operation\n\n   A significant difference between HTTP/1.1 and earlier versions of\n   HTTP is that persistent connections are the default behavior of any\n   HTTP connection. That is, unless otherwise indicated, the client\n   SHOULD assume that the server will maintain a persistent connection,\n   even after error responses from the server.\n\n   Persistent connections provide a mechanism by which a client and a\n   server can signal the close of a TCP connection. This signaling takes\n   place using the Connection header field (section 14.10). Once a close\n   has been signaled, the client MUST NOT send any more requests on that\n   connection.\n\n8.1.2.1 Negotiation\n\n   An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to\n   maintain a persistent connection unless a Connection header including\n   the connection-token \"close\" was sent in the request. If the server\n   chooses to close the connection immediately after sending the\n   response, it SHOULD send a Connection header including the\n   connection-token close.\n\n   An HTTP/1.1 client MAY expect a connection to remain open, but would\n   decide to keep it open based on whether the response from a server\n   contains a Connection header with the connection-token close. In case\n   the client does not want to maintain a connection for more than that\n   request, it SHOULD send a Connection header including the\n   connection-token close.\n\n   If either the client or the server sends the close token in the\n   Connection header, that request becomes the last one for the\n   connection.\n\n   Clients and servers SHOULD NOT assume that a persistent connection is\n   maintained for HTTP versions less than 1.1 unless it is explicitly\n   signaled. See section 19.6.2 for more information on backward\n   compatibility with HTTP/1.0 clients.\n\n   In order to remain persistent, all messages on the connection MUST\n   have a self-defined message length (i.e., one not defined by closure\n   of the connection), as described in section 4.4.\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 45]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.1.2.2 Pipelining\n\n   A client that supports persistent connections MAY \"pipeline\" its\n   requests (i.e., send multiple requests without waiting for each\n   response). A server MUST send its responses to those requests in the\n   same order that the requests were received.\n\n   Clients which assume persistent connections and pipeline immediately\n   after connection establishment SHOULD be prepared to retry their\n   connection if the first pipelined attempt fails. If a client does\n   such a retry, it MUST NOT pipeline before it knows the connection is\n   persistent. Clients MUST also be prepared to resend their requests if\n   the server closes the connection before sending all of the\n   corresponding responses.\n\n   Clients SHOULD NOT pipeline requests using non-idempotent methods or\n   non-idempotent sequences of methods (see section 9.1.2). Otherwise, a\n   premature termination of the transport connection could lead to\n   indeterminate results. A client wishing to send a non-idempotent\n   request SHOULD wait to send that request until it has received the\n   response status for the previous request.\n\n8.1.3 Proxy Servers\n\n   It is especially important that proxies correctly implement the\n   properties of the Connection header field as specified in section\n   14.10.\n\n   The proxy server MUST signal persistent connections separately with\n   its clients and the origin servers (or other proxy servers) that it\n   connects to. Each persistent connection applies to only one transport\n   link.\n\n   A proxy server MUST NOT establish a HTTP/1.1 persistent connection\n   with an HTTP/1.0 client (but see RFC 2068 [33] for information and\n   discussion of the problems with the Keep-Alive header implemented by\n   many HTTP/1.0 clients).\n\n8.1.4 Practical Considerations\n\n   Servers will usually have some time-out value beyond which they will\n   no longer maintain an inactive connection. Proxy servers might make\n   this a higher value since it is likely that the client will be making\n   more connections through the same server. The use of persistent\n   connections places no requirements on the length (or existence) of\n   this time-out for either the client or the server.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 46]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   When a client or server wishes to time-out it SHOULD issue a graceful\n   close on the transport connection. Clients and servers SHOULD both\n   constantly watch for the other side of the transport close, and\n   respond to it as appropriate. If a client or server does not detect\n   the other side's close promptly it could cause unnecessary resource\n   drain on the network.\n\n   A client, server, or proxy MAY close the transport connection at any\n   time. For example, a client might have started to send a new request\n   at the same time that the server has decided to close the \"idle\"\n   connection. From the server's point of view, the connection is being\n   closed while it was idle, but from the client's point of view, a\n   request is in progress.\n\n   This means that clients, servers, and proxies MUST be able to recover\n   from asynchronous close events. Client software SHOULD reopen the\n   transport connection and retransmit the aborted sequence of requests\n   without user interaction so long as the request sequence is\n   idempotent (see section 9.1.2). Non-idempotent methods or sequences\n   MUST NOT be automatically retried, although user agents MAY offer a\n   human operator the choice of retrying the request(s). Confirmation by\n   user-agent software with semantic understanding of the application\n   MAY substitute for user confirmation. The automatic retry SHOULD NOT\n   be repeated if the second sequence of requests fails.\n\n   Servers SHOULD always respond to at least one request per connection,\n   if at all possible. Servers SHOULD NOT close a connection in the\n   middle of transmitting a response, unless a network or client failure\n   is suspected.\n\n   Clients that use persistent connections SHOULD limit the number of\n   simultaneous connections that they maintain to a given server. A\n   single-user client SHOULD NOT maintain more than 2 connections with\n   any server or proxy. A proxy SHOULD use up to 2*N connections to\n   another server or proxy, where N is the number of simultaneously\n   active users. These guidelines are intended to improve HTTP response\n   times and avoid congestion.\n\n8.2 Message Transmission Requirements\n\n8.2.1 Persistent Connections and Flow Control\n\n   HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's\n   flow control mechanisms to resolve temporary overloads, rather than\n   terminating connections with the expectation that clients will retry.\n   The latter technique can exacerbate network congestion.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 47]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.2.2 Monitoring Connections for Error Status Messages\n\n   An HTTP/1.1 (or later) client sending a message-body SHOULD monitor\n   the network connection for an error status while it is transmitting\n   the request. If the client sees an error status, it SHOULD\n   immediately cease transmitting the body. If the body is being sent\n   using a \"chunked\" encoding (section 3.6), a zero length chunk and\n   empty trailer MAY be used to prematurely mark the end of the message.\n   If the body was preceded by a Content-Length header, the client MUST\n   close the connection.\n\n8.2.3 Use of the 100 (Continue) Status\n\n   The purpose of the 100 (Continue) status (see section 10.1.1) is to\n   allow a client that is sending a request message with a request body\n   to determine if the origin server is willing to accept the request\n   (based on the request headers) before the client sends the request\n   body. In some cases, it might either be inappropriate or highly\n   inefficient for the client to send the body if the server will reject\n   the message without looking at the body.\n\n   Requirements for HTTP/1.1 clients:\n\n      - If a client will wait for a 100 (Continue) response before\n        sending the request body, it MUST send an Expect request-header\n        field (section 14.20) with the \"100-continue\" expectation.\n\n      - A client MUST NOT send an Expect request-header field (section\n        14.20) with the \"100-continue\" expectation if it does not intend\n        to send a request body.\n\n   Because of the presence of older implementations, the protocol allows\n   ambiguous situations in which a client may send \"Expect: 100-\n   continue\" without receiving either a 417 (Expectation Failed) status\n   or a 100 (Continue) status. Therefore, when a client sends this\n   header field to an origin server (possibly via a proxy) from which it\n   has never seen a 100 (Continue) status, the client SHOULD NOT wait\n   for an indefinite period before sending the request body.\n\n   Requirements for HTTP/1.1 origin servers:\n\n      - Upon receiving a request which includes an Expect request-header\n        field with the \"100-continue\" expectation, an origin server MUST\n        either respond with 100 (Continue) status and continue to read\n        from the input stream, or respond with a final status code. The\n        origin server MUST NOT wait for the request body before sending\n        the 100 (Continue) response. If it responds with a final status\n        code, it MAY close the transport connection or it MAY continue\n\n\n\nFielding, et al.            Standards Track                    [Page 48]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n        to read and discard the rest of the request.  It MUST NOT\n        perform the requested method if it returns a final status code.\n\n      - An origin server SHOULD NOT send a 100 (Continue) response if\n        the request message does not include an Expect request-header\n        field with the \"100-continue\" expectation, and MUST NOT send a\n        100 (Continue) response if such a request comes from an HTTP/1.0\n        (or earlier) client. There is an exception to this rule: for\n        compatibility with RFC 2068, a server MAY send a 100 (Continue)\n        status in response to an HTTP/1.1 PUT or POST request that does\n        not include an Expect request-header field with the \"100-\n        continue\" expectation. This exception, the purpose of which is\n        to minimize any client processing delays associated with an\n        undeclared wait for 100 (Continue) status, applies only to\n        HTTP/1.1 requests, and not to requests with any other HTTP-\n        version value.\n\n      - An origin server MAY omit a 100 (Continue) response if it has\n        already received some or all of the request body for the\n        corresponding request.\n\n      - An origin server that sends a 100 (Continue) response MUST\n        ultimately send a final status code, once the request body is\n        received and processed, unless it terminates the transport\n        connection prematurely.\n\n      - If an origin server receives a request that does not include an\n        Expect request-header field with the \"100-continue\" expectation,\n        the request includes a request body, and the server responds\n        with a final status code before reading the entire request body\n        from the transport connection, then the server SHOULD NOT close\n        the transport connection until it has read the entire request,\n        or until the client closes the connection. Otherwise, the client\n        might not reliably receive the response message. However, this\n        requirement is not be construed as preventing a server from\n        defending itself against denial-of-service attacks, or from\n        badly broken client implementations.\n\n   Requirements for HTTP/1.1 proxies:\n\n      - If a proxy receives a request that includes an Expect request-\n        header field with the \"100-continue\" expectation, and the proxy\n        either knows that the next-hop server complies with HTTP/1.1 or\n        higher, or does not know the HTTP version of the next-hop\n        server, it MUST forward the request, including the Expect header\n        field.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 49]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If the proxy knows that the version of the next-hop server is\n        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST\n        respond with a 417 (Expectation Failed) status.\n\n      - Proxies SHOULD maintain a cache recording the HTTP version\n        numbers received from recently-referenced next-hop servers.\n\n      - A proxy MUST NOT forward a 100 (Continue) response if the\n        request message was received from an HTTP/1.0 (or earlier)\n        client and did not include an Expect request-header field with\n        the \"100-continue\" expectation. This requirement overrides the\n        general rule for forwarding of 1xx responses (see section 10.1).\n\n8.2.4 Client Behavior if Server Prematurely Closes Connection\n\n   If an HTTP/1.1 client sends a request which includes a request body,\n   but which does not include an Expect request-header field with the\n   \"100-continue\" expectation, and if the client is not directly\n   connected to an HTTP/1.1 origin server, and if the client sees the\n   connection close before receiving any status from the server, the\n   client SHOULD retry the request.  If the client does retry this\n   request, it MAY use the following \"binary exponential backoff\"\n   algorithm to be assured of obtaining a reliable response:\n\n      1. Initiate a new connection to the server\n\n      2. Transmit the request-headers\n\n      3. Initialize a variable R to the estimated round-trip time to the\n         server (e.g., based on the time it took to establish the\n         connection), or to a constant value of 5 seconds if the round-\n         trip time is not available.\n\n      4. Compute T = R * (2**N), where N is the number of previous\n         retries of this request.\n\n      5. Wait either for an error response from the server, or for T\n         seconds (whichever comes first)\n\n      6. If no error response is received, after T seconds transmit the\n         body of the request.\n\n      7. If client sees that the connection is closed prematurely,\n         repeat from step 1 until the request is accepted, an error\n         response is received, or the user becomes impatient and\n         terminates the retry process.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 50]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If at any point an error status is received, the client\n\n      - SHOULD NOT continue and\n\n      - SHOULD close the connection if it has not completed sending the\n        request message.\n\n9 Method Definitions\n\n   The set of common methods for HTTP/1.1 is defined below. Although\n   this set can be expanded, additional methods cannot be assumed to\n   share the same semantics for separately extended clients and servers.\n\n   The Host request-header field (section 14.23) MUST accompany all\n   HTTP/1.1 requests.\n\n9.1 Safe and Idempotent Methods\n\n9.1.1 Safe Methods\n\n   Implementors should be aware that the software represents the user in\n   their interactions over the Internet, and should be careful to allow\n   the user to be aware of any actions they might take which may have an\n   unexpected significance to themselves or others.\n\n   In particular, the convention has been established that the GET and\n   HEAD methods SHOULD NOT have the significance of taking an action\n   other than retrieval. These methods ought to be considered \"safe\".\n   This allows user agents to represent other methods, such as POST, PUT\n   and DELETE, in a special way, so that the user is made aware of the\n   fact that a possibly unsafe action is being requested.\n\n   Naturally, it is not possible to ensure that the server does not\n   generate side-effects as a result of performing a GET request; in\n   fact, some dynamic resources consider that a feature. The important\n   distinction here is that the user did not request the side-effects,\n   so therefore cannot be held accountable for them.\n\n9.1.2 Idempotent Methods\n\n   Methods can also have the property of \"idempotence\" in that (aside\n   from error or expiration issues) the side-effects of N > 0 identical\n   requests is the same as for a single request. The methods GET, HEAD,\n   PUT and DELETE share this property. Also, the methods OPTIONS and\n   TRACE SHOULD NOT have side effects, and so are inherently idempotent.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 51]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   However, it is possible that a sequence of several requests is non-\n   idempotent, even if all of the methods executed in that sequence are\n   idempotent. (A sequence is idempotent if a single execution of the\n   entire sequence always yields a result that is not changed by a\n   reexecution of all, or part, of that sequence.) For example, a\n   sequence is non-idempotent if its result depends on a value that is\n   later modified in the same sequence.\n\n   A sequence that never has side effects is idempotent, by definition\n   (provided that no concurrent operations are being executed on the\n   same set of resources).\n\n9.2 OPTIONS\n\n   The OPTIONS method represents a request for information about the\n   communication options available on the request/response chain\n   identified by the Request-URI. This method allows the client to\n   determine the options and/or requirements associated with a resource,\n   or the capabilities of a server, without implying a resource action\n   or initiating a resource retrieval.\n\n   Responses to this method are not cacheable.\n\n   If the OPTIONS request includes an entity-body (as indicated by the\n   presence of Content-Length or Transfer-Encoding), then the media type\n   MUST be indicated by a Content-Type field. Although this\n   specification does not define any use for such a body, future\n   extensions to HTTP might use the OPTIONS body to make more detailed\n   queries on the server. A server that does not support such an\n   extension MAY discard the request body.\n\n   If the Request-URI is an asterisk (\"*\"), the OPTIONS request is\n   intended to apply to the server in general rather than to a specific\n   resource. Since a server's communication options typically depend on\n   the resource, the \"*\" request is only useful as a \"ping\" or \"no-op\"\n   type of method; it does nothing beyond allowing the client to test\n   the capabilities of the server. For example, this can be used to test\n   a proxy for HTTP/1.1 compliance (or lack thereof).\n\n   If the Request-URI is not an asterisk, the OPTIONS request applies\n   only to the options that are available when communicating with that\n   resource.\n\n   A 200 response SHOULD include any header fields that indicate\n   optional features implemented by the server and applicable to that\n   resource (e.g., Allow), possibly including extensions not defined by\n   this specification. The response body, if any, SHOULD also include\n   information about the communication options. The format for such a\n\n\n\nFielding, et al.            Standards Track                    [Page 52]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   body is not defined by this specification, but might be defined by\n   future extensions to HTTP. Content negotiation MAY be used to select\n   the appropriate response format. If no response body is included, the\n   response MUST include a Content-Length field with a field-value of\n   \"0\".\n\n   The Max-Forwards request-header field MAY be used to target a\n   specific proxy in the request chain. When a proxy receives an OPTIONS\n   request on an absoluteURI for which request forwarding is permitted,\n   the proxy MUST check for a Max-Forwards field. If the Max-Forwards\n   field-value is zero (\"0\"), the proxy MUST NOT forward the message;\n   instead, the proxy SHOULD respond with its own communication options.\n   If the Max-Forwards field-value is an integer greater than zero, the\n   proxy MUST decrement the field-value when it forwards the request. If\n   no Max-Forwards field is present in the request, then the forwarded\n   request MUST NOT include a Max-Forwards field.\n\n9.3 GET\n\n   The GET method means retrieve whatever information (in the form of an\n   entity) is identified by the Request-URI. If the Request-URI refers\n   to a data-producing process, it is the produced data which shall be\n   returned as the entity in the response and not the source text of the\n   process, unless that text happens to be the output of the process.\n\n   The semantics of the GET method change to a \"conditional GET\" if the\n   request message includes an If-Modified-Since, If-Unmodified-Since,\n   If-Match, If-None-Match, or If-Range header field. A conditional GET\n   method requests that the entity be transferred only under the\n   circumstances described by the conditional header field(s). The\n   conditional GET method is intended to reduce unnecessary network\n   usage by allowing cached entities to be refreshed without requiring\n   multiple requests or transferring data already held by the client.\n\n   The semantics of the GET method change to a \"partial GET\" if the\n   request message includes a Range header field. A partial GET requests\n   that only part of the entity be transferred, as described in section\n   14.35. The partial GET method is intended to reduce unnecessary\n   network usage by allowing partially-retrieved entities to be\n   completed without transferring data already held by the client.\n\n   The response to a GET request is cacheable if and only if it meets\n   the requirements for HTTP caching described in section 13.\n\n   See section 15.1.3 for security considerations when used for forms.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 53]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n9.4 HEAD\n\n   The HEAD method is identical to GET except that the server MUST NOT\n   return a message-body in the response. The metainformation contained\n   in the HTTP headers in response to a HEAD request SHOULD be identical\n   to the information sent in response to a GET request. This method can\n   be used for obtaining metainformation about the entity implied by the\n   request without transferring the entity-body itself. This method is\n   often used for testing hypertext links for validity, accessibility,\n   and recent modification.\n\n   The response to a HEAD request MAY be cacheable in the sense that the\n   information contained in the response MAY be used to update a\n   previously cached entity from that resource. If the new field values\n   indicate that the cached entity differs from the current entity (as\n   would be indicated by a change in Content-Length, Content-MD5, ETag\n   or Last-Modified), then the cache MUST treat the cache entry as\n   stale.\n\n9.5 POST\n\n   The POST method is used to request that the origin server accept the\n   entity enclosed in the request as a new subordinate of the resource\n   identified by the Request-URI in the Request-Line. POST is designed\n   to allow a uniform method to cover the following functions:\n\n      - Annotation of existing resources;\n\n      - Posting a message to a bulletin board, newsgroup, mailing list,\n        or similar group of articles;\n\n      - Providing a block of data, such as the result of submitting a\n        form, to a data-handling process;\n\n      - Extending a database through an append operation.\n\n   The actual function performed by the POST method is determined by the\n   server and is usually dependent on the Request-URI. The posted entity\n   is subordinate to that URI in the same way that a file is subordinate\n   to a directory containing it, a news article is subordinate to a\n   newsgroup to which it is posted, or a record is subordinate to a\n   database.\n\n   The action performed by the POST method might not result in a\n   resource that can be identified by a URI. In this case, either 200\n   (OK) or 204 (No Content) is the appropriate response status,\n   depending on whether or not the response includes an entity that\n   describes the result.\n\n\n\nFielding, et al.            Standards Track                    [Page 54]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If a resource has been created on the origin server, the response\n   SHOULD be 201 (Created) and contain an entity which describes the\n   status of the request and refers to the new resource, and a Location\n   header (see section 14.30).\n\n   Responses to this method are not cacheable, unless the response\n   includes appropriate Cache-Control or Expires header fields. However,\n   the 303 (See Other) response can be used to direct the user agent to\n   retrieve a cacheable resource.\n\n   POST requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   See section 15.1.3 for security considerations.\n\n9.6 PUT\n\n   The PUT method requests that the enclosed entity be stored under the\n   supplied Request-URI. If the Request-URI refers to an already\n   existing resource, the enclosed entity SHOULD be considered as a\n   modified version of the one residing on the origin server. If the\n   Request-URI does not point to an existing resource, and that URI is\n   capable of being defined as a new resource by the requesting user\n   agent, the origin server can create the resource with that URI. If a\n   new resource is created, the origin server MUST inform the user agent\n   via the 201 (Created) response. If an existing resource is modified,\n   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent\n   to indicate successful completion of the request. If the resource\n   could not be created or modified with the Request-URI, an appropriate\n   error response SHOULD be given that reflects the nature of the\n   problem. The recipient of the entity MUST NOT ignore any Content-*\n   (e.g. Content-Range) headers that it does not understand or implement\n   and MUST return a 501 (Not Implemented) response in such cases.\n\n   If the request passes through a cache and the Request-URI identifies\n   one or more currently cached entities, those entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\n   The fundamental difference between the POST and PUT requests is\n   reflected in the different meaning of the Request-URI. The URI in a\n   POST request identifies the resource that will handle the enclosed\n   entity. That resource might be a data-accepting process, a gateway to\n   some other protocol, or a separate entity that accepts annotations.\n   In contrast, the URI in a PUT request identifies the entity enclosed\n   with the request -- the user agent knows what URI is intended and the\n   server MUST NOT attempt to apply the request to some other resource.\n   If the server desires that the request be applied to a different URI,\n\n\n\n\nFielding, et al.            Standards Track                    [Page 55]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   it MUST send a 301 (Moved Permanently) response; the user agent MAY\n   then make its own decision regarding whether or not to redirect the\n   request.\n\n   A single resource MAY be identified by many different URIs. For\n   example, an article might have a URI for identifying \"the current\n   version\" which is separate from the URI identifying each particular\n   version. In this case, a PUT request on a general URI might result in\n   several other URIs being defined by the origin server.\n\n   HTTP/1.1 does not define how a PUT method affects the state of an\n   origin server.\n\n   PUT requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   Unless otherwise specified for a particular entity-header, the\n   entity-headers in the PUT request SHOULD be applied to the resource\n   created or modified by the PUT.\n\n9.7 DELETE\n\n   The DELETE method requests that the origin server delete the resource\n   identified by the Request-URI. This method MAY be overridden by human\n   intervention (or other means) on the origin server. The client cannot\n   be guaranteed that the operation has been carried out, even if the\n   status code returned from the origin server indicates that the action\n   has been completed successfully. However, the server SHOULD NOT\n   indicate success unless, at the time the response is given, it\n   intends to delete the resource or move it to an inaccessible\n   location.\n\n   A successful response SHOULD be 200 (OK) if the response includes an\n   entity describing the status, 202 (Accepted) if the action has not\n   yet been enacted, or 204 (No Content) if the action has been enacted\n   but the response does not include an entity.\n\n   If the request passes through a cache and the Request-URI identifies\n   one or more currently cached entities, those entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\n9.8 TRACE\n\n   The TRACE method is used to invoke a remote, application-layer loop-\n   back of the request message. The final recipient of the request\n   SHOULD reflect the message received back to the client as the\n   entity-body of a 200 (OK) response. The final recipient is either the\n\n\n\n\nFielding, et al.            Standards Track                    [Page 56]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   origin server or the first proxy or gateway to receive a Max-Forwards\n   value of zero (0) in the request (see section 14.31). A TRACE request\n   MUST NOT include an entity.\n\n   TRACE allows the client to see what is being received at the other\n   end of the request chain and use that data for testing or diagnostic\n   information. The value of the Via header field (section 14.45) is of\n   particular interest, since it acts as a trace of the request chain.\n   Use of the Max-Forwards header field allows the client to limit the\n   length of the request chain, which is useful for testing a chain of\n   proxies forwarding messages in an infinite loop.\n\n   If the request is valid, the response SHOULD contain the entire\n   request message in the entity-body, with a Content-Type of\n   \"message/http\". Responses to this method MUST NOT be cached.\n\n9.9 CONNECT\n\n   This specification reserves the method name CONNECT for use with a\n   proxy that can dynamically switch to being a tunnel (e.g. SSL\n   tunneling [44]).\n\n10 Status Code Definitions\n\n   Each Status-Code is described below, including a description of which\n   method(s) it can follow and any metainformation required in the\n   response.\n\n10.1 Informational 1xx\n\n   This class of status code indicates a provisional response,\n   consisting only of the Status-Line and optional headers, and is\n   terminated by an empty line. There are no required headers for this\n   class of status code. Since HTTP/1.0 did not define any 1xx status\n   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client\n   except under experimental conditions.\n\n   A client MUST be prepared to accept one or more 1xx status responses\n   prior to a regular response, even if the client does not expect a 100\n   (Continue) status message. Unexpected 1xx status responses MAY be\n   ignored by a user agent.\n\n   Proxies MUST forward 1xx responses, unless the connection between the\n   proxy and its client has been closed, or unless the proxy itself\n   requested the generation of the 1xx response. (For example, if a\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 57]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   proxy adds a \"Expect: 100-continue\" field when it forwards a request,\n   then it need not forward the corresponding 100 (Continue)\n   response(s).)\n\n10.1.1 100 Continue\n\n   The client SHOULD continue with its request. This interim response is\n   used to inform the client that the initial part of the request has\n   been received and has not yet been rejected by the server. The client\n   SHOULD continue by sending the remainder of the request or, if the\n   request has already been completed, ignore this response. The server\n   MUST send a final response after the request has been completed. See\n   section 8.2.3 for detailed discussion of the use and handling of this\n   status code.\n\n10.1.2 101 Switching Protocols\n\n   The server understands and is willing to comply with the client's\n   request, via the Upgrade message header field (section 14.42), for a\n   change in the application protocol being used on this connection. The\n   server will switch protocols to those defined by the response's\n   Upgrade header field immediately after the empty line which\n   terminates the 101 response.\n\n   The protocol SHOULD be switched only when it is advantageous to do\n   so. For example, switching to a newer version of HTTP is advantageous\n   over older versions, and switching to a real-time, synchronous\n   protocol might be advantageous when delivering resources that use\n   such features.\n\n10.2 Successful 2xx\n\n   This class of status code indicates that the client's request was\n   successfully received, understood, and accepted.\n\n10.2.1 200 OK\n\n   The request has succeeded. The information returned with the response\n   is dependent on the method used in the request, for example:\n\n   GET    an entity corresponding to the requested resource is sent in\n          the response;\n\n   HEAD   the entity-header fields corresponding to the requested\n          resource are sent in the response without any message-body;\n\n   POST   an entity describing or containing the result of the action;\n\n\n\n\nFielding, et al.            Standards Track                    [Page 58]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   TRACE  an entity containing the request message as received by the\n          end server.\n\n10.2.2 201 Created\n\n   The request has been fulfilled and resulted in a new resource being\n   created. The newly created resource can be referenced by the URI(s)\n   returned in the entity of the response, with the most specific URI\n   for the resource given by a Location header field. The response\n   SHOULD include an entity containing a list of resource\n   characteristics and location(s) from which the user or user agent can\n   choose the one most appropriate. The entity format is specified by\n   the media type given in the Content-Type header field. The origin\n   server MUST create the resource before returning the 201 status code.\n   If the action cannot be carried out immediately, the server SHOULD\n   respond with 202 (Accepted) response instead.\n\n   A 201 response MAY contain an ETag response header field indicating\n   the current value of the entity tag for the requested variant just\n   created, see section 14.19.\n\n10.2.3 202 Accepted\n\n   The request has been accepted for processing, but the processing has\n   not been completed.  The request might or might not eventually be\n   acted upon, as it might be disallowed when processing actually takes\n   place. There is no facility for re-sending a status code from an\n   asynchronous operation such as this.\n\n   The 202 response is intentionally non-committal. Its purpose is to\n   allow a server to accept a request for some other process (perhaps a\n   batch-oriented process that is only run once per day) without\n   requiring that the user agent's connection to the server persist\n   until the process is completed. The entity returned with this\n   response SHOULD include an indication of the request's current status\n   and either a pointer to a status monitor or some estimate of when the\n   user can expect the request to be fulfilled.\n\n10.2.4 203 Non-Authoritative Information\n\n   The returned metainformation in the entity-header is not the\n   definitive set as available from the origin server, but is gathered\n   from a local or a third-party copy. The set presented MAY be a subset\n   or superset of the original version. For example, including local\n   annotation information about the resource might result in a superset\n   of the metainformation known by the origin server. Use of this\n   response code is not required and is only appropriate when the\n   response would otherwise be 200 (OK).\n\n\n\nFielding, et al.            Standards Track                    [Page 59]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.2.5 204 No Content\n\n   The server has fulfilled the request but does not need to return an\n   entity-body, and might want to return updated metainformation. The\n   response MAY include new or updated metainformation in the form of\n   entity-headers, which if present SHOULD be associated with the\n   requested variant.\n\n   If the client is a user agent, it SHOULD NOT change its document view\n   from that which caused the request to be sent. This response is\n   primarily intended to allow input for actions to take place without\n   causing a change to the user agent's active document view, although\n   any new or updated metainformation SHOULD be applied to the document\n   currently in the user agent's active view.\n\n   The 204 response MUST NOT include a message-body, and thus is always\n   terminated by the first empty line after the header fields.\n\n10.2.6 205 Reset Content\n\n   The server has fulfilled the request and the user agent SHOULD reset\n   the document view which caused the request to be sent. This response\n   is primarily intended to allow input for actions to take place via\n   user input, followed by a clearing of the form in which the input is\n   given so that the user can easily initiate another input action. The\n   response MUST NOT include an entity.\n\n10.2.7 206 Partial Content\n\n   The server has fulfilled the partial GET request for the resource.\n   The request MUST have included a Range header field (section 14.35)\n   indicating the desired range, and MAY have included an If-Range\n   header field (section 14.27) to make the request conditional.\n\n   The response MUST include the following header fields:\n\n      - Either a Content-Range header field (section 14.16) indicating\n        the range included with this response, or a multipart/byteranges\n        Content-Type including Content-Range fields for each part. If a\n        Content-Length header field is present in the response, its\n        value MUST match the actual number of OCTETs transmitted in the\n        message-body.\n\n      - Date\n\n      - ETag and/or Content-Location, if the header would have been sent\n        in a 200 response to the same request\n\n\n\n\nFielding, et al.            Standards Track                    [Page 60]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - Expires, Cache-Control, and/or Vary, if the field-value might\n        differ from that sent in any previous response for the same\n        variant\n\n   If the 206 response is the result of an If-Range request that used a\n   strong cache validator (see section 13.3.3), the response SHOULD NOT\n   include other entity-headers. If the response is the result of an\n   If-Range request that used a weak validator, the response MUST NOT\n   include other entity-headers; this prevents inconsistencies between\n   cached entity-bodies and updated headers. Otherwise, the response\n   MUST include all of the entity-headers that would have been returned\n   with a 200 (OK) response to the same request.\n\n   A cache MUST NOT combine a 206 response with other previously cached\n   content if the ETag or Last-Modified headers do not match exactly,\n   see 13.5.4.\n\n   A cache that does not support the Range and Content-Range headers\n   MUST NOT cache 206 (Partial) responses.\n\n10.3 Redirection 3xx\n\n   This class of status code indicates that further action needs to be\n   taken by the user agent in order to fulfill the request.  The action\n   required MAY be carried out by the user agent without interaction\n   with the user if and only if the method used in the second request is\n   GET or HEAD. A client SHOULD detect infinite redirection loops, since\n   such loops generate network traffic for each redirection.\n\n      Note: previous versions of this specification recommended a\n      maximum of five redirections. Content developers should be aware\n      that there might be clients that implement such a fixed\n      limitation.\n\n10.3.1 300 Multiple Choices\n\n   The requested resource corresponds to any one of a set of\n   representations, each with its own specific location, and agent-\n   driven negotiation information (section 12) is being provided so that\n   the user (or user agent) can select a preferred representation and\n   redirect its request to that location.\n\n   Unless it was a HEAD request, the response SHOULD include an entity\n   containing a list of resource characteristics and location(s) from\n   which the user or user agent can choose the one most appropriate. The\n   entity format is specified by the media type given in the Content-\n   Type header field. Depending upon the format and the capabilities of\n\n\n\n\nFielding, et al.            Standards Track                    [Page 61]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the user agent, selection of the most appropriate choice MAY be\n   performed automatically. However, this specification does not define\n   any standard for such automatic selection.\n\n   If the server has a preferred choice of representation, it SHOULD\n   include the specific URI for that representation in the Location\n   field; user agents MAY use the Location field value for automatic\n   redirection. This response is cacheable unless indicated otherwise.\n\n10.3.2 301 Moved Permanently\n\n   The requested resource has been assigned a new permanent URI and any\n   future references to this resource SHOULD use one of the returned\n   URIs.  Clients with link editing capabilities ought to automatically\n   re-link references to the Request-URI to one or more of the new\n   references returned by the server, where possible. This response is\n   cacheable unless indicated otherwise.\n\n   The new permanent URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n   If the 301 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n      Note: When automatically redirecting a POST request after\n      receiving a 301 status code, some existing HTTP/1.0 user agents\n      will erroneously change it into a GET request.\n\n10.3.3 302 Found\n\n   The requested resource resides temporarily under a different URI.\n   Since the redirection might be altered on occasion, the client SHOULD\n   continue to use the Request-URI for future requests.  This response\n   is only cacheable if indicated by a Cache-Control or Expires header\n   field.\n\n   The temporary URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 62]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the 302 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n      Note: RFC 1945 and RFC 2068 specify that the client is not allowed\n      to change the method on the redirected request.  However, most\n      existing user agent implementations treat 302 as if it were a 303\n      response, performing a GET on the Location field-value regardless\n      of the original request method. The status codes 303 and 307 have\n      been added for servers that wish to make unambiguously clear which\n      kind of reaction is expected of the client.\n\n10.3.4 303 See Other\n\n   The response to the request can be found under a different URI and\n   SHOULD be retrieved using a GET method on that resource. This method\n   exists primarily to allow the output of a POST-activated script to\n   redirect the user agent to a selected resource. The new URI is not a\n   substitute reference for the originally requested resource. The 303\n   response MUST NOT be cached, but the response to the second\n   (redirected) request might be cacheable.\n\n   The different URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n      Note: Many pre-HTTP/1.1 user agents do not understand the 303\n      status. When interoperability with such clients is a concern, the\n      302 status code may be used instead, since most user agents react\n      to a 302 response as described here for 303.\n\n10.3.5 304 Not Modified\n\n   If the client has performed a conditional GET request and access is\n   allowed, but the document has not been modified, the server SHOULD\n   respond with this status code. The 304 response MUST NOT contain a\n   message-body, and thus is always terminated by the first empty line\n   after the header fields.\n\n   The response MUST include the following header fields:\n\n      - Date, unless its omission is required by section 14.18.1\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 63]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If a clockless origin server obeys these rules, and proxies and\n   clients add their own Date to any response received without one (as\n   already specified by [RFC 2068], section 14.19), caches will operate\n   correctly.\n\n      - ETag and/or Content-Location, if the header would have been sent\n        in a 200 response to the same request\n\n      - Expires, Cache-Control, and/or Vary, if the field-value might\n        differ from that sent in any previous response for the same\n        variant\n\n   If the conditional GET used a strong cache validator (see section\n   13.3.3), the response SHOULD NOT include other entity-headers.\n   Otherwise (i.e., the conditional GET used a weak validator), the\n   response MUST NOT include other entity-headers; this prevents\n   inconsistencies between cached entity-bodies and updated headers.\n\n   If a 304 response indicates an entity not currently cached, then the\n   cache MUST disregard the response and repeat the request without the\n   conditional.\n\n   If a cache uses a received 304 response to update a cache entry, the\n   cache MUST update the entry to reflect any new field values given in\n   the response.\n\n10.3.6 305 Use Proxy\n\n   The requested resource MUST be accessed through the proxy given by\n   the Location field. The Location field gives the URI of the proxy.\n   The recipient is expected to repeat this single request via the\n   proxy. 305 responses MUST only be generated by origin servers.\n\n      Note: RFC 2068 was not clear that 305 was intended to redirect a\n      single request, and to be generated by origin servers only.  Not\n      observing these limitations has significant security consequences.\n\n10.3.7 306 (Unused)\n\n   The 306 status code was used in a previous version of the\n   specification, is no longer used, and the code is reserved.\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 64]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.3.8 307 Temporary Redirect\n\n   The requested resource resides temporarily under a different URI.\n   Since the redirection MAY be altered on occasion, the client SHOULD\n   continue to use the Request-URI for future requests.  This response\n   is only cacheable if indicated by a Cache-Control or Expires header\n   field.\n\n   The temporary URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s) , since many pre-HTTP/1.1 user agents do not\n   understand the 307 status. Therefore, the note SHOULD contain the\n   information necessary for a user to repeat the original request on\n   the new URI.\n\n   If the 307 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n10.4 Client Error 4xx\n\n   The 4xx class of status code is intended for cases in which the\n   client seems to have erred. Except when responding to a HEAD request,\n   the server SHOULD include an entity containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n   condition. These status codes are applicable to any request method.\n   User agents SHOULD display any included entity to the user.\n\n   If the client is sending data, a server implementation using TCP\n   SHOULD be careful to ensure that the client acknowledges receipt of\n   the packet(s) containing the response, before the server closes the\n   input connection. If the client continues sending data to the server\n   after the close, the server's TCP stack will send a reset packet to\n   the client, which may erase the client's unacknowledged input buffers\n   before they can be read and interpreted by the HTTP application.\n\n10.4.1 400 Bad Request\n\n   The request could not be understood by the server due to malformed\n   syntax. The client SHOULD NOT repeat the request without\n   modifications.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 65]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.2 401 Unauthorized\n\n   The request requires user authentication. The response MUST include a\n   WWW-Authenticate header field (section 14.47) containing a challenge\n   applicable to the requested resource. The client MAY repeat the\n   request with a suitable Authorization header field (section 14.8). If\n   the request already included Authorization credentials, then the 401\n   response indicates that authorization has been refused for those\n   credentials. If the 401 response contains the same challenge as the\n   prior response, and the user agent has already attempted\n   authentication at least once, then the user SHOULD be presented the\n   entity that was given in the response, since that entity might\n   include relevant diagnostic information. HTTP access authentication\n   is explained in \"HTTP Authentication: Basic and Digest Access\n   Authentication\" [43].\n\n10.4.3 402 Payment Required\n\n   This code is reserved for future use.\n\n10.4.4 403 Forbidden\n\n   The server understood the request, but is refusing to fulfill it.\n   Authorization will not help and the request SHOULD NOT be repeated.\n   If the request method was not HEAD and the server wishes to make\n   public why the request has not been fulfilled, it SHOULD describe the\n   reason for the refusal in the entity.  If the server does not wish to\n   make this information available to the client, the status code 404\n   (Not Found) can be used instead.\n\n10.4.5 404 Not Found\n\n   The server has not found anything matching the Request-URI. No\n   indication is given of whether the condition is temporary or\n   permanent. The 410 (Gone) status code SHOULD be used if the server\n   knows, through some internally configurable mechanism, that an old\n   resource is permanently unavailable and has no forwarding address.\n   This status code is commonly used when the server does not wish to\n   reveal exactly why the request has been refused, or when no other\n   response is applicable.\n\n10.4.6 405 Method Not Allowed\n\n   The method specified in the Request-Line is not allowed for the\n   resource identified by the Request-URI. The response MUST include an\n   Allow header containing a list of valid methods for the requested\n   resource.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 66]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.7 406 Not Acceptable\n\n   The resource identified by the request is only capable of generating\n   response entities which have content characteristics not acceptable\n   according to the accept headers sent in the request.\n\n   Unless it was a HEAD request, the response SHOULD include an entity\n   containing a list of available entity characteristics and location(s)\n   from which the user or user agent can choose the one most\n   appropriate. The entity format is specified by the media type given\n   in the Content-Type header field. Depending upon the format and the\n   capabilities of the user agent, selection of the most appropriate\n   choice MAY be performed automatically. However, this specification\n   does not define any standard for such automatic selection.\n\n      Note: HTTP/1.1 servers are allowed to return responses which are\n      not acceptable according to the accept headers sent in the\n      request. In some cases, this may even be preferable to sending a\n      406 response. User agents are encouraged to inspect the headers of\n      an incoming response to determine if it is acceptable.\n\n   If the response could be unacceptable, a user agent SHOULD\n   temporarily stop receipt of more data and query the user for a\n   decision on further actions.\n\n10.4.8 407 Proxy Authentication Required\n\n   This code is similar to 401 (Unauthorized), but indicates that the\n   client must first authenticate itself with the proxy. The proxy MUST\n   return a Proxy-Authenticate header field (section 14.33) containing a\n   challenge applicable to the proxy for the requested resource. The\n   client MAY repeat the request with a suitable Proxy-Authorization\n   header field (section 14.34). HTTP access authentication is explained\n   in \"HTTP Authentication: Basic and Digest Access Authentication\"\n   [43].\n\n10.4.9 408 Request Timeout\n\n   The client did not produce a request within the time that the server\n   was prepared to wait. The client MAY repeat the request without\n   modifications at any later time.\n\n10.4.10 409 Conflict\n\n   The request could not be completed due to a conflict with the current\n   state of the resource. This code is only allowed in situations where\n   it is expected that the user might be able to resolve the conflict\n   and resubmit the request. The response body SHOULD include enough\n\n\n\nFielding, et al.            Standards Track                    [Page 67]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   information for the user to recognize the source of the conflict.\n   Ideally, the response entity would include enough information for the\n   user or user agent to fix the problem; however, that might not be\n   possible and is not required.\n\n   Conflicts are most likely to occur in response to a PUT request. For\n   example, if versioning were being used and the entity being PUT\n   included changes to a resource which conflict with those made by an\n   earlier (third-party) request, the server might use the 409 response\n   to indicate that it can't complete the request. In this case, the\n   response entity would likely contain a list of the differences\n   between the two versions in a format defined by the response\n   Content-Type.\n\n10.4.11 410 Gone\n\n   The requested resource is no longer available at the server and no\n   forwarding address is known. This condition is expected to be\n   considered permanent. Clients with link editing capabilities SHOULD\n   delete references to the Request-URI after user approval. If the\n   server does not know, or has no facility to determine, whether or not\n   the condition is permanent, the status code 404 (Not Found) SHOULD be\n   used instead. This response is cacheable unless indicated otherwise.\n\n   The 410 response is primarily intended to assist the task of web\n   maintenance by notifying the recipient that the resource is\n   intentionally unavailable and that the server owners desire that\n   remote links to that resource be removed. Such an event is common for\n   limited-time, promotional services and for resources belonging to\n   individuals no longer working at the server's site. It is not\n   necessary to mark all permanently unavailable resources as \"gone\" or\n   to keep the mark for any length of time -- that is left to the\n   discretion of the server owner.\n\n10.4.12 411 Length Required\n\n   The server refuses to accept the request without a defined Content-\n   Length. The client MAY repeat the request if it adds a valid\n   Content-Length header field containing the length of the message-body\n   in the request message.\n\n10.4.13 412 Precondition Failed\n\n   The precondition given in one or more of the request-header fields\n   evaluated to false when it was tested on the server. This response\n   code allows the client to place preconditions on the current resource\n   metainformation (header field data) and thus prevent the requested\n   method from being applied to a resource other than the one intended.\n\n\n\nFielding, et al.            Standards Track                    [Page 68]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.14 413 Request Entity Too Large\n\n   The server is refusing to process a request because the request\n   entity is larger than the server is willing or able to process. The\n   server MAY close the connection to prevent the client from continuing\n   the request.\n\n   If the condition is temporary, the server SHOULD include a Retry-\n   After header field to indicate that it is temporary and after what\n   time the client MAY try again.\n\n10.4.15 414 Request-URI Too Long\n\n   The server is refusing to service the request because the Request-URI\n   is longer than the server is willing to interpret. This rare\n   condition is only likely to occur when a client has improperly\n   converted a POST request to a GET request with long query\n   information, when the client has descended into a URI \"black hole\" of\n   redirection (e.g., a redirected URI prefix that points to a suffix of\n   itself), or when the server is under attack by a client attempting to\n   exploit security holes present in some servers using fixed-length\n   buffers for reading or manipulating the Request-URI.\n\n10.4.16 415 Unsupported Media Type\n\n   The server is refusing to service the request because the entity of\n   the request is in a format not supported by the requested resource\n   for the requested method.\n\n10.4.17 416 Requested Range Not Satisfiable\n\n   A server SHOULD return a response with this status code if a request\n   included a Range request-header field (section 14.35), and none of\n   the range-specifier values in this field overlap the current extent\n   of the selected resource, and the request did not include an If-Range\n   request-header field. (For byte-ranges, this means that the first-\n   byte-pos of all of the byte-range-spec values were greater than the\n   current length of the selected resource.)\n\n   When this status code is returned for a byte-range request, the\n   response SHOULD include a Content-Range entity-header field\n   specifying the current length of the selected resource (see section\n   14.16). This response MUST NOT use the multipart/byteranges content-\n   type.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 69]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.18 417 Expectation Failed\n\n   The expectation given in an Expect request-header field (see section\n   14.20) could not be met by this server, or, if the server is a proxy,\n   the server has unambiguous evidence that the request could not be met\n   by the next-hop server.\n\n10.5 Server Error 5xx\n\n   Response status codes beginning with the digit \"5\" indicate cases in\n   which the server is aware that it has erred or is incapable of\n   performing the request. Except when responding to a HEAD request, the\n   server SHOULD include an entity containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n   condition. User agents SHOULD display any included entity to the\n   user. These response codes are applicable to any request method.\n\n10.5.1 500 Internal Server Error\n\n   The server encountered an unexpected condition which prevented it\n   from fulfilling the request.\n\n10.5.2 501 Not Implemented\n\n   The server does not support the functionality required to fulfill the\n   request. This is the appropriate response when the server does not\n   recognize the request method and is not capable of supporting it for\n   any resource.\n\n10.5.3 502 Bad Gateway\n\n   The server, while acting as a gateway or proxy, received an invalid\n   response from the upstream server it accessed in attempting to\n   fulfill the request.\n\n10.5.4 503 Service Unavailable\n\n   The server is currently unable to handle the request due to a\n   temporary overloading or maintenance of the server. The implication\n   is that this is a temporary condition which will be alleviated after\n   some delay. If known, the length of the delay MAY be indicated in a\n   Retry-After header. If no Retry-After is given, the client SHOULD\n   handle the response as it would for a 500 response.\n\n      Note: The existence of the 503 status code does not imply that a\n      server must use it when becoming overloaded. Some servers may wish\n      to simply refuse the connection.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 70]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.5.5 504 Gateway Timeout\n\n   The server, while acting as a gateway or proxy, did not receive a\n   timely response from the upstream server specified by the URI (e.g.\n   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed\n   to access in attempting to complete the request.\n\n      Note: Note to implementors: some deployed proxies are known to\n      return 400 or 500 when DNS lookups time out.\n\n10.5.6 505 HTTP Version Not Supported\n\n   The server does not support, or refuses to support, the HTTP protocol\n   version that was used in the request message. The server is\n   indicating that it is unable or unwilling to complete the request\n   using the same major version as the client, as described in section\n   3.1, other than with this error message. The response SHOULD contain\n   an entity describing why that version is not supported and what other\n   protocols are supported by that server.\n\n11 Access Authentication\n\n   HTTP provides several OPTIONAL challenge-response authentication\n   mechanisms which can be used by a server to challenge a client\n   request and by a client to provide authentication information. The\n   general framework for access authentication, and the specification of\n   \"basic\" and \"digest\" authentication, are specified in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. This\n   specification adopts the definitions of \"challenge\" and \"credentials\"\n   from that specification.\n\n12 Content Negotiation\n\n   Most HTTP responses include an entity which contains information for\n   interpretation by a human user. Naturally, it is desirable to supply\n   the user with the \"best available\" entity corresponding to the\n   request. Unfortunately for servers and caches, not all users have the\n   same preferences for what is \"best,\" and not all user agents are\n   equally capable of rendering all entity types. For that reason, HTTP\n   has provisions for several mechanisms for \"content negotiation\" --\n   the process of selecting the best representation for a given response\n   when there are multiple representations available.\n\n      Note: This is not called \"format negotiation\" because the\n      alternate representations may be of the same media type, but use\n      different capabilities of that type, be in different languages,\n      etc.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 71]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Any response containing an entity-body MAY be subject to negotiation,\n   including error responses.\n\n   There are two kinds of content negotiation which are possible in\n   HTTP: server-driven and agent-driven negotiation. These two kinds of\n   negotiation are orthogonal and thus may be used separately or in\n   combination. One method of combination, referred to as transparent\n   negotiation, occurs when a cache uses the agent-driven negotiation\n   information provided by the origin server in order to provide\n   server-driven negotiation for subsequent requests.\n\n12.1 Server-driven Negotiation\n\n   If the selection of the best representation for a response is made by\n   an algorithm located at the server, it is called server-driven\n   negotiation. Selection is based on the available representations of\n   the response (the dimensions over which it can vary; e.g. language,\n   content-coding, etc.) and the contents of particular header fields in\n   the request message or on other information pertaining to the request\n   (such as the network address of the client).\n\n   Server-driven negotiation is advantageous when the algorithm for\n   selecting from among the available representations is difficult to\n   describe to the user agent, or when the server desires to send its\n   \"best guess\" to the client along with the first response (hoping to\n   avoid the round-trip delay of a subsequent request if the \"best\n   guess\" is good enough for the user). In order to improve the server's\n   guess, the user agent MAY include request header fields (Accept,\n   Accept-Language, Accept-Encoding, etc.) which describe its\n   preferences for such a response.\n\n   Server-driven negotiation has disadvantages:\n\n      1. It is impossible for the server to accurately determine what\n         might be \"best\" for any given user, since that would require\n         complete knowledge of both the capabilities of the user agent\n         and the intended use for the response (e.g., does the user want\n         to view it on screen or print it on paper?).\n\n      2. Having the user agent describe its capabilities in every\n         request can be both very inefficient (given that only a small\n         percentage of responses have multiple representations) and a\n         potential violation of the user's privacy.\n\n      3. It complicates the implementation of an origin server and the\n         algorithms for generating responses to a request.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 72]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      4. It may limit a public cache's ability to use the same response\n         for multiple user's requests.\n\n   HTTP/1.1 includes the following request-header fields for enabling\n   server-driven negotiation through description of user agent\n   capabilities and user preferences: Accept (section 14.1), Accept-\n   Charset (section 14.2), Accept-Encoding (section 14.3), Accept-\n   Language (section 14.4), and User-Agent (section 14.43). However, an\n   origin server is not limited to these dimensions and MAY vary the\n   response based on any aspect of the request, including information\n   outside the request-header fields or within extension header fields\n   not defined by this specification.\n\n   The Vary  header field can be used to express the parameters the\n   server uses to select a representation that is subject to server-\n   driven negotiation. See section 13.6 for use of the Vary header field\n   by caches and section 14.44 for use of the Vary header field by\n   servers.\n\n12.2 Agent-driven Negotiation\n\n   With agent-driven negotiation, selection of the best representation\n   for a response is performed by the user agent after receiving an\n   initial response from the origin server. Selection is based on a list\n   of the available representations of the response included within the\n   header fields or entity-body of the initial response, with each\n   representation identified by its own URI. Selection from among the\n   representations may be performed automatically (if the user agent is\n   capable of doing so) or manually by the user selecting from a\n   generated (possibly hypertext) menu.\n\n   Agent-driven negotiation is advantageous when the response would vary\n   over commonly-used dimensions (such as type, language, or encoding),\n   when the origin server is unable to determine a user agent's\n   capabilities from examining the request, and generally when public\n   caches are used to distribute server load and reduce network usage.\n\n   Agent-driven negotiation suffers from the disadvantage of needing a\n   second request to obtain the best alternate representation. This\n   second request is only efficient when caching is used. In addition,\n   this specification does not define any mechanism for supporting\n   automatic selection, though it also does not prevent any such\n   mechanism from being developed as an extension and used within\n   HTTP/1.1.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 73]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)\n   status codes for enabling agent-driven negotiation when the server is\n   unwilling or unable to provide a varying response using server-driven\n   negotiation.\n\n12.3 Transparent Negotiation\n\n   Transparent negotiation is a combination of both server-driven and\n   agent-driven negotiation. When a cache is supplied with a form of the\n   list of available representations of the response (as in agent-driven\n   negotiation) and the dimensions of variance are completely understood\n   by the cache, then the cache becomes capable of performing server-\n   driven negotiation on behalf of the origin server for subsequent\n   requests on that resource.\n\n   Transparent negotiation has the advantage of distributing the\n   negotiation work that would otherwise be required of the origin\n   server and also removing the second request delay of agent-driven\n   negotiation when the cache is able to correctly guess the right\n   response.\n\n   This specification does not define any mechanism for transparent\n   negotiation, though it also does not prevent any such mechanism from\n   being developed as an extension that could be used within HTTP/1.1.\n\n13 Caching in HTTP\n\n   HTTP is typically used for distributed information systems, where\n   performance can be improved by the use of response caches. The\n   HTTP/1.1 protocol includes a number of elements intended to make\n   caching work as well as possible. Because these elements are\n   inextricable from other aspects of the protocol, and because they\n   interact with each other, it is useful to describe the basic caching\n   design of HTTP separately from the detailed descriptions of methods,\n   headers, response codes, etc.\n\n   Caching would be useless if it did not significantly improve\n   performance. The goal of caching in HTTP/1.1 is to eliminate the need\n   to send requests in many cases, and to eliminate the need to send\n   full responses in many other cases. The former reduces the number of\n   network round-trips required for many operations; we use an\n   \"expiration\" mechanism for this purpose (see section 13.2). The\n   latter reduces network bandwidth requirements; we use a \"validation\"\n   mechanism for this purpose (see section 13.3).\n\n   Requirements for performance, availability, and disconnected\n   operation require us to be able to relax the goal of semantic\n   transparency. The HTTP/1.1 protocol allows origin servers, caches,\n\n\n\nFielding, et al.            Standards Track                    [Page 74]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   and clients to explicitly reduce transparency when necessary.\n   However, because non-transparent operation may confuse non-expert\n   users, and might be incompatible with certain server applications\n   (such as those for ordering merchandise), the protocol requires that\n   transparency be relaxed\n\n      - only by an explicit protocol-level request when relaxed by\n        client or origin server\n\n      - only with an explicit warning to the end user when relaxed by\n        cache or client\n\n   Therefore, the HTTP/1.1 protocol provides these important elements:\n\n      1. Protocol features that provide full semantic transparency when\n         this is required by all parties.\n\n      2. Protocol features that allow an origin server or user agent to\n         explicitly request and control non-transparent operation.\n\n      3. Protocol features that allow a cache to attach warnings to\n         responses that do not preserve the requested approximation of\n         semantic transparency.\n\n   A basic principle is that it must be possible for the clients to\n   detect any potential relaxation of semantic transparency.\n\n      Note: The server, cache, or client implementor might be faced with\n      design decisions not explicitly discussed in this specification.\n      If a decision might affect semantic transparency, the implementor\n      ought to err on the side of maintaining transparency unless a\n      careful and complete analysis shows significant benefits in\n      breaking transparency.\n\n13.1.1 Cache Correctness\n\n   A correct cache MUST respond to a request with the most up-to-date\n   response held by the cache that is appropriate to the request (see\n   sections 13.2.5, 13.2.6, and 13.12) which meets one of the following\n   conditions:\n\n      1. It has been checked for equivalence with what the origin server\n         would have returned by revalidating the response with the\n         origin server (section 13.3);\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 75]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      2. It is \"fresh enough\" (see section 13.2). In the default case,\n         this means it meets the least restrictive freshness requirement\n         of the client, origin server, and cache (see section 14.9); if\n         the origin server so specifies, it is the freshness requirement\n         of the origin server alone.\n\n         If a stored response is not \"fresh enough\" by the most\n         restrictive freshness requirement of both the client and the\n         origin server, in carefully considered circumstances the cache\n         MAY still return the response with the appropriate Warning\n         header (see section 13.1.5 and 14.46), unless such a response\n         is prohibited (e.g., by a \"no-store\" cache-directive, or by a\n         \"no-cache\" cache-request-directive; see section 14.9).\n\n      3. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect),\n         or error (4xx or 5xx) response message.\n\n   If the cache can not communicate with the origin server, then a\n   correct cache SHOULD respond as above if the response can be\n   correctly served from the cache; if not it MUST return an error or\n   warning indicating that there was a communication failure.\n\n   If a cache receives a response (either an entire response, or a 304\n   (Not Modified) response) that it would normally forward to the\n   requesting client, and the received response is no longer fresh, the\n   cache SHOULD forward it to the requesting client without adding a new\n   Warning (but without removing any existing Warning headers). A cache\n   SHOULD NOT attempt to revalidate a response simply because that\n   response became stale in transit; this might lead to an infinite\n   loop. A user agent that receives a stale response without a Warning\n   MAY display a warning indication to the user.\n\n13.1.2 Warnings\n\n   Whenever a cache returns a response that is neither first-hand nor\n   \"fresh enough\" (in the sense of condition 2 in section 13.1.1), it\n   MUST attach a warning to that effect, using a Warning general-header.\n   The Warning header and the currently defined warnings are described\n   in section 14.46. The warning allows clients to take appropriate\n   action.\n\n   Warnings MAY be used for other purposes, both cache-related and\n   otherwise. The use of a warning, rather than an error status code,\n   distinguish these responses from true failures.\n\n   Warnings are assigned three digit warn-codes. The first digit\n   indicates whether the Warning MUST or MUST NOT be deleted from a\n   stored cache entry after a successful revalidation:\n\n\n\nFielding, et al.            Standards Track                    [Page 76]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   1xx  Warnings that describe the freshness or revalidation status of\n     the response, and so MUST be deleted after a successful\n     revalidation. 1XX warn-codes MAY be generated by a cache only when\n     validating a cached entry. It MUST NOT be generated by clients.\n\n   2xx  Warnings that describe some aspect of the entity body or entity\n     headers that is not rectified by a revalidation (for example, a\n     lossy compression of the entity bodies) and which MUST NOT be\n     deleted after a successful revalidation.\n\n   See section 14.46 for the definitions of the codes themselves.\n\n   HTTP/1.0 caches will cache all Warnings in responses, without\n   deleting the ones in the first category. Warnings in responses that\n   are passed to HTTP/1.0 caches carry an extra warning-date field,\n   which prevents a future HTTP/1.1 recipient from believing an\n   erroneously cached Warning.\n\n   Warnings also carry a warning text. The text MAY be in any\n   appropriate natural language (perhaps based on the client's Accept\n   headers), and include an OPTIONAL indication of what character set is\n   used.\n\n   Multiple warnings MAY be attached to a response (either by the origin\n   server or by a cache), including multiple warnings with the same code\n   number. For example, a server might provide the same warning with\n   texts in both English and Basque.\n\n   When multiple warnings are attached to a response, it might not be\n   practical or reasonable to display all of them to the user. This\n   version of HTTP does not specify strict priority rules for deciding\n   which warnings to display and in what order, but does suggest some\n   heuristics.\n\n13.1.3 Cache-control Mechanisms\n\n   The basic cache mechanisms in HTTP/1.1 (server-specified expiration\n   times and validators) are implicit directives to caches. In some\n   cases, a server or client might need to provide explicit directives\n   to the HTTP caches. We use the Cache-Control header for this purpose.\n\n   The Cache-Control header allows a client or server to transmit a\n   variety of directives in either requests or responses. These\n   directives typically override the default caching algorithms. As a\n   general rule, if there is any apparent conflict between header\n   values, the most restrictive interpretation is applied (that is, the\n   one that is most likely to preserve semantic transparency). However,\n\n\n\n\nFielding, et al.            Standards Track                    [Page 77]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   in some cases, cache-control directives are explicitly specified as\n   weakening the approximation of semantic transparency (for example,\n   \"max-stale\" or \"public\").\n\n   The cache-control directives are described in detail in section 14.9.\n\n13.1.4 Explicit User Agent Warnings\n\n   Many user agents make it possible for users to override the basic\n   caching mechanisms. For example, the user agent might allow the user\n   to specify that cached entities (even explicitly stale ones) are\n   never validated. Or the user agent might habitually add \"Cache-\n   Control: max-stale=3600\" to every request. The user agent SHOULD NOT\n   default to either non-transparent behavior, or behavior that results\n   in abnormally ineffective caching, but MAY be explicitly configured\n   to do so by an explicit action of the user.\n\n   If the user has overridden the basic caching mechanisms, the user\n   agent SHOULD explicitly indicate to the user whenever this results in\n   the display of information that might not meet the server's\n   transparency requirements (in particular, if the displayed entity is\n   known to be stale). Since the protocol normally allows the user agent\n   to determine if responses are stale or not, this indication need only\n   be displayed when this actually happens. The indication need not be a\n   dialog box; it could be an icon (for example, a picture of a rotting\n   fish) or some other indicator.\n\n   If the user has overridden the caching mechanisms in a way that would\n   abnormally reduce the effectiveness of caches, the user agent SHOULD\n   continually indicate this state to the user (for example, by a\n   display of a picture of currency in flames) so that the user does not\n   inadvertently consume excess resources or suffer from excessive\n   latency.\n\n13.1.5 Exceptions to the Rules and Warnings\n\n   In some cases, the operator of a cache MAY choose to configure it to\n   return stale responses even when not requested by clients. This\n   decision ought not be made lightly, but may be necessary for reasons\n   of availability or performance, especially when the cache is poorly\n   connected to the origin server. Whenever a cache returns a stale\n   response, it MUST mark it as such (using a Warning header) enabling\n   the client software to alert the user that there might be a potential\n   problem.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 78]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   It also allows the user agent to take steps to obtain a first-hand or\n   fresh response. For this reason, a cache SHOULD NOT return a stale\n   response if the client explicitly requests a first-hand or fresh one,\n   unless it is impossible to comply for technical or policy reasons.\n\n13.1.6 Client-controlled Behavior\n\n   While the origin server (and to a lesser extent, intermediate caches,\n   by their contribution to the age of a response) are the primary\n   source of expiration information, in some cases the client might need\n   to control a cache's decision about whether to return a cached\n   response without validating it. Clients do this using several\n   directives of the Cache-Control header.\n\n   A client's request MAY specify the maximum age it is willing to\n   accept of an unvalidated response; specifying a value of zero forces\n   the cache(s) to revalidate all responses. A client MAY also specify\n   the minimum time remaining before a response expires. Both of these\n   options increase constraints on the behavior of caches, and so cannot\n   further relax the cache's approximation of semantic transparency.\n\n   A client MAY also specify that it will accept stale responses, up to\n   some maximum amount of staleness. This loosens the constraints on the\n   caches, and so might violate the origin server's specified\n   constraints on semantic transparency, but might be necessary to\n   support disconnected operation, or high availability in the face of\n   poor connectivity.\n\n13.2 Expiration Model\n\n13.2.1 Server-Specified Expiration\n\n   HTTP caching works best when caches can entirely avoid making\n   requests to the origin server. The primary mechanism for avoiding\n   requests is for an origin server to provide an explicit expiration\n   time in the future, indicating that a response MAY be used to satisfy\n   subsequent requests. In other words, a cache can return a fresh\n   response without first contacting the server.\n\n   Our expectation is that servers will assign future explicit\n   expiration times to responses in the belief that the entity is not\n   likely to change, in a semantically significant way, before the\n   expiration time is reached. This normally preserves semantic\n   transparency, as long as the server's expiration times are carefully\n   chosen.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 79]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The expiration mechanism applies only to responses taken from a cache\n   and not to first-hand responses forwarded immediately to the\n   requesting client.\n\n   If an origin server wishes to force a semantically transparent cache\n   to validate every request, it MAY assign an explicit expiration time\n   in the past. This means that the response is always stale, and so the\n   cache SHOULD validate it before using it for subsequent requests. See\n   section 14.9.4 for a more restrictive way to force revalidation.\n\n   If an origin server wishes to force any HTTP/1.1 cache, no matter how\n   it is configured, to validate every request, it SHOULD use the \"must-\n   revalidate\" cache-control directive (see section 14.9).\n\n   Servers specify explicit expiration times using either the Expires\n   header, or the max-age directive of the Cache-Control header.\n\n   An expiration time cannot be used to force a user agent to refresh\n   its display or reload a resource; its semantics apply only to caching\n   mechanisms, and such mechanisms need only check a resource's\n   expiration status when a new request for that resource is initiated.\n   See section 13.13 for an explanation of the difference between caches\n   and history mechanisms.\n\n13.2.2 Heuristic Expiration\n\n   Since origin servers do not always provide explicit expiration times,\n   HTTP caches typically assign heuristic expiration times, employing\n   algorithms that use other header values (such as the Last-Modified\n   time) to estimate a plausible expiration time. The HTTP/1.1\n   specification does not provide specific algorithms, but does impose\n   worst-case constraints on their results. Since heuristic expiration\n   times might compromise semantic transparency, they ought to used\n   cautiously, and we encourage origin servers to provide explicit\n   expiration times as much as possible.\n\n13.2.3 Age Calculations\n\n   In order to know if a cached entry is fresh, a cache needs to know if\n   its age exceeds its freshness lifetime. We discuss how to calculate\n   the latter in section 13.2.4; this section describes how to calculate\n   the age of a response or cache entry.\n\n   In this discussion, we use the term \"now\" to mean \"the current value\n   of the clock at the host performing the calculation.\" Hosts that use\n   HTTP, but especially hosts running origin servers and caches, SHOULD\n   use NTP [28] or some similar protocol to synchronize their clocks to\n   a globally accurate time standard.\n\n\n\nFielding, et al.            Standards Track                    [Page 80]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 requires origin servers to send a Date header, if possible,\n   with every response, giving the time at which the response was\n   generated (see section 14.18). We use the term \"date_value\" to denote\n   the value of the Date header, in a form appropriate for arithmetic\n   operations.\n\n   HTTP/1.1 uses the Age response-header to convey the estimated age of\n   the response message when obtained from a cache. The Age field value\n   is the cache's estimate of the amount of time since the response was\n   generated or revalidated by the origin server.\n\n   In essence, the Age value is the sum of the time that the response\n   has been resident in each of the caches along the path from the\n   origin server, plus the amount of time it has been in transit along\n   network paths.\n\n   We use the term \"age_value\" to denote the value of the Age header, in\n   a form appropriate for arithmetic operations.\n\n   A response's age can be calculated in two entirely independent ways:\n\n      1. now minus date_value, if the local clock is reasonably well\n         synchronized to the origin server's clock. If the result is\n         negative, the result is replaced by zero.\n\n      2. age_value, if all of the caches along the response path\n         implement HTTP/1.1.\n\n   Given that we have two independent ways to compute the age of a\n   response when it is received, we can combine these as\n\n       corrected_received_age = max(now - date_value, age_value)\n\n   and as long as we have either nearly synchronized clocks or all-\n   HTTP/1.1 paths, one gets a reliable (conservative) result.\n\n   Because of network-imposed delays, some significant interval might\n   pass between the time that a server generates a response and the time\n   it is received at the next outbound cache or client. If uncorrected,\n   this delay could result in improperly low ages.\n\n   Because the request that resulted in the returned Age value must have\n   been initiated prior to that Age value's generation, we can correct\n   for delays imposed by the network by recording the time at which the\n   request was initiated. Then, when an Age value is received, it MUST\n   be interpreted relative to the time the request was initiated, not\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 81]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the time that the response was received. This algorithm results in\n   conservative behavior no matter how much delay is experienced. So, we\n   compute:\n\n      corrected_initial_age = corrected_received_age\n                            + (now - request_time)\n\n   where \"request_time\" is the time (according to the local clock) when\n   the request that elicited this response was sent.\n\n   Summary of age calculation algorithm, when a cache receives a\n   response:\n\n      /*\n       * age_value\n       *      is the value of Age: header received by the cache with\n       *              this response.\n       * date_value\n       *      is the value of the origin server's Date: header\n       * request_time\n       *      is the (local) time when the cache made the request\n       *              that resulted in this cached response\n       * response_time\n       *      is the (local) time when the cache received the\n       *              response\n       * now\n       *      is the current (local) time\n       */\n\n      apparent_age = max(0, response_time - date_value);\n      corrected_received_age = max(apparent_age, age_value);\n      response_delay = response_time - request_time;\n      corrected_initial_age = corrected_received_age + response_delay;\n      resident_time = now - response_time;\n      current_age   = corrected_initial_age + resident_time;\n\n   The current_age of a cache entry is calculated by adding the amount\n   of time (in seconds) since the cache entry was last validated by the\n   origin server to the corrected_initial_age. When a response is\n   generated from a cache entry, the cache MUST include a single Age\n   header field in the response with a value equal to the cache entry's\n   current_age.\n\n   The presence of an Age header field in a response implies that a\n   response is not first-hand. However, the converse is not true, since\n   the lack of an Age header field in a response does not imply that the\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 82]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   response is first-hand unless all caches along the request path are\n   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement\n   the Age header field).\n\n13.2.4 Expiration Calculations\n\n   In order to decide whether a response is fresh or stale, we need to\n   compare its freshness lifetime to its age. The age is calculated as\n   described in section 13.2.3; this section describes how to calculate\n   the freshness lifetime, and to determine if a response has expired.\n   In the discussion below, the values can be represented in any form\n   appropriate for arithmetic operations.\n\n   We use the term \"expires_value\" to denote the value of the Expires\n   header. We use the term \"max_age_value\" to denote an appropriate\n   value of the number of seconds carried by the \"max-age\" directive of\n   the Cache-Control header in a response (see section 14.9.3).\n\n   The max-age directive takes priority over Expires, so if max-age is\n   present in a response, the calculation is simply:\n\n      freshness_lifetime = max_age_value\n\n   Otherwise, if Expires is present in the response, the calculation is:\n\n      freshness_lifetime = expires_value - date_value\n\n   Note that neither of these calculations is vulnerable to clock skew,\n   since all of the information comes from the origin server.\n\n   If none of Expires, Cache-Control: max-age, or Cache-Control: s-\n   maxage (see section 14.9.3) appears in the response, and the response\n   does not include other restrictions on caching, the cache MAY compute\n   a freshness lifetime using a heuristic. The cache MUST attach Warning\n   113 to any response whose age is more than 24 hours if such warning\n   has not already been added.\n\n   Also, if the response does have a Last-Modified time, the heuristic\n   expiration value SHOULD be no more than some fraction of the interval\n   since that time. A typical setting of this fraction might be 10%.\n\n   The calculation to determine if a response has expired is quite\n   simple:\n\n      response_is_fresh = (freshness_lifetime > current_age)\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 83]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.2.5 Disambiguating Expiration Values\n\n   Because expiration values are assigned optimistically, it is possible\n   for two caches to contain fresh values for the same resource that are\n   different.\n\n   If a client performing a retrieval receives a non-first-hand response\n   for a request that was already fresh in its own cache, and the Date\n   header in its existing cache entry is newer than the Date on the new\n   response, then the client MAY ignore the response. If so, it MAY\n   retry the request with a \"Cache-Control: max-age=0\" directive (see\n   section 14.9), to force a check with the origin server.\n\n   If a cache has two fresh responses for the same representation with\n   different validators, it MUST use the one with the more recent Date\n   header. This situation might arise because the cache is pooling\n   responses from other caches, or because a client has asked for a\n   reload or a revalidation of an apparently fresh cache entry.\n\n13.2.6 Disambiguating Multiple Responses\n\n   Because a client might be receiving responses via multiple paths, so\n   that some responses flow through one set of caches and other\n   responses flow through a different set of caches, a client might\n   receive responses in an order different from that in which the origin\n   server sent them. We would like the client to use the most recently\n   generated response, even if older responses are still apparently\n   fresh.\n\n   Neither the entity tag nor the expiration value can impose an\n   ordering on responses, since it is possible that a later response\n   intentionally carries an earlier expiration time. The Date values are\n   ordered to a granularity of one second.\n\n   When a client tries to revalidate a cache entry, and the response it\n   receives contains a Date header that appears to be older than the one\n   for the existing entry, then the client SHOULD repeat the request\n   unconditionally, and include\n\n       Cache-Control: max-age=0\n\n   to force any intermediate caches to validate their copies directly\n   with the origin server, or\n\n       Cache-Control: no-cache\n\n   to force any intermediate caches to obtain a new copy from the origin\n   server.\n\n\n\nFielding, et al.            Standards Track                    [Page 84]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the Date values are equal, then the client MAY use either response\n   (or MAY, if it is being extremely prudent, request a new response).\n   Servers MUST NOT depend on clients being able to choose\n   deterministically between responses generated during the same second,\n   if their expiration times overlap.\n\n13.3 Validation Model\n\n   When a cache has a stale entry that it would like to use as a\n   response to a client's request, it first has to check with the origin\n   server (or possibly an intermediate cache with a fresh response) to\n   see if its cached entry is still usable. We call this \"validating\"\n   the cache entry. Since we do not want to have to pay the overhead of\n   retransmitting the full response if the cached entry is good, and we\n   do not want to pay the overhead of an extra round trip if the cached\n   entry is invalid, the HTTP/1.1 protocol supports the use of\n   conditional methods.\n\n   The key protocol features for supporting conditional methods are\n   those concerned with \"cache validators.\" When an origin server\n   generates a full response, it attaches some sort of validator to it,\n   which is kept with the cache entry. When a client (user agent or\n   proxy cache) makes a conditional request for a resource for which it\n   has a cache entry, it includes the associated validator in the\n   request.\n\n   The server then checks that validator against the current validator\n   for the entity, and, if they match (see section 13.3.3), it responds\n   with a special status code (usually, 304 (Not Modified)) and no\n   entity-body. Otherwise, it returns a full response (including\n   entity-body). Thus, we avoid transmitting the full response if the\n   validator matches, and we avoid an extra round trip if it does not\n   match.\n\n   In HTTP/1.1, a conditional request looks exactly the same as a normal\n   request for the same resource, except that it carries a special\n   header (which includes the validator) that implicitly turns the\n   method (usually, GET) into a conditional.\n\n   The protocol includes both positive and negative senses of cache-\n   validating conditions. That is, it is possible to request either that\n   a method be performed if and only if a validator matches or if and\n   only if no validators match.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 85]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      Note: a response that lacks a validator may still be cached, and\n      served from cache until it expires, unless this is explicitly\n      prohibited by a cache-control directive. However, a cache cannot\n      do a conditional retrieval if it does not have a validator for the\n      entity, which means it will not be refreshable after it expires.\n\n13.3.1 Last-Modified Dates\n\n   The Last-Modified entity-header field value is often used as a cache\n   validator. In simple terms, a cache entry is considered to be valid\n   if the entity has not been modified since the Last-Modified value.\n\n13.3.2 Entity Tag Cache Validators\n\n   The ETag response-header field value, an entity tag, provides for an\n   \"opaque\" cache validator. This might allow more reliable validation\n   in situations where it is inconvenient to store modification dates,\n   where the one-second resolution of HTTP date values is not\n   sufficient, or where the origin server wishes to avoid certain\n   paradoxes that might arise from the use of modification dates.\n\n   Entity Tags are described in section 3.11. The headers used with\n   entity tags are described in sections 14.19, 14.24, 14.26 and 14.44.\n\n13.3.3 Weak and Strong Validators\n\n   Since both origin servers and caches will compare two validators to\n   decide if they represent the same or different entities, one normally\n   would expect that if the entity (the entity-body or any entity-\n   headers) changes in any way, then the associated validator would\n   change as well. If this is true, then we call this validator a\n   \"strong validator.\"\n\n   However, there might be cases when a server prefers to change the\n   validator only on semantically significant changes, and not when\n   insignificant aspects of the entity change. A validator that does not\n   always change when the resource changes is a \"weak validator.\"\n\n   Entity tags are normally \"strong validators,\" but the protocol\n   provides a mechanism to tag an entity tag as \"weak.\" One can think of\n   a strong validator as one that changes whenever the bits of an entity\n   changes, while a weak value changes whenever the meaning of an entity\n   changes. Alternatively, one can think of a strong validator as part\n   of an identifier for a specific entity, while a weak validator is\n   part of an identifier for a set of semantically equivalent entities.\n\n      Note: One example of a strong validator is an integer that is\n      incremented in stable storage every time an entity is changed.\n\n\n\nFielding, et al.            Standards Track                    [Page 86]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      An entity's modification time, if represented with one-second\n      resolution, could be a weak validator, since it is possible that\n      the resource might be modified twice during a single second.\n\n      Support for weak validators is optional. However, weak validators\n      allow for more efficient caching of equivalent objects; for\n      example, a hit counter on a site is probably good enough if it is\n      updated every few days or weeks, and any value during that period\n      is likely \"good enough\" to be equivalent.\n\n   A \"use\" of a validator is either when a client generates a request\n   and includes the validator in a validating header field, or when a\n   server compares two validators.\n\n   Strong validators are usable in any context. Weak validators are only\n   usable in contexts that do not depend on exact equality of an entity.\n   For example, either kind is usable for a conditional GET of a full\n   entity. However, only a strong validator is usable for a sub-range\n   retrieval, since otherwise the client might end up with an internally\n   inconsistent entity.\n\n   Clients MAY issue simple (non-subrange) GET requests with either weak\n   validators or strong validators. Clients MUST NOT use weak validators\n   in other forms of request.\n\n   The only function that the HTTP/1.1 protocol defines on validators is\n   comparison. There are two validator comparison functions, depending\n   on whether the comparison context allows the use of weak validators\n   or not:\n\n      - The strong comparison function: in order to be considered equal,\n        both validators MUST be identical in every way, and both MUST\n        NOT be weak.\n\n      - The weak comparison function: in order to be considered equal,\n        both validators MUST be identical in every way, but either or\n        both of them MAY be tagged as \"weak\" without affecting the\n        result.\n\n   An entity tag is strong unless it is explicitly tagged as weak.\n   Section 3.11 gives the syntax for entity tags.\n\n   A Last-Modified time, when used as a validator in a request, is\n   implicitly weak unless it is possible to deduce that it is strong,\n   using the following rules:\n\n      - The validator is being compared by an origin server to the\n        actual current validator for the entity and,\n\n\n\nFielding, et al.            Standards Track                    [Page 87]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - That origin server reliably knows that the associated entity did\n        not change twice during the second covered by the presented\n        validator.\n\n   or\n\n      - The validator is about to be used by a client in an If-\n        Modified-Since or If-Unmodified-Since header, because the client\n        has a cache entry for the associated entity, and\n\n      - That cache entry includes a Date value, which gives the time\n        when the origin server sent the original response, and\n\n      - The presented Last-Modified time is at least 60 seconds before\n        the Date value.\n\n   or\n\n      - The validator is being compared by an intermediate cache to the\n        validator stored in its cache entry for the entity, and\n\n      - That cache entry includes a Date value, which gives the time\n        when the origin server sent the original response, and\n\n      - The presented Last-Modified time is at least 60 seconds before\n        the Date value.\n\n   This method relies on the fact that if two different responses were\n   sent by the origin server during the same second, but both had the\n   same Last-Modified time, then at least one of those responses would\n   have a Date value equal to its Last-Modified time. The arbitrary 60-\n   second limit guards against the possibility that the Date and Last-\n   Modified values are generated from different clocks, or at somewhat\n   different times during the preparation of the response. An\n   implementation MAY use a value larger than 60 seconds, if it is\n   believed that 60 seconds is too short.\n\n   If a client wishes to perform a sub-range retrieval on a value for\n   which it has only a Last-Modified time and no opaque validator, it\n   MAY do this only if the Last-Modified time is strong in the sense\n   described here.\n\n   A cache or origin server receiving a conditional request, other than\n   a full-body GET request, MUST use the strong comparison function to\n   evaluate the condition.\n\n   These rules allow HTTP/1.1 caches and clients to safely perform sub-\n   range retrievals on values that have been obtained from HTTP/1.0\n\n\n\nFielding, et al.            Standards Track                    [Page 88]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   servers.\n\n13.3.4 Rules for When to Use Entity Tags and Last-Modified Dates\n\n   We adopt a set of rules and recommendations for origin servers,\n   clients, and caches regarding when various validator types ought to\n   be used, and for what purposes.\n\n   HTTP/1.1 origin servers:\n\n      - SHOULD send an entity tag validator unless it is not feasible to\n        generate one.\n\n      - MAY send a weak entity tag instead of a strong entity tag, if\n        performance considerations support the use of weak entity tags,\n        or if it is unfeasible to send a strong entity tag.\n\n      - SHOULD send a Last-Modified value if it is feasible to send one,\n        unless the risk of a breakdown in semantic transparency that\n        could result from using this date in an If-Modified-Since header\n        would lead to serious problems.\n\n   In other words, the preferred behavior for an HTTP/1.1 origin server\n   is to send both a strong entity tag and a Last-Modified value.\n\n   In order to be legal, a strong entity tag MUST change whenever the\n   associated entity value changes in any way. A weak entity tag SHOULD\n   change whenever the associated entity changes in a semantically\n   significant way.\n\n      Note: in order to provide semantically transparent caching, an\n      origin server must avoid reusing a specific strong entity tag\n      value for two different entities, or reusing a specific weak\n      entity tag value for two semantically different entities. Cache\n      entries might persist for arbitrarily long periods, regardless of\n      expiration times, so it might be inappropriate to expect that a\n      cache will never again attempt to validate an entry using a\n      validator that it obtained at some point in the past.\n\n   HTTP/1.1 clients:\n\n      - If an entity tag has been provided by the origin server, MUST\n        use that entity tag in any cache-conditional request (using If-\n        Match or If-None-Match).\n\n      - If only a Last-Modified value has been provided by the origin\n        server, SHOULD use that value in non-subrange cache-conditional\n        requests (using If-Modified-Since).\n\n\n\nFielding, et al.            Standards Track                    [Page 89]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If only a Last-Modified value has been provided by an HTTP/1.0\n        origin server, MAY use that value in subrange cache-conditional\n        requests (using If-Unmodified-Since:). The user agent SHOULD\n        provide a way to disable this, in case of difficulty.\n\n      - If both an entity tag and a Last-Modified value have been\n        provided by the origin server, SHOULD use both validators in\n        cache-conditional requests. This allows both HTTP/1.0 and\n        HTTP/1.1 caches to respond appropriately.\n\n   An HTTP/1.1 origin server, upon receiving a conditional request that\n   includes both a Last-Modified date (e.g., in an If-Modified-Since or\n   If-Unmodified-Since header field) and one or more entity tags (e.g.,\n   in an If-Match, If-None-Match, or If-Range header field) as cache\n   validators, MUST NOT return a response status of 304 (Not Modified)\n   unless doing so is consistent with all of the conditional header\n   fields in the request.\n\n   An HTTP/1.1 caching proxy, upon receiving a conditional request that\n   includes both a Last-Modified date and one or more entity tags as\n   cache validators, MUST NOT return a locally cached response to the\n   client unless that cached response is consistent with all of the\n   conditional header fields in the request.\n\n      Note: The general principle behind these rules is that HTTP/1.1\n      servers and clients should transmit as much non-redundant\n      information as is available in their responses and requests.\n      HTTP/1.1 systems receiving this information will make the most\n      conservative assumptions about the validators they receive.\n\n      HTTP/1.0 clients and caches will ignore entity tags. Generally,\n      last-modified values received or used by these systems will\n      support transparent and efficient caching, and so HTTP/1.1 origin\n      servers should provide Last-Modified values. In those rare cases\n      where the use of a Last-Modified value as a validator by an\n      HTTP/1.0 system could result in a serious problem, then HTTP/1.1\n      origin servers should not provide one.\n\n13.3.5 Non-validating Conditionals\n\n   The principle behind entity tags is that only the service author\n   knows the semantics of a resource well enough to select an\n   appropriate cache validation mechanism, and the specification of any\n   validator comparison function more complex than byte-equality would\n   open up a can of worms. Thus, comparisons of any other headers\n   (except Last-Modified, for compatibility with HTTP/1.0) are never\n   used for purposes of validating a cache entry.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 90]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.4 Response Cacheability\n\n   Unless specifically constrained by a cache-control (section 14.9)\n   directive, a caching system MAY always store a successful response\n   (see section 13.8) as a cache entry, MAY return it without validation\n   if it is fresh, and MAY return it after successful validation. If\n   there is neither a cache validator nor an explicit expiration time\n   associated with a response, we do not expect it to be cached, but\n   certain caches MAY violate this expectation (for example, when little\n   or no network connectivity is available). A client can usually detect\n   that such a response was taken from a cache by comparing the Date\n   header to the current time.\n\n      Note: some HTTP/1.0 caches are known to violate this expectation\n      without providing any Warning.\n\n   However, in some cases it might be inappropriate for a cache to\n   retain an entity, or to return it in response to a subsequent\n   request. This might be because absolute semantic transparency is\n   deemed necessary by the service author, or because of security or\n   privacy considerations. Certain cache-control directives are\n   therefore provided so that the server can indicate that certain\n   resource entities, or portions thereof, are not to be cached\n   regardless of other considerations.\n\n   Note that section 14.8 normally prevents a shared cache from saving\n   and returning a response to a previous request if that request\n   included an Authorization header.\n\n   A response received with a status code of 200, 203, 206, 300, 301 or\n   410 MAY be stored by a cache and used in reply to a subsequent\n   request, subject to the expiration mechanism, unless a cache-control\n   directive prohibits caching. However, a cache that does not support\n   the Range and Content-Range headers MUST NOT cache 206 (Partial\n   Content) responses.\n\n   A response received with any other status code (e.g. status codes 302\n   and 307) MUST NOT be returned in a reply to a subsequent request\n   unless there are cache-control directives or another header(s) that\n   explicitly allow it. For example, these include the following: an\n   Expires header (section 14.21); a \"max-age\", \"s-maxage\",  \"must-\n   revalidate\", \"proxy-revalidate\", \"public\" or \"private\" cache-control\n   directive (section 14.9).\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 91]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5 Constructing Responses From Caches\n\n   The purpose of an HTTP cache is to store information received in\n   response to requests for use in responding to future requests. In\n   many cases, a cache simply returns the appropriate parts of a\n   response to the requester. However, if the cache holds a cache entry\n   based on a previous response, it might have to combine parts of a new\n   response with what is held in the cache entry.\n\n13.5.1 End-to-end and Hop-by-hop Headers\n\n   For the purpose of defining the behavior of caches and non-caching\n   proxies, we divide HTTP headers into two categories:\n\n      - End-to-end headers, which are  transmitted to the ultimate\n        recipient of a request or response. End-to-end headers in\n        responses MUST be stored as part of a cache entry and MUST be\n        transmitted in any response formed from a cache entry.\n\n      - Hop-by-hop headers, which are meaningful only for a single\n        transport-level connection, and are not stored by caches or\n        forwarded by proxies.\n\n   The following HTTP/1.1 headers are hop-by-hop headers:\n\n      - Connection\n      - Keep-Alive\n      - Proxy-Authenticate\n      - Proxy-Authorization\n      - TE\n      - Trailers\n      - Transfer-Encoding\n      - Upgrade\n\n   All other headers defined by HTTP/1.1 are end-to-end headers.\n\n   Other hop-by-hop headers MUST be listed in a Connection header,\n   (section 14.10) to be introduced into HTTP/1.1 (or later).\n\n13.5.2 Non-modifiable Headers\n\n   Some features of the HTTP/1.1 protocol, such as Digest\n   Authentication, depend on the value of certain end-to-end headers. A\n   transparent proxy SHOULD NOT modify an end-to-end header unless the\n   definition of that header requires or specifically allows that.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 92]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A transparent proxy MUST NOT modify any of the following fields in a\n   request or response, and it MUST NOT add any of these fields if not\n   already present:\n\n      - Content-Location\n\n      - Content-MD5\n\n      - ETag\n\n      - Last-Modified\n\n   A transparent proxy MUST NOT modify any of the following fields in a\n   response:\n\n      - Expires\n\n   but it MAY add any of these fields if not already present. If an\n   Expires header is added, it MUST be given a field-value identical to\n   that of the Date header in that response.\n\n   A  proxy MUST NOT modify or add any of the following fields in a\n   message that contains the no-transform cache-control directive, or in\n   any request:\n\n      - Content-Encoding\n\n      - Content-Range\n\n      - Content-Type\n\n   A non-transparent proxy MAY modify or add these fields to a message\n   that does not include no-transform, but if it does so, it MUST add a\n   Warning 214 (Transformation applied) if one does not already appear\n   in the message (see section 14.46).\n\n      Warning: unnecessary modification of end-to-end headers might\n      cause authentication failures if stronger authentication\n      mechanisms are introduced in later versions of HTTP. Such\n      authentication mechanisms MAY rely on the values of header fields\n      not listed here.\n\n   The Content-Length field of a request or response is added or deleted\n   according to the rules in section 4.4. A transparent proxy MUST\n   preserve the entity-length (section 7.2.2) of the entity-body,\n   although it MAY change the transfer-length (section 4.4).\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 93]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5.3 Combining Headers\n\n   When a cache makes a validating request to a server, and the server\n   provides a 304 (Not Modified) response or a 206 (Partial Content)\n   response, the cache then constructs a response to send to the\n   requesting client.\n\n   If the status code is 304 (Not Modified), the cache uses the entity-\n   body stored in the cache entry as the entity-body of this outgoing\n   response. If the status code is 206 (Partial Content) and the ETag or\n   Last-Modified headers match exactly, the cache MAY combine the\n   contents stored in the cache entry with the new contents received in\n   the response and use the result as the entity-body of this outgoing\n   response, (see 13.5.4).\n\n   The end-to-end headers stored in the cache entry are used for the\n   constructed response, except that\n\n      - any stored Warning headers with warn-code 1xx (see section\n        14.46) MUST be deleted from the cache entry and the forwarded\n        response.\n\n      - any stored Warning headers with warn-code 2xx MUST be retained\n        in the cache entry and the forwarded response.\n\n      - any end-to-end headers provided in the 304 or 206 response MUST\n        replace the corresponding headers from the cache entry.\n\n   Unless the cache decides to remove the cache entry, it MUST also\n   replace the end-to-end headers stored with the cache entry with\n   corresponding headers received in the incoming response, except for\n   Warning headers as described immediately above. If a header field-\n   name in the incoming response matches more than one header in the\n   cache entry, all such old headers MUST be replaced.\n\n   In other words, the set of end-to-end headers received in the\n   incoming response overrides all corresponding end-to-end headers\n   stored with the cache entry (except for stored Warning headers with\n   warn-code 1xx, which are deleted even if not overridden).\n\n      Note: this rule allows an origin server to use a 304 (Not\n      Modified) or a 206 (Partial Content) response to update any header\n      associated with a previous response for the same entity or sub-\n      ranges thereof, although it might not always be meaningful or\n      correct to do so. This rule does not allow an origin server to use\n      a 304 (Not Modified) or a 206 (Partial Content) response to\n      entirely delete a header that it had provided with a previous\n      response.\n\n\n\nFielding, et al.            Standards Track                    [Page 94]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5.4 Combining Byte Ranges\n\n   A response might transfer only a subrange of the bytes of an entity-\n   body, either because the request included one or more Range\n   specifications, or because a connection was broken prematurely. After\n   several such transfers, a cache might have received several ranges of\n   the same entity-body.\n\n   If a cache has a stored non-empty set of subranges for an entity, and\n   an incoming response transfers another subrange, the cache MAY\n   combine the new subrange with the existing set if both the following\n   conditions are met:\n\n      - Both the incoming response and the cache entry have a cache\n        validator.\n\n      - The two cache validators match using the strong comparison\n        function (see section 13.3.3).\n\n   If either requirement is not met, the cache MUST use only the most\n   recent partial response (based on the Date values transmitted with\n   every response, and using the incoming response if these values are\n   equal or missing), and MUST discard the other partial information.\n\n13.6 Caching Negotiated Responses\n\n   Use of server-driven content negotiation (section 12.1), as indicated\n   by the presence of a Vary header field in a response, alters the\n   conditions and procedure by which a cache can use the response for\n   subsequent requests. See section 14.44 for use of the Vary header\n   field by servers.\n\n   A server SHOULD use the Vary header field to inform a cache of what\n   request-header fields were used to select among multiple\n   representations of a cacheable response subject to server-driven\n   negotiation. The set of header fields named by the Vary field value\n   is known as the \"selecting\" request-headers.\n\n   When the cache receives a subsequent request whose Request-URI\n   specifies one or more cache entries including a Vary header field,\n   the cache MUST NOT use such a cache entry to construct a response to\n   the new request unless all of the selecting request-headers present\n   in the new request match the corresponding stored request-headers in\n   the original request.\n\n   The selecting request-headers from two requests are defined to match\n   if and only if the selecting request-headers in the first request can\n   be transformed to the selecting request-headers in the second request\n\n\n\nFielding, et al.            Standards Track                    [Page 95]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   by adding or removing linear white space (LWS) at places where this\n   is allowed by the corresponding BNF, and/or combining multiple\n   message-header fields with the same field name following the rules\n   about message headers in section 4.2.\n\n   A Vary header field-value of \"*\" always fails to match and subsequent\n   requests on that resource can only be properly interpreted by the\n   origin server.\n\n   If the selecting request header fields for the cached entry do not\n   match the selecting request header fields of the new request, then\n   the cache MUST NOT use a cached entry to satisfy the request unless\n   it first relays the new request to the origin server in a conditional\n   request and the server responds with 304 (Not Modified), including an\n   entity tag or Content-Location that indicates the entity to be used.\n\n   If an entity tag was assigned to a cached representation, the\n   forwarded request SHOULD be conditional and include the entity tags\n   in an If-None-Match header field from all its cache entries for the\n   resource. This conveys to the server the set of entities currently\n   held by the cache, so that if any one of these entities matches the\n   requested entity, the server can use the ETag header field in its 304\n   (Not Modified) response to tell the cache which entry is appropriate.\n   If the entity-tag of the new response matches that of an existing\n   entry, the new response SHOULD be used to update the header fields of\n   the existing entry, and the result MUST be returned to the client.\n\n   If any of the existing cache entries contains only partial content\n   for the associated entity, its entity-tag SHOULD NOT be included in\n   the If-None-Match header field unless the request is for a range that\n   would be fully satisfied by that entry.\n\n   If a cache receives a successful response whose Content-Location\n   field matches that of an existing cache entry for the same Request-\n   ]URI, whose entity-tag differs from that of the existing entry, and\n   whose Date is more recent than that of the existing entry, the\n   existing entry SHOULD NOT be returned in response to future requests\n   and SHOULD be deleted from the cache.\n\n13.7 Shared and Non-Shared Caches\n\n   For reasons of security and privacy, it is necessary to make a\n   distinction between \"shared\" and \"non-shared\" caches. A non-shared\n   cache is one that is accessible only to a single user. Accessibility\n   in this case SHOULD be enforced by appropriate security mechanisms.\n   All other caches are considered to be \"shared.\" Other sections of\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 96]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   this specification place certain constraints on the operation of\n   shared caches in order to prevent loss of privacy or failure of\n   access controls.\n\n13.8 Errors or Incomplete Response Cache Behavior\n\n   A cache that receives an incomplete response (for example, with fewer\n   bytes of data than specified in a Content-Length header) MAY store\n   the response. However, the cache MUST treat this as a partial\n   response. Partial responses MAY be combined as described in section\n   13.5.4; the result might be a full response or might still be\n   partial. A cache MUST NOT return a partial response to a client\n   without explicitly marking it as such, using the 206 (Partial\n   Content) status code. A cache MUST NOT return a partial response\n   using a status code of 200 (OK).\n\n   If a cache receives a 5xx response while attempting to revalidate an\n   entry, it MAY either forward this response to the requesting client,\n   or act as if the server failed to respond. In the latter case, it MAY\n   return a previously received response unless the cached entry\n   includes the \"must-revalidate\" cache-control directive (see section\n   14.9).\n\n13.9 Side Effects of GET and HEAD\n\n   Unless the origin server explicitly prohibits the caching of their\n   responses, the application of GET and HEAD methods to any resources\n   SHOULD NOT have side effects that would lead to erroneous behavior if\n   these responses are taken from a cache. They MAY still have side\n   effects, but a cache is not required to consider such side effects in\n   its caching decisions. Caches are always expected to observe an\n   origin server's explicit restrictions on caching.\n\n   We note one exception to this rule: since some applications have\n   traditionally used GETs and HEADs with query URLs (those containing a\n   \"?\" in the rel_path part) to perform operations with significant side\n   effects, caches MUST NOT treat responses to such URIs as fresh unless\n   the server provides an explicit expiration time. This specifically\n   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT\n   be taken from a cache. See section 9.1.1 for related information.\n\n13.10 Invalidation After Updates or Deletions\n\n   The effect of certain methods performed on a resource at the origin\n   server might cause one or more existing cache entries to become non-\n   transparently invalid. That is, although they might continue to be\n   \"fresh,\" they do not accurately reflect what the origin server would\n   return for a new request on that resource.\n\n\n\nFielding, et al.            Standards Track                    [Page 97]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   There is no way for the HTTP protocol to guarantee that all such\n   cache entries are marked invalid. For example, the request that\n   caused the change at the origin server might not have gone through\n   the proxy where a cache entry is stored. However, several rules help\n   reduce the likelihood of erroneous behavior.\n\n   In this section, the phrase \"invalidate an entity\" means that the\n   cache will either remove all instances of that entity from its\n   storage, or will mark these as \"invalid\" and in need of a mandatory\n   revalidation before they can be returned in response to a subsequent\n   request.\n\n   Some HTTP methods MUST cause a cache to invalidate an entity. This is\n   either the entity referred to by the Request-URI, or by the Location\n   or Content-Location headers (if present). These methods are:\n\n      - PUT\n\n      - DELETE\n\n      - POST\n\n   In order to prevent denial of service attacks, an invalidation based\n   on the URI in a Location or Content-Location header MUST only be\n   performed if the host part is the same as in the Request-URI.\n\n   A cache that passes through requests for methods it does not\n   understand SHOULD invalidate any entities referred to by the\n   Request-URI.\n\n13.11 Write-Through Mandatory\n\n   All methods that might be expected to cause modifications to the\n   origin server's resources MUST be written through to the origin\n   server. This currently includes all methods except for GET and HEAD.\n   A cache MUST NOT reply to such a request from a client before having\n   transmitted the request to the inbound server, and having received a\n   corresponding response from the inbound server. This does not prevent\n   a proxy cache from sending a 100 (Continue) response before the\n   inbound server has sent its final reply.\n\n   The alternative (known as \"write-back\" or \"copy-back\" caching) is not\n   allowed in HTTP/1.1, due to the difficulty of providing consistent\n   updates and the problems arising from server, cache, or network\n   failure prior to write-back.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 98]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.12 Cache Replacement\n\n   If a new cacheable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8)\n   response is received from a resource while any existing responses for\n   the same resource are cached, the cache SHOULD use the new response\n   to reply to the current request. It MAY insert it into cache storage\n   and MAY, if it meets all other requirements, use it to respond to any\n   future requests that would previously have caused the old response to\n   be returned. If it inserts the new response into cache storage  the\n   rules in section 13.5.3 apply.\n\n      Note: a new response that has an older Date header value than\n      existing cached responses is not cacheable.\n\n13.13 History Lists\n\n   User agents often have history mechanisms, such as \"Back\" buttons and\n   history lists, which can be used to redisplay an entity retrieved\n   earlier in a session.\n\n   History mechanisms and caches are different. In particular history\n   mechanisms SHOULD NOT try to show a semantically transparent view of\n   the current state of a resource. Rather, a history mechanism is meant\n   to show exactly what the user saw at the time when the resource was\n   retrieved.\n\n   By default, an expiration time does not apply to history mechanisms.\n   If the entity is still in storage, a history mechanism SHOULD display\n   it even if the entity has expired, unless the user has specifically\n   configured the agent to refresh expired history documents.\n\n   This is not to be construed to prohibit the history mechanism from\n   telling the user that a view might be stale.\n\n      Note: if history list mechanisms unnecessarily prevent users from\n      viewing stale resources, this will tend to force service authors\n      to avoid using HTTP expiration controls and cache controls when\n      they would otherwise like to. Service authors may consider it\n      important that users not be presented with error messages or\n      warning messages when they use navigation controls (such as BACK)\n      to view previously fetched resources. Even though sometimes such\n      resources ought not to cached, or ought to expire quickly, user\n      interface considerations may force service authors to resort to\n      other means of preventing caching (e.g. \"once-only\" URLs) in order\n      not to suffer the effects of improperly functioning history\n      mechanisms.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 99]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14 Header Field Definitions\n\n   This section defines the syntax and semantics of all standard\n   HTTP/1.1 header fields. For entity-header fields, both sender and\n   recipient refer to either the client or the server, depending on who\n   sends and who receives the entity.\n\n14.1 Accept\n\n   The Accept request-header field can be used to specify certain media\n   types which are acceptable for the response. Accept headers can be\n   used to indicate that the request is specifically limited to a small\n   set of desired types, as in the case of a request for an in-line\n   image.\n\n       Accept         = \"Accept\" \":\"\n                        #( media-range [ accept-params ] )\n\n       media-range    = ( \"*/*\"\n                        | ( type \"/\" \"*\" )\n                        | ( type \"/\" subtype )\n                        ) *( \";\" parameter )\n       accept-params  = \";\" \"q\" \"=\" qvalue *( accept-extension )\n       accept-extension = \";\" token [ \"=\" ( token | quoted-string ) ]\n\n   The asterisk \"*\" character is used to group media types into ranges,\n   with \"*/*\" indicating all media types and \"type/*\" indicating all\n   subtypes of that type. The media-range MAY include media type\n   parameters that are applicable to that range.\n\n   Each media-range MAY be followed by one or more accept-params,\n   beginning with the \"q\" parameter for indicating a relative quality\n   factor. The first \"q\" parameter (if any) separates the media-range\n   parameter(s) from the accept-params. Quality factors allow the user\n   or user agent to indicate the relative degree of preference for that\n   media-range, using the qvalue scale from 0 to 1 (section 3.9). The\n   default value is q=1.\n\n      Note: Use of the \"q\" parameter name to separate media type\n      parameters from Accept extension parameters is due to historical\n      practice. Although this prevents any media type parameter named\n      \"q\" from being used with a media range, such an event is believed\n      to be unlikely given the lack of any \"q\" parameters in the IANA\n      media type registry and the rare usage of any media type\n      parameters in Accept. Future media types are discouraged from\n      registering any parameter named \"q\".\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 100]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The example\n\n       Accept: audio/*; q=0.2, audio/basic\n\n   SHOULD be interpreted as \"I prefer audio/basic, but send me any audio\n   type if it is the best available after an 80% mark-down in quality.\"\n\n   If no Accept header field is present, then it is assumed that the\n   client accepts all media types. If an Accept header field is present,\n   and if the server cannot send a response which is acceptable\n   according to the combined Accept field value, then the server SHOULD\n   send a 406 (not acceptable) response.\n\n   A more elaborate example is\n\n       Accept: text/plain; q=0.5, text/html,\n               text/x-dvi; q=0.8, text/x-c\n\n   Verbally, this would be interpreted as \"text/html and text/x-c are\n   the preferred media types, but if they do not exist, then send the\n   text/x-dvi entity, and if that does not exist, send the text/plain\n   entity.\"\n\n   Media ranges can be overridden by more specific media ranges or\n   specific media types. If more than one media range applies to a given\n   type, the most specific reference has precedence. For example,\n\n       Accept: text/*, text/html, text/html;level=1, */*\n\n   have the following precedence:\n\n       1) text/html;level=1\n       2) text/html\n       3) text/*\n       4) */*\n\n   The media type quality factor associated with a given type is\n   determined by finding the media range with the highest precedence\n   which matches that type. For example,\n\n       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,\n               text/html;level=2;q=0.4, */*;q=0.5\n\n   would cause the following values to be associated:\n\n       text/html;level=1         = 1\n       text/html                 = 0.7\n       text/plain                = 0.3\n\n\n\nFielding, et al.            Standards Track                   [Page 101]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       image/jpeg                = 0.5\n       text/html;level=2         = 0.4\n       text/html;level=3         = 0.7\n\n      Note: A user agent might be provided with a default set of quality\n      values for certain media ranges. However, unless the user agent is\n      a closed system which cannot interact with other rendering agents,\n      this default set ought to be configurable by the user.\n\n14.2 Accept-Charset\n\n   The Accept-Charset request-header field can be used to indicate what\n   character sets are acceptable for the response. This field allows\n   clients capable of understanding more comprehensive or special-\n   purpose character sets to signal that capability to a server which is\n   capable of representing documents in those character sets.\n\n      Accept-Charset = \"Accept-Charset\" \":\"\n              1#( ( charset | \"*\" )[ \";\" \"q\" \"=\" qvalue ] )\n\n\n   Character set values are described in section 3.4. Each charset MAY\n   be given an associated quality value which represents the user's\n   preference for that charset. The default value is q=1. An example is\n\n      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n\n   The special value \"*\", if present in the Accept-Charset field,\n   matches every character set (including ISO-8859-1) which is not\n   mentioned elsewhere in the Accept-Charset field. If no \"*\" is present\n   in an Accept-Charset field, then all character sets not explicitly\n   mentioned get a quality value of 0, except for ISO-8859-1, which gets\n   a quality value of 1 if not explicitly mentioned.\n\n   If no Accept-Charset header is present, the default is that any\n   character set is acceptable. If an Accept-Charset header is present,\n   and if the server cannot send a response which is acceptable\n   according to the Accept-Charset header, then the server SHOULD send\n   an error response with the 406 (not acceptable) status code, though\n   the sending of an unacceptable response is also allowed.\n\n14.3 Accept-Encoding\n\n   The Accept-Encoding request-header field is similar to Accept, but\n   restricts the content-codings (section 3.5) that are acceptable in\n   the response.\n\n       Accept-Encoding  = \"Accept-Encoding\" \":\"\n\n\n\nFielding, et al.            Standards Track                   [Page 102]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                          1#( codings [ \";\" \"q\" \"=\" qvalue ] )\n       codings          = ( content-coding | \"*\" )\n\n   Examples of its use are:\n\n       Accept-Encoding: compress, gzip\n       Accept-Encoding:\n       Accept-Encoding: *\n       Accept-Encoding: compress;q=0.5, gzip;q=1.0\n       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n\n   A server tests whether a content-coding is acceptable, according to\n   an Accept-Encoding field, using these rules:\n\n      1. If the content-coding is one of the content-codings listed in\n         the Accept-Encoding field, then it is acceptable, unless it is\n         accompanied by a qvalue of 0. (As defined in section 3.9, a\n         qvalue of 0 means \"not acceptable.\")\n\n      2. The special \"*\" symbol in an Accept-Encoding field matches any\n         available content-coding not explicitly listed in the header\n         field.\n\n      3. If multiple content-codings are acceptable, then the acceptable\n         content-coding with the highest non-zero qvalue is preferred.\n\n      4. The \"identity\" content-coding is always acceptable, unless\n         specifically refused because the Accept-Encoding field includes\n         \"identity;q=0\", or because the field includes \"*;q=0\" and does\n         not explicitly include the \"identity\" content-coding. If the\n         Accept-Encoding field-value is empty, then only the \"identity\"\n         encoding is acceptable.\n\n   If an Accept-Encoding field is present in a request, and if the\n   server cannot send a response which is acceptable according to the\n   Accept-Encoding header, then the server SHOULD send an error response\n   with the 406 (Not Acceptable) status code.\n\n   If no Accept-Encoding field is present in a request, the server MAY\n   assume that the client will accept any content coding. In this case,\n   if \"identity\" is one of the available content-codings, then the\n   server SHOULD use the \"identity\" content-coding, unless it has\n   additional information that a different content-coding is meaningful\n   to the client.\n\n      Note: If the request does not include an Accept-Encoding field,\n      and if the \"identity\" content-coding is unavailable, then\n      content-codings commonly understood by HTTP/1.0 clients (i.e.,\n\n\n\nFielding, et al.            Standards Track                   [Page 103]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      \"gzip\" and \"compress\") are preferred; some older clients\n      improperly display messages sent with other content-codings.  The\n      server might also make this decision based on information about\n      the particular user-agent or client.\n\n      Note: Most HTTP/1.0 applications do not recognize or obey qvalues\n      associated with content-codings. This means that qvalues will not\n      work and are not permitted with x-gzip or x-compress.\n\n14.4 Accept-Language\n\n   The Accept-Language request-header field is similar to Accept, but\n   restricts the set of natural languages that are preferred as a\n   response to the request. Language tags are defined in section 3.10.\n\n       Accept-Language = \"Accept-Language\" \":\"\n                         1#( language-range [ \";\" \"q\" \"=\" qvalue ] )\n       language-range  = ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) | \"*\" )\n\n   Each language-range MAY be given an associated quality value which\n   represents an estimate of the user's preference for the languages\n   specified by that range. The quality value defaults to \"q=1\". For\n   example,\n\n       Accept-Language: da, en-gb;q=0.8, en;q=0.7\n\n   would mean: \"I prefer Danish, but will accept British English and\n   other types of English.\" A language-range matches a language-tag if\n   it exactly equals the tag, or if it exactly equals a prefix of the\n   tag such that the first tag character following the prefix is \"-\".\n   The special range \"*\", if present in the Accept-Language field,\n   matches every tag not matched by any other range present in the\n   Accept-Language field.\n\n      Note: This use of a prefix matching rule does not imply that\n      language tags are assigned to languages in such a way that it is\n      always true that if a user understands a language with a certain\n      tag, then this user will also understand all languages with tags\n      for which this tag is a prefix. The prefix rule simply allows the\n      use of prefix tags if this is the case.\n\n   The language quality factor assigned to a language-tag by the\n   Accept-Language field is the quality value of the longest language-\n   range in the field that matches the language-tag. If no language-\n   range in the field matches the tag, the language quality factor\n   assigned is 0. If no Accept-Language header is present in the\n   request, the server\n\n\n\n\nFielding, et al.            Standards Track                   [Page 104]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   SHOULD assume that all languages are equally acceptable. If an\n   Accept-Language header is present, then all languages which are\n   assigned a quality factor greater than 0 are acceptable.\n\n   It might be contrary to the privacy expectations of the user to send\n   an Accept-Language header with the complete linguistic preferences of\n   the user in every request. For a discussion of this issue, see\n   section 15.1.4.\n\n   As intelligibility is highly dependent on the individual user, it is\n   recommended that client applications make the choice of linguistic\n   preference available to the user. If the choice is not made\n   available, then the Accept-Language header field MUST NOT be given in\n   the request.\n\n      Note: When making the choice of linguistic preference available to\n      the user, we remind implementors of  the fact that users are not\n      familiar with the details of language matching as described above,\n      and should provide appropriate guidance. As an example, users\n      might assume that on selecting \"en-gb\", they will be served any\n      kind of English document if British English is not available. A\n      user agent might suggest in such a case to add \"en\" to get the\n      best matching behavior.\n\n14.5 Accept-Ranges\n\n      The Accept-Ranges response-header field allows the server to\n      indicate its acceptance of range requests for a resource:\n\n          Accept-Ranges     = \"Accept-Ranges\" \":\" acceptable-ranges\n          acceptable-ranges = 1#range-unit | \"none\"\n\n      Origin servers that accept byte-range requests MAY send\n\n          Accept-Ranges: bytes\n\n      but are not required to do so. Clients MAY generate byte-range\n      requests without having received this header for the resource\n      involved. Range units are defined in section 3.12.\n\n      Servers that do not accept any kind of range request for a\n      resource MAY send\n\n          Accept-Ranges: none\n\n      to advise the client not to attempt a range request.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 105]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.6 Age\n\n      The Age response-header field conveys the sender's estimate of the\n      amount of time since the response (or its revalidation) was\n      generated at the origin server. A cached response is \"fresh\" if\n      its age does not exceed its freshness lifetime. Age values are\n      calculated as specified in section 13.2.3.\n\n           Age = \"Age\" \":\" age-value\n           age-value = delta-seconds\n\n      Age values are non-negative decimal integers, representing time in\n      seconds.\n\n      If a cache receives a value larger than the largest positive\n      integer it can represent, or if any of its age calculations\n      overflows, it MUST transmit an Age header with a value of\n      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST\n      include an Age header field in every response generated from its\n      own cache. Caches SHOULD use an arithmetic type of at least 31\n      bits of range.\n\n14.7 Allow\n\n      The Allow entity-header field lists the set of methods supported\n      by the resource identified by the Request-URI. The purpose of this\n      field is strictly to inform the recipient of valid methods\n      associated with the resource. An Allow header field MUST be\n      present in a 405 (Method Not Allowed) response.\n\n          Allow   = \"Allow\" \":\" #Method\n\n      Example of use:\n\n          Allow: GET, HEAD, PUT\n\n      This field cannot prevent a client from trying other methods.\n      However, the indications given by the Allow header field value\n      SHOULD be followed. The actual set of allowed methods is defined\n      by the origin server at the time of each request.\n\n      The Allow header field MAY be provided with a PUT request to\n      recommend the methods to be supported by the new or modified\n      resource. The server is not required to support these methods and\n      SHOULD include an Allow header in the response giving the actual\n      supported methods.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 106]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      A proxy MUST NOT modify the Allow header field even if it does not\n      understand all the methods specified, since the user agent might\n      have other means of communicating with the origin server.\n\n14.8 Authorization\n\n      A user agent that wishes to authenticate itself with a server--\n      usually, but not necessarily, after receiving a 401 response--does\n      so by including an Authorization request-header field with the\n      request.  The Authorization field value consists of credentials\n      containing the authentication information of the user agent for\n      the realm of the resource being requested.\n\n          Authorization  = \"Authorization\" \":\" credentials\n\n      HTTP access authentication is described in \"HTTP Authentication:\n      Basic and Digest Access Authentication\" [43]. If a request is\n      authenticated and a realm specified, the same credentials SHOULD\n      be valid for all other requests within this realm (assuming that\n      the authentication scheme itself does not require otherwise, such\n      as credentials that vary according to a challenge value or using\n      synchronized clocks).\n\n      When a shared cache (see section 13.7) receives a request\n      containing an Authorization field, it MUST NOT return the\n      corresponding response as a reply to any other request, unless one\n      of the following specific exceptions holds:\n\n      1. If the response includes the \"s-maxage\" cache-control\n         directive, the cache MAY use that response in replying to a\n         subsequent request. But (if the specified maximum age has\n         passed) a proxy cache MUST first revalidate it with the origin\n         server, using the request-headers from the new request to allow\n         the origin server to authenticate the new request. (This is the\n         defined behavior for s-maxage.) If the response includes \"s-\n         maxage=0\", the proxy MUST always revalidate it before re-using\n         it.\n\n      2. If the response includes the \"must-revalidate\" cache-control\n         directive, the cache MAY use that response in replying to a\n         subsequent request. But if the response is stale, all caches\n         MUST first revalidate it with the origin server, using the\n         request-headers from the new request to allow the origin server\n         to authenticate the new request.\n\n      3. If the response includes the \"public\" cache-control directive,\n         it MAY be returned in reply to any subsequent request.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 107]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.9 Cache-Control\n\n   The Cache-Control general-header field is used to specify directives\n   that MUST be obeyed by all caching mechanisms along the\n   request/response chain. The directives specify behavior intended to\n   prevent caches from adversely interfering with the request or\n   response. These directives typically override the default caching\n   algorithms. Cache directives are unidirectional in that the presence\n   of a directive in a request does not imply that the same directive is\n   to be given in the response.\n\n      Note that HTTP/1.0 caches might not implement Cache-Control and\n      might only implement Pragma: no-cache (see section 14.32).\n\n   Cache directives MUST be passed through by a proxy or gateway\n   application, regardless of their significance to that application,\n   since the directives might be applicable to all recipients along the\n   request/response chain. It is not possible to specify a cache-\n   directive for a specific cache.\n\n    Cache-Control   = \"Cache-Control\" \":\" 1#cache-directive\n\n    cache-directive = cache-request-directive\n         | cache-response-directive\n\n    cache-request-directive =\n           \"no-cache\"                          ; Section 14.9.1\n         | \"no-store\"                          ; Section 14.9.2\n         | \"max-age\" \"=\" delta-seconds         ; Section 14.9.3, 14.9.4\n         | \"max-stale\" [ \"=\" delta-seconds ]   ; Section 14.9.3\n         | \"min-fresh\" \"=\" delta-seconds       ; Section 14.9.3\n         | \"no-transform\"                      ; Section 14.9.5\n         | \"only-if-cached\"                    ; Section 14.9.4\n         | cache-extension                     ; Section 14.9.6\n\n     cache-response-directive =\n           \"public\"                               ; Section 14.9.1\n         | \"private\" [ \"=\" <\"> 1#field-name <\"> ] ; Section 14.9.1\n         | \"no-cache\" [ \"=\" <\"> 1#field-name <\"> ]; Section 14.9.1\n         | \"no-store\"                             ; Section 14.9.2\n         | \"no-transform\"                         ; Section 14.9.5\n         | \"must-revalidate\"                      ; Section 14.9.4\n         | \"proxy-revalidate\"                     ; Section 14.9.4\n         | \"max-age\" \"=\" delta-seconds            ; Section 14.9.3\n         | \"s-maxage\" \"=\" delta-seconds           ; Section 14.9.3\n         | cache-extension                        ; Section 14.9.6\n\n    cache-extension = token [ \"=\" ( token | quoted-string ) ]\n\n\n\nFielding, et al.            Standards Track                   [Page 108]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   When a directive appears without any 1#field-name parameter, the\n   directive applies to the entire request or response. When such a\n   directive appears with a 1#field-name parameter, it applies only to\n   the named field or fields, and not to the rest of the request or\n   response. This mechanism supports extensibility; implementations of\n   future versions of the HTTP protocol might apply these directives to\n   header fields not defined in HTTP/1.1.\n\n   The cache-control directives can be broken down into these general\n   categories:\n\n      - Restrictions on what are cacheable; these may only be imposed by\n        the origin server.\n\n      - Restrictions on what may be stored by a cache; these may be\n        imposed by either the origin server or the user agent.\n\n      - Modifications of the basic expiration mechanism; these may be\n        imposed by either the origin server or the user agent.\n\n      - Controls over cache revalidation and reload; these may only be\n        imposed by a user agent.\n\n      - Control over transformation of entities.\n\n      - Extensions to the caching system.\n\n14.9.1 What is Cacheable\n\n   By default, a response is cacheable if the requirements of the\n   request method, request header fields, and the response status\n   indicate that it is cacheable. Section 13.4 summarizes these defaults\n   for cacheability. The following Cache-Control response directives\n   allow an origin server to override the default cacheability of a\n   response:\n\n   public\n      Indicates that the response MAY be cached by any cache, even if it\n      would normally be non-cacheable or cacheable only within a non-\n      shared cache. (See also Authorization, section 14.8, for\n      additional details.)\n\n   private\n      Indicates that all or part of the response message is intended for\n      a single user and MUST NOT be cached by a shared cache. This\n      allows an origin server to state that the specified parts of the\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 109]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      response are intended for only one user and are not a valid\n      response for requests by other users. A private (non-shared) cache\n      MAY cache the response.\n\n       Note: This usage of the word private only controls where the\n       response may be cached, and cannot ensure the privacy of the\n       message content.\n\n   no-cache\n       If the no-cache directive does not specify a field-name, then a\n      cache MUST NOT use the response to satisfy a subsequent request\n      without successful revalidation with the origin server. This\n      allows an origin server to prevent caching even by caches that\n      have been configured to return stale responses to client requests.\n\n      If the no-cache directive does specify one or more field-names,\n      then a cache MAY use the response to satisfy a subsequent request,\n      subject to any other restrictions on caching. However, the\n      specified field-name(s) MUST NOT be sent in the response to a\n      subsequent request without successful revalidation with the origin\n      server. This allows an origin server to prevent the re-use of\n      certain header fields in a response, while still allowing caching\n      of the rest of the response.\n\n       Note: Most HTTP/1.0 caches will not recognize or obey this\n       directive.\n\n14.9.2 What May be Stored by Caches\n\n   no-store\n      The purpose of the no-store directive is to prevent the\n      inadvertent release or retention of sensitive information (for\n      example, on backup tapes). The no-store directive applies to the\n      entire message, and MAY be sent either in a response or in a\n      request. If sent in a request, a cache MUST NOT store any part of\n      either this request or any response to it. If sent in a response,\n      a cache MUST NOT store any part of either this response or the\n      request that elicited it. This directive applies to both non-\n      shared and shared caches. \"MUST NOT store\" in this context means\n      that the cache MUST NOT intentionally store the information in\n      non-volatile storage, and MUST make a best-effort attempt to\n      remove the information from volatile storage as promptly as\n      possible after forwarding it.\n\n      Even when this directive is associated with a response, users\n      might explicitly store such a response outside of the caching\n      system (e.g., with a \"Save As\" dialog). History buffers MAY store\n      such responses as part of their normal operation.\n\n\n\nFielding, et al.            Standards Track                   [Page 110]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      The purpose of this directive is to meet the stated requirements\n      of certain users and service authors who are concerned about\n      accidental releases of information via unanticipated accesses to\n      cache data structures. While the use of this directive might\n      improve privacy in some cases, we caution that it is NOT in any\n      way a reliable or sufficient mechanism for ensuring privacy. In\n      particular, malicious or compromised caches might not recognize or\n      obey this directive, and communications networks might be\n      vulnerable to eavesdropping.\n\n14.9.3 Modifications of the Basic Expiration Mechanism\n\n   The expiration time of an entity MAY be specified by the origin\n   server using the Expires header (see section 14.21). Alternatively,\n   it MAY be specified using the max-age directive in a response. When\n   the max-age cache-control directive is present in a cached response,\n   the response is stale if its current age is greater than the age\n   value given (in seconds) at the time of a new request for that\n   resource. The max-age directive on a response implies that the\n   response is cacheable (i.e., \"public\") unless some other, more\n   restrictive cache directive is also present.\n\n   If a response includes both an Expires header and a max-age\n   directive, the max-age directive overrides the Expires header, even\n   if the Expires header is more restrictive. This rule allows an origin\n   server to provide, for a given response, a longer expiration time to\n   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be\n   useful if certain HTTP/1.0 caches improperly calculate ages or\n   expiration times, perhaps due to desynchronized clocks.\n\n   Many HTTP/1.0 cache implementations will treat an Expires value that\n   is less than or equal to the response Date value as being equivalent\n   to the Cache-Control response directive \"no-cache\". If an HTTP/1.1\n   cache receives such a response, and the response does not include a\n   Cache-Control header field, it SHOULD consider the response to be\n   non-cacheable in order to retain compatibility with HTTP/1.0 servers.\n\n       Note: An origin server might wish to use a relatively new HTTP\n       cache control feature, such as the \"private\" directive, on a\n       network including older caches that do not understand that\n       feature. The origin server will need to combine the new feature\n       with an Expires field whose value is less than or equal to the\n       Date value. This will prevent older caches from improperly\n       caching the response.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 111]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   s-maxage\n       If a response includes an s-maxage directive, then for a shared\n       cache (but not for a private cache), the maximum age specified by\n       this directive overrides the maximum age specified by either the\n       max-age directive or the Expires header. The s-maxage directive\n       also implies the semantics of the proxy-revalidate directive (see\n       section 14.9.4), i.e., that the shared cache must not use the\n       entry after it becomes stale to respond to a subsequent request\n       without first revalidating it with the origin server. The s-\n       maxage directive is always ignored by a private cache.\n\n   Note that most older caches, not compliant with this specification,\n   do not implement any cache-control directives. An origin server\n   wishing to use a cache-control directive that restricts, but does not\n   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the\n   requirement that the max-age directive overrides the Expires header,\n   and the fact that pre-HTTP/1.1-compliant caches do not observe the\n   max-age directive.\n\n   Other directives allow a user agent to modify the basic expiration\n   mechanism. These directives MAY be specified on a request:\n\n   max-age\n      Indicates that the client is willing to accept a response whose\n      age is no greater than the specified time in seconds. Unless max-\n      stale directive is also included, the client is not willing to\n      accept a stale response.\n\n   min-fresh\n      Indicates that the client is willing to accept a response whose\n      freshness lifetime is no less than its current age plus the\n      specified time in seconds. That is, the client wants a response\n      that will still be fresh for at least the specified number of\n      seconds.\n\n   max-stale\n      Indicates that the client is willing to accept a response that has\n      exceeded its expiration time. If max-stale is assigned a value,\n      then the client is willing to accept a response that has exceeded\n      its expiration time by no more than the specified number of\n      seconds. If no value is assigned to max-stale, then the client is\n      willing to accept a stale response of any age.\n\n   If a cache returns a stale response, either because of a max-stale\n   directive on a request, or because the cache is configured to\n   override the expiration time of a response, the cache MUST attach a\n   Warning header to the stale response, using Warning 110 (Response is\n   stale).\n\n\n\nFielding, et al.            Standards Track                   [Page 112]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A cache MAY be configured to return stale responses without\n   validation, but only if this does not conflict with any \"MUST\"-level\n   requirements concerning cache validation (e.g., a \"must-revalidate\"\n   cache-control directive).\n\n   If both the new request and the cached entry include \"max-age\"\n   directives, then the lesser of the two values is used for determining\n   the freshness of the cached entry for that request.\n\n14.9.4 Cache Revalidation and Reload Controls\n\n   Sometimes a user agent might want or need to insist that a cache\n   revalidate its cache entry with the origin server (and not just with\n   the next cache along the path to the origin server), or to reload its\n   cache entry from the origin server. End-to-end revalidation might be\n   necessary if either the cache or the origin server has overestimated\n   the expiration time of the cached response. End-to-end reload may be\n   necessary if the cache entry has become corrupted for some reason.\n\n   End-to-end revalidation may be requested either when the client does\n   not have its own local cached copy, in which case we call it\n   \"unspecified end-to-end revalidation\", or when the client does have a\n   local cached copy, in which case we call it \"specific end-to-end\n   revalidation.\"\n\n   The client can specify these three kinds of action using Cache-\n   Control request directives:\n\n   End-to-end reload\n      The request includes a \"no-cache\" cache-control directive or, for\n      compatibility with HTTP/1.0 clients, \"Pragma: no-cache\". Field\n      names MUST NOT be included with the no-cache directive in a\n      request. The server MUST NOT use a cached copy when responding to\n      such a request.\n\n   Specific end-to-end revalidation\n      The request includes a \"max-age=0\" cache-control directive, which\n      forces each cache along the path to the origin server to\n      revalidate its own entry, if any, with the next cache or server.\n      The initial request includes a cache-validating conditional with\n      the client's current validator.\n\n   Unspecified end-to-end revalidation\n      The request includes \"max-age=0\" cache-control directive, which\n      forces each cache along the path to the origin server to\n      revalidate its own entry, if any, with the next cache or server.\n      The initial request does not include a cache-validating\n\n\n\n\nFielding, et al.            Standards Track                   [Page 113]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      conditional; the first cache along the path (if any) that holds a\n      cache entry for this resource includes a cache-validating\n      conditional with its current validator.\n\n   max-age\n      When an intermediate cache is forced, by means of a max-age=0\n      directive, to revalidate its own cache entry, and the client has\n      supplied its own validator in the request, the supplied validator\n      might differ from the validator currently stored with the cache\n      entry. In this case, the cache MAY use either validator in making\n      its own request without affecting semantic transparency.\n\n      However, the choice of validator might affect performance. The\n      best approach is for the intermediate cache to use its own\n      validator when making its request. If the server replies with 304\n      (Not Modified), then the cache can return its now validated copy\n      to the client with a 200 (OK) response. If the server replies with\n      a new entity and cache validator, however, the intermediate cache\n      can compare the returned validator with the one provided in the\n      client's request, using the strong comparison function. If the\n      client's validator is equal to the origin server's, then the\n      intermediate cache simply returns 304 (Not Modified). Otherwise,\n      it returns the new entity with a 200 (OK) response.\n\n      If a request includes the no-cache directive, it SHOULD NOT\n      include min-fresh, max-stale, or max-age.\n\n   only-if-cached\n      In some cases, such as times of extremely poor network\n      connectivity, a client may want a cache to return only those\n      responses that it currently has stored, and not to reload or\n      revalidate with the origin server. To do this, the client may\n      include the only-if-cached directive in a request. If it receives\n      this directive, a cache SHOULD either respond using a cached entry\n      that is consistent with the other constraints of the request, or\n      respond with a 504 (Gateway Timeout) status. However, if a group\n      of caches is being operated as a unified system with good internal\n      connectivity, such a request MAY be forwarded within that group of\n      caches.\n\n   must-revalidate\n      Because a cache MAY be configured to ignore a server's specified\n      expiration time, and because a client request MAY include a max-\n      stale directive (which has a similar effect), the protocol also\n      includes a mechanism for the origin server to require revalidation\n      of a cache entry on any subsequent use. When the must-revalidate\n      directive is present in a response received by a cache, that cache\n      MUST NOT use the entry after it becomes stale to respond to a\n\n\n\nFielding, et al.            Standards Track                   [Page 114]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      subsequent request without first revalidating it with the origin\n      server. (I.e., the cache MUST do an end-to-end revalidation every\n      time, if, based solely on the origin server's Expires or max-age\n      value, the cached response is stale.)\n\n      The must-revalidate directive is necessary to support reliable\n      operation for certain protocol features. In all circumstances an\n      HTTP/1.1 cache MUST obey the must-revalidate directive; in\n      particular, if the cache cannot reach the origin server for any\n      reason, it MUST generate a 504 (Gateway Timeout) response.\n\n      Servers SHOULD send the must-revalidate directive if and only if\n      failure to revalidate a request on the entity could result in\n      incorrect operation, such as a silently unexecuted financial\n      transaction. Recipients MUST NOT take any automated action that\n      violates this directive, and MUST NOT automatically provide an\n      unvalidated copy of the entity if revalidation fails.\n\n      Although this is not recommended, user agents operating under\n      severe connectivity constraints MAY violate this directive but, if\n      so, MUST explicitly warn the user that an unvalidated response has\n      been provided. The warning MUST be provided on each unvalidated\n      access, and SHOULD require explicit user confirmation.\n\n   proxy-revalidate\n      The proxy-revalidate directive has the same meaning as the must-\n      revalidate directive, except that it does not apply to non-shared\n      user agent caches. It can be used on a response to an\n      authenticated request to permit the user's cache to store and\n      later return the response without needing to revalidate it (since\n      it has already been authenticated once by that user), while still\n      requiring proxies that service many users to revalidate each time\n      (in order to make sure that each user has been authenticated).\n      Note that such authenticated responses also need the public cache\n      control directive in order to allow them to be cached at all.\n\n14.9.5 No-Transform Directive\n\n   no-transform\n      Implementors of intermediate caches (proxies) have found it useful\n      to convert the media type of certain entity bodies. A non-\n      transparent proxy might, for example, convert between image\n      formats in order to save cache space or to reduce the amount of\n      traffic on a slow link.\n\n      Serious operational problems occur, however, when these\n      transformations are applied to entity bodies intended for certain\n      kinds of applications. For example, applications for medical\n\n\n\nFielding, et al.            Standards Track                   [Page 115]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      imaging, scientific data analysis and those using end-to-end\n      authentication, all depend on receiving an entity body that is bit\n      for bit identical to the original entity-body.\n\n      Therefore, if a message includes the no-transform directive, an\n      intermediate cache or proxy MUST NOT change those headers that are\n      listed in section 13.5.2 as being subject to the no-transform\n      directive. This implies that the cache or proxy MUST NOT change\n      any aspect of the entity-body that is specified by these headers,\n      including the value of the entity-body itself.\n\n14.9.6 Cache Control Extensions\n\n   The Cache-Control header field can be extended through the use of one\n   or more cache-extension tokens, each with an optional assigned value.\n   Informational extensions (those which do not require a change in\n   cache behavior) MAY be added without changing the semantics of other\n   directives. Behavioral extensions are designed to work by acting as\n   modifiers to the existing base of cache directives. Both the new\n   directive and the standard directive are supplied, such that\n   applications which do not understand the new directive will default\n   to the behavior specified by the standard directive, and those that\n   understand the new directive will recognize it as modifying the\n   requirements associated with the standard directive. In this way,\n   extensions to the cache-control directives can be made without\n   requiring changes to the base protocol.\n\n   This extension mechanism depends on an HTTP cache obeying all of the\n   cache-control directives defined for its native HTTP-version, obeying\n   certain extensions, and ignoring all directives that it does not\n   understand.\n\n   For example, consider a hypothetical new response directive called\n   community which acts as a modifier to the private directive. We\n   define this new directive to mean that, in addition to any non-shared\n   cache, any cache which is shared only by members of the community\n   named within its value may cache the response. An origin server\n   wishing to allow the UCI community to use an otherwise private\n   response in their shared cache(s) could do so by including\n\n       Cache-Control: private, community=\"UCI\"\n\n   A cache seeing this header field will act correctly even if the cache\n   does not understand the community cache-extension, since it will also\n   see and understand the private directive and thus default to the safe\n   behavior.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 116]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Unrecognized cache-directives MUST be ignored; it is assumed that any\n   cache-directive likely to be unrecognized by an HTTP/1.1 cache will\n   be combined with standard directives (or the response's default\n   cacheability) such that the cache behavior will remain minimally\n   correct even if the cache does not understand the extension(s).\n\n14.10 Connection\n\n   The Connection general-header field allows the sender to specify\n   options that are desired for that particular connection and MUST NOT\n   be communicated by proxies over further connections.\n\n   The Connection header has the following grammar:\n\n       Connection = \"Connection\" \":\" 1#(connection-token)\n       connection-token  = token\n\n   HTTP/1.1 proxies MUST parse the Connection header field before a\n   message is forwarded and, for each connection-token in this field,\n   remove any header field(s) from the message with the same name as the\n   connection-token. Connection options are signaled by the presence of\n   a connection-token in the Connection header field, not by any\n   corresponding additional header field(s), since the additional header\n   field may not be sent if there are no parameters associated with that\n   connection option.\n\n   Message headers listed in the Connection header MUST NOT include\n   end-to-end headers, such as Cache-Control.\n\n   HTTP/1.1 defines the \"close\" connection option for the sender to\n   signal that the connection will be closed after completion of the\n   response. For example,\n\n       Connection: close\n\n   in either the request or the response header fields indicates that\n   the connection SHOULD NOT be considered `persistent' (section 8.1)\n   after the current request/response is complete.\n\n   HTTP/1.1 applications that do not support persistent connections MUST\n   include the \"close\" connection option in every message.\n\n   A system receiving an HTTP/1.0 (or lower-version) message that\n   includes a Connection header MUST, for each connection-token in this\n   field, remove and ignore any header field(s) from the message with\n   the same name as the connection-token. This protects against mistaken\n   forwarding of such header fields by pre-HTTP/1.1 proxies. See section\n   19.6.2.\n\n\n\nFielding, et al.            Standards Track                   [Page 117]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.11 Content-Encoding\n\n   The Content-Encoding entity-header field is used as a modifier to the\n   media-type. When present, its value indicates what additional content\n   codings have been applied to the entity-body, and thus what decoding\n   mechanisms must be applied in order to obtain the media-type\n   referenced by the Content-Type header field. Content-Encoding is\n   primarily used to allow a document to be compressed without losing\n   the identity of its underlying media type.\n\n       Content-Encoding  = \"Content-Encoding\" \":\" 1#content-coding\n\n   Content codings are defined in section 3.5. An example of its use is\n\n       Content-Encoding: gzip\n\n   The content-coding is a characteristic of the entity identified by\n   the Request-URI. Typically, the entity-body is stored with this\n   encoding and is only decoded before rendering or analogous usage.\n   However, a non-transparent proxy MAY modify the content-coding if the\n   new coding is known to be acceptable to the recipient, unless the\n   \"no-transform\" cache-control directive is present in the message.\n\n   If the content-coding of an entity is not \"identity\", then the\n   response MUST include a Content-Encoding entity-header (section\n   14.11) that lists the non-identity content-coding(s) used.\n\n   If the content-coding of an entity in a request message is not\n   acceptable to the origin server, the server SHOULD respond with a\n   status code of 415 (Unsupported Media Type).\n\n   If multiple encodings have been applied to an entity, the content\n   codings MUST be listed in the order in which they were applied.\n   Additional information about the encoding parameters MAY be provided\n   by other entity-header fields not defined by this specification.\n\n14.12 Content-Language\n\n   The Content-Language entity-header field describes the natural\n   language(s) of the intended audience for the enclosed entity. Note\n   that this might not be equivalent to all the languages used within\n   the entity-body.\n\n       Content-Language  = \"Content-Language\" \":\" 1#language-tag\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 118]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Language tags are defined in section 3.10. The primary purpose of\n   Content-Language is to allow a user to identify and differentiate\n   entities according to the user's own preferred language. Thus, if the\n   body content is intended only for a Danish-literate audience, the\n   appropriate field is\n\n       Content-Language: da\n\n   If no Content-Language is specified, the default is that the content\n   is intended for all language audiences. This might mean that the\n   sender does not consider it to be specific to any natural language,\n   or that the sender does not know for which language it is intended.\n\n   Multiple languages MAY be listed for content that is intended for\n   multiple audiences. For example, a rendition of the \"Treaty of\n   Waitangi,\" presented simultaneously in the original Maori and English\n   versions, would call for\n\n       Content-Language: mi, en\n\n   However, just because multiple languages are present within an entity\n   does not mean that it is intended for multiple linguistic audiences.\n   An example would be a beginner's language primer, such as \"A First\n   Lesson in Latin,\" which is clearly intended to be used by an\n   English-literate audience. In this case, the Content-Language would\n   properly only include \"en\".\n\n   Content-Language MAY be applied to any media type -- it is not\n   limited to textual documents.\n\n14.13 Content-Length\n\n   The Content-Length entity-header field indicates the size of the\n   entity-body, in decimal number of OCTETs, sent to the recipient or,\n   in the case of the HEAD method, the size of the entity-body that\n   would have been sent had the request been a GET.\n\n       Content-Length    = \"Content-Length\" \":\" 1*DIGIT\n\n   An example is\n\n       Content-Length: 3495\n\n   Applications SHOULD use this field to indicate the transfer-length of\n   the message-body, unless this is prohibited by the rules in section\n   4.4.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 119]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Any Content-Length greater than or equal to zero is a valid value.\n   Section 4.4 describes how to determine the length of a message-body\n   if a Content-Length is not given.\n\n   Note that the meaning of this field is significantly different from\n   the corresponding definition in MIME, where it is an optional field\n   used within the \"message/external-body\" content-type. In HTTP, it\n   SHOULD be sent whenever the message's length can be determined prior\n   to being transferred, unless this is prohibited by the rules in\n   section 4.4.\n\n14.14 Content-Location\n\n   The Content-Location entity-header field MAY be used to supply the\n   resource location for the entity enclosed in the message when that\n   entity is accessible from a location separate from the requested\n   resource's URI. A server SHOULD provide a Content-Location for the\n   variant corresponding to the response entity; especially in the case\n   where a resource has multiple entities associated with it, and those\n   entities actually have separate locations by which they might be\n   individually accessed, the server SHOULD provide a Content-Location\n   for the particular variant which is returned.\n\n       Content-Location = \"Content-Location\" \":\"\n                         ( absoluteURI | relativeURI )\n\n   The value of Content-Location also defines the base URI for the\n   entity.\n\n   The Content-Location value is not a replacement for the original\n   requested URI; it is only a statement of the location of the resource\n   corresponding to this particular entity at the time of the request.\n   Future requests MAY specify the Content-Location URI as the request-\n   URI if the desire is to identify the source of that particular\n   entity.\n\n   A cache cannot assume that an entity with a Content-Location\n   different from the URI used to retrieve it can be used to respond to\n   later requests on that Content-Location URI. However, the Content-\n   Location can be used to differentiate between multiple entities\n   retrieved from a single requested resource, as described in section\n   13.6.\n\n   If the Content-Location is a relative URI, the relative URI is\n   interpreted relative to the Request-URI.\n\n   The meaning of the Content-Location header in PUT or POST requests is\n   undefined; servers are free to ignore it in those cases.\n\n\n\nFielding, et al.            Standards Track                   [Page 120]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.15 Content-MD5\n\n   The Content-MD5 entity-header field, as defined in RFC 1864 [23], is\n   an MD5 digest of the entity-body for the purpose of providing an\n   end-to-end message integrity check (MIC) of the entity-body. (Note: a\n   MIC is good for detecting accidental modification of the entity-body\n   in transit, but is not proof against malicious attacks.)\n\n        Content-MD5   = \"Content-MD5\" \":\" md5-digest\n        md5-digest   = <base64 of 128 bit MD5 digest as per RFC 1864>\n\n   The Content-MD5 header field MAY be generated by an origin server or\n   client to function as an integrity check of the entity-body. Only\n   origin servers or clients MAY generate the Content-MD5 header field;\n   proxies and gateways MUST NOT generate it, as this would defeat its\n   value as an end-to-end integrity check. Any recipient of the entity-\n   body, including gateways and proxies, MAY check that the digest value\n   in this header field matches that of the entity-body as received.\n\n   The MD5 digest is computed based on the content of the entity-body,\n   including any content-coding that has been applied, but not including\n   any transfer-encoding applied to the message-body. If the message is\n   received with a transfer-encoding, that encoding MUST be removed\n   prior to checking the Content-MD5 value against the received entity.\n\n   This has the result that the digest is computed on the octets of the\n   entity-body exactly as, and in the order that, they would be sent if\n   no transfer-encoding were being applied.\n\n   HTTP extends RFC 1864 to permit the digest to be computed for MIME\n   composite media-types (e.g., multipart/* and message/rfc822), but\n   this does not change how the digest is computed as defined in the\n   preceding paragraph.\n\n   There are several consequences of this. The entity-body for composite\n   types MAY contain many body-parts, each with its own MIME and HTTP\n   headers (including Content-MD5, Content-Transfer-Encoding, and\n   Content-Encoding headers). If a body-part has a Content-Transfer-\n   Encoding or Content-Encoding header, it is assumed that the content\n   of the body-part has had the encoding applied, and the body-part is\n   included in the Content-MD5 digest as is -- i.e., after the\n   application. The Transfer-Encoding header field is not allowed within\n   body-parts.\n\n   Conversion of all line breaks to CRLF MUST NOT be done before\n   computing or checking the digest: the line break convention used in\n   the text actually transmitted MUST be left unaltered when computing\n   the digest.\n\n\n\nFielding, et al.            Standards Track                   [Page 121]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      Note: while the definition of Content-MD5 is exactly the same for\n      HTTP as in RFC 1864 for MIME entity-bodies, there are several ways\n      in which the application of Content-MD5 to HTTP entity-bodies\n      differs from its application to MIME entity-bodies. One is that\n      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and\n      does use Transfer-Encoding and Content-Encoding. Another is that\n      HTTP more frequently uses binary content types than MIME, so it is\n      worth noting that, in such cases, the byte order used to compute\n      the digest is the transmission byte order defined for the type.\n      Lastly, HTTP allows transmission of text types with any of several\n      line break conventions and not just the canonical form using CRLF.\n\n14.16 Content-Range\n\n   The Content-Range entity-header is sent with a partial entity-body to\n   specify where in the full entity-body the partial body should be\n   applied. Range units are defined in section 3.12.\n\n       Content-Range = \"Content-Range\" \":\" content-range-spec\n\n       content-range-spec      = byte-content-range-spec\n       byte-content-range-spec = bytes-unit SP\n                                 byte-range-resp-spec \"/\"\n                                 ( instance-length | \"*\" )\n\n       byte-range-resp-spec = (first-byte-pos \"-\" last-byte-pos)\n                                      | \"*\"\n       instance-length           = 1*DIGIT\n\n   The header SHOULD indicate the total length of the full entity-body,\n   unless this length is unknown or difficult to determine. The asterisk\n   \"*\" character means that the instance-length is unknown at the time\n   when the response was generated.\n\n   Unlike byte-ranges-specifier values (see section 14.35.1), a byte-\n   range-resp-spec MUST only specify one range, and MUST contain\n   absolute byte positions for both the first and last byte of the\n   range.\n\n   A byte-content-range-spec with a byte-range-resp-spec whose last-\n   byte-pos value is less than its first-byte-pos value, or whose\n   instance-length value is less than or equal to its last-byte-pos\n   value, is invalid. The recipient of an invalid byte-content-range-\n   spec MUST ignore it and any content transferred along with it.\n\n   A server sending a response with status code 416 (Requested range not\n   satisfiable) SHOULD include a Content-Range field with a byte-range-\n   resp-spec of \"*\". The instance-length specifies the current length of\n\n\n\nFielding, et al.            Standards Track                   [Page 122]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the selected resource. A response with status code 206 (Partial\n   Content) MUST NOT include a Content-Range field with a byte-range-\n   resp-spec of \"*\".\n\n   Examples of byte-content-range-spec values, assuming that the entity\n   contains a total of 1234 bytes:\n\n      . The first 500 bytes:\n       bytes 0-499/1234\n\n      . The second 500 bytes:\n       bytes 500-999/1234\n\n      . All except for the first 500 bytes:\n       bytes 500-1233/1234\n\n      . The last 500 bytes:\n       bytes 734-1233/1234\n\n   When an HTTP message includes the content of a single range (for\n   example, a response to a request for a single range, or to a request\n   for a set of ranges that overlap without any holes), this content is\n   transmitted with a Content-Range header, and a Content-Length header\n   showing the number of bytes actually transferred. For example,\n\n       HTTP/1.1 206 Partial content\n       Date: Wed, 15 Nov 1995 06:25:24 GMT\n       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n       Content-Range: bytes 21010-47021/47022\n       Content-Length: 26012\n       Content-Type: image/gif\n\n   When an HTTP message includes the content of multiple ranges (for\n   example, a response to a request for multiple non-overlapping\n   ranges), these are transmitted as a multipart message. The multipart\n   media type used for this purpose is \"multipart/byteranges\" as defined\n   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.\n\n   A response to a request for a single range MUST NOT be sent using the\n   multipart/byteranges media type.  A response to a request for\n   multiple ranges, whose result is a single range, MAY be sent as a\n   multipart/byteranges media type with one part. A client that cannot\n   decode a multipart/byteranges message MUST NOT ask for multiple\n   byte-ranges in a single request.\n\n   When a client requests multiple byte-ranges in one request, the\n   server SHOULD return them in the order that they appeared in the\n   request.\n\n\n\nFielding, et al.            Standards Track                   [Page 123]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the server ignores a byte-range-spec because it is syntactically\n   invalid, the server SHOULD treat the request as if the invalid Range\n   header field did not exist. (Normally, this means return a 200\n   response containing the full entity).\n\n   If the server receives a request (other than one including an If-\n   Range request-header field) with an unsatisfiable Range request-\n   header field (that is, all of whose byte-range-spec values have a\n   first-byte-pos value greater than the current length of the selected\n   resource), it SHOULD return a response code of 416 (Requested range\n   not satisfiable) (section 10.4.17).\n\n      Note: clients cannot depend on servers to send a 416 (Requested\n      range not satisfiable) response instead of a 200 (OK) response for\n      an unsatisfiable Range request-header, since not all servers\n      implement this request-header.\n\n14.17 Content-Type\n\n   The Content-Type entity-header field indicates the media type of the\n   entity-body sent to the recipient or, in the case of the HEAD method,\n   the media type that would have been sent had the request been a GET.\n\n       Content-Type   = \"Content-Type\" \":\" media-type\n\n   Media types are defined in section 3.7. An example of the field is\n\n       Content-Type: text/html; charset=ISO-8859-4\n\n   Further discussion of methods for identifying the media type of an\n   entity is provided in section 7.2.1.\n\n14.18 Date\n\n   The Date general-header field represents the date and time at which\n   the message was originated, having the same semantics as orig-date in\n   RFC 822. The field value is an HTTP-date, as described in section\n   3.3.1; it MUST be sent in RFC 1123 [8]-date format.\n\n       Date  = \"Date\" \":\" HTTP-date\n\n   An example is\n\n       Date: Tue, 15 Nov 1994 08:12:31 GMT\n\n   Origin servers MUST include a Date header field in all responses,\n   except in these cases:\n\n\n\n\nFielding, et al.            Standards Track                   [Page 124]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      1. If the response status code is 100 (Continue) or 101 (Switching\n         Protocols), the response MAY include a Date header field, at\n         the server's option.\n\n      2. If the response status code conveys a server error, e.g. 500\n         (Internal Server Error) or 503 (Service Unavailable), and it is\n         inconvenient or impossible to generate a valid Date.\n\n      3. If the server does not have a clock that can provide a\n         reasonable approximation of the current time, its responses\n         MUST NOT include a Date header field. In this case, the rules\n         in section 14.18.1 MUST be followed.\n\n   A received message that does not have a Date header field MUST be\n   assigned one by the recipient if the message will be cached by that\n   recipient or gatewayed via a protocol which requires a Date. An HTTP\n   implementation without a clock MUST NOT cache responses without\n   revalidating them on every use. An HTTP cache, especially a shared\n   cache, SHOULD use a mechanism, such as NTP [28], to synchronize its\n   clock with a reliable external standard.\n\n   Clients SHOULD only send a Date header field in messages that include\n   an entity-body, as in the case of the PUT and POST requests, and even\n   then it is optional. A client without a clock MUST NOT send a Date\n   header field in a request.\n\n   The HTTP-date sent in a Date header SHOULD NOT represent a date and\n   time subsequent to the generation of the message. It SHOULD represent\n   the best available approximation of the date and time of message\n   generation, unless the implementation has no means of generating a\n   reasonably accurate date and time. In theory, the date ought to\n   represent the moment just before the entity is generated. In\n   practice, the date can be generated at any time during the message\n   origination without affecting its semantic value.\n\n14.18.1 Clockless Origin Server Operation\n\n   Some origin server implementations might not have a clock available.\n   An origin server without a clock MUST NOT assign Expires or Last-\n   Modified values to a response, unless these values were associated\n   with the resource by a system or user with a reliable clock. It MAY\n   assign an Expires value that is known, at or before server\n   configuration time, to be in the past (this allows \"pre-expiration\"\n   of responses without storing separate Expires values for each\n   resource).\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 125]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.19 ETag\n\n   The ETag response-header field provides the current value of the\n   entity tag for the requested variant. The headers used with entity\n   tags are described in sections 14.24, 14.26 and 14.44. The entity tag\n   MAY be used for comparison with other entities from the same resource\n   (see section 13.3.3).\n\n      ETag = \"ETag\" \":\" entity-tag\n\n   Examples:\n\n      ETag: \"xyzzy\"\n      ETag: W/\"xyzzy\"\n      ETag: \"\"\n\n14.20 Expect\n\n   The Expect request-header field is used to indicate that particular\n   server behaviors are required by the client.\n\n      Expect       =  \"Expect\" \":\" 1#expectation\n\n      expectation  =  \"100-continue\" | expectation-extension\n      expectation-extension =  token [ \"=\" ( token | quoted-string )\n                               *expect-params ]\n      expect-params =  \";\" token [ \"=\" ( token | quoted-string ) ]\n\n\n   A server that does not understand or is unable to comply with any of\n   the expectation values in the Expect field of a request MUST respond\n   with appropriate error status. The server MUST respond with a 417\n   (Expectation Failed) status if any of the expectations cannot be met\n   or, if there are other problems with the request, some other 4xx\n   status.\n\n   This header field is defined with extensible syntax to allow for\n   future extensions. If a server receives a request containing an\n   Expect field that includes an expectation-extension that it does not\n   support, it MUST respond with a 417 (Expectation Failed) status.\n\n   Comparison of expectation values is case-insensitive for unquoted\n   tokens (including the 100-continue token), and is case-sensitive for\n   quoted-string expectation-extensions.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 126]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST\n   return a 417 (Expectation Failed) status if it receives a request\n   with an expectation that it cannot meet. However, the Expect\n   request-header itself is end-to-end; it MUST be forwarded if the\n   request is forwarded.\n\n   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the\n   Expect header.\n\n   See section 8.2.3 for the use of the 100 (continue) status.\n\n14.21 Expires\n\n   The Expires entity-header field gives the date/time after which the\n   response is considered stale. A stale cache entry may not normally be\n   returned by a cache (either a proxy cache or a user agent cache)\n   unless it is first validated with the origin server (or with an\n   intermediate cache that has a fresh copy of the entity). See section\n   13.2 for further discussion of the expiration model.\n\n   The presence of an Expires field does not imply that the original\n   resource will change or cease to exist at, before, or after that\n   time.\n\n   The format is an absolute date and time as defined by HTTP-date in\n   section 3.3.1; it MUST be in RFC 1123 date format:\n\n      Expires = \"Expires\" \":\" HTTP-date\n\n   An example of its use is\n\n      Expires: Thu, 01 Dec 1994 16:00:00 GMT\n\n      Note: if a response includes a Cache-Control field with the max-\n      age directive (see section 14.9.3), that directive overrides the\n      Expires field.\n\n   HTTP/1.1 clients and caches MUST treat other invalid date formats,\n   especially including the value \"0\", as in the past (i.e., \"already\n   expired\").\n\n   To mark a response as \"already expired,\" an origin server sends an\n   Expires date that is equal to the Date header value. (See the rules\n   for expiration calculations in section 13.2.4.)\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 127]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   To mark a response as \"never expires,\" an origin server sends an\n   Expires date approximately one year from the time the response is\n   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one\n   year in the future.\n\n   The presence of an Expires header field with a date value of some\n   time in the future on a response that otherwise would by default be\n   non-cacheable indicates that the response is cacheable, unless\n   indicated otherwise by a Cache-Control header field (section 14.9).\n\n14.22 From\n\n   The From request-header field, if given, SHOULD contain an Internet\n   e-mail address for the human user who controls the requesting user\n   agent. The address SHOULD be machine-usable, as defined by \"mailbox\"\n   in RFC 822 [9] as updated by RFC 1123 [8]:\n\n       From   = \"From\" \":\" mailbox\n\n   An example is:\n\n       From: webmaster@w3.org\n\n   This header field MAY be used for logging purposes and as a means for\n   identifying the source of invalid or unwanted requests. It SHOULD NOT\n   be used as an insecure form of access protection. The interpretation\n   of this field is that the request is being performed on behalf of the\n   person given, who accepts responsibility for the method performed. In\n   particular, robot agents SHOULD include this header so that the\n   person responsible for running the robot can be contacted if problems\n   occur on the receiving end.\n\n   The Internet e-mail address in this field MAY be separate from the\n   Internet host which issued the request. For example, when a request\n   is passed through a proxy the original issuer's address SHOULD be\n   used.\n\n   The client SHOULD NOT send the From header field without the user's\n   approval, as it might conflict with the user's privacy interests or\n   their site's security policy. It is strongly recommended that the\n   user be able to disable, enable, and modify the value of this field\n   at any time prior to a request.\n\n14.23 Host\n\n   The Host request-header field specifies the Internet host and port\n   number of the resource being requested, as obtained from the original\n   URI given by the user or referring resource (generally an HTTP URL,\n\n\n\nFielding, et al.            Standards Track                   [Page 128]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   as described in section 3.2.2). The Host field value MUST represent\n   the naming authority of the origin server or gateway given by the\n   original URL. This allows the origin server or gateway to\n   differentiate between internally-ambiguous URLs, such as the root \"/\"\n   URL of a server for multiple host names on a single IP address.\n\n       Host = \"Host\" \":\" host [ \":\" port ] ; Section 3.2.2\n\n   A \"host\" without any trailing port information implies the default\n   port for the service requested (e.g., \"80\" for an HTTP URL). For\n   example, a request on the origin server for\n   <http://www.w3.org/pub/WWW/> would properly include:\n\n       GET /pub/WWW/ HTTP/1.1\n       Host: www.w3.org\n\n   A client MUST include a Host header field in all HTTP/1.1 request\n   messages . If the requested URI does not include an Internet host\n   name for the service being requested, then the Host header field MUST\n   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any\n   request message it forwards does contain an appropriate Host header\n   field that identifies the service being requested by the proxy. All\n   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)\n   status code to any HTTP/1.1 request message which lacks a Host header\n   field.\n\n   See sections 5.2 and 19.6.1.1 for other requirements relating to\n   Host.\n\n14.24 If-Match\n\n   The If-Match request-header field is used with a method to make it\n   conditional. A client that has one or more entities previously\n   obtained from the resource can verify that one of those entities is\n   current by including a list of their associated entity tags in the\n   If-Match header field. Entity tags are defined in section 3.11. The\n   purpose of this feature is to allow efficient updates of cached\n   information with a minimum amount of transaction overhead. It is also\n   used, on updating requests, to prevent inadvertent modification of\n   the wrong version of a resource. As a special case, the value \"*\"\n   matches any current entity of the resource.\n\n       If-Match = \"If-Match\" \":\" ( \"*\" | 1#entity-tag )\n\n   If any of the entity tags match the entity tag of the entity that\n   would have been returned in the response to a similar GET request\n   (without the If-Match header) on that resource, or if \"*\" is given\n\n\n\n\nFielding, et al.            Standards Track                   [Page 129]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   and any current entity exists for that resource, then the server MAY\n   perform the requested method as if the If-Match header field did not\n   exist.\n\n   A server MUST use the strong comparison function (see section 13.3.3)\n   to compare the entity tags in If-Match.\n\n   If none of the entity tags match, or if \"*\" is given and no current\n   entity exists, the server MUST NOT perform the requested method, and\n   MUST return a 412 (Precondition Failed) response. This behavior is\n   most useful when the client wants to prevent an updating method, such\n   as PUT, from modifying a resource that has changed since the client\n   last retrieved it.\n\n   If the request would, without the If-Match header field, result in\n   anything other than a 2xx or 412 status, then the If-Match header\n   MUST be ignored.\n\n   The meaning of \"If-Match: *\" is that the method SHOULD be performed\n   if the representation selected by the origin server (or by a cache,\n   possibly using the Vary mechanism, see section 14.44) exists, and\n   MUST NOT be performed if the representation does not exist.\n\n   A request intended to update a resource (e.g., a PUT) MAY include an\n   If-Match header field to signal that the request method MUST NOT be\n   applied if the entity corresponding to the If-Match value (a single\n   entity tag) is no longer a representation of that resource. This\n   allows the user to indicate that they do not wish the request to be\n   successful if the resource has been changed without their knowledge.\n   Examples:\n\n       If-Match: \"xyzzy\"\n       If-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n       If-Match: *\n\n   The result of a request having both an If-Match header field and\n   either an If-None-Match or an If-Modified-Since header fields is\n   undefined by this specification.\n\n14.25 If-Modified-Since\n\n   The If-Modified-Since request-header field is used with a method to\n   make it conditional: if the requested variant has not been modified\n   since the time specified in this field, an entity will not be\n   returned from the server; instead, a 304 (not modified) response will\n   be returned without any message-body.\n\n       If-Modified-Since = \"If-Modified-Since\" \":\" HTTP-date\n\n\n\nFielding, et al.            Standards Track                   [Page 130]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   An example of the field is:\n\n       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n   A GET method with an If-Modified-Since header and no Range header\n   requests that the identified entity be transferred only if it has\n   been modified since the date given by the If-Modified-Since header.\n   The algorithm for determining this includes the following cases:\n\n      a) If the request would normally result in anything other than a\n         200 (OK) status, or if the passed If-Modified-Since date is\n         invalid, the response is exactly the same as for a normal GET.\n         A date which is later than the server's current time is\n         invalid.\n\n      b) If the variant has been modified since the If-Modified-Since\n         date, the response is exactly the same as for a normal GET.\n\n      c) If the variant has not been modified since a valid If-\n         Modified-Since date, the server SHOULD return a 304 (Not\n         Modified) response.\n\n   The purpose of this feature is to allow efficient updates of cached\n   information with a minimum amount of transaction overhead.\n\n      Note: The Range request-header field modifies the meaning of If-\n      Modified-Since; see section 14.35 for full details.\n\n      Note: If-Modified-Since times are interpreted by the server, whose\n      clock might not be synchronized with the client.\n\n      Note: When handling an If-Modified-Since header field, some\n      servers will use an exact date comparison function, rather than a\n      less-than function, for deciding whether to send a 304 (Not\n      Modified) response. To get best results when sending an If-\n      Modified-Since header field for cache validation, clients are\n      advised to use the exact date string received in a previous Last-\n      Modified header field whenever possible.\n\n      Note: If a client uses an arbitrary date in the If-Modified-Since\n      header instead of a date taken from the Last-Modified header for\n      the same request, the client should be aware of the fact that this\n      date is interpreted in the server's understanding of time. The\n      client should consider unsynchronized clocks and rounding problems\n      due to the different encodings of time between the client and\n      server. This includes the possibility of race conditions if the\n      document has changed between the time it was first requested and\n      the If-Modified-Since date of a subsequent request, and the\n\n\n\nFielding, et al.            Standards Track                   [Page 131]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      possibility of clock-skew-related problems if the If-Modified-\n      Since date is derived from the client's clock without correction\n      to the server's clock. Corrections for different time bases\n      between client and server are at best approximate due to network\n      latency.\n\n   The result of a request having both an If-Modified-Since header field\n   and either an If-Match or an If-Unmodified-Since header fields is\n   undefined by this specification.\n\n14.26 If-None-Match\n\n   The If-None-Match request-header field is used with a method to make\n   it conditional. A client that has one or more entities previously\n   obtained from the resource can verify that none of those entities is\n   current by including a list of their associated entity tags in the\n   If-None-Match header field. The purpose of this feature is to allow\n   efficient updates of cached information with a minimum amount of\n   transaction overhead. It is also used to prevent a method (e.g. PUT)\n   from inadvertently modifying an existing resource when the client\n   believes that the resource does not exist.\n\n   As a special case, the value \"*\" matches any current entity of the\n   resource.\n\n       If-None-Match = \"If-None-Match\" \":\" ( \"*\" | 1#entity-tag )\n\n   If any of the entity tags match the entity tag of the entity that\n   would have been returned in the response to a similar GET request\n   (without the If-None-Match header) on that resource, or if \"*\" is\n   given and any current entity exists for that resource, then the\n   server MUST NOT perform the requested method, unless required to do\n   so because the resource's modification date fails to match that\n   supplied in an If-Modified-Since header field in the request.\n   Instead, if the request method was GET or HEAD, the server SHOULD\n   respond with a 304 (Not Modified) response, including the cache-\n   related header fields (particularly ETag) of one of the entities that\n   matched. For all other request methods, the server MUST respond with\n   a status of 412 (Precondition Failed).\n\n   See section 13.3.3 for rules on how to determine if two entities tags\n   match. The weak comparison function can only be used with GET or HEAD\n   requests.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 132]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If none of the entity tags match, then the server MAY perform the\n   requested method as if the If-None-Match header field did not exist,\n   but MUST also ignore any If-Modified-Since header field(s) in the\n   request. That is, if no entity tags match, then the server MUST NOT\n   return a 304 (Not Modified) response.\n\n   If the request would, without the If-None-Match header field, result\n   in anything other than a 2xx or 304 status, then the If-None-Match\n   header MUST be ignored. (See section 13.3.4 for a discussion of\n   server behavior when both If-Modified-Since and If-None-Match appear\n   in the same request.)\n\n   The meaning of \"If-None-Match: *\" is that the method MUST NOT be\n   performed if the representation selected by the origin server (or by\n   a cache, possibly using the Vary mechanism, see section 14.44)\n   exists, and SHOULD be performed if the representation does not exist.\n   This feature is intended to be useful in preventing races between PUT\n   operations.\n\n   Examples:\n\n       If-None-Match: \"xyzzy\"\n       If-None-Match: W/\"xyzzy\"\n       If-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n       If-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"\n       If-None-Match: *\n\n   The result of a request having both an If-None-Match header field and\n   either an If-Match or an If-Unmodified-Since header fields is\n   undefined by this specification.\n\n14.27 If-Range\n\n   If a client has a partial copy of an entity in its cache, and wishes\n   to have an up-to-date copy of the entire entity in its cache, it\n   could use the Range request-header with a conditional GET (using\n   either or both of If-Unmodified-Since and If-Match.) However, if the\n   condition fails because the entity has been modified, the client\n   would then have to make a second request to obtain the entire current\n   entity-body.\n\n   The If-Range header allows a client to \"short-circuit\" the second\n   request. Informally, its meaning is `if the entity is unchanged, send\n   me the part(s) that I am missing; otherwise, send me the entire new\n   entity'.\n\n        If-Range = \"If-Range\" \":\" ( entity-tag | HTTP-date )\n\n\n\n\nFielding, et al.            Standards Track                   [Page 133]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the client has no entity tag for an entity, but does have a Last-\n   Modified date, it MAY use that date in an If-Range header. (The\n   server can distinguish between a valid HTTP-date and any form of\n   entity-tag by examining no more than two characters.) The If-Range\n   header SHOULD only be used together with a Range header, and MUST be\n   ignored if the request does not include a Range header, or if the\n   server does not support the sub-range operation.\n\n   If the entity tag given in the If-Range header matches the current\n   entity tag for the entity, then the server SHOULD provide the\n   specified sub-range of the entity using a 206 (Partial content)\n   response. If the entity tag does not match, then the server SHOULD\n   return the entire entity using a 200 (OK) response.\n\n14.28 If-Unmodified-Since\n\n   The If-Unmodified-Since request-header field is used with a method to\n   make it conditional. If the requested resource has not been modified\n   since the time specified in this field, the server SHOULD perform the\n   requested operation as if the If-Unmodified-Since header were not\n   present.\n\n   If the requested variant has been modified since the specified time,\n   the server MUST NOT perform the requested operation, and MUST return\n   a 412 (Precondition Failed).\n\n      If-Unmodified-Since = \"If-Unmodified-Since\" \":\" HTTP-date\n\n   An example of the field is:\n\n       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n   If the request normally (i.e., without the If-Unmodified-Since\n   header) would result in anything other than a 2xx or 412 status, the\n   If-Unmodified-Since header SHOULD be ignored.\n\n   If the specified date is invalid, the header is ignored.\n\n   The result of a request having both an If-Unmodified-Since header\n   field and either an If-None-Match or an If-Modified-Since header\n   fields is undefined by this specification.\n\n14.29 Last-Modified\n\n   The Last-Modified entity-header field indicates the date and time at\n   which the origin server believes the variant was last modified.\n\n       Last-Modified  = \"Last-Modified\" \":\" HTTP-date\n\n\n\nFielding, et al.            Standards Track                   [Page 134]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   An example of its use is\n\n       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n\n   The exact meaning of this header field depends on the implementation\n   of the origin server and the nature of the original resource. For\n   files, it may be just the file system last-modified time. For\n   entities with dynamically included parts, it may be the most recent\n   of the set of last-modify times for its component parts. For database\n   gateways, it may be the last-update time stamp of the record. For\n   virtual objects, it may be the last time the internal state changed.\n\n   An origin server MUST NOT send a Last-Modified date which is later\n   than the server's time of message origination. In such cases, where\n   the resource's last modification would indicate some time in the\n   future, the server MUST replace that date with the message\n   origination date.\n\n   An origin server SHOULD obtain the Last-Modified value of the entity\n   as close as possible to the time that it generates the Date value of\n   its response. This allows a recipient to make an accurate assessment\n   of the entity's modification time, especially if the entity changes\n   near the time that the response is generated.\n\n   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.\n\n14.30 Location\n\n   The Location response-header field is used to redirect the recipient\n   to a location other than the Request-URI for completion of the\n   request or identification of a new resource. For 201 (Created)\n   responses, the Location is that of the new resource which was created\n   by the request. For 3xx responses, the location SHOULD indicate the\n   server's preferred URI for automatic redirection to the resource. The\n   field value consists of a single absolute URI.\n\n       Location       = \"Location\" \":\" absoluteURI\n\n   An example is:\n\n       Location: http://www.w3.org/pub/WWW/People.html\n\n      Note: The Content-Location header field (section 14.14) differs\n      from Location in that the Content-Location identifies the original\n      location of the entity enclosed in the request. It is therefore\n      possible for a response to contain header fields for both Location\n      and Content-Location. Also see section 13.10 for cache\n      requirements of some methods.\n\n\n\nFielding, et al.            Standards Track                   [Page 135]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.31 Max-Forwards\n\n   The Max-Forwards request-header field provides a mechanism with the\n   TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit the\n   number of proxies or gateways that can forward the request to the\n   next inbound server. This can be useful when the client is attempting\n   to trace a request chain which appears to be failing or looping in\n   mid-chain.\n\n       Max-Forwards   = \"Max-Forwards\" \":\" 1*DIGIT\n\n   The Max-Forwards value is a decimal integer indicating the remaining\n   number of times this request message may be forwarded.\n\n   Each proxy or gateway recipient of a TRACE or OPTIONS request\n   containing a Max-Forwards header field MUST check and update its\n   value prior to forwarding the request. If the received value is zero\n   (0), the recipient MUST NOT forward the request; instead, it MUST\n   respond as the final recipient. If the received Max-Forwards value is\n   greater than zero, then the forwarded message MUST contain an updated\n   Max-Forwards field with a value decremented by one (1).\n\n   The Max-Forwards header field MAY be ignored for all other methods\n   defined by this specification and for any extension methods for which\n   it is not explicitly referred to as part of that method definition.\n\n14.32 Pragma\n\n   The Pragma general-header field is used to include implementation-\n   specific directives that might apply to any recipient along the\n   request/response chain. All pragma directives specify optional\n   behavior from the viewpoint of the protocol; however, some systems\n   MAY require that behavior be consistent with the directives.\n\n       Pragma            = \"Pragma\" \":\" 1#pragma-directive\n       pragma-directive  = \"no-cache\" | extension-pragma\n       extension-pragma  = token [ \"=\" ( token | quoted-string ) ]\n\n   When the no-cache directive is present in a request message, an\n   application SHOULD forward the request toward the origin server even\n   if it has a cached copy of what is being requested. This pragma\n   directive has the same semantics as the no-cache cache-directive (see\n   section 14.9) and is defined here for backward compatibility with\n   HTTP/1.0. Clients SHOULD include both header fields when a no-cache\n   request is sent to a server not known to be HTTP/1.1 compliant.\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 136]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Pragma directives MUST be passed through by a proxy or gateway\n   application, regardless of their significance to that application,\n   since the directives might be applicable to all recipients along the\n   request/response chain. It is not possible to specify a pragma for a\n   specific recipient; however, any pragma directive not relevant to a\n   recipient SHOULD be ignored by that recipient.\n\n   HTTP/1.1 caches SHOULD treat \"Pragma: no-cache\" as if the client had\n   sent \"Cache-Control: no-cache\". No new Pragma directives will be\n   defined in HTTP.\n\n      Note: because the meaning of \"Pragma: no-cache as a response\n      header field is not actually specified, it does not provide a\n      reliable replacement for \"Cache-Control: no-cache\" in a response\n\n14.33 Proxy-Authenticate\n\n   The Proxy-Authenticate response-header field MUST be included as part\n   of a 407 (Proxy Authentication Required) response. The field value\n   consists of a challenge that indicates the authentication scheme and\n   parameters applicable to the proxy for this Request-URI.\n\n       Proxy-Authenticate  = \"Proxy-Authenticate\" \":\" 1#challenge\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. Unlike\n   WWW-Authenticate, the Proxy-Authenticate header field applies only to\n   the current connection and SHOULD NOT be passed on to downstream\n   clients. However, an intermediate proxy might need to obtain its own\n   credentials by requesting them from the downstream client, which in\n   some circumstances will appear as if the proxy is forwarding the\n   Proxy-Authenticate header field.\n\n14.34 Proxy-Authorization\n\n   The Proxy-Authorization request-header field allows the client to\n   identify itself (or its user) to a proxy which requires\n   authentication. The Proxy-Authorization field value consists of\n   credentials containing the authentication information of the user\n   agent for the proxy and/or realm of the resource being requested.\n\n       Proxy-Authorization     = \"Proxy-Authorization\" \":\" credentials\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43] . Unlike\n   Authorization, the Proxy-Authorization header field applies only to\n   the next outbound proxy that demanded authentication using the Proxy-\n   Authenticate field. When multiple proxies are used in a chain, the\n\n\n\nFielding, et al.            Standards Track                   [Page 137]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Proxy-Authorization header field is consumed by the first outbound\n   proxy that was expecting to receive credentials. A proxy MAY relay\n   the credentials from the client request to the next proxy if that is\n   the mechanism by which the proxies cooperatively authenticate a given\n   request.\n\n14.35 Range\n\n14.35.1 Byte Ranges\n\n   Since all HTTP entities are represented in HTTP messages as sequences\n   of bytes, the concept of a byte range is meaningful for any HTTP\n   entity. (However, not all clients and servers need to support byte-\n   range operations.)\n\n   Byte range specifications in HTTP apply to the sequence of bytes in\n   the entity-body (not necessarily the same as the message-body).\n\n   A byte range operation MAY specify a single range of bytes, or a set\n   of ranges within a single entity.\n\n       ranges-specifier = byte-ranges-specifier\n       byte-ranges-specifier = bytes-unit \"=\" byte-range-set\n       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )\n       byte-range-spec = first-byte-pos \"-\" [last-byte-pos]\n       first-byte-pos  = 1*DIGIT\n       last-byte-pos   = 1*DIGIT\n\n   The first-byte-pos value in a byte-range-spec gives the byte-offset\n   of the first byte in a range. The last-byte-pos value gives the\n   byte-offset of the last byte in the range; that is, the byte\n   positions specified are inclusive. Byte offsets start at zero.\n\n   If the last-byte-pos value is present, it MUST be greater than or\n   equal to the first-byte-pos in that byte-range-spec, or the byte-\n   range-spec is syntactically invalid. The recipient of a byte-range-\n   set that includes one or more syntactically invalid byte-range-spec\n   values MUST ignore the header field that includes that byte-range-\n   set.\n\n   If the last-byte-pos value is absent, or if the value is greater than\n   or equal to the current length of the entity-body, last-byte-pos is\n   taken to be equal to one less than the current length of the entity-\n   body in bytes.\n\n   By its choice of last-byte-pos, a client can limit the number of\n   bytes retrieved without knowing the size of the entity.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 138]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       suffix-byte-range-spec = \"-\" suffix-length\n       suffix-length = 1*DIGIT\n\n   A suffix-byte-range-spec is used to specify the suffix of the\n   entity-body, of a length given by the suffix-length value. (That is,\n   this form specifies the last N bytes of an entity-body.) If the\n   entity is shorter than the specified suffix-length, the entire\n   entity-body is used.\n\n   If a syntactically valid byte-range-set includes at least one byte-\n   range-spec whose first-byte-pos is less than the current length of\n   the entity-body, or at least one suffix-byte-range-spec with a non-\n   zero suffix-length, then the byte-range-set is satisfiable.\n   Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set\n   is unsatisfiable, the server SHOULD return a response with a status\n   of 416 (Requested range not satisfiable). Otherwise, the server\n   SHOULD return a response with a status of 206 (Partial Content)\n   containing the satisfiable ranges of the entity-body.\n\n   Examples of byte-ranges-specifier values (assuming an entity-body of\n   length 10000):\n\n      - The first 500 bytes (byte offsets 0-499, inclusive):  bytes=0-\n        499\n\n      - The second 500 bytes (byte offsets 500-999, inclusive):\n        bytes=500-999\n\n      - The final 500 bytes (byte offsets 9500-9999, inclusive):\n        bytes=-500\n\n      - Or bytes=9500-\n\n      - The first and last bytes only (bytes 0 and 9999):  bytes=0-0,-1\n\n      - Several legal but not canonical specifications of the second 500\n        bytes (byte offsets 500-999, inclusive):\n         bytes=500-600,601-999\n         bytes=500-700,601-999\n\n14.35.2 Range Retrieval Requests\n\n   HTTP retrieval requests using conditional or unconditional GET\n   methods MAY request one or more sub-ranges of the entity, instead of\n   the entire entity, using the Range request header, which applies to\n   the entity returned as the result of the request:\n\n      Range = \"Range\" \":\" ranges-specifier\n\n\n\nFielding, et al.            Standards Track                   [Page 139]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A server MAY ignore the Range header. However, HTTP/1.1 origin\n   servers and intermediate caches ought to support byte ranges when\n   possible, since Range supports efficient recovery from partially\n   failed transfers, and supports efficient partial retrieval of large\n   entities.\n\n   If the server supports the Range header and the specified range or\n   ranges are appropriate for the entity:\n\n      - The presence of a Range header in an unconditional GET modifies\n        what is returned if the GET is otherwise successful. In other\n        words, the response carries a status code of 206 (Partial\n        Content) instead of 200 (OK).\n\n      - The presence of a Range header in a conditional GET (a request\n        using one or both of If-Modified-Since and If-None-Match, or\n        one or both of If-Unmodified-Since and If-Match) modifies what\n        is returned if the GET is otherwise successful and the\n        condition is true. It does not affect the 304 (Not Modified)\n        response returned if the conditional is false.\n\n   In some cases, it might be more appropriate to use the If-Range\n   header (see section 14.27) in addition to the Range header.\n\n   If a proxy that supports ranges receives a Range request, forwards\n   the request to an inbound server, and receives an entire entity in\n   reply, it SHOULD only return the requested range to its client. It\n   SHOULD store the entire received response in its cache if that is\n   consistent with its cache allocation policies.\n\n14.36 Referer\n\n   The Referer[sic] request-header field allows the client to specify,\n   for the server's benefit, the address (URI) of the resource from\n   which the Request-URI was obtained (the \"referrer\", although the\n   header field is misspelled.) The Referer request-header allows a\n   server to generate lists of back-links to resources for interest,\n   logging, optimized caching, etc. It also allows obsolete or mistyped\n   links to be traced for maintenance. The Referer field MUST NOT be\n   sent if the Request-URI was obtained from a source that does not have\n   its own URI, such as input from the user keyboard.\n\n       Referer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\n\n   Example:\n\n       Referer: http://www.w3.org/hypertext/DataSources/Overview.html\n\n\n\n\nFielding, et al.            Standards Track                   [Page 140]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the field value is a relative URI, it SHOULD be interpreted\n   relative to the Request-URI. The URI MUST NOT include a fragment. See\n   section 15.1.3 for security considerations.\n\n14.37 Retry-After\n\n   The Retry-After response-header field can be used with a 503 (Service\n   Unavailable) response to indicate how long the service is expected to\n   be unavailable to the requesting client. This field MAY also be used\n   with any 3xx (Redirection) response to indicate the minimum time the\n   user-agent is asked wait before issuing the redirected request. The\n   value of this field can be either an HTTP-date or an integer number\n   of seconds (in decimal) after the time of the response.\n\n       Retry-After  = \"Retry-After\" \":\" ( HTTP-date | delta-seconds )\n\n   Two examples of its use are\n\n       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT\n       Retry-After: 120\n\n   In the latter example, the delay is 2 minutes.\n\n14.38 Server\n\n   The Server response-header field contains information about the\n   software used by the origin server to handle the request. The field\n   can contain multiple product tokens (section 3.8) and comments\n   identifying the server and any significant subproducts. The product\n   tokens are listed in order of their significance for identifying the\n   application.\n\n       Server         = \"Server\" \":\" 1*( product | comment )\n\n   Example:\n\n       Server: CERN/3.0 libwww/2.17\n\n   If the response is being forwarded through a proxy, the proxy\n   application MUST NOT modify the Server response-header. Instead, it\n   SHOULD include a Via field (as described in section 14.45).\n\n      Note: Revealing the specific software version of the server might\n      allow the server machine to become more vulnerable to attacks\n      against software that is known to contain security holes. Server\n      implementors are encouraged to make this field a configurable\n      option.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 141]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.39 TE\n\n   The TE request-header field indicates what extension transfer-codings\n   it is willing to accept in the response and whether or not it is\n   willing to accept trailer fields in a chunked transfer-coding. Its\n   value may consist of the keyword \"trailers\" and/or a comma-separated\n   list of extension transfer-coding names with optional accept\n   parameters (as described in section 3.6).\n\n       TE        = \"TE\" \":\" #( t-codings )\n       t-codings = \"trailers\" | ( transfer-extension [ accept-params ] )\n\n   The presence of the keyword \"trailers\" indicates that the client is\n   willing to accept trailer fields in a chunked transfer-coding, as\n   defined in section 3.6.1. This keyword is reserved for use with\n   transfer-coding values even though it does not itself represent a\n   transfer-coding.\n\n   Examples of its use are:\n\n       TE: deflate\n       TE:\n       TE: trailers, deflate;q=0.5\n\n   The TE header field only applies to the immediate connection.\n   Therefore, the keyword MUST be supplied within a Connection header\n   field (section 14.10) whenever TE is present in an HTTP/1.1 message.\n\n   A server tests whether a transfer-coding is acceptable, according to\n   a TE field, using these rules:\n\n      1. The \"chunked\" transfer-coding is always acceptable. If the\n         keyword \"trailers\" is listed, the client indicates that it is\n         willing to accept trailer fields in the chunked response on\n         behalf of itself and any downstream clients. The implication is\n         that, if given, the client is stating that either all\n         downstream clients are willing to accept trailer fields in the\n         forwarded response, or that it will attempt to buffer the\n         response on behalf of downstream recipients.\n\n         Note: HTTP/1.1 does not define any means to limit the size of a\n         chunked response such that a client can be assured of buffering\n         the entire response.\n\n      2. If the transfer-coding being tested is one of the transfer-\n         codings listed in the TE field, then it is acceptable unless it\n         is accompanied by a qvalue of 0. (As defined in section 3.9, a\n         qvalue of 0 means \"not acceptable.\")\n\n\n\nFielding, et al.            Standards Track                   [Page 142]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      3. If multiple transfer-codings are acceptable, then the\n         acceptable transfer-coding with the highest non-zero qvalue is\n         preferred.  The \"chunked\" transfer-coding always has a qvalue\n         of 1.\n\n   If the TE field-value is empty or if no TE field is present, the only\n   transfer-coding  is \"chunked\". A message with no transfer-coding is\n   always acceptable.\n\n14.40 Trailer\n\n   The Trailer general field value indicates that the given set of\n   header fields is present in the trailer of a message encoded with\n   chunked transfer-coding.\n\n       Trailer  = \"Trailer\" \":\" 1#field-name\n\n   An HTTP/1.1 message SHOULD include a Trailer header field in a\n   message using chunked transfer-coding with a non-empty trailer. Doing\n   so allows the recipient to know which header fields to expect in the\n   trailer.\n\n   If no Trailer header field is present, the trailer SHOULD NOT include\n   any header fields. See section 3.6.1 for restrictions on the use of\n   trailer fields in a \"chunked\" transfer-coding.\n\n   Message header fields listed in the Trailer header field MUST NOT\n   include the following header fields:\n\n      . Transfer-Encoding\n\n      . Content-Length\n\n      . Trailer\n\n14.41 Transfer-Encoding\n\n   The Transfer-Encoding general-header field indicates what (if any)\n   type of transformation has been applied to the message body in order\n   to safely transfer it between the sender and the recipient. This\n   differs from the content-coding in that the transfer-coding is a\n   property of the message, not of the entity.\n\n     Transfer-Encoding       = \"Transfer-Encoding\" \":\" 1#transfer-coding\n\n   Transfer-codings are defined in section 3.6. An example is:\n\n     Transfer-Encoding: chunked\n\n\n\nFielding, et al.            Standards Track                   [Page 143]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If multiple encodings have been applied to an entity, the transfer-\n   codings MUST be listed in the order in which they were applied.\n   Additional information about the encoding parameters MAY be provided\n   by other entity-header fields not defined by this specification.\n\n   Many older HTTP/1.0 applications do not understand the Transfer-\n   Encoding header.\n\n14.42 Upgrade\n\n   The Upgrade general-header allows the client to specify what\n   additional communication protocols it supports and would like to use\n   if the server finds it appropriate to switch protocols. The server\n   MUST use the Upgrade header field within a 101 (Switching Protocols)\n   response to indicate which protocol(s) are being switched.\n\n       Upgrade        = \"Upgrade\" \":\" 1#product\n\n   For example,\n\n       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\n\n   The Upgrade header field is intended to provide a simple mechanism\n   for transition from HTTP/1.1 to some other, incompatible protocol. It\n   does so by allowing the client to advertise its desire to use another\n   protocol, such as a later version of HTTP with a higher major version\n   number, even though the current request has been made using HTTP/1.1.\n   This eases the difficult transition between incompatible protocols by\n   allowing the client to initiate a request in the more commonly\n   supported protocol while indicating to the server that it would like\n   to use a \"better\" protocol if available (where \"better\" is determined\n   by the server, possibly according to the nature of the method and/or\n   resource being requested).\n\n   The Upgrade header field only applies to switching application-layer\n   protocols upon the existing transport-layer connection. Upgrade\n   cannot be used to insist on a protocol change; its acceptance and use\n   by the server is optional. The capabilities and nature of the\n   application-layer communication after the protocol change is entirely\n   dependent upon the new protocol chosen, although the first action\n   after changing the protocol MUST be a response to the initial HTTP\n   request containing the Upgrade header field.\n\n   The Upgrade header field only applies to the immediate connection.\n   Therefore, the upgrade keyword MUST be supplied within a Connection\n   header field (section 14.10) whenever Upgrade is present in an\n   HTTP/1.1 message.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 144]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Upgrade header field cannot be used to indicate a switch to a\n   protocol on a different connection. For that purpose, it is more\n   appropriate to use a 301, 302, 303, or 305 redirection response.\n\n   This specification only defines the protocol name \"HTTP\" for use by\n   the family of Hypertext Transfer Protocols, as defined by the HTTP\n   version rules of section 3.1 and future updates to this\n   specification. Any token can be used as a protocol name; however, it\n   will only be useful if both the client and server associate the name\n   with the same protocol.\n\n14.43 User-Agent\n\n   The User-Agent request-header field contains information about the\n   user agent originating the request. This is for statistical purposes,\n   the tracing of protocol violations, and automated recognition of user\n   agents for the sake of tailoring responses to avoid particular user\n   agent limitations. User agents SHOULD include this field with\n   requests. The field can contain multiple product tokens (section 3.8)\n   and comments identifying the agent and any subproducts which form a\n   significant part of the user agent. By convention, the product tokens\n   are listed in order of their significance for identifying the\n   application.\n\n       User-Agent     = \"User-Agent\" \":\" 1*( product | comment )\n\n   Example:\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n\n14.44 Vary\n\n   The Vary field value indicates the set of request-header fields that\n   fully determines, while the response is fresh, whether a cache is\n   permitted to use the response to reply to a subsequent request\n   without revalidation. For uncacheable or stale responses, the Vary\n   field value advises the user agent about the criteria that were used\n   to select the representation. A Vary field value of \"*\" implies that\n   a cache cannot determine from the request headers of a subsequent\n   request whether this response is the appropriate representation. See\n   section 13.6 for use of the Vary header field by caches.\n\n       Vary  = \"Vary\" \":\" ( \"*\" | 1#field-name )\n\n   An HTTP/1.1 server SHOULD include a Vary header field with any\n   cacheable response that is subject to server-driven negotiation.\n   Doing so allows a cache to properly interpret future requests on that\n   resource and informs the user agent about the presence of negotiation\n\n\n\nFielding, et al.            Standards Track                   [Page 145]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   on that resource. A server MAY include a Vary header field with a\n   non-cacheable response that is subject to server-driven negotiation,\n   since this might provide the user agent with useful information about\n   the dimensions over which the response varies at the time of the\n   response.\n\n   A Vary field value consisting of a list of field-names signals that\n   the representation selected for the response is based on a selection\n   algorithm which considers ONLY the listed request-header field values\n   in selecting the most appropriate representation. A cache MAY assume\n   that the same selection will be made for future requests with the\n   same values for the listed field names, for the duration of time for\n   which the response is fresh.\n\n   The field-names given are not limited to the set of standard\n   request-header fields defined by this specification. Field names are\n   case-insensitive.\n\n   A Vary field value of \"*\" signals that unspecified parameters not\n   limited to the request-headers (e.g., the network address of the\n   client), play a role in the selection of the response representation.\n   The \"*\" value MUST NOT be generated by a proxy server; it may only be\n   generated by an origin server.\n\n14.45  Via\n\n   The Via general-header field MUST be used by gateways and proxies to\n   indicate the intermediate protocols and recipients between the user\n   agent and the server on requests, and between the origin server and\n   the client on responses. It is analogous to the \"Received\" field of\n   RFC 822 [9] and is intended to be used for tracking message forwards,\n   avoiding request loops, and identifying the protocol capabilities of\n   all senders along the request/response chain.\n\n      Via =  \"Via\" \":\" 1#( received-protocol received-by [ comment ] )\n      received-protocol = [ protocol-name \"/\" ] protocol-version\n      protocol-name     = token\n      protocol-version  = token\n      received-by       = ( host [ \":\" port ] ) | pseudonym\n      pseudonym         = token\n\n   The received-protocol indicates the protocol version of the message\n   received by the server or client along each segment of the\n   request/response chain. The received-protocol version is appended to\n   the Via field value when the message is forwarded so that information\n   about the protocol capabilities of upstream applications remains\n   visible to all recipients.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 146]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The protocol-name is optional if and only if it would be \"HTTP\". The\n   received-by field is normally the host and optional port number of a\n   recipient server or client that subsequently forwarded the message.\n   However, if the real host is considered to be sensitive information,\n   it MAY be replaced by a pseudonym. If the port is not given, it MAY\n   be assumed to be the default port of the received-protocol.\n\n   Multiple Via field values represents each proxy or gateway that has\n   forwarded the message. Each recipient MUST append its information\n   such that the end result is ordered according to the sequence of\n   forwarding applications.\n\n   Comments MAY be used in the Via header field to identify the software\n   of the recipient proxy or gateway, analogous to the User-Agent and\n   Server header fields. However, all comments in the Via field are\n   optional and MAY be removed by any recipient prior to forwarding the\n   message.\n\n   For example, a request message could be sent from an HTTP/1.0 user\n   agent to an internal proxy code-named \"fred\", which uses HTTP/1.1 to\n   forward the request to a public proxy at nowhere.com, which completes\n   the request by forwarding it to the origin server at www.ics.uci.edu.\n   The request received by www.ics.uci.edu would then have the following\n   Via header field:\n\n       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\n\n   Proxies and gateways used as a portal through a network firewall\n   SHOULD NOT, by default, forward the names and ports of hosts within\n   the firewall region. This information SHOULD only be propagated if\n   explicitly enabled. If not enabled, the received-by host of any host\n   behind the firewall SHOULD be replaced by an appropriate pseudonym\n   for that host.\n\n   For organizations that have strong privacy requirements for hiding\n   internal structures, a proxy MAY combine an ordered subsequence of\n   Via header field entries with identical received-protocol values into\n   a single such entry. For example,\n\n       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy\n\n        could be collapsed to\n\n       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 147]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Applications SHOULD NOT combine multiple entries unless they are all\n   under the same organizational control and the hosts have already been\n   replaced by pseudonyms. Applications MUST NOT combine entries which\n   have different received-protocol values.\n\n14.46 Warning\n\n   The Warning general-header field is used to carry additional\n   information about the status or transformation of a message which\n   might not be reflected in the message. This information is typically\n   used to warn about a possible lack of semantic transparency from\n   caching operations or transformations applied to the entity body of\n   the message.\n\n   Warning headers are sent with responses using:\n\n       Warning    = \"Warning\" \":\" 1#warning-value\n\n       warning-value = warn-code SP warn-agent SP warn-text\n                                             [SP warn-date]\n\n       warn-code  = 3DIGIT\n       warn-agent = ( host [ \":\" port ] ) | pseudonym\n                       ; the name or pseudonym of the server adding\n                       ; the Warning header, for use in debugging\n       warn-text  = quoted-string\n       warn-date  = <\"> HTTP-date <\">\n\n   A response MAY carry more than one Warning header.\n\n   The warn-text SHOULD be in a natural language and character set that\n   is most likely to be intelligible to the human user receiving the\n   response. This decision MAY be based on any available knowledge, such\n   as the location of the cache or user, the Accept-Language field in a\n   request, the Content-Language field in a response, etc. The default\n   language is English and the default character set is ISO-8859-1.\n\n   If a character set other than ISO-8859-1 is used, it MUST be encoded\n   in the warn-text using the method described in RFC 2047 [14].\n\n   Warning headers can in general be applied to any message, however\n   some specific warn-codes are specific to caches and can only be\n   applied to response messages. New Warning headers SHOULD be added\n   after any existing Warning headers. A cache MUST NOT delete any\n   Warning header that it received with a message. However, if a cache\n   successfully validates a cache entry, it SHOULD remove any Warning\n   headers previously attached to that entry except as specified for\n\n\n\n\nFielding, et al.            Standards Track                   [Page 148]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   specific Warning codes. It MUST then add any Warning headers received\n   in the validating response. In other words, Warning headers are those\n   that would be attached to the most recent relevant response.\n\n   When multiple Warning headers are attached to a response, the user\n   agent ought to inform the user of as many of them as possible, in the\n   order that they appear in the response. If it is not possible to\n   inform the user of all of the warnings, the user agent SHOULD follow\n   these heuristics:\n\n      - Warnings that appear early in the response take priority over\n        those appearing later in the response.\n\n      - Warnings in the user's preferred character set take priority\n        over warnings in other character sets but with identical warn-\n        codes and warn-agents.\n\n   Systems that generate multiple Warning headers SHOULD order them with\n   this user agent behavior in mind.\n\n   Requirements for the behavior of caches with respect to Warnings are\n   stated in section 13.1.2.\n\n   This is a list of the currently-defined warn-codes, each with a\n   recommended warn-text in English, and a description of its meaning.\n\n   110 Response is stale\n     MUST be included whenever the returned response is stale.\n\n   111 Revalidation failed\n     MUST be included if a cache returns a stale response because an\n     attempt to revalidate the response failed, due to an inability to\n     reach the server.\n\n   112 Disconnected operation\n     SHOULD be included if the cache is intentionally disconnected from\n     the rest of the network for a period of time.\n\n   113 Heuristic expiration\n     MUST be included if the cache heuristically chose a freshness\n     lifetime greater than 24 hours and the response's age is greater\n     than 24 hours.\n\n   199 Miscellaneous warning\n     The warning text MAY include arbitrary information to be presented\n     to a human user, or logged. A system receiving this warning MUST\n     NOT take any automated action, besides presenting the warning to\n     the user.\n\n\n\nFielding, et al.            Standards Track                   [Page 149]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   214 Transformation applied\n     MUST be added by an intermediate cache or proxy if it applies any\n     transformation changing the content-coding (as specified in the\n     Content-Encoding header) or media-type (as specified in the\n     Content-Type header) of the response, or the entity-body of the\n     response, unless this Warning code already appears in the response.\n\n   299 Miscellaneous persistent warning\n     The warning text MAY include arbitrary information to be presented\n     to a human user, or logged. A system receiving this warning MUST\n     NOT take any automated action.\n\n   If an implementation sends a message with one or more Warning headers\n   whose version is HTTP/1.0 or lower, then the sender MUST include in\n   each warning-value a warn-date that matches the date in the response.\n\n   If an implementation receives a message with a warning-value that\n   includes a warn-date, and that warn-date is different from the Date\n   value in the response, then that warning-value MUST be deleted from\n   the message before storing, forwarding, or using it. (This prevents\n   bad consequences of naive caching of Warning header fields.) If all\n   of the warning-values are deleted for this reason, the Warning header\n   MUST be deleted as well.\n\n14.47 WWW-Authenticate\n\n   The WWW-Authenticate response-header field MUST be included in 401\n   (Unauthorized) response messages. The field value consists of at\n   least one challenge that indicates the authentication scheme(s) and\n   parameters applicable to the Request-URI.\n\n       WWW-Authenticate  = \"WWW-Authenticate\" \":\" 1#challenge\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. User\n   agents are advised to take special care in parsing the WWW-\n   Authenticate field value as it might contain more than one challenge,\n   or if more than one WWW-Authenticate header field is provided, the\n   contents of a challenge itself can contain a comma-separated list of\n   authentication parameters.\n\n15 Security Considerations\n\n   This section is meant to inform application developers, information\n   providers, and users of the security limitations in HTTP/1.1 as\n   described by this document. The discussion does not include\n   definitive solutions to the problems revealed, though it does make\n   some suggestions for reducing security risks.\n\n\n\nFielding, et al.            Standards Track                   [Page 150]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.1 Personal Information\n\n   HTTP clients are often privy to large amounts of personal information\n   (e.g. the user's name, location, mail address, passwords, encryption\n   keys, etc.), and SHOULD be very careful to prevent unintentional\n   leakage of this information via the HTTP protocol to other sources.\n   We very strongly recommend that a convenient interface be provided\n   for the user to control dissemination of such information, and that\n   designers and implementors be particularly careful in this area.\n   History shows that errors in this area often create serious security\n   and/or privacy problems and generate highly adverse publicity for the\n   implementor's company.\n\n15.1.1 Abuse of Server Log Information\n\n   A server is in the position to save personal data about a user's\n   requests which might identify their reading patterns or subjects of\n   interest. This information is clearly confidential in nature and its\n   handling can be constrained by law in certain countries. People using\n   the HTTP protocol to provide data are responsible for ensuring that\n   such material is not distributed without the permission of any\n   individuals that are identifiable by the published results.\n\n15.1.2 Transfer of Sensitive Information\n\n   Like any generic data transfer protocol, HTTP cannot regulate the\n   content of the data that is transferred, nor is there any a priori\n   method of determining the sensitivity of any particular piece of\n   information within the context of any given request. Therefore,\n   applications SHOULD supply as much control over this information as\n   possible to the provider of that information. Four header fields are\n   worth special mention in this context: Server, Via, Referer and From.\n\n   Revealing the specific software version of the server might allow the\n   server machine to become more vulnerable to attacks against software\n   that is known to contain security holes. Implementors SHOULD make the\n   Server header field a configurable option.\n\n   Proxies which serve as a portal through a network firewall SHOULD\n   take special precautions regarding the transfer of header information\n   that identifies the hosts behind the firewall. In particular, they\n   SHOULD remove, or replace with sanitized versions, any Via fields\n   generated behind the firewall.\n\n   The Referer header allows reading patterns to be studied and reverse\n   links drawn. Although it can be very useful, its power can be abused\n   if user details are not separated from the information contained in\n\n\n\n\nFielding, et al.            Standards Track                   [Page 151]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the Referer. Even when the personal information has been removed, the\n   Referer header might indicate a private document's URI whose\n   publication would be inappropriate.\n\n   The information sent in the From field might conflict with the user's\n   privacy interests or their site's security policy, and hence it\n   SHOULD NOT be transmitted without the user being able to disable,\n   enable, and modify the contents of the field. The user MUST be able\n   to set the contents of this field within a user preference or\n   application defaults configuration.\n\n   We suggest, though do not require, that a convenient toggle interface\n   be provided for the user to enable or disable the sending of From and\n   Referer information.\n\n   The User-Agent (section 14.43) or Server (section 14.38) header\n   fields can sometimes be used to determine that a specific client or\n   server have a particular security hole which might be exploited.\n   Unfortunately, this same information is often used for other valuable\n   purposes for which HTTP currently has no better mechanism.\n\n15.1.3 Encoding Sensitive Information in URI's\n\n   Because the source of a link might be private information or might\n   reveal an otherwise private information source, it is strongly\n   recommended that the user be able to select whether or not the\n   Referer field is sent. For example, a browser client could have a\n   toggle switch for browsing openly/anonymously, which would\n   respectively enable/disable the sending of Referer and From\n   information.\n\n   Clients SHOULD NOT include a Referer header field in a (non-secure)\n   HTTP request if the referring page was transferred with a secure\n   protocol.\n\n   Authors of services which use the HTTP protocol SHOULD NOT use GET\n   based forms for the submission of sensitive data, because this will\n   cause this data to be encoded in the Request-URI. Many existing\n   servers, proxies, and user agents will log the request URI in some\n   place where it might be visible to third parties. Servers can use\n   POST-based form submission instead\n\n15.1.4 Privacy Issues Connected to Accept Headers\n\n   Accept request-headers can reveal information about the user to all\n   servers which are accessed. The Accept-Language header in particular\n   can reveal information the user would consider to be of a private\n   nature, because the understanding of particular languages is often\n\n\n\nFielding, et al.            Standards Track                   [Page 152]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   strongly correlated to the membership of a particular ethnic group.\n   User agents which offer the option to configure the contents of an\n   Accept-Language header to be sent in every request are strongly\n   encouraged to let the configuration process include a message which\n   makes the user aware of the loss of privacy involved.\n\n   An approach that limits the loss of privacy would be for a user agent\n   to omit the sending of Accept-Language headers by default, and to ask\n   the user whether or not to start sending Accept-Language headers to a\n   server if it detects, by looking for any Vary response-header fields\n   generated by the server, that such sending could improve the quality\n   of service.\n\n   Elaborate user-customized accept header fields sent in every request,\n   in particular if these include quality values, can be used by servers\n   as relatively reliable and long-lived user identifiers. Such user\n   identifiers would allow content providers to do click-trail tracking,\n   and would allow collaborating content providers to match cross-server\n   click-trails or form submissions of individual users. Note that for\n   many users not behind a proxy, the network address of the host\n   running the user agent will also serve as a long-lived user\n   identifier. In environments where proxies are used to enhance\n   privacy, user agents ought to be conservative in offering accept\n   header configuration options to end users. As an extreme privacy\n   measure, proxies could filter the accept headers in relayed requests.\n   General purpose user agents which provide a high degree of header\n   configurability SHOULD warn users about the loss of privacy which can\n   be involved.\n\n15.2 Attacks Based On File and Path Names\n\n   Implementations of HTTP origin servers SHOULD be careful to restrict\n   the documents returned by HTTP requests to be only those that were\n   intended by the server administrators. If an HTTP server translates\n   HTTP URIs directly into file system calls, the server MUST take\n   special care not to serve files that were not intended to be\n   delivered to HTTP clients. For example, UNIX, Microsoft Windows, and\n   other operating systems use \"..\" as a path component to indicate a\n   directory level above the current one. On such a system, an HTTP\n   server MUST disallow any such construct in the Request-URI if it\n   would otherwise allow access to a resource outside those intended to\n   be accessible via the HTTP server. Similarly, files intended for\n   reference only internally to the server (such as access control\n   files, configuration files, and script code) MUST be protected from\n   inappropriate retrieval, since they might contain sensitive\n   information. Experience has shown that minor bugs in such HTTP server\n   implementations have turned into security risks.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 153]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.3 DNS Spoofing\n\n   Clients using HTTP rely heavily on the Domain Name Service, and are\n   thus generally prone to security attacks based on the deliberate\n   mis-association of IP addresses and DNS names. Clients need to be\n   cautious in assuming the continuing validity of an IP number/DNS name\n   association.\n\n   In particular, HTTP clients SHOULD rely on their name resolver for\n   confirmation of an IP number/DNS name association, rather than\n   caching the result of previous host name lookups. Many platforms\n   already can cache host name lookups locally when appropriate, and\n   they SHOULD be configured to do so. It is proper for these lookups to\n   be cached, however, only when the TTL (Time To Live) information\n   reported by the name server makes it likely that the cached\n   information will remain useful.\n\n   If HTTP clients cache the results of host name lookups in order to\n   achieve a performance improvement, they MUST observe the TTL\n   information reported by DNS.\n\n   If HTTP clients do not observe this rule, they could be spoofed when\n   a previously-accessed server's IP address changes. As network\n   renumbering is expected to become increasingly common [24], the\n   possibility of this form of attack will grow. Observing this\n   requirement thus reduces this potential security vulnerability.\n\n   This requirement also improves the load-balancing behavior of clients\n   for replicated servers using the same DNS name and reduces the\n   likelihood of a user's experiencing failure in accessing sites which\n   use that strategy.\n\n15.4 Location Headers and Spoofing\n\n   If a single server supports multiple organizations that do not trust\n   one another, then it MUST check the values of Location and Content-\n   Location headers in responses that are generated under control of\n   said organizations to make sure that they do not attempt to\n   invalidate resources over which they have no authority.\n\n15.5 Content-Disposition Issues\n\n   RFC 1806 [35], from which the often implemented Content-Disposition\n   (see section 19.5.1) header in HTTP is derived, has a number of very\n   serious security considerations. Content-Disposition is not part of\n   the HTTP standard, but since it is widely implemented, we are\n   documenting its use and risks for implementors. See RFC 2183 [49]\n   (which updates RFC 1806) for details.\n\n\n\nFielding, et al.            Standards Track                   [Page 154]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.6 Authentication Credentials and Idle Clients\n\n   Existing HTTP clients and user agents typically retain authentication\n   information indefinitely. HTTP/1.1. does not provide a method for a\n   server to direct clients to discard these cached credentials. This is\n   a significant defect that requires further extensions to HTTP.\n   Circumstances under which credential caching can interfere with the\n   application's security model include but are not limited to:\n\n      - Clients which have been idle for an extended period following\n        which the server might wish to cause the client to reprompt the\n        user for credentials.\n\n      - Applications which include a session termination indication\n        (such as a `logout' or `commit' button on a page) after which\n        the server side of the application `knows' that there is no\n        further reason for the client to retain the credentials.\n\n   This is currently under separate study. There are a number of work-\n   arounds to parts of this problem, and we encourage the use of\n   password protection in screen savers, idle time-outs, and other\n   methods which mitigate the security problems inherent in this\n   problem. In particular, user agents which cache credentials are\n   encouraged to provide a readily accessible mechanism for discarding\n   cached credentials under user control.\n\n15.7 Proxies and Caching\n\n   By their very nature, HTTP proxies are men-in-the-middle, and\n   represent an opportunity for man-in-the-middle attacks. Compromise of\n   the systems on which the proxies run can result in serious security\n   and privacy problems. Proxies have access to security-related\n   information, personal information about individual users and\n   organizations, and proprietary information belonging to users and\n   content providers. A compromised proxy, or a proxy implemented or\n   configured without regard to security and privacy considerations,\n   might be used in the commission of a wide range of potential attacks.\n\n   Proxy operators should protect the systems on which proxies run as\n   they would protect any system that contains or transports sensitive\n   information. In particular, log information gathered at proxies often\n   contains highly sensitive personal information, and/or information\n   about organizations. Log information should be carefully guarded, and\n   appropriate guidelines for use developed and followed. (Section\n   15.1.1).\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 155]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Caching proxies provide additional potential vulnerabilities, since\n   the contents of the cache represent an attractive target for\n   malicious exploitation. Because cache contents persist after an HTTP\n   request is complete, an attack on the cache can reveal information\n   long after a user believes that the information has been removed from\n   the network. Therefore, cache contents should be protected as\n   sensitive information.\n\n   Proxy implementors should consider the privacy and security\n   implications of their design and coding decisions, and of the\n   configuration options they provide to proxy operators (especially the\n   default configuration).\n\n   Users of a proxy need to be aware that they are no trustworthier than\n   the people who run the proxy; HTTP itself cannot solve this problem.\n\n   The judicious use of cryptography, when appropriate, may suffice to\n   protect against a broad range of security and privacy attacks. Such\n   cryptography is beyond the scope of the HTTP/1.1 specification.\n\n15.7.1 Denial of Service Attacks on Proxies\n\n   They exist. They are hard to defend against. Research continues.\n   Beware.\n\n16 Acknowledgments\n\n   This specification makes heavy use of the augmented BNF and generic\n   constructs defined by David H. Crocker for RFC 822 [9]. Similarly, it\n   reuses many of the definitions provided by Nathaniel Borenstein and\n   Ned Freed for MIME [7]. We hope that their inclusion in this\n   specification will help reduce past confusion over the relationship\n   between HTTP and Internet mail message formats.\n\n   The HTTP protocol has evolved considerably over the years. It has\n   benefited from a large and active developer community--the many\n   people who have participated on the www-talk mailing list--and it is\n   that community which has been most responsible for the success of\n   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert\n   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois\n   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob\n   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc\n   VanHeyningen deserve special recognition for their efforts in\n   defining early aspects of the protocol.\n\n   This document has benefited greatly from the comments of all those\n   participating in the HTTP-WG. In addition to those already mentioned,\n   the following individuals have contributed to this specification:\n\n\n\nFielding, et al.            Standards Track                   [Page 156]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       Gary Adams                  Ross Patterson\n       Harald Tveit Alvestrand     Albert Lunde\n       Keith Ball                  John C. Mallery\n       Brian Behlendorf            Jean-Philippe Martin-Flatin\n       Paul Burchard               Mitra\n       Maurizio Codogno            David Morris\n       Mike Cowlishaw              Gavin Nicol\n       Roman Czyborra              Bill Perry\n       Michael A. Dolan            Jeffrey Perry\n       David J. Fiander            Scott Powers\n       Alan Freier                 Owen Rees\n       Marc Hedlund                Luigi Rizzo\n       Greg Herlihy                David Robinson\n       Koen Holtman                Marc Salomon\n       Alex Hopmann                Rich Salz\n       Bob Jernigan                Allan M. Schiffman\n       Shel Kaphan                 Jim Seidman\n       Rohit Khare                 Chuck Shotton\n       John Klensin                Eric W. Sink\n       Martijn Koster              Simon E. Spero\n       Alexei Kosut                Richard N. Taylor\n       David M. Kristol            Robert S. Thau\n       Daniel LaLiberte            Bill (BearHeart) Weinman\n       Ben Laurie                  Francois Yergeau\n       Paul J. Leach               Mary Ellen Zurko\n       Daniel DuBois               Josh Cohen\n\n\n   Much of the content and presentation of the caching design is due to\n   suggestions and comments from individuals including: Shel Kaphan,\n   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.\n\n   Most of the specification of ranges is based on work originally done\n   by Ari Luotonen and John Franks, with additional input from Steve\n   Zilles.\n\n   Thanks to the \"cave men\" of Palo Alto. You know who you are.\n\n   Jim Gettys (the current editor of this document) wishes particularly\n   to thank Roy Fielding, the previous editor of this document, along\n   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen\n   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and\n   Larry Masinter for their help. And thanks go particularly to Jeff\n   Mogul and Scott Lawrence for performing the \"MUST/MAY/SHOULD\" audit.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 157]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik\n   Frystyk implemented RFC 2068 early, and we wish to thank them for the\n   discovery of many of the problems that this document attempts to\n   rectify.\n\n17 References\n\n   [1] Alvestrand, H., \"Tags for the Identification of Languages\", RFC\n       1766, March 1995.\n\n   [2] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,\n       D. and B. Alberti, \"The Internet Gopher Protocol (a distributed\n       document search and retrieval protocol)\", RFC 1436, March 1993.\n\n   [3] Berners-Lee, T., \"Universal Resource Identifiers in WWW\", RFC\n       1630, June 1994.\n\n   [4] Berners-Lee, T., Masinter, L. and M. McCahill, \"Uniform Resource\n       Locators (URL)\", RFC 1738, December 1994.\n\n   [5] Berners-Lee, T. and D. Connolly, \"Hypertext Markup Language -\n       2.0\", RFC 1866, November 1995.\n\n   [6] Berners-Lee, T., Fielding, R. and H. Frystyk, \"Hypertext Transfer\n       Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n\n   [7] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n       Extensions (MIME) Part One: Format of Internet Message Bodies\",\n       RFC 2045, November 1996.\n\n   [8] Braden, R., \"Requirements for Internet Hosts -- Communication\n       Layers\", STD 3, RFC 1123, October 1989.\n\n   [9] Crocker, D., \"Standard for The Format of ARPA Internet Text\n       Messages\", STD 11, RFC 822, August 1982.\n\n   [10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,\n        Sui, J., and M. Grinbaum, \"WAIS Interface Protocol Prototype\n        Functional Specification,\" (v1.5), Thinking Machines\n        Corporation, April 1990.\n\n   [11] Fielding, R., \"Relative Uniform Resource Locators\", RFC 1808,\n        June 1995.\n\n   [12] Horton, M. and R. Adams, \"Standard for Interchange of USENET\n        Messages\", RFC 1036, December 1987.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 158]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [13] Kantor, B. and P. Lapsley, \"Network News Transfer Protocol\", RFC\n        977, February 1986.\n\n   [14] Moore, K., \"MIME (Multipurpose Internet Mail Extensions) Part\n        Three: Message Header Extensions for Non-ASCII Text\", RFC 2047,\n        November 1996.\n\n   [15] Nebel, E. and L. Masinter, \"Form-based File Upload in HTML\", RFC\n        1867, November 1995.\n\n   [16] Postel, J., \"Simple Mail Transfer Protocol\", STD 10, RFC 821,\n        August 1982.\n\n   [17] Postel, J., \"Media Type Registration Procedure\", RFC 1590,\n        November 1996.\n\n   [18] Postel, J. and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC\n        959, October 1985.\n\n   [19] Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700,\n        October 1994.\n\n   [20] Sollins, K. and L. Masinter, \"Functional Requirements for\n        Uniform Resource Names\", RFC 1737, December 1994.\n\n   [21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for\n        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.\n\n   [22] ISO-8859. International Standard -- Information Processing --\n        8-bit Single-Byte Coded Graphic Character Sets --\n        Part 1: Latin alphabet No. 1, ISO-8859-1:1987.\n        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.\n        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.\n        Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.\n        Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.\n        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.\n        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.\n        Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.\n        Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.\n\n   [23] Meyers, J. and M. Rose, \"The Content-MD5 Header Field\", RFC\n        1864, October 1995.\n\n   [24] Carpenter, B. and Y. Rekhter, \"Renumbering Needs Work\", RFC\n        1900, February 1996.\n\n   [25] Deutsch, P., \"GZIP file format specification version 4.3\", RFC\n        1952, May 1996.\n\n\n\nFielding, et al.            Standards Track                   [Page 159]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [26] Venkata N. Padmanabhan, and Jeffrey C. Mogul. \"Improving HTTP\n        Latency\", Computer Networks and ISDN Systems, v. 28, pp. 25-35,\n        Dec. 1995. Slightly revised version of paper in Proc. 2nd\n        International WWW Conference '94: Mosaic and the Web, Oct. 1994,\n        which is available at\n        http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat\n        ency.html.\n\n   [27] Joe Touch, John Heidemann, and Katia Obraczka. \"Analysis of HTTP\n        Performance\", <URL: http://www.isi.edu/touch/pubs/http-perf96/>,\n        ISI Research Report ISI/RR-98-463, (original report dated Aug.\n        1996), USC/Information Sciences Institute, August 1998.\n\n   [28] Mills, D., \"Network Time Protocol (Version 3) Specification,\n        Implementation and Analysis\", RFC 1305, March 1992.\n\n   [29] Deutsch, P., \"DEFLATE Compressed Data Format Specification\n        version 1.3\", RFC 1951, May 1996.\n\n   [30] S. Spero, \"Analysis of HTTP Performance Problems,\"\n        http://sunsite.unc.edu/mdma-release/http-prob.html.\n\n   [31] Deutsch, P. and J. Gailly, \"ZLIB Compressed Data Format\n        Specification version 3.3\", RFC 1950, May 1996.\n\n   [32] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,\n        Luotonen, A., Sink, E. and L. Stewart, \"An Extension to HTTP:\n        Digest Access Authentication\", RFC 2069, January 1997.\n\n   [33] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T.\n        Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC\n        2068, January 1997.\n\n   [34] Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n\n   [35] Troost, R. and Dorner, S., \"Communicating Presentation\n        Information in Internet Messages: The Content-Disposition\n        Header\", RFC 1806, June 1995.\n\n   [36] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, \"Use and\n        Interpretation of HTTP Version Numbers\", RFC 2145, May 1997.\n        [jg639]\n\n   [37] Palme, J., \"Common Internet Message Headers\", RFC 2076, February\n        1997. [jg640]\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 160]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [38] Yergeau, F., \"UTF-8, a transformation format of Unicode and\n        ISO-10646\", RFC 2279, January 1998. [jg641]\n\n   [39] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E.,\n        Lie, H., and C. Lilley. \"Network Performance Effects of\n        HTTP/1.1, CSS1, and PNG,\" Proceedings of ACM SIGCOMM '97, Cannes\n        France, September 1997.[jg642]\n\n   [40] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Two: Media Types\", RFC 2046, November\n        1996. [jg643]\n\n   [41] Alvestrand, H., \"IETF Policy on Character Sets and Languages\",\n        BCP 18, RFC 2277, January 1998. [jg644]\n\n   [42] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource\n        Identifiers (URI): Generic Syntax and Semantics\", RFC 2396,\n        August 1998. [jg645]\n\n   [43] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n        Leach, P., Luotonen, A., Sink, E. and L. Stewart, \"HTTP\n        Authentication: Basic and Digest Access Authentication\", RFC\n        2617, June 1999. [jg646]\n\n   [44] Luotonen, A., \"Tunneling TCP based protocols through Web proxy\n        servers,\" Work in Progress. [jg647]\n\n   [45] Palme, J. and A. Hopmann, \"MIME E-mail Encapsulation of\n        Aggregate Documents, such as HTML (MHTML)\", RFC 2110, March\n        1997.\n\n   [46] Bradner, S., \"The Internet Standards Process -- Revision 3\", BCP\n        9, RFC 2026, October 1996.\n\n   [47] Masinter, L., \"Hyper Text Coffee Pot Control Protocol\n        (HTCPCP/1.0)\", RFC 2324, 1 April 1998.\n\n   [48] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Five: Conformance Criteria and Examples\",\n        RFC 2049, November 1996.\n\n   [49] Troost, R., Dorner, S. and K. Moore, \"Communicating Presentation\n        Information in Internet Messages: The Content-Disposition Header\n        Field\", RFC 2183, August 1997.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 161]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n18 Authors' Addresses\n\n   Roy T. Fielding\n   Information and Computer Science\n   University of California, Irvine\n   Irvine, CA 92697-3425, USA\n\n   Fax: +1 (949) 824-1715\n   EMail: fielding@ics.uci.edu\n\n\n   James Gettys\n   World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: jg@w3.org\n\n\n   Jeffrey C. Mogul\n   Western Research Laboratory\n   Compaq Computer Corporation\n   250 University Avenue\n   Palo Alto, California, 94305, USA\n\n   EMail: mogul@wrl.dec.com\n\n\n   Henrik Frystyk Nielsen\n   World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: frystyk@w3.org\n\n\n   Larry Masinter\n   Xerox Corporation\n   3333 Coyote Hill Road\n   Palo Alto, CA 94034, USA\n\n   EMail: masinter@parc.xerox.com\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 162]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Paul J. Leach\n   Microsoft Corporation\n   1 Microsoft Way\n   Redmond, WA 98052, USA\n\n   EMail: paulle@microsoft.com\n\n\n   Tim Berners-Lee\n   Director, World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: timbl@w3.org\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 163]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n19 Appendices\n\n19.1 Internet Media Type message/http and application/http\n\n   In addition to defining the HTTP/1.1 protocol, this document serves\n   as the specification for the Internet media type \"message/http\" and\n   \"application/http\". The message/http type can be used to enclose a\n   single HTTP request or response message, provided that it obeys the\n   MIME restrictions for all \"message\" types regarding line length and\n   encodings. The application/http type can be used to enclose a\n   pipeline of one or more HTTP request or response messages (not\n   intermixed). The following is to be registered with IANA [17].\n\n       Media Type name:         message\n       Media subtype name:      http\n       Required parameters:     none\n       Optional parameters:     version, msgtype\n        version: The HTTP-Version number of the enclosed message\n                 (e.g., \"1.1\"). If not present, the version can be\n                 determined from the first line of the body.\n        msgtype: The message type -- \"request\" or \"response\". If not\n                 present, the type can be determined from the first\n                 line of the body.\n       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                                permitted\n       Security considerations: none\n\n       Media Type name:         application\n       Media subtype name:      http\n       Required parameters:     none\n       Optional parameters:     version, msgtype\n        version: The HTTP-Version number of the enclosed messages\n                 (e.g., \"1.1\"). If not present, the version can be\n                 determined from the first line of the body.\n        msgtype: The message type -- \"request\" or \"response\". If not\n                 present, the type can be determined from the first\n                 line of the body.\n       Encoding considerations: HTTP messages enclosed by this type\n                 are in \"binary\" format; use of an appropriate\n                 Content-Transfer-Encoding is required when\n                 transmitted via E-mail.\n       Security considerations: none\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 164]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n19.2 Internet Media Type multipart/byteranges\n\n   When an HTTP 206 (Partial Content) response message includes the\n   content of multiple ranges (a response to a request for multiple\n   non-overlapping ranges), these are transmitted as a multipart\n   message-body. The media type for this purpose is called\n   \"multipart/byteranges\".\n\n   The multipart/byteranges media type includes two or more parts, each\n   with its own Content-Type and Content-Range fields. The required\n   boundary parameter specifies the boundary string used to separate\n   each body-part.\n\n       Media Type name:         multipart\n       Media subtype name:      byteranges\n       Required parameters:     boundary\n       Optional parameters:     none\n       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                                permitted\n       Security considerations: none\n\n\n   For example:\n\n   HTTP/1.1 206 Partial Content\n   Date: Wed, 15 Nov 1995 06:25:24 GMT\n   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n\n   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n   Content-range: bytes 500-999/8000\n\n   ...the first range...\n   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n   Content-range: bytes 7000-7999/8000\n\n   ...the second range\n   --THIS_STRING_SEPARATES--\n\n      Notes:\n\n      1) Additional CRLFs may precede the first boundary string in the\n         entity.\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 165]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      2) Although RFC 2046 [40] permits the boundary string to be\n         quoted, some existing implementations handle a quoted boundary\n         string incorrectly.\n\n      3) A number of browsers and servers were coded to an early draft\n         of the byteranges specification to use a media type of\n         multipart/x-byteranges, which is almost, but not quite\n         compatible with the version documented in HTTP/1.1.\n\n19.3 Tolerant Applications\n\n   Although this document specifies the requirements for the generation\n   of HTTP/1.1 messages, not all applications will be correct in their\n   implementation. We therefore recommend that operational applications\n   be tolerant of deviations whenever those deviations can be\n   interpreted unambiguously.\n\n   Clients SHOULD be tolerant in parsing the Status-Line and servers\n   tolerant when parsing the Request-Line. In particular, they SHOULD\n   accept any amount of SP or HT characters between fields, even though\n   only a single SP is required.\n\n   The line terminator for message-header fields is the sequence CRLF.\n   However, we recommend that applications, when parsing such headers,\n   recognize a single LF as a line terminator and ignore the leading CR.\n\n   The character set of an entity-body SHOULD be labeled as the lowest\n   common denominator of the character codes used within that body, with\n   the exception that not labeling the entity is preferred over labeling\n   the entity with the labels US-ASCII or ISO-8859-1. See section 3.7.1\n   and 3.4.1.\n\n   Additional rules for requirements on parsing and encoding of dates\n   and other potential problems with date encodings include:\n\n      - HTTP/1.1 clients and caches SHOULD assume that an RFC-850 date\n        which appears to be more than 50 years in the future is in fact\n        in the past (this helps solve the \"year 2000\" problem).\n\n      - An HTTP/1.1 implementation MAY internally represent a parsed\n        Expires date as earlier than the proper value, but MUST NOT\n        internally represent a parsed Expires date as later than the\n        proper value.\n\n      - All expiration-related calculations MUST be done in GMT. The\n        local time zone MUST NOT influence the calculation or comparison\n        of an age or expiration time.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 166]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If an HTTP header incorrectly carries a date value with a time\n        zone other than GMT, it MUST be converted into GMT using the\n        most conservative possible conversion.\n\n19.4 Differences Between HTTP Entities and RFC 2045 Entities\n\n   HTTP/1.1 uses many of the constructs defined for Internet Mail (RFC\n   822 [9]) and the Multipurpose Internet Mail Extensions (MIME [7]) to\n   allow entities to be transmitted in an open variety of\n   representations and with extensible mechanisms. However, RFC 2045\n   discusses mail, and HTTP has a few features that are different from\n   those described in RFC 2045. These differences were carefully chosen\n   to optimize performance over binary connections, to allow greater\n   freedom in the use of new media types, to make date comparisons\n   easier, and to acknowledge the practice of some early HTTP servers\n   and clients.\n\n   This appendix describes specific areas where HTTP differs from RFC\n   2045. Proxies and gateways to strict MIME environments SHOULD be\n   aware of these differences and provide the appropriate conversions\n   where necessary. Proxies and gateways from MIME environments to HTTP\n   also need to be aware of the differences because some conversions\n   might be required.\n\n19.4.1 MIME-Version\n\n   HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY\n   include a single MIME-Version general-header field to indicate what\n   version of the MIME protocol was used to construct the message. Use\n   of the MIME-Version header field indicates that the message is in\n   full compliance with the MIME protocol (as defined in RFC 2045[7]).\n   Proxies/gateways are responsible for ensuring full compliance (where\n   possible) when exporting HTTP messages to strict MIME environments.\n\n       MIME-Version   = \"MIME-Version\" \":\" 1*DIGIT \".\" 1*DIGIT\n\n   MIME version \"1.0\" is the default for use in HTTP/1.1. However,\n   HTTP/1.1 message parsing and semantics are defined by this document\n   and not the MIME specification.\n\n19.4.2 Conversion to Canonical Form\n\n   RFC 2045 [7] requires that an Internet mail entity be converted to\n   canonical form prior to being transferred, as described in section 4\n   of RFC 2049 [48]. Section 3.7.1 of this document describes the forms\n   allowed for subtypes of the \"text\" media type when transmitted over\n   HTTP. RFC 2046 requires that content with a type of \"text\" represent\n   line breaks as CRLF and forbids the use of CR or LF outside of line\n\n\n\nFielding, et al.            Standards Track                   [Page 167]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a\n   line break within text content when a message is transmitted over\n   HTTP.\n\n   Where it is possible, a proxy or gateway from HTTP to a strict MIME\n   environment SHOULD translate all line breaks within the text media\n   types described in section 3.7.1 of this document to the RFC 2049\n   canonical form of CRLF. Note, however, that this might be complicated\n   by the presence of a Content-Encoding and by the fact that HTTP\n   allows the use of some character sets which do not use octets 13 and\n   10 to represent CR and LF, as is the case for some multi-byte\n   character sets.\n\n   Implementors should note that conversion will break any cryptographic\n   checksums applied to the original content unless the original content\n   is already in canonical form. Therefore, the canonical form is\n   recommended for any content that uses such checksums in HTTP.\n\n19.4.3 Conversion of Date Formats\n\n   HTTP/1.1 uses a restricted set of date formats (section 3.3.1) to\n   simplify the process of date comparison. Proxies and gateways from\n   other protocols SHOULD ensure that any Date header field present in a\n   message conforms to one of the HTTP/1.1 formats and rewrite the date\n   if necessary.\n\n19.4.4 Introduction of Content-Encoding\n\n   RFC 2045 does not include any concept equivalent to HTTP/1.1's\n   Content-Encoding header field. Since this acts as a modifier on the\n   media type, proxies and gateways from HTTP to MIME-compliant\n   protocols MUST either change the value of the Content-Type header\n   field or decode the entity-body before forwarding the message. (Some\n   experimental applications of Content-Type for Internet mail have used\n   a media-type parameter of \";conversions=<content-coding>\" to perform\n   a function equivalent to Content-Encoding. However, this parameter is\n   not part of RFC 2045.)\n\n19.4.5 No Content-Transfer-Encoding\n\n   HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC\n   2045. Proxies and gateways from MIME-compliant protocols to HTTP MUST\n   remove any non-identity CTE (\"quoted-printable\" or \"base64\") encoding\n   prior to delivering the response message to an HTTP client.\n\n   Proxies and gateways from HTTP to MIME-compliant protocols are\n   responsible for ensuring that the message is in the correct format\n   and encoding for safe transport on that protocol, where \"safe\n\n\n\nFielding, et al.            Standards Track                   [Page 168]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   transport\" is defined by the limitations of the protocol being used.\n   Such a proxy or gateway SHOULD label the data with an appropriate\n   Content-Transfer-Encoding if doing so will improve the likelihood of\n   safe transport over the destination protocol.\n\n19.4.6 Introduction of Transfer-Encoding\n\n   HTTP/1.1 introduces the Transfer-Encoding header field (section\n   14.41). Proxies/gateways MUST remove any transfer-coding prior to\n   forwarding a message via a MIME-compliant protocol.\n\n   A process for decoding the \"chunked\" transfer-coding (section 3.6)\n   can be represented in pseudo-code as:\n\n       length := 0\n       read chunk-size, chunk-extension (if any) and CRLF\n       while (chunk-size > 0) {\n          read chunk-data and CRLF\n          append chunk-data to entity-body\n          length := length + chunk-size\n          read chunk-size and CRLF\n       }\n       read entity-header\n       while (entity-header not empty) {\n          append entity-header to existing header fields\n          read entity-header\n       }\n       Content-Length := length\n       Remove \"chunked\" from Transfer-Encoding\n\n19.4.7 MHTML and Line Length Limitations\n\n   HTTP implementations which share code with MHTML [45] implementations\n   need to be aware of MIME line length limitations. Since HTTP does not\n   have this limitation, HTTP does not fold long lines. MHTML messages\n   being transported by HTTP follow all conventions of MHTML, including\n   line length limitations and folding, canonicalization, etc., since\n   HTTP transports all message-bodies as payload (see section 3.7.2) and\n   does not interpret the content or any MIME header lines that might be\n   contained therein.\n\n19.5 Additional Features\n\n   RFC 1945 and RFC 2068 document protocol elements used by some\n   existing HTTP implementations, but not consistently and correctly\n   across most HTTP/1.1 applications. Implementors are advised to be\n   aware of these features, but cannot rely upon their presence in, or\n   interoperability with, other HTTP/1.1 applications. Some of these\n\n\n\nFielding, et al.            Standards Track                   [Page 169]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   describe proposed experimental features, and some describe features\n   that experimental deployment found lacking that are now addressed in\n   the base HTTP/1.1 specification.\n\n   A number of other headers, such as Content-Disposition and Title,\n   from SMTP and MIME are also often implemented (see RFC 2076 [37]).\n\n19.5.1 Content-Disposition\n\n   The Content-Disposition response-header field has been proposed as a\n   means for the origin server to suggest a default filename if the user\n   requests that the content is saved to a file. This usage is derived\n   from the definition of Content-Disposition in RFC 1806 [35].\n\n        content-disposition = \"Content-Disposition\" \":\"\n                              disposition-type *( \";\" disposition-parm )\n        disposition-type = \"attachment\" | disp-extension-token\n        disposition-parm = filename-parm | disp-extension-parm\n        filename-parm = \"filename\" \"=\" quoted-string\n        disp-extension-token = token\n        disp-extension-parm = token \"=\" ( token | quoted-string )\n\n   An example is\n\n        Content-Disposition: attachment; filename=\"fname.ext\"\n\n   The receiving user agent SHOULD NOT respect any directory path\n   information present in the filename-parm parameter, which is the only\n   parameter believed to apply to HTTP implementations at this time. The\n   filename SHOULD be treated as a terminal component only.\n\n   If this header is used in a response with the application/octet-\n   stream content-type, the implied suggestion is that the user agent\n   should not display the response, but directly enter a `save response\n   as...' dialog.\n\n   See section 15.5 for Content-Disposition security issues.\n\n19.6 Compatibility with Previous Versions\n\n   It is beyond the scope of a protocol specification to mandate\n   compliance with previous versions. HTTP/1.1 was deliberately\n   designed, however, to make supporting previous versions easy. It is\n   worth noting that, at the time of composing this specification\n   (1996), we would expect commercial HTTP/1.1 servers to:\n\n      - recognize the format of the Request-Line for HTTP/0.9, 1.0, and\n        1.1 requests;\n\n\n\nFielding, et al.            Standards Track                   [Page 170]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - understand any valid request in the format of HTTP/0.9, 1.0, or\n        1.1;\n\n      - respond appropriately with a message in the same major version\n        used by the client.\n\n   And we would expect HTTP/1.1 clients to:\n\n      - recognize the format of the Status-Line for HTTP/1.0 and 1.1\n        responses;\n\n      - understand any valid response in the format of HTTP/0.9, 1.0, or\n        1.1.\n\n   For most implementations of HTTP/1.0, each connection is established\n   by the client prior to the request and closed by the server after\n   sending the response. Some implementations implement the Keep-Alive\n   version of persistent connections described in section 19.7.1 of RFC\n   2068 [33].\n\n19.6.1 Changes from HTTP/1.0\n\n   This section summarizes major differences between versions HTTP/1.0\n   and HTTP/1.1.\n\n19.6.1.1 Changes to Simplify Multi-homed Web Servers and Conserve IP\n         Addresses\n\n   The requirements that clients and servers support the Host request-\n   header, report an error if the Host request-header (section 14.23) is\n   missing from an HTTP/1.1 request, and accept absolute URIs (section\n   5.1.2) are among the most important changes defined by this\n   specification.\n\n   Older HTTP/1.0 clients assumed a one-to-one relationship of IP\n   addresses and servers; there was no other established mechanism for\n   distinguishing the intended server of a request than the IP address\n   to which that request was directed. The changes outlined above will\n   allow the Internet, once older HTTP clients are no longer common, to\n   support multiple Web sites from a single IP address, greatly\n   simplifying large operational Web servers, where allocation of many\n   IP addresses to a single host has created serious problems. The\n   Internet will also be able to recover the IP addresses that have been\n   allocated for the sole purpose of allowing special-purpose domain\n   names to be used in root-level HTTP URLs. Given the rate of growth of\n   the Web, and the number of servers already deployed, it is extremely\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 171]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   important that all implementations of HTTP (including updates to\n   existing HTTP/1.0 applications) correctly implement these\n   requirements:\n\n      - Both clients and servers MUST support the Host request-header.\n\n      - A client that sends an HTTP/1.1 request MUST send a Host header.\n\n      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1\n        request does not include a Host request-header.\n\n      - Servers MUST accept absolute URIs.\n\n19.6.2 Compatibility with HTTP/1.0 Persistent Connections\n\n   Some clients and servers might wish to be compatible with some\n   previous implementations of persistent connections in HTTP/1.0\n   clients and servers. Persistent connections in HTTP/1.0 are\n   explicitly negotiated as they are not the default behavior. HTTP/1.0\n   experimental implementations of persistent connections are faulty,\n   and the new facilities in HTTP/1.1 are designed to rectify these\n   problems. The problem was that some existing 1.0 clients may be\n   sending Keep-Alive to a proxy server that doesn't understand\n   Connection, which would then erroneously forward it to the next\n   inbound server, which would establish the Keep-Alive connection and\n   result in a hung HTTP/1.0 proxy waiting for the close on the\n   response. The result is that HTTP/1.0 clients must be prevented from\n   using Keep-Alive when talking to proxies.\n\n   However, talking to proxies is the most important use of persistent\n   connections, so that prohibition is clearly unacceptable. Therefore,\n   we need some other mechanism for indicating a persistent connection\n   is desired, which is safe to use even when talking to an old proxy\n   that ignores Connection. Persistent connections are the default for\n   HTTP/1.1 messages; we introduce a new keyword (Connection: close) for\n   declaring non-persistence. See section 14.10.\n\n   The original HTTP/1.0 form of persistent connections (the Connection:\n   Keep-Alive and Keep-Alive header) is documented in RFC 2068. [33]\n\n19.6.3 Changes from RFC 2068\n\n   This specification has been carefully audited to correct and\n   disambiguate key word usage; RFC 2068 had many problems in respect to\n   the conventions laid out in RFC 2119 [34].\n\n   Clarified which error code should be used for inbound server failures\n   (e.g. DNS failures). (Section 10.5.5).\n\n\n\nFielding, et al.            Standards Track                   [Page 172]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   CREATE had a race that required an Etag be sent when a resource is\n   first created. (Section 10.2.2).\n\n   Content-Base was deleted from the specification: it was not\n   implemented widely, and there is no simple, safe way to introduce it\n   without a robust extension mechanism. In addition, it is used in a\n   similar, but not identical fashion in MHTML [45].\n\n   Transfer-coding and message lengths all interact in ways that\n   required fixing exactly when chunked encoding is used (to allow for\n   transfer encoding that may not be self delimiting); it was important\n   to straighten out exactly how message lengths are computed. (Sections\n   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)\n\n   A content-coding of \"identity\" was introduced, to solve problems\n   discovered in caching. (section 3.5)\n\n   Quality Values of zero should indicate that \"I don't want something\"\n   to allow clients to refuse a representation. (Section 3.9)\n\n   The use and interpretation of HTTP version numbers has been clarified\n   by RFC 2145. Require proxies to upgrade requests to highest protocol\n   version they support to deal with problems discovered in HTTP/1.0\n   implementations (Section 3.1)\n\n   Charset wildcarding is introduced to avoid explosion of character set\n   names in accept headers. (Section 14.2)\n\n   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage\n   was introduced to add this missing case. (Sections 13.4, 14.8, 14.9,\n   14.9.3)\n\n   The Cache-Control: max-age directive was not properly defined for\n   responses. (Section 14.9.3)\n\n   There are situations where a server (especially a proxy) does not\n   know the full length of a response but is capable of serving a\n   byterange request. We therefore need a mechanism to allow byteranges\n   with a content-range not indicating the full length of the message.\n   (Section 14.16)\n\n   Range request responses would become very verbose if all meta-data\n   were always returned; by allowing the server to only send needed\n   headers in a 206 response, this problem can be avoided. (Section\n   10.2.7, 13.5.3, and 14.27)\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 173]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Fix problem with unsatisfiable range requests; there are two cases:\n   syntactic problems, and range doesn't exist in the document. The 416\n   status code was needed to resolve this ambiguity needed to indicate\n   an error for a byte range request that falls outside of the actual\n   contents of a document. (Section 10.4.17, 14.16)\n\n   Rewrite of message transmission requirements to make it much harder\n   for implementors to get it wrong, as the consequences of errors here\n   can have significant impact on the Internet, and to deal with the\n   following problems:\n\n      1. Changing \"HTTP/1.1 or later\" to \"HTTP/1.1\", in contexts where\n         this was incorrectly placing a requirement on the behavior of\n         an implementation of a future version of HTTP/1.x\n\n      2. Made it clear that user-agents should retry requests, not\n         \"clients\" in general.\n\n      3. Converted requirements for clients to ignore unexpected 100\n         (Continue) responses, and for proxies to forward 100 responses,\n         into a general requirement for 1xx responses.\n\n      4. Modified some TCP-specific language, to make it clearer that\n         non-TCP transports are possible for HTTP.\n\n      5. Require that the origin server MUST NOT wait for the request\n         body before it sends a required 100 (Continue) response.\n\n      6. Allow, rather than require, a server to omit 100 (Continue) if\n         it has already seen some of the request body.\n\n      7. Allow servers to defend against denial-of-service attacks and\n         broken clients.\n\n   This change adds the Expect header and 417 status code. The message\n   transmission requirements fixes are in sections 8.2, 10.4.18,\n   8.1.2.2, 13.11, and 14.20.\n\n   Proxies should be able to add Content-Length when appropriate.\n   (Section 13.5.2)\n\n   Clean up confusion between 403 and 404 responses. (Section 10.4.4,\n   10.4.5, and 10.4.11)\n\n   Warnings could be cached incorrectly, or not updated appropriately.\n   (Section 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning\n   also needed to be a general header, as PUT or other methods may have\n   need for it in requests.\n\n\n\nFielding, et al.            Standards Track                   [Page 174]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Transfer-coding had significant problems, particularly with\n   interactions with chunked encoding. The solution is that transfer-\n   codings become as full fledged as content-codings. This involves\n   adding an IANA registry for transfer-codings (separate from content\n   codings), a new header field (TE) and enabling trailer headers in the\n   future. Transfer encoding is a major performance benefit, so it was\n   worth fixing [39]. TE also solves another, obscure, downward\n   interoperability problem that could have occurred due to interactions\n   between authentication trailers, chunked encoding and HTTP/1.0\n   clients.(Section 3.6, 3.6.1, and 14.39)\n\n   The PATCH, LINK, UNLINK methods were defined but not commonly\n   implemented in previous versions of this specification. See RFC 2068\n   [33].\n\n   The Alternates, Content-Version, Derived-From, Link, URI, Public and\n   Content-Base header fields were defined in previous versions of this\n   specification, but not commonly implemented. See RFC 2068 [33].\n\n20 Index\n\n   Please see the PostScript version of this RFC for the INDEX.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 175]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n21.  Full Copyright Statement\n\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n\n   This document and translations of it may be copied and furnished to\n   others, and derivative works that comment on or otherwise explain it\n   or assist in its implementation may be prepared, copied, published\n   and distributed, in whole or in part, without restriction of any\n   kind, provided that the above copyright notice and this paragraph are\n   included on all such copies and derivative works.  However, this\n   document itself may not be modified in any way, such as by removing\n   the copyright notice or references to the Internet Society or other\n   Internet organizations, except as needed for the purpose of\n   developing Internet standards in which case the procedures for\n   copyrights defined in the Internet Standards process must be\n   followed, or as required to translate it into languages other than\n   English.\n\n   The limited permissions granted above are perpetual and will not be\n   revoked by the Internet Society or its successors or assigns.\n\n   This document and the information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\nAcknowledgement\n\n   Funding for the RFC Editor function is currently provided by the\n   Internet Society.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 176]\n\f\n\n\n==================== RFC - JSON ====================\n\n\n\n\n\n\n\nInternet Engineering Task Force (IETF)                      T. Bray, Ed.\nRequest for Comments: 8259                                    Textuality\nObsoletes: 7159                                            December 2017\nCategory: Standards Track\nISSN: 2070-1721\n\n\n     The JavaScript Object Notation (JSON) Data Interchange Format\n\nAbstract\n\n   JavaScript Object Notation (JSON) is a lightweight, text-based,\n   language-independent data interchange format.  It was derived from\n   the ECMAScript Programming Language Standard.  JSON defines a small\n   set of formatting rules for the portable representation of structured\n   data.\n\n   This document removes inconsistencies with other specifications of\n   JSON, repairs specification errors, and offers experience-based\n   interoperability guidance.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8259.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 1]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nCopyright Notice\n\n   Copyright (c) 2017 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(s) controlling the copyright in some of this\n   material may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 2]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nTable of Contents\n\n   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n     1.1.  Conventions Used in This Document . . . . . . . . . . . .   4\n     1.2.  Specifications of JSON  . . . . . . . . . . . . . . . . .   4\n     1.3.  Introduction to This Revision . . . . . . . . . . . . . .   5\n   2.  JSON Grammar  . . . . . . . . . . . . . . . . . . . . . . . .   5\n   3.  Values  . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n   4.  Objects . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n   5.  Arrays  . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n   6.  Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n   7.  Strings . . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n   8.  String and Character Issues . . . . . . . . . . . . . . . . .   9\n     8.1.  Character Encoding  . . . . . . . . . . . . . . . . . . .   9\n     8.2.  Unicode Characters  . . . . . . . . . . . . . . . . . . .  10\n     8.3.  String Comparison . . . . . . . . . . . . . . . . . . . .  10\n   9.  Parsers . . . . . . . . . . . . . . . . . . . . . . . . . . .  10\n   10. Generators  . . . . . . . . . . . . . . . . . . . . . . . . .  10\n   11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  11\n   12. Security Considerations . . . . . . . . . . . . . . . . . . .  12\n   13. Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  12\n   14. References  . . . . . . . . . . . . . . . . . . . . . . . . .  14\n     14.1.  Normative References . . . . . . . . . . . . . . . . . .  14\n     14.2.  Informative References . . . . . . . . . . . . . . . . .  14\n   Appendix A.  Changes from RFC 7159  . . . . . . . . . . . . . . .  16\n   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  16\n   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  16\n\n1.  Introduction\n\n   JavaScript Object Notation (JSON) is a text format for the\n   serialization of structured data.  It is derived from the object\n   literals of JavaScript, as defined in the ECMAScript Programming\n   Language Standard, Third Edition [ECMA-262].\n\n   JSON can represent four primitive types (strings, numbers, booleans,\n   and null) and two structured types (objects and arrays).\n\n   A string is a sequence of zero or more Unicode characters [UNICODE].\n   Note that this citation references the latest version of Unicode\n   rather than a specific release.  It is not expected that future\n   changes in the Unicode specification will impact the syntax of JSON.\n\n   An object is an unordered collection of zero or more name/value\n   pairs, where a name is a string and a value is a string, number,\n   boolean, null, object, or array.\n\n   An array is an ordered sequence of zero or more values.\n\n\n\nBray                         Standards Track                    [Page 3]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   The terms \"object\" and \"array\" come from the conventions of\n   JavaScript.\n\n   JSON's design goals were for it to be minimal, portable, textual, and\n   a subset of JavaScript.\n\n1.1.  Conventions Used in This Document\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described in BCP\n   14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals, as shown here.\n\n   The grammatical rules in this document are to be interpreted as\n   described in [RFC5234].\n\n1.2.  Specifications of JSON\n\n   This document replaces [RFC7159].  [RFC7159] obsoleted [RFC4627],\n   which originally described JSON and registered the media type\n   \"application/json\".\n\n   JSON is also described in [ECMA-404].\n\n   The reference to ECMA-404 in the previous sentence is normative, not\n   with the usual meaning that implementors need to consult it in order\n   to understand this document, but to emphasize that there are no\n   inconsistencies in the definition of the term \"JSON text\" in any of\n   its specifications.  Note, however, that ECMA-404 allows several\n   practices that this specification recommends avoiding in the\n   interests of maximal interoperability.\n\n   The intent is that the grammar is the same between the two documents,\n   although different descriptions are used.  If there is a difference\n   found between them, ECMA and the IETF will work together to update\n   both documents.\n\n   If an error is found with either document, the other should be\n   examined to see if it has a similar error; if it does, it should be\n   fixed, if possible.\n\n   If either document is changed in the future, ECMA and the IETF will\n   work together to ensure that the two documents stay aligned through\n   the change.\n\n\n\n\n\n\nBray                         Standards Track                    [Page 4]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n1.3.  Introduction to This Revision\n\n   In the years since the publication of RFC 4627, JSON has found very\n   wide use.  This experience has revealed certain patterns that, while\n   allowed by its specifications, have caused interoperability problems.\n\n   Also, a small number of errata have been reported regarding RFC 4627\n   (see RFC Errata IDs 607 [Err607] and 3607 [Err3607]) and regarding\n   RFC 7159 (see RFC Errata IDs 3915 [Err3915], 4264 [Err4264], 4336\n   [Err4336], and 4388 [Err4388]).\n\n   This document's goal is to apply the errata, remove inconsistencies\n   with other specifications of JSON, and highlight practices that can\n   lead to interoperability problems.\n\n2.  JSON Grammar\n\n   A JSON text is a sequence of tokens.  The set of tokens includes six\n   structural characters, strings, numbers, and three literal names.\n\n   A JSON text is a serialized value.  Note that certain previous\n   specifications of JSON constrained a JSON text to be an object or an\n   array.  Implementations that generate only objects or arrays where a\n   JSON text is called for will be interoperable in the sense that all\n   implementations will accept these as conforming JSON texts.\n\n      JSON-text = ws value ws\n\n   These are the six structural characters:\n\n      begin-array     = ws %x5B ws  ; [ left square bracket\n\n      begin-object    = ws %x7B ws  ; { left curly bracket\n\n      end-array       = ws %x5D ws  ; ] right square bracket\n\n      end-object      = ws %x7D ws  ; } right curly bracket\n\n      name-separator  = ws %x3A ws  ; : colon\n\n      value-separator = ws %x2C ws  ; , comma\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 5]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   Insignificant whitespace is allowed before or after any of the six\n   structural characters.\n\n      ws = *(\n              %x20 /              ; Space\n              %x09 /              ; Horizontal tab\n              %x0A /              ; Line feed or New line\n              %x0D )              ; Carriage return\n\n3.  Values\n\n   A JSON value MUST be an object, array, number, or string, or one of\n   the following three literal names:\n\n      false\n      null\n      true\n\n   The literal names MUST be lowercase.  No other literal names are\n   allowed.\n\n      value = false / null / true / object / array / number / string\n\n      false = %x66.61.6c.73.65   ; false\n\n      null  = %x6e.75.6c.6c      ; null\n\n      true  = %x74.72.75.65      ; true\n\n4.  Objects\n\n   An object structure is represented as a pair of curly brackets\n   surrounding zero or more name/value pairs (or members).  A name is a\n   string.  A single colon comes after each name, separating the name\n   from the value.  A single comma separates a value from a following\n   name.  The names within an object SHOULD be unique.\n\n      object = begin-object [ member *( value-separator member ) ]\n               end-object\n\n      member = string name-separator value\n\n   An object whose names are all unique is interoperable in the sense\n   that all software implementations receiving that object will agree on\n   the name-value mappings.  When the names within an object are not\n   unique, the behavior of software that receives such an object is\n   unpredictable.  Many implementations report the last name/value pair\n   only.  Other implementations report an error or fail to parse the\n\n\n\nBray                         Standards Track                    [Page 6]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   object, and some implementations report all of the name/value pairs,\n   including duplicates.\n\n   JSON parsing libraries have been observed to differ as to whether or\n   not they make the ordering of object members visible to calling\n   software.  Implementations whose behavior does not depend on member\n   ordering will be interoperable in the sense that they will not be\n   affected by these differences.\n\n5.  Arrays\n\n   An array structure is represented as square brackets surrounding zero\n   or more values (or elements).  Elements are separated by commas.\n\n   array = begin-array [ value *( value-separator value ) ] end-array\n\n   There is no requirement that the values in an array be of the same\n   type.\n\n6.  Numbers\n\n   The representation of numbers is similar to that used in most\n   programming languages.  A number is represented in base 10 using\n   decimal digits.  It contains an integer component that may be\n   prefixed with an optional minus sign, which may be followed by a\n   fraction part and/or an exponent part.  Leading zeros are not\n   allowed.\n\n   A fraction part is a decimal point followed by one or more digits.\n\n   An exponent part begins with the letter E in uppercase or lowercase,\n   which may be followed by a plus or minus sign.  The E and optional\n   sign are followed by one or more digits.\n\n   Numeric values that cannot be represented in the grammar below (such\n   as Infinity and NaN) are not permitted.\n\n      number = [ minus ] int [ frac ] [ exp ]\n\n      decimal-point = %x2E       ; .\n\n      digit1-9 = %x31-39         ; 1-9\n\n      e = %x65 / %x45            ; e E\n\n      exp = e [ minus / plus ] 1*DIGIT\n\n      frac = decimal-point 1*DIGIT\n\n\n\nBray                         Standards Track                    [Page 7]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n      int = zero / ( digit1-9 *DIGIT )\n\n      minus = %x2D               ; -\n\n      plus = %x2B                ; +\n\n      zero = %x30                ; 0\n\n   This specification allows implementations to set limits on the range\n   and precision of numbers accepted.  Since software that implements\n   IEEE 754 binary64 (double precision) numbers [IEEE754] is generally\n   available and widely used, good interoperability can be achieved by\n   implementations that expect no more precision or range than these\n   provide, in the sense that implementations will approximate JSON\n   numbers within the expected precision.  A JSON number such as 1E400\n   or 3.141592653589793238462643383279 may indicate potential\n   interoperability problems, since it suggests that the software that\n   created it expects receiving software to have greater capabilities\n   for numeric magnitude and precision than is widely available.\n\n   Note that when such software is used, numbers that are integers and\n   are in the range [-(2**53)+1, (2**53)-1] are interoperable in the\n   sense that implementations will agree exactly on their numeric\n   values.\n\n7.  Strings\n\n   The representation of strings is similar to conventions used in the C\n   family of programming languages.  A string begins and ends with\n   quotation marks.  All Unicode characters may be placed within the\n   quotation marks, except for the characters that MUST be escaped:\n   quotation mark, reverse solidus, and the control characters (U+0000\n   through U+001F).\n\n   Any character may be escaped.  If the character is in the Basic\n   Multilingual Plane (U+0000 through U+FFFF), then it may be\n   represented as a six-character sequence: a reverse solidus, followed\n   by the lowercase letter u, followed by four hexadecimal digits that\n   encode the character's code point.  The hexadecimal letters A through\n   F can be uppercase or lowercase.  So, for example, a string\n   containing only a single reverse solidus character may be represented\n   as \"\\u005C\".\n\n   Alternatively, there are two-character sequence escape\n   representations of some popular characters.  So, for example, a\n   string containing only a single reverse solidus character may be\n   represented more compactly as \"\\\\\".\n\n\n\n\nBray                         Standards Track                    [Page 8]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   To escape an extended character that is not in the Basic Multilingual\n   Plane, the character is represented as a 12-character sequence,\n   encoding the UTF-16 surrogate pair.  So, for example, a string\n   containing only the G clef character (U+1D11E) may be represented as\n   \"\\uD834\\uDD1E\".\n\n      string = quotation-mark *char quotation-mark\n\n      char = unescaped /\n          escape (\n              %x22 /          ; \"    quotation mark  U+0022\n              %x5C /          ; \\    reverse solidus U+005C\n              %x2F /          ; /    solidus         U+002F\n              %x62 /          ; b    backspace       U+0008\n              %x66 /          ; f    form feed       U+000C\n              %x6E /          ; n    line feed       U+000A\n              %x72 /          ; r    carriage return U+000D\n              %x74 /          ; t    tab             U+0009\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\n\n      escape = %x5C              ; \\\n\n      quotation-mark = %x22      ; \"\n\n      unescaped = %x20-21 / %x23-5B / %x5D-10FFFF\n\n8.  String and Character Issues\n\n8.1.  Character Encoding\n\n   JSON text exchanged between systems that are not part of a closed\n   ecosystem MUST be encoded using UTF-8 [RFC3629].\n\n   Previous specifications of JSON have not required the use of UTF-8\n   when transmitting JSON text.  However, the vast majority of JSON-\n   based software implementations have chosen to use the UTF-8 encoding,\n   to the extent that it is the only encoding that achieves\n   interoperability.\n\n   Implementations MUST NOT add a byte order mark (U+FEFF) to the\n   beginning of a networked-transmitted JSON text.  In the interests of\n   interoperability, implementations that parse JSON texts MAY ignore\n   the presence of a byte order mark rather than treating it as an\n   error.\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 9]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n8.2.  Unicode Characters\n\n   When all the strings represented in a JSON text are composed entirely\n   of Unicode characters [UNICODE] (however escaped), then that JSON\n   text is interoperable in the sense that all software implementations\n   that parse it will agree on the contents of names and of string\n   values in objects and arrays.\n\n   However, the ABNF in this specification allows member names and\n   string values to contain bit sequences that cannot encode Unicode\n   characters; for example, \"\\uDEAD\" (a single unpaired UTF-16\n   surrogate).  Instances of this have been observed, for example, when\n   a library truncates a UTF-16 string without checking whether the\n   truncation split a surrogate pair.  The behavior of software that\n   receives JSON texts containing such values is unpredictable; for\n   example, implementations might return different values for the length\n   of a string value or even suffer fatal runtime exceptions.\n\n8.3.  String Comparison\n\n   Software implementations are typically required to test names of\n   object members for equality.  Implementations that transform the\n   textual representation into sequences of Unicode code units and then\n   perform the comparison numerically, code unit by code unit, are\n   interoperable in the sense that implementations will agree in all\n   cases on equality or inequality of two strings.  For example,\n   implementations that compare strings with escaped characters\n   unconverted may incorrectly find that \"a\\\\b\" and \"a\\u005Cb\" are not\n   equal.\n\n9.  Parsers\n\n   A JSON parser transforms a JSON text into another representation.  A\n   JSON parser MUST accept all texts that conform to the JSON grammar.\n   A JSON parser MAY accept non-JSON forms or extensions.\n\n   An implementation may set limits on the size of texts that it\n   accepts.  An implementation may set limits on the maximum depth of\n   nesting.  An implementation may set limits on the range and precision\n   of numbers.  An implementation may set limits on the length and\n   character contents of strings.\n\n10.  Generators\n\n   A JSON generator produces JSON text.  The resulting text MUST\n   strictly conform to the JSON grammar.\n\n\n\n\n\nBray                         Standards Track                   [Page 10]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n11.  IANA Considerations\n\n   The media type for JSON text is application/json.\n\n   Type name:  application\n\n   Subtype name:  json\n\n   Required parameters:  n/a\n\n   Optional parameters:  n/a\n\n   Encoding considerations:  binary\n\n   Security considerations:  See RFC 8259, Section 12\n\n   Interoperability considerations:  Described in RFC 8259\n\n   Published specification:  RFC 8259\n\n   Applications that use this media type:\n      JSON has been used to exchange data between applications written\n      in all of these programming languages: ActionScript, C, C#,\n      Clojure, ColdFusion, Common Lisp, E, Erlang, Go, Java, JavaScript,\n      Lua, Objective CAML, Perl, PHP, Python, Rebol, Ruby, Scala, and\n      Scheme.\n\n   Additional information:\n      Magic number(s): n/a\n      File extension(s): .json\n      Macintosh file type code(s): TEXT\n\n   Person & email address to contact for further information:\n      IESG\n      <iesg@ietf.org>\n\n   Intended usage:  COMMON\n\n   Restrictions on usage:  none\n\n   Author:\n      Douglas Crockford\n      <douglas@crockford.com>\n\n   Change controller:\n      IESG\n      <iesg@ietf.org>\n\n\n\n\nBray                         Standards Track                   [Page 11]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   Note:  No \"charset\" parameter is defined for this registration.\n      Adding one really has no effect on compliant recipients.\n\n12.  Security Considerations\n\n   Generally, there are security issues with scripting languages.  JSON\n   is a subset of JavaScript but excludes assignment and invocation.\n\n   Since JSON's syntax is borrowed from JavaScript, it is possible to\n   use that language's \"eval()\" function to parse most JSON texts (but\n   not all; certain characters such as U+2028 LINE SEPARATOR and U+2029\n   PARAGRAPH SEPARATOR are legal in JSON but not JavaScript).  This\n   generally constitutes an unacceptable security risk, since the text\n   could contain executable code along with data declarations.  The same\n   consideration applies to the use of eval()-like functions in any\n   other programming language in which JSON texts conform to that\n   language's syntax.\n\n13.  Examples\n\n   This is a JSON object:\n\n      {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n          }\n      }\n\n   Its Image member is an object whose Thumbnail member is an object and\n   whose IDs member is an array of numbers.\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 12]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   This is a JSON array containing two objects:\n\n      [\n        {\n           \"precision\": \"zip\",\n           \"Latitude\":  37.7668,\n           \"Longitude\": -122.3959,\n           \"Address\":   \"\",\n           \"City\":      \"SAN FRANCISCO\",\n           \"State\":     \"CA\",\n           \"Zip\":       \"94107\",\n           \"Country\":   \"US\"\n        },\n        {\n           \"precision\": \"zip\",\n           \"Latitude\":  37.371991,\n           \"Longitude\": -122.026020,\n           \"Address\":   \"\",\n           \"City\":      \"SUNNYVALE\",\n           \"State\":     \"CA\",\n           \"Zip\":       \"94085\",\n           \"Country\":   \"US\"\n        }\n      ]\n\n   Here are three small JSON texts containing only values:\n\n   \"Hello world!\"\n\n   42\n\n   true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 13]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n14.  References\n\n14.1.  Normative References\n\n   [ECMA-404] Ecma International, \"The JSON Data Interchange Format\",\n              Standard ECMA-404,\n              <http://www.ecma-international.org/publications/\n              standards/Ecma-404.htm>.\n\n   [IEEE754]  IEEE, \"IEEE Standard for Floating-Point Arithmetic\",\n              IEEE 754.\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n              2003, <https://www.rfc-editor.org/info/rfc3629>.\n\n   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234, January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n\n   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n\n   [UNICODE]  The Unicode Consortium, \"The Unicode Standard\",\n              <http://www.unicode.org/versions/latest/>.\n\n14.2.  Informative References\n\n   [ECMA-262] Ecma International, \"ECMAScript Language Specification\",\n              Standard ECMA-262, Third Edition, December 1999,\n              <http://www.ecma-international.org/publications/files/\n              ECMA-ST-ARCH/\n              ECMA-262,%203rd%20edition,%20December%201999.pdf>.\n\n   [Err3607]  RFC Errata, Erratum ID 3607, RFC 4627,\n              <https://www.rfc-editor.org/errata/eid3607>.\n\n   [Err3915]  RFC Errata, Erratum ID 3915, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid3915>.\n\n\n\n\n\nBray                         Standards Track                   [Page 14]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   [Err4264]  RFC Errata, Erratum ID 4264, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4264>.\n\n   [Err4336]  RFC Errata, Erratum ID 4336, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4336>.\n\n   [Err4388]  RFC Errata, Erratum ID 4388, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4388>.\n\n   [Err607]   RFC Errata, Erratum ID 607, RFC 4627,\n              <https://www.rfc-editor.org/errata/eid607>.\n\n   [RFC4627]  Crockford, D., \"The application/json Media Type for\n              JavaScript Object Notation (JSON)\", RFC 4627,\n              DOI 10.17487/RFC4627, July 2006,\n              <https://www.rfc-editor.org/info/rfc4627>.\n\n   [RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n              Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March\n              2014, <https://www.rfc-editor.org/info/rfc7159>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 15]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nAppendix A.  Changes from RFC 7159\n\n   This section lists changes between this document and the text in\n   RFC 7159.\n\n   o  Section 1.2 has been updated to reflect the removal of a JSON\n      specification from ECMA-262, to make ECMA-404 a normative\n      reference, and to explain the particular meaning of \"normative\".\n\n   o  Section 1.3 has been updated to reflect errata filed against\n      RFC 7159, not RFC 4627.\n\n   o  Section 8.1 was changed to require the use of UTF-8 when\n      transmitted over a network.\n\n   o  Section 12 has been updated to increase the precision of the\n      description of the security risk that follows from using the\n      ECMAScript \"eval()\" function.\n\n   o  Section 14.1 has been updated to include ECMA-404 as a normative\n      reference.\n\n   o  Section 14.2 has been updated to remove ECMA-404, update the\n      version of ECMA-262, and refresh the errata list.\n\nContributors\n\n   RFC 4627 was written by Douglas Crockford.  This document was\n   constructed by making a relatively small number of changes to that\n   document; thus, the vast majority of the text here is his.\n\nAuthor's Address\n\n   Tim Bray (editor)\n   Textuality\n\n   Email: tbray@textuality.com\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 16]\n\f\n\n\n==================== RFC - OAUTH ====================\n\n\n\n\n\n\n\nInternet Engineering Task Force (IETF)                     D. Hardt, Ed.\nRequest for Comments: 6749                                     Microsoft\nObsoletes: 5849                                             October 2012\nCategory: Standards Track\nISSN: 2070-1721\n\n\n                 The OAuth 2.0 Authorization Framework\n\nAbstract\n\n   The OAuth 2.0 authorization framework enables a third-party\n   application to obtain limited access to an HTTP service, either on\n   behalf of a resource owner by orchestrating an approval interaction\n   between the resource owner and the HTTP service, or by allowing the\n   third-party application to obtain access on its own behalf.  This\n   specification replaces and obsoletes the OAuth 1.0 protocol described\n   in RFC 5849.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 5741.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6749.\n\nCopyright Notice\n\n   Copyright (c) 2012 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\n\n\n\nHardt                        Standards Track                    [Page 1]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nTable of Contents\n\n   1. Introduction ....................................................4\n      1.1. Roles ......................................................6\n      1.2. Protocol Flow ..............................................7\n      1.3. Authorization Grant ........................................8\n           1.3.1. Authorization Code ..................................8\n           1.3.2. Implicit ............................................8\n           1.3.3. Resource Owner Password Credentials .................9\n           1.3.4. Client Credentials ..................................9\n      1.4. Access Token ..............................................10\n      1.5. Refresh Token .............................................10\n      1.6. TLS Version ...............................................12\n      1.7. HTTP Redirections .........................................12\n      1.8. Interoperability ..........................................12\n      1.9. Notational Conventions ....................................13\n   2. Client Registration ............................................13\n      2.1. Client Types ..............................................14\n      2.2. Client Identifier .........................................15\n      2.3. Client Authentication .....................................16\n           2.3.1. Client Password ....................................16\n           2.3.2. Other Authentication Methods .......................17\n      2.4. Unregistered Clients ......................................17\n   3. Protocol Endpoints .............................................18\n      3.1. Authorization Endpoint ....................................18\n           3.1.1. Response Type ......................................19\n           3.1.2. Redirection Endpoint ...............................19\n      3.2. Token Endpoint ............................................21\n           3.2.1. Client Authentication ..............................22\n      3.3. Access Token Scope ........................................23\n   4. Obtaining Authorization ........................................23\n      4.1. Authorization Code Grant ..................................24\n           4.1.1. Authorization Request ..............................25\n           4.1.2. Authorization Response .............................26\n           4.1.3. Access Token Request ...............................29\n           4.1.4. Access Token Response ..............................30\n      4.2. Implicit Grant ............................................31\n           4.2.1. Authorization Request ..............................33\n           4.2.2. Access Token Response ..............................35\n      4.3. Resource Owner Password Credentials Grant .................37\n           4.3.1. Authorization Request and Response .................39\n           4.3.2. Access Token Request ...............................39\n           4.3.3. Access Token Response ..............................40\n      4.4. Client Credentials Grant ..................................40\n           4.4.1. Authorization Request and Response .................41\n           4.4.2. Access Token Request ...............................41\n           4.4.3. Access Token Response ..............................42\n      4.5. Extension Grants ..........................................42\n\n\n\nHardt                        Standards Track                    [Page 2]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   5. Issuing an Access Token ........................................43\n      5.1. Successful Response .......................................43\n      5.2. Error Response ............................................45\n   6. Refreshing an Access Token .....................................47\n   7. Accessing Protected Resources ..................................48\n      7.1. Access Token Types ........................................49\n      7.2. Error Response ............................................49\n   8. Extensibility ..................................................50\n      8.1. Defining Access Token Types ...............................50\n      8.2. Defining New Endpoint Parameters ..........................50\n      8.3. Defining New Authorization Grant Types ....................51\n      8.4. Defining New Authorization Endpoint Response Types ........51\n      8.5. Defining Additional Error Codes ...........................51\n   9. Native Applications ............................................52\n   10. Security Considerations .......................................53\n      10.1. Client Authentication ....................................53\n      10.2. Client Impersonation .....................................54\n      10.3. Access Tokens ............................................55\n      10.4. Refresh Tokens ...........................................55\n      10.5. Authorization Codes ......................................56\n      10.6. Authorization Code Redirection URI Manipulation ..........56\n      10.7. Resource Owner Password Credentials ......................57\n      10.8. Request Confidentiality ..................................58\n      10.9. Ensuring Endpoint Authenticity ...........................58\n      10.10. Credentials-Guessing Attacks ............................58\n      10.11. Phishing Attacks ........................................58\n      10.12. Cross-Site Request Forgery ..............................59\n      10.13. Clickjacking ............................................60\n      10.14. Code Injection and Input Validation .....................60\n      10.15. Open Redirectors ........................................60\n      10.16. Misuse of Access Token to Impersonate Resource\n             Owner in Implicit Flow ..................................61\n   11. IANA Considerations ...........................................62\n      11.1. OAuth Access Token Types Registry ........................62\n           11.1.1. Registration Template .............................62\n      11.2. OAuth Parameters Registry ................................63\n           11.2.1. Registration Template .............................63\n           11.2.2. Initial Registry Contents .........................64\n      11.3. OAuth Authorization Endpoint Response Types Registry .....66\n           11.3.1. Registration Template .............................66\n           11.3.2. Initial Registry Contents .........................67\n      11.4. OAuth Extensions Error Registry ..........................67\n           11.4.1. Registration Template .............................68\n   12. References ....................................................68\n      12.1. Normative References .....................................68\n      12.2. Informative References ...................................70\n\n\n\n\n\nHardt                        Standards Track                    [Page 3]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Appendix A. Augmented Backus-Naur Form (ABNF) Syntax ..............71\n     A.1.  \"client_id\" Syntax ........................................71\n     A.2.  \"client_secret\" Syntax ....................................71\n     A.3.  \"response_type\" Syntax ....................................71\n     A.4.  \"scope\" Syntax ............................................72\n     A.5.  \"state\" Syntax ............................................72\n     A.6.  \"redirect_uri\" Syntax .....................................72\n     A.7.  \"error\" Syntax ............................................72\n     A.8.  \"error_description\" Syntax ................................72\n     A.9.  \"error_uri\" Syntax ........................................72\n     A.10. \"grant_type\" Syntax .......................................73\n     A.11. \"code\" Syntax .............................................73\n     A.12. \"access_token\" Syntax .....................................73\n     A.13. \"token_type\" Syntax .......................................73\n     A.14. \"expires_in\" Syntax .......................................73\n     A.15. \"username\" Syntax .........................................73\n     A.16. \"password\" Syntax .........................................73\n     A.17. \"refresh_token\" Syntax ....................................74\n     A.18. Endpoint Parameter Syntax .................................74\n   Appendix B. Use of application/x-www-form-urlencoded Media Type ...74\n   Appendix C. Acknowledgements ......................................75\n\n1.  Introduction\n\n   In the traditional client-server authentication model, the client\n   requests an access-restricted resource (protected resource) on the\n   server by authenticating with the server using the resource owner's\n   credentials.  In order to provide third-party applications access to\n   restricted resources, the resource owner shares its credentials with\n   the third party.  This creates several problems and limitations:\n\n   o  Third-party applications are required to store the resource\n      owner's credentials for future use, typically a password in\n      clear-text.\n\n   o  Servers are required to support password authentication, despite\n      the security weaknesses inherent in passwords.\n\n   o  Third-party applications gain overly broad access to the resource\n      owner's protected resources, leaving resource owners without any\n      ability to restrict duration or access to a limited subset of\n      resources.\n\n   o  Resource owners cannot revoke access to an individual third party\n      without revoking access to all third parties, and must do so by\n      changing the third party's password.\n\n\n\n\n\nHardt                        Standards Track                    [Page 4]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   o  Compromise of any third-party application results in compromise of\n      the end-user's password and all of the data protected by that\n      password.\n\n   OAuth addresses these issues by introducing an authorization layer\n   and separating the role of the client from that of the resource\n   owner.  In OAuth, the client requests access to resources controlled\n   by the resource owner and hosted by the resource server, and is\n   issued a different set of credentials than those of the resource\n   owner.\n\n   Instead of using the resource owner's credentials to access protected\n   resources, the client obtains an access token -- a string denoting a\n   specific scope, lifetime, and other access attributes.  Access tokens\n   are issued to third-party clients by an authorization server with the\n   approval of the resource owner.  The client uses the access token to\n   access the protected resources hosted by the resource server.\n\n   For example, an end-user (resource owner) can grant a printing\n   service (client) access to her protected photos stored at a photo-\n   sharing service (resource server), without sharing her username and\n   password with the printing service.  Instead, she authenticates\n   directly with a server trusted by the photo-sharing service\n   (authorization server), which issues the printing service delegation-\n   specific credentials (access token).\n\n   This specification is designed for use with HTTP ([RFC2616]).  The\n   use of OAuth over any protocol other than HTTP is out of scope.\n\n   The OAuth 1.0 protocol ([RFC5849]), published as an informational\n   document, was the result of a small ad hoc community effort.  This\n   Standards Track specification builds on the OAuth 1.0 deployment\n   experience, as well as additional use cases and extensibility\n   requirements gathered from the wider IETF community.  The OAuth 2.0\n   protocol is not backward compatible with OAuth 1.0.  The two versions\n   may co-exist on the network, and implementations may choose to\n   support both.  However, it is the intention of this specification\n   that new implementations support OAuth 2.0 as specified in this\n   document and that OAuth 1.0 is used only to support existing\n   deployments.  The OAuth 2.0 protocol shares very few implementation\n   details with the OAuth 1.0 protocol.  Implementers familiar with\n   OAuth 1.0 should approach this document without any assumptions as to\n   its structure and details.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 5]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.1.  Roles\n\n   OAuth defines four roles:\n\n   resource owner\n      An entity capable of granting access to a protected resource.\n      When the resource owner is a person, it is referred to as an\n      end-user.\n\n   resource server\n      The server hosting the protected resources, capable of accepting\n      and responding to protected resource requests using access tokens.\n\n   client\n      An application making protected resource requests on behalf of the\n      resource owner and with its authorization.  The term \"client\" does\n      not imply any particular implementation characteristics (e.g.,\n      whether the application executes on a server, a desktop, or other\n      devices).\n\n   authorization server\n      The server issuing access tokens to the client after successfully\n      authenticating the resource owner and obtaining authorization.\n\n   The interaction between the authorization server and resource server\n   is beyond the scope of this specification.  The authorization server\n   may be the same server as the resource server or a separate entity.\n   A single authorization server may issue access tokens accepted by\n   multiple resource servers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 6]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.2.  Protocol Flow\n\n     +--------+                               +---------------+\n     |        |--(A)- Authorization Request ->|   Resource    |\n     |        |                               |     Owner     |\n     |        |<-(B)-- Authorization Grant ---|               |\n     |        |                               +---------------+\n     |        |\n     |        |                               +---------------+\n     |        |--(C)-- Authorization Grant -->| Authorization |\n     | Client |                               |     Server    |\n     |        |<-(D)----- Access Token -------|               |\n     |        |                               +---------------+\n     |        |\n     |        |                               +---------------+\n     |        |--(E)----- Access Token ------>|    Resource   |\n     |        |                               |     Server    |\n     |        |<-(F)--- Protected Resource ---|               |\n     +--------+                               +---------------+\n\n                     Figure 1: Abstract Protocol Flow\n\n   The abstract OAuth 2.0 flow illustrated in Figure 1 describes the\n   interaction between the four roles and includes the following steps:\n\n   (A)  The client requests authorization from the resource owner.  The\n        authorization request can be made directly to the resource owner\n        (as shown), or preferably indirectly via the authorization\n        server as an intermediary.\n\n   (B)  The client receives an authorization grant, which is a\n        credential representing the resource owner's authorization,\n        expressed using one of four grant types defined in this\n        specification or using an extension grant type.  The\n        authorization grant type depends on the method used by the\n        client to request authorization and the types supported by the\n        authorization server.\n\n   (C)  The client requests an access token by authenticating with the\n        authorization server and presenting the authorization grant.\n\n   (D)  The authorization server authenticates the client and validates\n        the authorization grant, and if valid, issues an access token.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 7]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (E)  The client requests the protected resource from the resource\n        server and authenticates by presenting the access token.\n\n   (F)  The resource server validates the access token, and if valid,\n        serves the request.\n\n   The preferred method for the client to obtain an authorization grant\n   from the resource owner (depicted in steps (A) and (B)) is to use the\n   authorization server as an intermediary, which is illustrated in\n   Figure 3 in Section 4.1.\n\n1.3.  Authorization Grant\n\n   An authorization grant is a credential representing the resource\n   owner's authorization (to access its protected resources) used by the\n   client to obtain an access token.  This specification defines four\n   grant types -- authorization code, implicit, resource owner password\n   credentials, and client credentials -- as well as an extensibility\n   mechanism for defining additional types.\n\n1.3.1.  Authorization Code\n\n   The authorization code is obtained by using an authorization server\n   as an intermediary between the client and resource owner.  Instead of\n   requesting authorization directly from the resource owner, the client\n   directs the resource owner to an authorization server (via its\n   user-agent as defined in [RFC2616]), which in turn directs the\n   resource owner back to the client with the authorization code.\n\n   Before directing the resource owner back to the client with the\n   authorization code, the authorization server authenticates the\n   resource owner and obtains authorization.  Because the resource owner\n   only authenticates with the authorization server, the resource\n   owner's credentials are never shared with the client.\n\n   The authorization code provides a few important security benefits,\n   such as the ability to authenticate the client, as well as the\n   transmission of the access token directly to the client without\n   passing it through the resource owner's user-agent and potentially\n   exposing it to others, including the resource owner.\n\n1.3.2.  Implicit\n\n   The implicit grant is a simplified authorization code flow optimized\n   for clients implemented in a browser using a scripting language such\n   as JavaScript.  In the implicit flow, instead of issuing the client\n   an authorization code, the client is issued an access token directly\n\n\n\n\nHardt                        Standards Track                    [Page 8]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (as the result of the resource owner authorization).  The grant type\n   is implicit, as no intermediate credentials (such as an authorization\n   code) are issued (and later used to obtain an access token).\n\n   When issuing an access token during the implicit grant flow, the\n   authorization server does not authenticate the client.  In some\n   cases, the client identity can be verified via the redirection URI\n   used to deliver the access token to the client.  The access token may\n   be exposed to the resource owner or other applications with access to\n   the resource owner's user-agent.\n\n   Implicit grants improve the responsiveness and efficiency of some\n   clients (such as a client implemented as an in-browser application),\n   since it reduces the number of round trips required to obtain an\n   access token.  However, this convenience should be weighed against\n   the security implications of using implicit grants, such as those\n   described in Sections 10.3 and 10.16, especially when the\n   authorization code grant type is available.\n\n1.3.3.  Resource Owner Password Credentials\n\n   The resource owner password credentials (i.e., username and password)\n   can be used directly as an authorization grant to obtain an access\n   token.  The credentials should only be used when there is a high\n   degree of trust between the resource owner and the client (e.g., the\n   client is part of the device operating system or a highly privileged\n   application), and when other authorization grant types are not\n   available (such as an authorization code).\n\n   Even though this grant type requires direct client access to the\n   resource owner credentials, the resource owner credentials are used\n   for a single request and are exchanged for an access token.  This\n   grant type can eliminate the need for the client to store the\n   resource owner credentials for future use, by exchanging the\n   credentials with a long-lived access token or refresh token.\n\n1.3.4.  Client Credentials\n\n   The client credentials (or other forms of client authentication) can\n   be used as an authorization grant when the authorization scope is\n   limited to the protected resources under the control of the client,\n   or to protected resources previously arranged with the authorization\n   server.  Client credentials are used as an authorization grant\n   typically when the client is acting on its own behalf (the client is\n   also the resource owner) or is requesting access to protected\n   resources based on an authorization previously arranged with the\n   authorization server.\n\n\n\n\nHardt                        Standards Track                    [Page 9]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.4.  Access Token\n\n   Access tokens are credentials used to access protected resources.  An\n   access token is a string representing an authorization issued to the\n   client.  The string is usually opaque to the client.  Tokens\n   represent specific scopes and durations of access, granted by the\n   resource owner, and enforced by the resource server and authorization\n   server.\n\n   The token may denote an identifier used to retrieve the authorization\n   information or may self-contain the authorization information in a\n   verifiable manner (i.e., a token string consisting of some data and a\n   signature).  Additional authentication credentials, which are beyond\n   the scope of this specification, may be required in order for the\n   client to use a token.\n\n   The access token provides an abstraction layer, replacing different\n   authorization constructs (e.g., username and password) with a single\n   token understood by the resource server.  This abstraction enables\n   issuing access tokens more restrictive than the authorization grant\n   used to obtain them, as well as removing the resource server's need\n   to understand a wide range of authentication methods.\n\n   Access tokens can have different formats, structures, and methods of\n   utilization (e.g., cryptographic properties) based on the resource\n   server security requirements.  Access token attributes and the\n   methods used to access protected resources are beyond the scope of\n   this specification and are defined by companion specifications such\n   as [RFC6750].\n\n1.5.  Refresh Token\n\n   Refresh tokens are credentials used to obtain access tokens.  Refresh\n   tokens are issued to the client by the authorization server and are\n   used to obtain a new access token when the current access token\n   becomes invalid or expires, or to obtain additional access tokens\n   with identical or narrower scope (access tokens may have a shorter\n   lifetime and fewer permissions than authorized by the resource\n   owner).  Issuing a refresh token is optional at the discretion of the\n   authorization server.  If the authorization server issues a refresh\n   token, it is included when issuing an access token (i.e., step (D) in\n   Figure 1).\n\n   A refresh token is a string representing the authorization granted to\n   the client by the resource owner.  The string is usually opaque to\n   the client.  The token denotes an identifier used to retrieve the\n\n\n\n\n\nHardt                        Standards Track                   [Page 10]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   authorization information.  Unlike access tokens, refresh tokens are\n   intended for use only with authorization servers and are never sent\n   to resource servers.\n\n  +--------+                                           +---------------+\n  |        |--(A)------- Authorization Grant --------->|               |\n  |        |                                           |               |\n  |        |<-(B)----------- Access Token -------------|               |\n  |        |               & Refresh Token             |               |\n  |        |                                           |               |\n  |        |                            +----------+   |               |\n  |        |--(C)---- Access Token ---->|          |   |               |\n  |        |                            |          |   |               |\n  |        |<-(D)- Protected Resource --| Resource |   | Authorization |\n  | Client |                            |  Server  |   |     Server    |\n  |        |--(E)---- Access Token ---->|          |   |               |\n  |        |                            |          |   |               |\n  |        |<-(F)- Invalid Token Error -|          |   |               |\n  |        |                            +----------+   |               |\n  |        |                                           |               |\n  |        |--(G)----------- Refresh Token ----------->|               |\n  |        |                                           |               |\n  |        |<-(H)----------- Access Token -------------|               |\n  +--------+           & Optional Refresh Token        +---------------+\n\n               Figure 2: Refreshing an Expired Access Token\n\n   The flow illustrated in Figure 2 includes the following steps:\n\n   (A)  The client requests an access token by authenticating with the\n        authorization server and presenting an authorization grant.\n\n   (B)  The authorization server authenticates the client and validates\n        the authorization grant, and if valid, issues an access token\n        and a refresh token.\n\n   (C)  The client makes a protected resource request to the resource\n        server by presenting the access token.\n\n   (D)  The resource server validates the access token, and if valid,\n        serves the request.\n\n   (E)  Steps (C) and (D) repeat until the access token expires.  If the\n        client knows the access token expired, it skips to step (G);\n        otherwise, it makes another protected resource request.\n\n   (F)  Since the access token is invalid, the resource server returns\n        an invalid token error.\n\n\n\nHardt                        Standards Track                   [Page 11]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (G)  The client requests a new access token by authenticating with\n        the authorization server and presenting the refresh token.  The\n        client authentication requirements are based on the client type\n        and on the authorization server policies.\n\n   (H)  The authorization server authenticates the client and validates\n        the refresh token, and if valid, issues a new access token (and,\n        optionally, a new refresh token).\n\n   Steps (C), (D), (E), and (F) are outside the scope of this\n   specification, as described in Section 7.\n\n1.6.  TLS Version\n\n   Whenever Transport Layer Security (TLS) is used by this\n   specification, the appropriate version (or versions) of TLS will vary\n   over time, based on the widespread deployment and known security\n   vulnerabilities.  At the time of this writing, TLS version 1.2\n   [RFC5246] is the most recent version, but has a very limited\n   deployment base and might not be readily available for\n   implementation.  TLS version 1.0 [RFC2246] is the most widely\n   deployed version and will provide the broadest interoperability.\n\n   Implementations MAY also support additional transport-layer security\n   mechanisms that meet their security requirements.\n\n1.7.  HTTP Redirections\n\n   This specification makes extensive use of HTTP redirections, in which\n   the client or the authorization server directs the resource owner's\n   user-agent to another destination.  While the examples in this\n   specification show the use of the HTTP 302 status code, any other\n   method available via the user-agent to accomplish this redirection is\n   allowed and is considered to be an implementation detail.\n\n1.8.  Interoperability\n\n   OAuth 2.0 provides a rich authorization framework with well-defined\n   security properties.  However, as a rich and highly extensible\n   framework with many optional components, on its own, this\n   specification is likely to produce a wide range of non-interoperable\n   implementations.\n\n   In addition, this specification leaves a few required components\n   partially or fully undefined (e.g., client registration,\n   authorization server capabilities, endpoint discovery).  Without\n\n\n\n\n\nHardt                        Standards Track                   [Page 12]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   these components, clients must be manually and specifically\n   configured against a specific authorization server and resource\n   server in order to interoperate.\n\n   This framework was designed with the clear expectation that future\n   work will define prescriptive profiles and extensions necessary to\n   achieve full web-scale interoperability.\n\n1.9.  Notational Conventions\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   specification are to be interpreted as described in [RFC2119].\n\n   This specification uses the Augmented Backus-Naur Form (ABNF)\n   notation of [RFC5234].  Additionally, the rule URI-reference is\n   included from \"Uniform Resource Identifier (URI): Generic Syntax\"\n   [RFC3986].\n\n   Certain security-related terms are to be understood in the sense\n   defined in [RFC4949].  These terms include, but are not limited to,\n   \"attack\", \"authentication\", \"authorization\", \"certificate\",\n   \"confidentiality\", \"credential\", \"encryption\", \"identity\", \"sign\",\n   \"signature\", \"trust\", \"validate\", and \"verify\".\n\n   Unless otherwise noted, all the protocol parameter names and values\n   are case sensitive.\n\n2.  Client Registration\n\n   Before initiating the protocol, the client registers with the\n   authorization server.  The means through which the client registers\n   with the authorization server are beyond the scope of this\n   specification but typically involve end-user interaction with an HTML\n   registration form.\n\n   Client registration does not require a direct interaction between the\n   client and the authorization server.  When supported by the\n   authorization server, registration can rely on other means for\n   establishing trust and obtaining the required client properties\n   (e.g., redirection URI, client type).  For example, registration can\n   be accomplished using a self-issued or third-party-issued assertion,\n   or by the authorization server performing client discovery using a\n   trusted channel.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 13]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   When registering a client, the client developer SHALL:\n\n   o  specify the client type as described in Section 2.1,\n\n   o  provide its client redirection URIs as described in Section 3.1.2,\n      and\n\n   o  include any other information required by the authorization server\n      (e.g., application name, website, description, logo image, the\n      acceptance of legal terms).\n\n2.1.  Client Types\n\n   OAuth defines two client types, based on their ability to\n   authenticate securely with the authorization server (i.e., ability to\n   maintain the confidentiality of their client credentials):\n\n   confidential\n      Clients capable of maintaining the confidentiality of their\n      credentials (e.g., client implemented on a secure server with\n      restricted access to the client credentials), or capable of secure\n      client authentication using other means.\n\n   public\n      Clients incapable of maintaining the confidentiality of their\n      credentials (e.g., clients executing on the device used by the\n      resource owner, such as an installed native application or a web\n      browser-based application), and incapable of secure client\n      authentication via any other means.\n\n   The client type designation is based on the authorization server's\n   definition of secure authentication and its acceptable exposure\n   levels of client credentials.  The authorization server SHOULD NOT\n   make assumptions about the client type.\n\n   A client may be implemented as a distributed set of components, each\n   with a different client type and security context (e.g., a\n   distributed client with both a confidential server-based component\n   and a public browser-based component).  If the authorization server\n   does not provide support for such clients or does not provide\n   guidance with regard to their registration, the client SHOULD\n   register each component as a separate client.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 14]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   This specification has been designed around the following client\n   profiles:\n\n   web application\n      A web application is a confidential client running on a web\n      server.  Resource owners access the client via an HTML user\n      interface rendered in a user-agent on the device used by the\n      resource owner.  The client credentials as well as any access\n      token issued to the client are stored on the web server and are\n      not exposed to or accessible by the resource owner.\n\n   user-agent-based application\n      A user-agent-based application is a public client in which the\n      client code is downloaded from a web server and executes within a\n      user-agent (e.g., web browser) on the device used by the resource\n      owner.  Protocol data and credentials are easily accessible (and\n      often visible) to the resource owner.  Since such applications\n      reside within the user-agent, they can make seamless use of the\n      user-agent capabilities when requesting authorization.\n\n   native application\n      A native application is a public client installed and executed on\n      the device used by the resource owner.  Protocol data and\n      credentials are accessible to the resource owner.  It is assumed\n      that any client authentication credentials included in the\n      application can be extracted.  On the other hand, dynamically\n      issued credentials such as access tokens or refresh tokens can\n      receive an acceptable level of protection.  At a minimum, these\n      credentials are protected from hostile servers with which the\n      application may interact.  On some platforms, these credentials\n      might be protected from other applications residing on the same\n      device.\n\n2.2.  Client Identifier\n\n   The authorization server issues the registered client a client\n   identifier -- a unique string representing the registration\n   information provided by the client.  The client identifier is not a\n   secret; it is exposed to the resource owner and MUST NOT be used\n   alone for client authentication.  The client identifier is unique to\n   the authorization server.\n\n   The client identifier string size is left undefined by this\n   specification.  The client should avoid making assumptions about the\n   identifier size.  The authorization server SHOULD document the size\n   of any identifier it issues.\n\n\n\n\n\nHardt                        Standards Track                   [Page 15]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n2.3.  Client Authentication\n\n   If the client type is confidential, the client and authorization\n   server establish a client authentication method suitable for the\n   security requirements of the authorization server.  The authorization\n   server MAY accept any form of client authentication meeting its\n   security requirements.\n\n   Confidential clients are typically issued (or establish) a set of\n   client credentials used for authenticating with the authorization\n   server (e.g., password, public/private key pair).\n\n   The authorization server MAY establish a client authentication method\n   with public clients.  However, the authorization server MUST NOT rely\n   on public client authentication for the purpose of identifying the\n   client.\n\n   The client MUST NOT use more than one authentication method in each\n   request.\n\n2.3.1.  Client Password\n\n   Clients in possession of a client password MAY use the HTTP Basic\n   authentication scheme as defined in [RFC2617] to authenticate with\n   the authorization server.  The client identifier is encoded using the\n   \"application/x-www-form-urlencoded\" encoding algorithm per\n   Appendix B, and the encoded value is used as the username; the client\n   password is encoded using the same algorithm and used as the\n   password.  The authorization server MUST support the HTTP Basic\n   authentication scheme for authenticating clients that were issued a\n   client password.\n\n   For example (with extra line breaks for display purposes only):\n\n     Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n\n   Alternatively, the authorization server MAY support including the\n   client credentials in the request-body using the following\n   parameters:\n\n   client_id\n         REQUIRED.  The client identifier issued to the client during\n         the registration process described by Section 2.2.\n\n   client_secret\n         REQUIRED.  The client secret.  The client MAY omit the\n         parameter if the client secret is an empty string.\n\n\n\n\nHardt                        Standards Track                   [Page 16]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Including the client credentials in the request-body using the two\n   parameters is NOT RECOMMENDED and SHOULD be limited to clients unable\n   to directly utilize the HTTP Basic authentication scheme (or other\n   password-based HTTP authentication schemes).  The parameters can only\n   be transmitted in the request-body and MUST NOT be included in the\n   request URI.\n\n   For example, a request to refresh an access token (Section 6) using\n   the body parameters (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n     &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n\n   The authorization server MUST require the use of TLS as described in\n   Section 1.6 when sending requests using password authentication.\n\n   Since this client authentication method involves a password, the\n   authorization server MUST protect any endpoint utilizing it against\n   brute force attacks.\n\n2.3.2.  Other Authentication Methods\n\n   The authorization server MAY support any suitable HTTP authentication\n   scheme matching its security requirements.  When using other\n   authentication methods, the authorization server MUST define a\n   mapping between the client identifier (registration record) and\n   authentication scheme.\n\n2.4.  Unregistered Clients\n\n   This specification does not exclude the use of unregistered clients.\n   However, the use of such clients is beyond the scope of this\n   specification and requires additional security analysis and review of\n   its interoperability impact.\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 17]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.  Protocol Endpoints\n\n   The authorization process utilizes two authorization server endpoints\n   (HTTP resources):\n\n   o  Authorization endpoint - used by the client to obtain\n      authorization from the resource owner via user-agent redirection.\n\n   o  Token endpoint - used by the client to exchange an authorization\n      grant for an access token, typically with client authentication.\n\n   As well as one client endpoint:\n\n   o  Redirection endpoint - used by the authorization server to return\n      responses containing authorization credentials to the client via\n      the resource owner user-agent.\n\n   Not every authorization grant type utilizes both endpoints.\n   Extension grant types MAY define additional endpoints as needed.\n\n3.1.  Authorization Endpoint\n\n   The authorization endpoint is used to interact with the resource\n   owner and obtain an authorization grant.  The authorization server\n   MUST first verify the identity of the resource owner.  The way in\n   which the authorization server authenticates the resource owner\n   (e.g., username and password login, session cookies) is beyond the\n   scope of this specification.\n\n   The means through which the client obtains the location of the\n   authorization endpoint are beyond the scope of this specification,\n   but the location is typically provided in the service documentation.\n\n   The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n   formatted (per Appendix B) query component ([RFC3986] Section 3.4),\n   which MUST be retained when adding additional query parameters.  The\n   endpoint URI MUST NOT include a fragment component.\n\n   Since requests to the authorization endpoint result in user\n   authentication and the transmission of clear-text credentials (in the\n   HTTP response), the authorization server MUST require the use of TLS\n   as described in Section 1.6 when sending requests to the\n   authorization endpoint.\n\n   The authorization server MUST support the use of the HTTP \"GET\"\n   method [RFC2616] for the authorization endpoint and MAY support the\n   use of the \"POST\" method as well.\n\n\n\n\nHardt                        Standards Track                   [Page 18]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Parameters sent without a value MUST be treated as if they were\n   omitted from the request.  The authorization server MUST ignore\n   unrecognized request parameters.  Request and response parameters\n   MUST NOT be included more than once.\n\n3.1.1.  Response Type\n\n   The authorization endpoint is used by the authorization code grant\n   type and implicit grant type flows.  The client informs the\n   authorization server of the desired grant type using the following\n   parameter:\n\n   response_type\n         REQUIRED.  The value MUST be one of \"code\" for requesting an\n         authorization code as described by Section 4.1.1, \"token\" for\n         requesting an access token (implicit grant) as described by\n         Section 4.2.1, or a registered extension value as described by\n         Section 8.4.\n\n   Extension response types MAY contain a space-delimited (%x20) list of\n   values, where the order of values does not matter (e.g., response\n   type \"a b\" is the same as \"b a\").  The meaning of such composite\n   response types is defined by their respective specifications.\n\n   If an authorization request is missing the \"response_type\" parameter,\n   or if the response type is not understood, the authorization server\n   MUST return an error response as described in Section 4.1.2.1.\n\n3.1.2.  Redirection Endpoint\n\n   After completing its interaction with the resource owner, the\n   authorization server directs the resource owner's user-agent back to\n   the client.  The authorization server redirects the user-agent to the\n   client's redirection endpoint previously established with the\n   authorization server during the client registration process or when\n   making the authorization request.\n\n   The redirection endpoint URI MUST be an absolute URI as defined by\n   [RFC3986] Section 4.3.  The endpoint URI MAY include an\n   \"application/x-www-form-urlencoded\" formatted (per Appendix B) query\n   component ([RFC3986] Section 3.4), which MUST be retained when adding\n   additional query parameters.  The endpoint URI MUST NOT include a\n   fragment component.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 19]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.1.2.1.  Endpoint Request Confidentiality\n\n   The redirection endpoint SHOULD require the use of TLS as described\n   in Section 1.6 when the requested response type is \"code\" or \"token\",\n   or when the redirection request will result in the transmission of\n   sensitive credentials over an open network.  This specification does\n   not mandate the use of TLS because at the time of this writing,\n   requiring clients to deploy TLS is a significant hurdle for many\n   client developers.  If TLS is not available, the authorization server\n   SHOULD warn the resource owner about the insecure endpoint prior to\n   redirection (e.g., display a message during the authorization\n   request).\n\n   Lack of transport-layer security can have a severe impact on the\n   security of the client and the protected resources it is authorized\n   to access.  The use of transport-layer security is particularly\n   critical when the authorization process is used as a form of\n   delegated end-user authentication by the client (e.g., third-party\n   sign-in service).\n\n3.1.2.2.  Registration Requirements\n\n   The authorization server MUST require the following clients to\n   register their redirection endpoint:\n\n   o  Public clients.\n\n   o  Confidential clients utilizing the implicit grant type.\n\n   The authorization server SHOULD require all clients to register their\n   redirection endpoint prior to utilizing the authorization endpoint.\n\n   The authorization server SHOULD require the client to provide the\n   complete redirection URI (the client MAY use the \"state\" request\n   parameter to achieve per-request customization).  If requiring the\n   registration of the complete redirection URI is not possible, the\n   authorization server SHOULD require the registration of the URI\n   scheme, authority, and path (allowing the client to dynamically vary\n   only the query component of the redirection URI when requesting\n   authorization).\n\n   The authorization server MAY allow the client to register multiple\n   redirection endpoints.\n\n   Lack of a redirection URI registration requirement can enable an\n   attacker to use the authorization endpoint as an open redirector as\n   described in Section 10.15.\n\n\n\n\nHardt                        Standards Track                   [Page 20]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.1.2.3.  Dynamic Configuration\n\n   If multiple redirection URIs have been registered, if only part of\n   the redirection URI has been registered, or if no redirection URI has\n   been registered, the client MUST include a redirection URI with the\n   authorization request using the \"redirect_uri\" request parameter.\n\n   When a redirection URI is included in an authorization request, the\n   authorization server MUST compare and match the value received\n   against at least one of the registered redirection URIs (or URI\n   components) as defined in [RFC3986] Section 6, if any redirection\n   URIs were registered.  If the client registration included the full\n   redirection URI, the authorization server MUST compare the two URIs\n   using simple string comparison as defined in [RFC3986] Section 6.2.1.\n\n3.1.2.4.  Invalid Endpoint\n\n   If an authorization request fails validation due to a missing,\n   invalid, or mismatching redirection URI, the authorization server\n   SHOULD inform the resource owner of the error and MUST NOT\n   automatically redirect the user-agent to the invalid redirection URI.\n\n3.1.2.5.  Endpoint Content\n\n   The redirection request to the client's endpoint typically results in\n   an HTML document response, processed by the user-agent.  If the HTML\n   response is served directly as the result of the redirection request,\n   any script included in the HTML document will execute with full\n   access to the redirection URI and the credentials it contains.\n\n   The client SHOULD NOT include any third-party scripts (e.g., third-\n   party analytics, social plug-ins, ad networks) in the redirection\n   endpoint response.  Instead, it SHOULD extract the credentials from\n   the URI and redirect the user-agent again to another endpoint without\n   exposing the credentials (in the URI or elsewhere).  If third-party\n   scripts are included, the client MUST ensure that its own scripts\n   (used to extract and remove the credentials from the URI) will\n   execute first.\n\n3.2.  Token Endpoint\n\n   The token endpoint is used by the client to obtain an access token by\n   presenting its authorization grant or refresh token.  The token\n   endpoint is used with every authorization grant except for the\n   implicit grant type (since an access token is issued directly).\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 21]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The means through which the client obtains the location of the token\n   endpoint are beyond the scope of this specification, but the location\n   is typically provided in the service documentation.\n\n   The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n   formatted (per Appendix B) query component ([RFC3986] Section 3.4),\n   which MUST be retained when adding additional query parameters.  The\n   endpoint URI MUST NOT include a fragment component.\n\n   Since requests to the token endpoint result in the transmission of\n   clear-text credentials (in the HTTP request and response), the\n   authorization server MUST require the use of TLS as described in\n   Section 1.6 when sending requests to the token endpoint.\n\n   The client MUST use the HTTP \"POST\" method when making access token\n   requests.\n\n   Parameters sent without a value MUST be treated as if they were\n   omitted from the request.  The authorization server MUST ignore\n   unrecognized request parameters.  Request and response parameters\n   MUST NOT be included more than once.\n\n3.2.1.  Client Authentication\n\n   Confidential clients or other clients issued client credentials MUST\n   authenticate with the authorization server as described in\n   Section 2.3 when making requests to the token endpoint.  Client\n   authentication is used for:\n\n   o  Enforcing the binding of refresh tokens and authorization codes to\n      the client they were issued to.  Client authentication is critical\n      when an authorization code is transmitted to the redirection\n      endpoint over an insecure channel or when the redirection URI has\n      not been registered in full.\n\n   o  Recovering from a compromised client by disabling the client or\n      changing its credentials, thus preventing an attacker from abusing\n      stolen refresh tokens.  Changing a single set of client\n      credentials is significantly faster than revoking an entire set of\n      refresh tokens.\n\n   o  Implementing authentication management best practices, which\n      require periodic credential rotation.  Rotation of an entire set\n      of refresh tokens can be challenging, while rotation of a single\n      set of client credentials is significantly easier.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 22]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   A client MAY use the \"client_id\" request parameter to identify itself\n   when sending requests to the token endpoint.  In the\n   \"authorization_code\" \"grant_type\" request to the token endpoint, an\n   unauthenticated client MUST send its \"client_id\" to prevent itself\n   from inadvertently accepting a code intended for a client with a\n   different \"client_id\".  This protects the client from substitution of\n   the authentication code.  (It provides no additional security for the\n   protected resource.)\n\n3.3.  Access Token Scope\n\n   The authorization and token endpoints allow the client to specify the\n   scope of the access request using the \"scope\" request parameter.  In\n   turn, the authorization server uses the \"scope\" response parameter to\n   inform the client of the scope of the access token issued.\n\n   The value of the scope parameter is expressed as a list of space-\n   delimited, case-sensitive strings.  The strings are defined by the\n   authorization server.  If the value contains multiple space-delimited\n   strings, their order does not matter, and each string adds an\n   additional access range to the requested scope.\n\n     scope       = scope-token *( SP scope-token )\n     scope-token = 1*( %x21 / %x23-5B / %x5D-7E )\n\n   The authorization server MAY fully or partially ignore the scope\n   requested by the client, based on the authorization server policy or\n   the resource owner's instructions.  If the issued access token scope\n   is different from the one requested by the client, the authorization\n   server MUST include the \"scope\" response parameter to inform the\n   client of the actual scope granted.\n\n   If the client omits the scope parameter when requesting\n   authorization, the authorization server MUST either process the\n   request using a pre-defined default value or fail the request\n   indicating an invalid scope.  The authorization server SHOULD\n   document its scope requirements and default value (if defined).\n\n4.  Obtaining Authorization\n\n   To request an access token, the client obtains authorization from the\n   resource owner.  The authorization is expressed in the form of an\n   authorization grant, which the client uses to request the access\n   token.  OAuth defines four grant types: authorization code, implicit,\n   resource owner password credentials, and client credentials.  It also\n   provides an extension mechanism for defining additional grant types.\n\n\n\n\n\nHardt                        Standards Track                   [Page 23]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.1.  Authorization Code Grant\n\n   The authorization code grant type is used to obtain both access\n   tokens and refresh tokens and is optimized for confidential clients.\n   Since this is a redirection-based flow, the client must be capable of\n   interacting with the resource owner's user-agent (typically a web\n   browser) and capable of receiving incoming requests (via redirection)\n   from the authorization server.\n\n     +----------+\n     | Resource |\n     |   Owner  |\n     |          |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier      +---------------+\n     |         -+----(A)-- & Redirection URI ---->|               |\n     |  User-   |                                 | Authorization |\n     |  Agent  -+----(B)-- User authenticates --->|     Server    |\n     |          |                                 |               |\n     |         -+----(C)-- Authorization Code ---<|               |\n     +-|----|---+                                 +---------------+\n       |    |                                         ^      v\n      (A)  (C)                                        |      |\n       |    |                                         |      |\n       ^    v                                         |      |\n     +---------+                                      |      |\n     |         |>---(D)-- Authorization Code ---------'      |\n     |  Client |          & Redirection URI                  |\n     |         |                                             |\n     |         |<---(E)----- Access Token -------------------'\n     +---------+       (w/ Optional Refresh Token)\n\n   Note: The lines illustrating steps (A), (B), and (C) are broken into\n   two parts as they pass through the user-agent.\n\n                     Figure 3: Authorization Code Flow\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 24]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The flow illustrated in Figure 3 includes the following steps:\n\n   (A)  The client initiates the flow by directing the resource owner's\n        user-agent to the authorization endpoint.  The client includes\n        its client identifier, requested scope, local state, and a\n        redirection URI to which the authorization server will send the\n        user-agent back once access is granted (or denied).\n\n   (B)  The authorization server authenticates the resource owner (via\n        the user-agent) and establishes whether the resource owner\n        grants or denies the client's access request.\n\n   (C)  Assuming the resource owner grants access, the authorization\n        server redirects the user-agent back to the client using the\n        redirection URI provided earlier (in the request or during\n        client registration).  The redirection URI includes an\n        authorization code and any local state provided by the client\n        earlier.\n\n   (D)  The client requests an access token from the authorization\n        server's token endpoint by including the authorization code\n        received in the previous step.  When making the request, the\n        client authenticates with the authorization server.  The client\n        includes the redirection URI used to obtain the authorization\n        code for verification.\n\n   (E)  The authorization server authenticates the client, validates the\n        authorization code, and ensures that the redirection URI\n        received matches the URI used to redirect the client in\n        step (C).  If valid, the authorization server responds back with\n        an access token and, optionally, a refresh token.\n\n4.1.1.  Authorization Request\n\n   The client constructs the request URI by adding the following\n   parameters to the query component of the authorization endpoint URI\n   using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   response_type\n         REQUIRED.  Value MUST be set to \"code\".\n\n   client_id\n         REQUIRED.  The client identifier as described in Section 2.2.\n\n   redirect_uri\n         OPTIONAL.  As described in Section 3.1.2.\n\n\n\n\n\nHardt                        Standards Track                   [Page 25]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   state\n         RECOMMENDED.  An opaque value used by the client to maintain\n         state between the request and callback.  The authorization\n         server includes this value when redirecting the user-agent back\n         to the client.  The parameter SHOULD be used for preventing\n         cross-site request forgery as described in Section 10.12.\n\n   The client directs the resource owner to the constructed URI using an\n   HTTP redirection response, or by other means available to it via the\n   user-agent.\n\n   For example, the client directs the user-agent to make the following\n   HTTP request using TLS (with extra line breaks for display purposes\n   only):\n\n    GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n    Host: server.example.com\n\n   The authorization server validates the request to ensure that all\n   required parameters are present and valid.  If the request is valid,\n   the authorization server authenticates the resource owner and obtains\n   an authorization decision (by asking the resource owner or by\n   establishing approval via other means).\n\n   When a decision is established, the authorization server directs the\n   user-agent to the provided client redirection URI using an HTTP\n   redirection response, or by other means available to it via the\n   user-agent.\n\n4.1.2.  Authorization Response\n\n   If the resource owner grants the access request, the authorization\n   server issues an authorization code and delivers it to the client by\n   adding the following parameters to the query component of the\n   redirection URI using the \"application/x-www-form-urlencoded\" format,\n   per Appendix B:\n\n   code\n         REQUIRED.  The authorization code generated by the\n         authorization server.  The authorization code MUST expire\n         shortly after it is issued to mitigate the risk of leaks.  A\n         maximum authorization code lifetime of 10 minutes is\n         RECOMMENDED.  The client MUST NOT use the authorization code\n\n\n\nHardt                        Standards Track                   [Page 26]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         more than once.  If an authorization code is used more than\n         once, the authorization server MUST deny the request and SHOULD\n         revoke (when possible) all tokens previously issued based on\n         that authorization code.  The authorization code is bound to\n         the client identifier and redirection URI.\n\n   state\n         REQUIRED if the \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n     HTTP/1.1 302 Found\n     Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n               &state=xyz\n\n   The client MUST ignore unrecognized response parameters.  The\n   authorization code string size is left undefined by this\n   specification.  The client should avoid making assumptions about code\n   value sizes.  The authorization server SHOULD document the size of\n   any value it issues.\n\n4.1.2.1.  Error Response\n\n   If the request fails due to a missing, invalid, or mismatching\n   redirection URI, or if the client identifier is missing or invalid,\n   the authorization server SHOULD inform the resource owner of the\n   error and MUST NOT automatically redirect the user-agent to the\n   invalid redirection URI.\n\n   If the resource owner denies the access request or if the request\n   fails for reasons other than a missing or invalid redirection URI,\n   the authorization server informs the client by adding the following\n   parameters to the query component of the redirection URI using the\n   \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               invalid parameter value, includes a parameter more than\n               once, or is otherwise malformed.\n\n\n\n\n\nHardt                        Standards Track                   [Page 27]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         unauthorized_client\n               The client is not authorized to request an authorization\n               code using this method.\n\n         access_denied\n               The resource owner or authorization server denied the\n               request.\n\n         unsupported_response_type\n               The authorization server does not support obtaining an\n               authorization code using this method.\n\n         invalid_scope\n               The requested scope is invalid, unknown, or malformed.\n\n         server_error\n               The authorization server encountered an unexpected\n               condition that prevented it from fulfilling the request.\n               (This error code is needed because a 500 Internal Server\n               Error HTTP status code cannot be returned to the client\n               via an HTTP redirect.)\n\n         temporarily_unavailable\n               The authorization server is currently unable to handle\n               the request due to a temporary overloading or maintenance\n               of the server.  (This error code is needed because a 503\n               Service Unavailable HTTP status code cannot be returned\n               to the client via an HTTP redirect.)\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n\n\n\n\nHardt                        Standards Track                   [Page 28]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   state\n         REQUIRED if a \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n   HTTP/1.1 302 Found\n   Location: https://client.example.com/cb?error=access_denied&state=xyz\n\n4.1.3.  Access Token Request\n\n   The client makes a request to the token endpoint by sending the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"authorization_code\".\n\n   code\n         REQUIRED.  The authorization code received from the\n         authorization server.\n\n   redirect_uri\n         REQUIRED, if the \"redirect_uri\" parameter was included in the\n         authorization request as described in Section 4.1.1, and their\n         values MUST be identical.\n\n   client_id\n         REQUIRED, if the client is not authenticating with the\n         authorization server as described in Section 3.2.1.\n\n   If the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 29]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, the client makes the following HTTP request using TLS\n   (with extra line breaks for display purposes only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n     &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included,\n\n   o  ensure that the authorization code was issued to the authenticated\n      confidential client, or if the client is public, ensure that the\n      code was issued to \"client_id\" in the request,\n\n   o  verify that the authorization code is valid, and\n\n   o  ensure that the \"redirect_uri\" parameter is present if the\n      \"redirect_uri\" parameter was included in the initial authorization\n      request as described in Section 4.1.1, and if included ensure that\n      their values are identical.\n\n4.1.4.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request client\n   authentication failed or is invalid, the authorization server returns\n   an error response as described in Section 5.2.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 30]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n4.2.  Implicit Grant\n\n   The implicit grant type is used to obtain access tokens (it does not\n   support the issuance of refresh tokens) and is optimized for public\n   clients known to operate a particular redirection URI.  These clients\n   are typically implemented in a browser using a scripting language\n   such as JavaScript.\n\n   Since this is a redirection-based flow, the client must be capable of\n   interacting with the resource owner's user-agent (typically a web\n   browser) and capable of receiving incoming requests (via redirection)\n   from the authorization server.\n\n   Unlike the authorization code grant type, in which the client makes\n   separate requests for authorization and for an access token, the\n   client receives the access token as the result of the authorization\n   request.\n\n   The implicit grant type does not include client authentication, and\n   relies on the presence of the resource owner and the registration of\n   the redirection URI.  Because the access token is encoded into the\n   redirection URI, it may be exposed to the resource owner and other\n   applications residing on the same device.\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 31]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n     +----------+\n     | Resource |\n     |  Owner   |\n     |          |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier     +---------------+\n     |         -+----(A)-- & Redirection URI --->|               |\n     |  User-   |                                | Authorization |\n     |  Agent  -|----(B)-- User authenticates -->|     Server    |\n     |          |                                |               |\n     |          |<---(C)--- Redirection URI ----<|               |\n     |          |          with Access Token     +---------------+\n     |          |            in Fragment\n     |          |                                +---------------+\n     |          |----(D)--- Redirection URI ---->|   Web-Hosted  |\n     |          |          without Fragment      |     Client    |\n     |          |                                |    Resource   |\n     |     (F)  |<---(E)------- Script ---------<|               |\n     |          |                                +---------------+\n     +-|--------+\n       |    |\n      (A)  (G) Access Token\n       |    |\n       ^    v\n     +---------+\n     |         |\n     |  Client |\n     |         |\n     +---------+\n\n   Note: The lines illustrating steps (A) and (B) are broken into two\n   parts as they pass through the user-agent.\n\n                       Figure 4: Implicit Grant Flow\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 32]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The flow illustrated in Figure 4 includes the following steps:\n\n   (A)  The client initiates the flow by directing the resource owner's\n        user-agent to the authorization endpoint.  The client includes\n        its client identifier, requested scope, local state, and a\n        redirection URI to which the authorization server will send the\n        user-agent back once access is granted (or denied).\n\n   (B)  The authorization server authenticates the resource owner (via\n        the user-agent) and establishes whether the resource owner\n        grants or denies the client's access request.\n\n   (C)  Assuming the resource owner grants access, the authorization\n        server redirects the user-agent back to the client using the\n        redirection URI provided earlier.  The redirection URI includes\n        the access token in the URI fragment.\n\n   (D)  The user-agent follows the redirection instructions by making a\n        request to the web-hosted client resource (which does not\n        include the fragment per [RFC2616]).  The user-agent retains the\n        fragment information locally.\n\n   (E)  The web-hosted client resource returns a web page (typically an\n        HTML document with an embedded script) capable of accessing the\n        full redirection URI including the fragment retained by the\n        user-agent, and extracting the access token (and other\n        parameters) contained in the fragment.\n\n   (F)  The user-agent executes the script provided by the web-hosted\n        client resource locally, which extracts the access token.\n\n   (G)  The user-agent passes the access token to the client.\n\n   See Sections 1.3.2 and 9 for background on using the implicit grant.\n   See Sections 10.3 and 10.16 for important security considerations\n   when using the implicit grant.\n\n4.2.1.  Authorization Request\n\n   The client constructs the request URI by adding the following\n   parameters to the query component of the authorization endpoint URI\n   using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   response_type\n         REQUIRED.  Value MUST be set to \"token\".\n\n   client_id\n         REQUIRED.  The client identifier as described in Section 2.2.\n\n\n\nHardt                        Standards Track                   [Page 33]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   redirect_uri\n         OPTIONAL.  As described in Section 3.1.2.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   state\n         RECOMMENDED.  An opaque value used by the client to maintain\n         state between the request and callback.  The authorization\n         server includes this value when redirecting the user-agent back\n         to the client.  The parameter SHOULD be used for preventing\n         cross-site request forgery as described in Section 10.12.\n\n   The client directs the resource owner to the constructed URI using an\n   HTTP redirection response, or by other means available to it via the\n   user-agent.\n\n   For example, the client directs the user-agent to make the following\n   HTTP request using TLS (with extra line breaks for display purposes\n   only):\n\n    GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz\n        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n    Host: server.example.com\n\n   The authorization server validates the request to ensure that all\n   required parameters are present and valid.  The authorization server\n   MUST verify that the redirection URI to which it will redirect the\n   access token matches a redirection URI registered by the client as\n   described in Section 3.1.2.\n\n   If the request is valid, the authorization server authenticates the\n   resource owner and obtains an authorization decision (by asking the\n   resource owner or by establishing approval via other means).\n\n   When a decision is established, the authorization server directs the\n   user-agent to the provided client redirection URI using an HTTP\n   redirection response, or by other means available to it via the\n   user-agent.\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 34]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.2.2.  Access Token Response\n\n   If the resource owner grants the access request, the authorization\n   server issues an access token and delivers it to the client by adding\n   the following parameters to the fragment component of the redirection\n   URI using the \"application/x-www-form-urlencoded\" format, per\n   Appendix B:\n\n   access_token\n         REQUIRED.  The access token issued by the authorization server.\n\n   token_type\n         REQUIRED.  The type of the token issued as described in\n         Section 7.1.  Value is case insensitive.\n\n   expires_in\n         RECOMMENDED.  The lifetime in seconds of the access token.  For\n         example, the value \"3600\" denotes that the access token will\n         expire in one hour from the time the response was generated.\n         If omitted, the authorization server SHOULD provide the\n         expiration time via other means or document the default value.\n\n   scope\n         OPTIONAL, if identical to the scope requested by the client;\n         otherwise, REQUIRED.  The scope of the access token as\n         described by Section 3.3.\n\n   state\n         REQUIRED if the \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   The authorization server MUST NOT issue a refresh token.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response (with extra line breaks for\n   display purposes only):\n\n     HTTP/1.1 302 Found\n     Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\n               &state=xyz&token_type=example&expires_in=3600\n\n   Developers should note that some user-agents do not support the\n   inclusion of a fragment component in the HTTP \"Location\" response\n   header field.  Such clients will require using other methods for\n   redirecting the client than a 3xx redirection response -- for\n   example, returning an HTML page that includes a 'continue' button\n   with an action linked to the redirection URI.\n\n\n\nHardt                        Standards Track                   [Page 35]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The client MUST ignore unrecognized response parameters.  The access\n   token string size is left undefined by this specification.  The\n   client should avoid making assumptions about value sizes.  The\n   authorization server SHOULD document the size of any value it issues.\n\n4.2.2.1.  Error Response\n\n   If the request fails due to a missing, invalid, or mismatching\n   redirection URI, or if the client identifier is missing or invalid,\n   the authorization server SHOULD inform the resource owner of the\n   error and MUST NOT automatically redirect the user-agent to the\n   invalid redirection URI.\n\n   If the resource owner denies the access request or if the request\n   fails for reasons other than a missing or invalid redirection URI,\n   the authorization server informs the client by adding the following\n   parameters to the fragment component of the redirection URI using the\n   \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               invalid parameter value, includes a parameter more than\n               once, or is otherwise malformed.\n\n         unauthorized_client\n               The client is not authorized to request an access token\n               using this method.\n\n         access_denied\n               The resource owner or authorization server denied the\n               request.\n\n         unsupported_response_type\n               The authorization server does not support obtaining an\n               access token using this method.\n\n         invalid_scope\n               The requested scope is invalid, unknown, or malformed.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 36]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         server_error\n               The authorization server encountered an unexpected\n               condition that prevented it from fulfilling the request.\n               (This error code is needed because a 500 Internal Server\n               Error HTTP status code cannot be returned to the client\n               via an HTTP redirect.)\n\n         temporarily_unavailable\n               The authorization server is currently unable to handle\n               the request due to a temporary overloading or maintenance\n               of the server.  (This error code is needed because a 503\n               Service Unavailable HTTP status code cannot be returned\n               to the client via an HTTP redirect.)\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n   state\n         REQUIRED if a \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n   HTTP/1.1 302 Found\n   Location: https://client.example.com/cb#error=access_denied&state=xyz\n\n4.3.  Resource Owner Password Credentials Grant\n\n   The resource owner password credentials grant type is suitable in\n   cases where the resource owner has a trust relationship with the\n   client, such as the device operating system or a highly privileged\n\n\n\nHardt                        Standards Track                   [Page 37]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   application.  The authorization server should take special care when\n   enabling this grant type and only allow it when other flows are not\n   viable.\n\n   This grant type is suitable for clients capable of obtaining the\n   resource owner's credentials (username and password, typically using\n   an interactive form).  It is also used to migrate existing clients\n   using direct authentication schemes such as HTTP Basic or Digest\n   authentication to OAuth by converting the stored credentials to an\n   access token.\n\n     +----------+\n     | Resource |\n     |  Owner   |\n     |          |\n     +----------+\n          v\n          |    Resource Owner\n         (A) Password Credentials\n          |\n          v\n     +---------+                                  +---------------+\n     |         |>--(B)---- Resource Owner ------->|               |\n     |         |         Password Credentials     | Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(C)---- Access Token ---------<|               |\n     |         |    (w/ Optional Refresh Token)   |               |\n     +---------+                                  +---------------+\n\n            Figure 5: Resource Owner Password Credentials Flow\n\n   The flow illustrated in Figure 5 includes the following steps:\n\n   (A)  The resource owner provides the client with its username and\n        password.\n\n   (B)  The client requests an access token from the authorization\n        server's token endpoint by including the credentials received\n        from the resource owner.  When making the request, the client\n        authenticates with the authorization server.\n\n   (C)  The authorization server authenticates the client and validates\n        the resource owner credentials, and if valid, issues an access\n        token.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 38]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.3.1.  Authorization Request and Response\n\n   The method through which the client obtains the resource owner\n   credentials is beyond the scope of this specification.  The client\n   MUST discard the credentials once an access token has been obtained.\n\n4.3.2.  Access Token Request\n\n   The client makes a request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"password\".\n\n   username\n         REQUIRED.  The resource owner username.\n\n   password\n         REQUIRED.  The resource owner password.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   If the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=password&username=johndoe&password=A3ddj3w\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 39]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included, and\n\n   o  validate the resource owner password credentials using its\n      existing password validation algorithm.\n\n   Since this access token request utilizes the resource owner's\n   password, the authorization server MUST protect the endpoint against\n   brute force attacks (e.g., using rate-limitation or generating\n   alerts).\n\n4.3.3.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n4.4.  Client Credentials Grant\n\n   The client can request an access token using only its client\n   credentials (or other supported means of authentication) when the\n   client is requesting access to the protected resources under its\n   control, or those of another resource owner that have been previously\n   arranged with the authorization server (the method of which is beyond\n   the scope of this specification).\n\n\n\n\nHardt                        Standards Track                   [Page 40]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The client credentials grant type MUST only be used by confidential\n   clients.\n\n     +---------+                                  +---------------+\n     |         |                                  |               |\n     |         |>--(A)- Client Authentication --->| Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(B)---- Access Token ---------<|               |\n     |         |                                  |               |\n     +---------+                                  +---------------+\n\n                     Figure 6: Client Credentials Flow\n\n   The flow illustrated in Figure 6 includes the following steps:\n\n   (A)  The client authenticates with the authorization server and\n        requests an access token from the token endpoint.\n\n   (B)  The authorization server authenticates the client, and if valid,\n        issues an access token.\n\n4.4.1.  Authorization Request and Response\n\n   Since the client authentication is used as the authorization grant,\n   no additional authorization request is needed.\n\n4.4.2.  Access Token Request\n\n   The client makes a request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"client_credentials\".\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   The client MUST authenticate with the authorization server as\n   described in Section 3.2.1.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 41]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=client_credentials\n\n   The authorization server MUST authenticate the client.\n\n4.4.3.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token as described in\n   Section 5.1.  A refresh token SHOULD NOT be included.  If the request\n   failed client authentication or is invalid, the authorization server\n   returns an error response as described in Section 5.2.\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"example_parameter\":\"example_value\"\n     }\n\n4.5.  Extension Grants\n\n   The client uses an extension grant type by specifying the grant type\n   using an absolute URI (defined by the authorization server) as the\n   value of the \"grant_type\" parameter of the token endpoint, and by\n   adding any additional parameters necessary.\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 42]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, to request an access token using a Security Assertion\n   Markup Language (SAML) 2.0 assertion grant type as defined by\n   [OAuth-SAML2], the client could make the following HTTP request using\n   TLS (with extra line breaks for display purposes only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-\n     bearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU\n     [...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n5.  Issuing an Access Token\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n5.1.  Successful Response\n\n   The authorization server issues an access token and optional refresh\n   token, and constructs the response by adding the following parameters\n   to the entity-body of the HTTP response with a 200 (OK) status code:\n\n   access_token\n         REQUIRED.  The access token issued by the authorization server.\n\n   token_type\n         REQUIRED.  The type of the token issued as described in\n         Section 7.1.  Value is case insensitive.\n\n   expires_in\n         RECOMMENDED.  The lifetime in seconds of the access token.  For\n         example, the value \"3600\" denotes that the access token will\n         expire in one hour from the time the response was generated.\n         If omitted, the authorization server SHOULD provide the\n         expiration time via other means or document the default value.\n\n\n\n\n\nHardt                        Standards Track                   [Page 43]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   refresh_token\n         OPTIONAL.  The refresh token, which can be used to obtain new\n         access tokens using the same authorization grant as described\n         in Section 6.\n\n   scope\n         OPTIONAL, if identical to the scope requested by the client;\n         otherwise, REQUIRED.  The scope of the access token as\n         described by Section 3.3.\n\n   The parameters are included in the entity-body of the HTTP response\n   using the \"application/json\" media type as defined by [RFC4627].  The\n   parameters are serialized into a JavaScript Object Notation (JSON)\n   structure by adding each parameter at the highest structure level.\n   Parameter names and string values are included as JSON strings.\n   Numerical values are included as JSON numbers.  The order of\n   parameters does not matter and can vary.\n\n   The authorization server MUST include the HTTP \"Cache-Control\"\n   response header field [RFC2616] with a value of \"no-store\" in any\n   response containing tokens, credentials, or other sensitive\n   information, as well as the \"Pragma\" response header field [RFC2616]\n   with a value of \"no-cache\".\n\n   For example:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n   The client MUST ignore unrecognized value names in the response.  The\n   sizes of tokens and other values received from the authorization\n   server are left undefined.  The client should avoid making\n   assumptions about value sizes.  The authorization server SHOULD\n   document the size of any value it issues.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 44]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n5.2.  Error Response\n\n   The authorization server responds with an HTTP 400 (Bad Request)\n   status code (unless specified otherwise) and includes the following\n   parameters with the response:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               unsupported parameter value (other than grant type),\n               repeats a parameter, includes multiple credentials,\n               utilizes more than one mechanism for authenticating the\n               client, or is otherwise malformed.\n\n         invalid_client\n               Client authentication failed (e.g., unknown client, no\n               client authentication included, or unsupported\n               authentication method).  The authorization server MAY\n               return an HTTP 401 (Unauthorized) status code to indicate\n               which HTTP authentication schemes are supported.  If the\n               client attempted to authenticate via the \"Authorization\"\n               request header field, the authorization server MUST\n               respond with an HTTP 401 (Unauthorized) status code and\n               include the \"WWW-Authenticate\" response header field\n               matching the authentication scheme used by the client.\n\n         invalid_grant\n               The provided authorization grant (e.g., authorization\n               code, resource owner credentials) or refresh token is\n               invalid, expired, revoked, does not match the redirection\n               URI used in the authorization request, or was issued to\n               another client.\n\n         unauthorized_client\n               The authenticated client is not authorized to use this\n               authorization grant type.\n\n         unsupported_grant_type\n               The authorization grant type is not supported by the\n               authorization server.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 45]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         invalid_scope\n               The requested scope is invalid, unknown, malformed, or\n               exceeds the scope granted by the resource owner.\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n   The parameters are included in the entity-body of the HTTP response\n   using the \"application/json\" media type as defined by [RFC4627].  The\n   parameters are serialized into a JSON structure by adding each\n   parameter at the highest structure level.  Parameter names and string\n   values are included as JSON strings.  Numerical values are included\n   as JSON numbers.  The order of parameters does not matter and can\n   vary.\n\n   For example:\n\n     HTTP/1.1 400 Bad Request\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"error\":\"invalid_request\"\n     }\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 46]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n6.  Refreshing an Access Token\n\n   If the authorization server issued a refresh token to the client, the\n   client makes a refresh request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"refresh_token\".\n\n   refresh_token\n         REQUIRED.  The refresh token issued to the client.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.  The requested scope MUST NOT include any scope\n         not originally granted by the resource owner, and if omitted is\n         treated as equal to the scope originally granted by the\n         resource owner.\n\n   Because refresh tokens are typically long-lasting credentials used to\n   request additional access tokens, the refresh token is bound to the\n   client to which it was issued.  If the client type is confidential or\n   the client was issued client credentials (or assigned other\n   authentication requirements), the client MUST authenticate with the\n   authorization server as described in Section 3.2.1.\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 47]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included and\n      ensure that the refresh token was issued to the authenticated\n      client, and\n\n   o  validate the refresh token.\n\n   If valid and authorized, the authorization server issues an access\n   token as described in Section 5.1.  If the request failed\n   verification or is invalid, the authorization server returns an error\n   response as described in Section 5.2.\n\n   The authorization server MAY issue a new refresh token, in which case\n   the client MUST discard the old refresh token and replace it with the\n   new refresh token.  The authorization server MAY revoke the old\n   refresh token after issuing a new refresh token to the client.  If a\n   new refresh token is issued, the refresh token scope MUST be\n   identical to that of the refresh token included by the client in the\n   request.\n\n7.  Accessing Protected Resources\n\n   The client accesses protected resources by presenting the access\n   token to the resource server.  The resource server MUST validate the\n   access token and ensure that it has not expired and that its scope\n   covers the requested resource.  The methods used by the resource\n   server to validate the access token (as well as any error responses)\n   are beyond the scope of this specification but generally involve an\n   interaction or coordination between the resource server and the\n   authorization server.\n\n   The method in which the client utilizes the access token to\n   authenticate with the resource server depends on the type of access\n   token issued by the authorization server.  Typically, it involves\n   using the HTTP \"Authorization\" request header field [RFC2617] with an\n   authentication scheme defined by the specification of the access\n   token type used, such as [RFC6750].\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 48]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n7.1.  Access Token Types\n\n   The access token type provides the client with the information\n   required to successfully utilize the access token to make a protected\n   resource request (along with type-specific attributes).  The client\n   MUST NOT use an access token if it does not understand the token\n   type.\n\n   For example, the \"bearer\" token type defined in [RFC6750] is utilized\n   by simply including the access token string in the request:\n\n     GET /resource/1 HTTP/1.1\n     Host: example.com\n     Authorization: Bearer mF_9.B5f-4.1JqM\n\n   while the \"mac\" token type defined in [OAuth-HTTP-MAC] is utilized by\n   issuing a Message Authentication Code (MAC) key together with the\n   access token that is used to sign certain components of the HTTP\n   requests:\n\n     GET /resource/1 HTTP/1.1\n     Host: example.com\n     Authorization: MAC id=\"h480djs93hd8\",\n                        nonce=\"274312:dj83hs9s\",\n                        mac=\"kDZvddkndxvhGRXZhvuDjEWhGeE=\"\n\n   The above examples are provided for illustration purposes only.\n   Developers are advised to consult the [RFC6750] and [OAuth-HTTP-MAC]\n   specifications before use.\n\n   Each access token type definition specifies the additional attributes\n   (if any) sent to the client together with the \"access_token\" response\n   parameter.  It also defines the HTTP authentication method used to\n   include the access token when making a protected resource request.\n\n7.2.  Error Response\n\n   If a resource access request fails, the resource server SHOULD inform\n   the client of the error.  While the specifics of such error responses\n   are beyond the scope of this specification, this document establishes\n   a common registry in Section 11.4 for error values to be shared among\n   OAuth token authentication schemes.\n\n   New authentication schemes designed primarily for OAuth token\n   authentication SHOULD define a mechanism for providing an error\n   status code to the client, in which the error values allowed are\n   registered in the error registry established by this specification.\n\n\n\n\nHardt                        Standards Track                   [Page 49]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Such schemes MAY limit the set of valid error codes to a subset of\n   the registered values.  If the error code is returned using a named\n   parameter, the parameter name SHOULD be \"error\".\n\n   Other schemes capable of being used for OAuth token authentication,\n   but not primarily designed for that purpose, MAY bind their error\n   values to the registry in the same manner.\n\n   New authentication schemes MAY choose to also specify the use of the\n   \"error_description\" and \"error_uri\" parameters to return error\n   information in a manner parallel to their usage in this\n   specification.\n\n8.  Extensibility\n\n8.1.  Defining Access Token Types\n\n   Access token types can be defined in one of two ways: registered in\n   the Access Token Types registry (following the procedures in\n   Section 11.1), or by using a unique absolute URI as its name.\n\n   Types utilizing a URI name SHOULD be limited to vendor-specific\n   implementations that are not commonly applicable, and are specific to\n   the implementation details of the resource server where they are\n   used.\n\n   All other types MUST be registered.  Type names MUST conform to the\n   type-name ABNF.  If the type definition includes a new HTTP\n   authentication scheme, the type name SHOULD be identical to the HTTP\n   authentication scheme name (as defined by [RFC2617]).  The token type\n   \"example\" is reserved for use in examples.\n\n     type-name  = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\n8.2.  Defining New Endpoint Parameters\n\n   New request or response parameters for use with the authorization\n   endpoint or the token endpoint are defined and registered in the\n   OAuth Parameters registry following the procedure in Section 11.2.\n\n   Parameter names MUST conform to the param-name ABNF, and parameter\n   values syntax MUST be well-defined (e.g., using ABNF, or a reference\n   to the syntax of an existing parameter).\n\n     param-name  = 1*name-char\n     name-char   = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\n\n\n\nHardt                        Standards Track                   [Page 50]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Unregistered vendor-specific parameter extensions that are not\n   commonly applicable and that are specific to the implementation\n   details of the authorization server where they are used SHOULD\n   utilize a vendor-specific prefix that is not likely to conflict with\n   other registered values (e.g., begin with 'companyname_').\n\n8.3.  Defining New Authorization Grant Types\n\n   New authorization grant types can be defined by assigning them a\n   unique absolute URI for use with the \"grant_type\" parameter.  If the\n   extension grant type requires additional token endpoint parameters,\n   they MUST be registered in the OAuth Parameters registry as described\n   by Section 11.2.\n\n8.4.  Defining New Authorization Endpoint Response Types\n\n   New response types for use with the authorization endpoint are\n   defined and registered in the Authorization Endpoint Response Types\n   registry following the procedure in Section 11.3.  Response type\n   names MUST conform to the response-type ABNF.\n\n     response-type  = response-name *( SP response-name )\n     response-name  = 1*response-char\n     response-char  = \"_\" / DIGIT / ALPHA\n\n   If a response type contains one or more space characters (%x20), it\n   is compared as a space-delimited list of values in which the order of\n   values does not matter.  Only one order of values can be registered,\n   which covers all other arrangements of the same set of values.\n\n   For example, the response type \"token code\" is left undefined by this\n   specification.  However, an extension can define and register the\n   \"token code\" response type.  Once registered, the same combination\n   cannot be registered as \"code token\", but both values can be used to\n   denote the same response type.\n\n8.5.  Defining Additional Error Codes\n\n   In cases where protocol extensions (i.e., access token types,\n   extension parameters, or extension grant types) require additional\n   error codes to be used with the authorization code grant error\n   response (Section 4.1.2.1), the implicit grant error response\n   (Section 4.2.2.1), the token error response (Section 5.2), or the\n   resource access error response (Section 7.2), such error codes MAY be\n   defined.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 51]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Extension error codes MUST be registered (following the procedures in\n   Section 11.4) if the extension they are used in conjunction with is a\n   registered access token type, a registered endpoint parameter, or an\n   extension grant type.  Error codes used with unregistered extensions\n   MAY be registered.\n\n   Error codes MUST conform to the error ABNF and SHOULD be prefixed by\n   an identifying name when possible.  For example, an error identifying\n   an invalid value set to the extension parameter \"example\" SHOULD be\n   named \"example_invalid\".\n\n     error      = 1*error-char\n     error-char = %x20-21 / %x23-5B / %x5D-7E\n\n9.  Native Applications\n\n   Native applications are clients installed and executed on the device\n   used by the resource owner (i.e., desktop application, native mobile\n   application).  Native applications require special consideration\n   related to security, platform capabilities, and overall end-user\n   experience.\n\n   The authorization endpoint requires interaction between the client\n   and the resource owner's user-agent.  Native applications can invoke\n   an external user-agent or embed a user-agent within the application.\n   For example:\n\n   o  External user-agent - the native application can capture the\n      response from the authorization server using a redirection URI\n      with a scheme registered with the operating system to invoke the\n      client as the handler, manual copy-and-paste of the credentials,\n      running a local web server, installing a user-agent extension, or\n      by providing a redirection URI identifying a server-hosted\n      resource under the client's control, which in turn makes the\n      response available to the native application.\n\n   o  Embedded user-agent - the native application obtains the response\n      by directly communicating with the embedded user-agent by\n      monitoring state changes emitted during the resource load, or\n      accessing the user-agent's cookies storage.\n\n   When choosing between an external or embedded user-agent, developers\n   should consider the following:\n\n   o  An external user-agent may improve completion rate, as the\n      resource owner may already have an active session with the\n      authorization server, removing the need to re-authenticate.  It\n      provides a familiar end-user experience and functionality.  The\n\n\n\nHardt                        Standards Track                   [Page 52]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n      resource owner may also rely on user-agent features or extensions\n      to assist with authentication (e.g., password manager, 2-factor\n      device reader).\n\n   o  An embedded user-agent may offer improved usability, as it removes\n      the need to switch context and open new windows.\n\n   o  An embedded user-agent poses a security challenge because resource\n      owners are authenticating in an unidentified window without access\n      to the visual protections found in most external user-agents.  An\n      embedded user-agent educates end-users to trust unidentified\n      requests for authentication (making phishing attacks easier to\n      execute).\n\n   When choosing between the implicit grant type and the authorization\n   code grant type, the following should be considered:\n\n   o  Native applications that use the authorization code grant type\n      SHOULD do so without using client credentials, due to the native\n      application's inability to keep client credentials confidential.\n\n   o  When using the implicit grant type flow, a refresh token is not\n      returned, which requires repeating the authorization process once\n      the access token expires.\n\n10.  Security Considerations\n\n   As a flexible and extensible framework, OAuth's security\n   considerations depend on many factors.  The following sections\n   provide implementers with security guidelines focused on the three\n   client profiles described in Section 2.1: web application,\n   user-agent-based application, and native application.\n\n   A comprehensive OAuth security model and analysis, as well as\n   background for the protocol design, is provided by\n   [OAuth-THREATMODEL].\n\n10.1.  Client Authentication\n\n   The authorization server establishes client credentials with web\n   application clients for the purpose of client authentication.  The\n   authorization server is encouraged to consider stronger client\n   authentication means than a client password.  Web application clients\n   MUST ensure confidentiality of client passwords and other client\n   credentials.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 53]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST NOT issue client passwords or other\n   client credentials to native application or user-agent-based\n   application clients for the purpose of client authentication.  The\n   authorization server MAY issue a client password or other credentials\n   for a specific installation of a native application client on a\n   specific device.\n\n   When client authentication is not possible, the authorization server\n   SHOULD employ other means to validate the client's identity -- for\n   example, by requiring the registration of the client redirection URI\n   or enlisting the resource owner to confirm identity.  A valid\n   redirection URI is not sufficient to verify the client's identity\n   when asking for resource owner authorization but can be used to\n   prevent delivering credentials to a counterfeit client after\n   obtaining resource owner authorization.\n\n   The authorization server must consider the security implications of\n   interacting with unauthenticated clients and take measures to limit\n   the potential exposure of other credentials (e.g., refresh tokens)\n   issued to such clients.\n\n10.2.  Client Impersonation\n\n   A malicious client can impersonate another client and obtain access\n   to protected resources if the impersonated client fails to, or is\n   unable to, keep its client credentials confidential.\n\n   The authorization server MUST authenticate the client whenever\n   possible.  If the authorization server cannot authenticate the client\n   due to the client's nature, the authorization server MUST require the\n   registration of any redirection URI used for receiving authorization\n   responses and SHOULD utilize other means to protect resource owners\n   from such potentially malicious clients.  For example, the\n   authorization server can engage the resource owner to assist in\n   identifying the client and its origin.\n\n   The authorization server SHOULD enforce explicit resource owner\n   authentication and provide the resource owner with information about\n   the client and the requested authorization scope and lifetime.  It is\n   up to the resource owner to review the information in the context of\n   the current client and to authorize or deny the request.\n\n   The authorization server SHOULD NOT process repeated authorization\n   requests automatically (without active resource owner interaction)\n   without authenticating the client or relying on other measures to\n   ensure that the repeated request comes from the original client and\n   not an impersonator.\n\n\n\n\nHardt                        Standards Track                   [Page 54]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.3.  Access Tokens\n\n   Access token credentials (as well as any confidential access token\n   attributes) MUST be kept confidential in transit and storage, and\n   only shared among the authorization server, the resource servers the\n   access token is valid for, and the client to whom the access token is\n   issued.  Access token credentials MUST only be transmitted using TLS\n   as described in Section 1.6 with server authentication as defined by\n   [RFC2818].\n\n   When using the implicit grant type, the access token is transmitted\n   in the URI fragment, which can expose it to unauthorized parties.\n\n   The authorization server MUST ensure that access tokens cannot be\n   generated, modified, or guessed to produce valid access tokens by\n   unauthorized parties.\n\n   The client SHOULD request access tokens with the minimal scope\n   necessary.  The authorization server SHOULD take the client identity\n   into account when choosing how to honor the requested scope and MAY\n   issue an access token with less rights than requested.\n\n   This specification does not provide any methods for the resource\n   server to ensure that an access token presented to it by a given\n   client was issued to that client by the authorization server.\n\n10.4.  Refresh Tokens\n\n   Authorization servers MAY issue refresh tokens to web application\n   clients and native application clients.\n\n   Refresh tokens MUST be kept confidential in transit and storage, and\n   shared only among the authorization server and the client to whom the\n   refresh tokens were issued.  The authorization server MUST maintain\n   the binding between a refresh token and the client to whom it was\n   issued.  Refresh tokens MUST only be transmitted using TLS as\n   described in Section 1.6 with server authentication as defined by\n   [RFC2818].\n\n   The authorization server MUST verify the binding between the refresh\n   token and client identity whenever the client identity can be\n   authenticated.  When client authentication is not possible, the\n   authorization server SHOULD deploy other means to detect refresh\n   token abuse.\n\n   For example, the authorization server could employ refresh token\n   rotation in which a new refresh token is issued with every access\n   token refresh response.  The previous refresh token is invalidated\n\n\n\nHardt                        Standards Track                   [Page 55]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   but retained by the authorization server.  If a refresh token is\n   compromised and subsequently used by both the attacker and the\n   legitimate client, one of them will present an invalidated refresh\n   token, which will inform the authorization server of the breach.\n\n   The authorization server MUST ensure that refresh tokens cannot be\n   generated, modified, or guessed to produce valid refresh tokens by\n   unauthorized parties.\n\n10.5.  Authorization Codes\n\n   The transmission of authorization codes SHOULD be made over a secure\n   channel, and the client SHOULD require the use of TLS with its\n   redirection URI if the URI identifies a network resource.  Since\n   authorization codes are transmitted via user-agent redirections, they\n   could potentially be disclosed through user-agent history and HTTP\n   referrer headers.\n\n   Authorization codes operate as plaintext bearer credentials, used to\n   verify that the resource owner who granted authorization at the\n   authorization server is the same resource owner returning to the\n   client to complete the process.  Therefore, if the client relies on\n   the authorization code for its own resource owner authentication, the\n   client redirection endpoint MUST require the use of TLS.\n\n   Authorization codes MUST be short lived and single-use.  If the\n   authorization server observes multiple attempts to exchange an\n   authorization code for an access token, the authorization server\n   SHOULD attempt to revoke all access tokens already granted based on\n   the compromised authorization code.\n\n   If the client can be authenticated, the authorization servers MUST\n   authenticate the client and ensure that the authorization code was\n   issued to the same client.\n\n10.6.  Authorization Code Redirection URI Manipulation\n\n   When requesting authorization using the authorization code grant\n   type, the client can specify a redirection URI via the \"redirect_uri\"\n   parameter.  If an attacker can manipulate the value of the\n   redirection URI, it can cause the authorization server to redirect\n   the resource owner user-agent to a URI under the control of the\n   attacker with the authorization code.\n\n   An attacker can create an account at a legitimate client and initiate\n   the authorization flow.  When the attacker's user-agent is sent to\n   the authorization server to grant access, the attacker grabs the\n   authorization URI provided by the legitimate client and replaces the\n\n\n\nHardt                        Standards Track                   [Page 56]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   client's redirection URI with a URI under the control of the\n   attacker.  The attacker then tricks the victim into following the\n   manipulated link to authorize access to the legitimate client.\n\n   Once at the authorization server, the victim is prompted with a\n   normal, valid request on behalf of a legitimate and trusted client,\n   and authorizes the request.  The victim is then redirected to an\n   endpoint under the control of the attacker with the authorization\n   code.  The attacker completes the authorization flow by sending the\n   authorization code to the client using the original redirection URI\n   provided by the client.  The client exchanges the authorization code\n   with an access token and links it to the attacker's client account,\n   which can now gain access to the protected resources authorized by\n   the victim (via the client).\n\n   In order to prevent such an attack, the authorization server MUST\n   ensure that the redirection URI used to obtain the authorization code\n   is identical to the redirection URI provided when exchanging the\n   authorization code for an access token.  The authorization server\n   MUST require public clients and SHOULD require confidential clients\n   to register their redirection URIs.  If a redirection URI is provided\n   in the request, the authorization server MUST validate it against the\n   registered value.\n\n10.7.  Resource Owner Password Credentials\n\n   The resource owner password credentials grant type is often used for\n   legacy or migration reasons.  It reduces the overall risk of storing\n   usernames and passwords by the client but does not eliminate the need\n   to expose highly privileged credentials to the client.\n\n   This grant type carries a higher risk than other grant types because\n   it maintains the password anti-pattern this protocol seeks to avoid.\n   The client could abuse the password, or the password could\n   unintentionally be disclosed to an attacker (e.g., via log files or\n   other records kept by the client).\n\n   Additionally, because the resource owner does not have control over\n   the authorization process (the resource owner's involvement ends when\n   it hands over its credentials to the client), the client can obtain\n   access tokens with a broader scope than desired by the resource\n   owner.  The authorization server should consider the scope and\n   lifetime of access tokens issued via this grant type.\n\n   The authorization server and client SHOULD minimize use of this grant\n   type and utilize other grant types whenever possible.\n\n\n\n\n\nHardt                        Standards Track                   [Page 57]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.8.  Request Confidentiality\n\n   Access tokens, refresh tokens, resource owner passwords, and client\n   credentials MUST NOT be transmitted in the clear.  Authorization\n   codes SHOULD NOT be transmitted in the clear.\n\n   The \"state\" and \"scope\" parameters SHOULD NOT include sensitive\n   client or resource owner information in plain text, as they can be\n   transmitted over insecure channels or stored insecurely.\n\n10.9.  Ensuring Endpoint Authenticity\n\n   In order to prevent man-in-the-middle attacks, the authorization\n   server MUST require the use of TLS with server authentication as\n   defined by [RFC2818] for any request sent to the authorization and\n   token endpoints.  The client MUST validate the authorization server's\n   TLS certificate as defined by [RFC6125] and in accordance with its\n   requirements for server identity authentication.\n\n10.10.  Credentials-Guessing Attacks\n\n   The authorization server MUST prevent attackers from guessing access\n   tokens, authorization codes, refresh tokens, resource owner\n   passwords, and client credentials.\n\n   The probability of an attacker guessing generated tokens (and other\n   credentials not intended for handling by end-users) MUST be less than\n   or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).\n\n   The authorization server MUST utilize other means to protect\n   credentials intended for end-user usage.\n\n10.11.  Phishing Attacks\n\n   Wide deployment of this and similar protocols may cause end-users to\n   become inured to the practice of being redirected to websites where\n   they are asked to enter their passwords.  If end-users are not\n   careful to verify the authenticity of these websites before entering\n   their credentials, it will be possible for attackers to exploit this\n   practice to steal resource owners' passwords.\n\n   Service providers should attempt to educate end-users about the risks\n   phishing attacks pose and should provide mechanisms that make it easy\n   for end-users to confirm the authenticity of their sites.  Client\n   developers should consider the security implications of how they\n   interact with the user-agent (e.g., external, embedded), and the\n   ability of the end-user to verify the authenticity of the\n   authorization server.\n\n\n\nHardt                        Standards Track                   [Page 58]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   To reduce the risk of phishing attacks, the authorization servers\n   MUST require the use of TLS on every endpoint used for end-user\n   interaction.\n\n10.12.  Cross-Site Request Forgery\n\n   Cross-site request forgery (CSRF) is an exploit in which an attacker\n   causes the user-agent of a victim end-user to follow a malicious URI\n   (e.g., provided to the user-agent as a misleading link, image, or\n   redirection) to a trusting server (usually established via the\n   presence of a valid session cookie).\n\n   A CSRF attack against the client's redirection URI allows an attacker\n   to inject its own authorization code or access token, which can\n   result in the client using an access token associated with the\n   attacker's protected resources rather than the victim's (e.g., save\n   the victim's bank account information to a protected resource\n   controlled by the attacker).\n\n   The client MUST implement CSRF protection for its redirection URI.\n   This is typically accomplished by requiring any request sent to the\n   redirection URI endpoint to include a value that binds the request to\n   the user-agent's authenticated state (e.g., a hash of the session\n   cookie used to authenticate the user-agent).  The client SHOULD\n   utilize the \"state\" request parameter to deliver this value to the\n   authorization server when making an authorization request.\n\n   Once authorization has been obtained from the end-user, the\n   authorization server redirects the end-user's user-agent back to the\n   client with the required binding value contained in the \"state\"\n   parameter.  The binding value enables the client to verify the\n   validity of the request by matching the binding value to the\n   user-agent's authenticated state.  The binding value used for CSRF\n   protection MUST contain a non-guessable value (as described in\n   Section 10.10), and the user-agent's authenticated state (e.g.,\n   session cookie, HTML5 local storage) MUST be kept in a location\n   accessible only to the client and the user-agent (i.e., protected by\n   same-origin policy).\n\n   A CSRF attack against the authorization server's authorization\n   endpoint can result in an attacker obtaining end-user authorization\n   for a malicious client without involving or alerting the end-user.\n\n   The authorization server MUST implement CSRF protection for its\n   authorization endpoint and ensure that a malicious client cannot\n   obtain authorization without the awareness and explicit consent of\n   the resource owner.\n\n\n\n\nHardt                        Standards Track                   [Page 59]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.13.  Clickjacking\n\n   In a clickjacking attack, an attacker registers a legitimate client\n   and then constructs a malicious site in which it loads the\n   authorization server's authorization endpoint web page in a\n   transparent iframe overlaid on top of a set of dummy buttons, which\n   are carefully constructed to be placed directly under important\n   buttons on the authorization page.  When an end-user clicks a\n   misleading visible button, the end-user is actually clicking an\n   invisible button on the authorization page (such as an \"Authorize\"\n   button).  This allows an attacker to trick a resource owner into\n   granting its client access without the end-user's knowledge.\n\n   To prevent this form of attack, native applications SHOULD use\n   external browsers instead of embedding browsers within the\n   application when requesting end-user authorization.  For most newer\n   browsers, avoidance of iframes can be enforced by the authorization\n   server using the (non-standard) \"x-frame-options\" header.  This\n   header can have two values, \"deny\" and \"sameorigin\", which will block\n   any framing, or framing by sites with a different origin,\n   respectively.  For older browsers, JavaScript frame-busting\n   techniques can be used but may not be effective in all browsers.\n\n10.14.  Code Injection and Input Validation\n\n   A code injection attack occurs when an input or otherwise external\n   variable is used by an application unsanitized and causes\n   modification to the application logic.  This may allow an attacker to\n   gain access to the application device or its data, cause denial of\n   service, or introduce a wide range of malicious side-effects.\n\n   The authorization server and client MUST sanitize (and validate when\n   possible) any value received -- in particular, the value of the\n   \"state\" and \"redirect_uri\" parameters.\n\n10.15.  Open Redirectors\n\n   The authorization server, authorization endpoint, and client\n   redirection endpoint can be improperly configured and operate as open\n   redirectors.  An open redirector is an endpoint using a parameter to\n   automatically redirect a user-agent to the location specified by the\n   parameter value without any validation.\n\n   Open redirectors can be used in phishing attacks, or by an attacker\n   to get end-users to visit malicious sites by using the URI authority\n   component of a familiar and trusted destination.  In addition, if the\n   authorization server allows the client to register only part of the\n   redirection URI, an attacker can use an open redirector operated by\n\n\n\nHardt                        Standards Track                   [Page 60]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   the client to construct a redirection URI that will pass the\n   authorization server validation but will send the authorization code\n   or access token to an endpoint under the control of the attacker.\n\n10.16.  Misuse of Access Token to Impersonate Resource Owner in Implicit\n        Flow\n\n   For public clients using implicit flows, this specification does not\n   provide any method for the client to determine what client an access\n   token was issued to.\n\n   A resource owner may willingly delegate access to a resource by\n   granting an access token to an attacker's malicious client.  This may\n   be due to phishing or some other pretext.  An attacker may also steal\n   a token via some other mechanism.  An attacker may then attempt to\n   impersonate the resource owner by providing the access token to a\n   legitimate public client.\n\n   In the implicit flow (response_type=token), the attacker can easily\n   switch the token in the response from the authorization server,\n   replacing the real access token with the one previously issued to the\n   attacker.\n\n   Servers communicating with native applications that rely on being\n   passed an access token in the back channel to identify the user of\n   the client may be similarly compromised by an attacker creating a\n   compromised application that can inject arbitrary stolen access\n   tokens.\n\n   Any public client that makes the assumption that only the resource\n   owner can present it with a valid access token for the resource is\n   vulnerable to this type of attack.\n\n   This type of attack may expose information about the resource owner\n   at the legitimate client to the attacker (malicious client).  This\n   will also allow the attacker to perform operations at the legitimate\n   client with the same permissions as the resource owner who originally\n   granted the access token or authorization code.\n\n   Authenticating resource owners to clients is out of scope for this\n   specification.  Any specification that uses the authorization process\n   as a form of delegated end-user authentication to the client (e.g.,\n   third-party sign-in service) MUST NOT use the implicit flow without\n   additional security mechanisms that would enable the client to\n   determine if the access token was issued for its use (e.g., audience-\n   restricting the access token).\n\n\n\n\n\nHardt                        Standards Track                   [Page 61]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.  IANA Considerations\n\n11.1.  OAuth Access Token Types Registry\n\n   This specification establishes the OAuth Access Token Types registry.\n\n   Access token types are registered with a Specification Required\n   ([RFC5226]) after a two-week review period on the\n   oauth-ext-review@ietf.org mailing list, on the advice of one or more\n   Designated Experts.  However, to allow for the allocation of values\n   prior to publication, the Designated Expert(s) may approve\n   registration once they are satisfied that such a specification will\n   be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for access token type: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.1.1.  Registration Template\n\n   Type name:\n      The name requested (e.g., \"example\").\n\n   Additional Token Endpoint Response Parameters:\n      Additional response parameters returned together with the\n      \"access_token\" parameter.  New parameters MUST be separately\n      registered in the OAuth Parameters registry as described by\n      Section 11.2.\n\n   HTTP Authentication Scheme(s):\n      The HTTP authentication scheme name(s), if any, used to\n      authenticate protected resource requests using access tokens of\n      this type.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n\n\nHardt                        Standards Track                   [Page 62]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Specification document(s):\n      Reference to the document(s) that specify the parameter,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n11.2.  OAuth Parameters Registry\n\n   This specification establishes the OAuth Parameters registry.\n\n   Additional parameters for inclusion in the authorization endpoint\n   request, the authorization endpoint response, the token endpoint\n   request, or the token endpoint response are registered with a\n   Specification Required ([RFC5226]) after a two-week review period on\n   the oauth-ext-review@ietf.org mailing list, on the advice of one or\n   more Designated Experts.  However, to allow for the allocation of\n   values prior to publication, the Designated Expert(s) may approve\n   registration once they are satisfied that such a specification will\n   be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for parameter: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.2.1.  Registration Template\n\n   Parameter name:\n      The name requested (e.g., \"example\").\n\n   Parameter usage location:\n      The location(s) where parameter can be used.  The possible\n      locations are authorization request, authorization response, token\n      request, or token response.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n\n\nHardt                        Standards Track                   [Page 63]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Specification document(s):\n      Reference to the document(s) that specify the parameter,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n11.2.2.  Initial Registry Contents\n\n   The OAuth Parameters registry's initial contents are:\n\n   o  Parameter name: client_id\n   o  Parameter usage location: authorization request, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: client_secret\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: response_type\n   o  Parameter usage location: authorization request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: redirect_uri\n   o  Parameter usage location: authorization request, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: scope\n   o  Parameter usage location: authorization request, authorization\n      response, token request, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: state\n   o  Parameter usage location: authorization request, authorization\n      response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: code\n   o  Parameter usage location: authorization response, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n\n\n\n\nHardt                        Standards Track                   [Page 64]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   o  Parameter name: error_description\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: error_uri\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: grant_type\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: access_token\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: token_type\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: expires_in\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: username\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: password\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: refresh_token\n   o  Parameter usage location: token request, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 65]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.3.  OAuth Authorization Endpoint Response Types Registry\n\n   This specification establishes the OAuth Authorization Endpoint\n   Response Types registry.\n\n   Additional response types for use with the authorization endpoint are\n   registered with a Specification Required ([RFC5226]) after a two-week\n   review period on the oauth-ext-review@ietf.org mailing list, on the\n   advice of one or more Designated Experts.  However, to allow for the\n   allocation of values prior to publication, the Designated Expert(s)\n   may approve registration once they are satisfied that such a\n   specification will be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for response type: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.3.1.  Registration Template\n\n   Response type name:\n      The name requested (e.g., \"example\").\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n   Specification document(s):\n      Reference to the document(s) that specify the type, preferably\n      including a URI that can be used to retrieve a copy of the\n      document(s).  An indication of the relevant sections may also be\n      included but is not required.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 66]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.3.2.  Initial Registry Contents\n\n   The OAuth Authorization Endpoint Response Types registry's initial\n   contents are:\n\n   o  Response type name: code\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Response type name: token\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n11.4.  OAuth Extensions Error Registry\n\n   This specification establishes the OAuth Extensions Error registry.\n\n   Additional error codes used together with other protocol extensions\n   (i.e., extension grant types, access token types, or extension\n   parameters) are registered with a Specification Required ([RFC5226])\n   after a two-week review period on the oauth-ext-review@ietf.org\n   mailing list, on the advice of one or more Designated Experts.\n   However, to allow for the allocation of values prior to publication,\n   the Designated Expert(s) may approve registration once they are\n   satisfied that such a specification will be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for error code: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 67]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.4.1.  Registration Template\n\n   Error name:\n      The name requested (e.g., \"example\").  Values for the error name\n      MUST NOT include characters outside the set %x20-21 / %x23-5B /\n      %x5D-7E.\n\n   Error usage location:\n      The location(s) where the error can be used.  The possible\n      locations are authorization code grant error response\n      (Section 4.1.2.1), implicit grant error response\n      (Section 4.2.2.1), token error response (Section 5.2), or resource\n      access error response (Section 7.2).\n\n   Related protocol extension:\n      The name of the extension grant type, access token type, or\n      extension parameter that the error code is used in conjunction\n      with.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n   Specification document(s):\n      Reference to the document(s) that specify the error code,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n12.  References\n\n12.1.  Normative References\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\n   [RFC2246]  Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\",\n              RFC 2246, January 1999.\n\n   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n\n   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n              Leach, P., Luotonen, A., and L. Stewart, \"HTTP\n              Authentication: Basic and Digest Access Authentication\",\n              RFC 2617, June 1999.\n\n\n\nHardt                        Standards Track                   [Page 68]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.\n\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of\n              ISO 10646\", STD 63, RFC 3629, November 2003.\n\n   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, January 2005.\n\n   [RFC4627]  Crockford, D., \"The application/json Media Type for\n              JavaScript Object Notation (JSON)\", RFC 4627, July 2006.\n\n   [RFC4949]  Shirey, R., \"Internet Security Glossary, Version 2\",\n              RFC 4949, August 2007.\n\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n\n   [RFC5234]  Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n\n   [RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification of Domain-Based Application Service Identity\n              within Internet Public Key Infrastructure Using X.509\n              (PKIX) Certificates in the Context of Transport Layer\n              Security (TLS)\", RFC 6125, March 2011.\n\n   [USASCII]  American National Standards Institute, \"Coded Character\n              Set -- 7-bit American Standard Code for Information\n              Interchange\", ANSI X3.4, 1986.\n\n   [W3C.REC-html401-19991224]\n              Raggett, D., Le Hors, A., and I. Jacobs, \"HTML 4.01\n              Specification\", World Wide Web Consortium\n              Recommendation REC-html401-19991224, December 1999,\n              <http://www.w3.org/TR/1999/REC-html401-19991224>.\n\n   [W3C.REC-xml-20081126]\n              Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,\n              and F. Yergeau, \"Extensible Markup Language (XML) 1.0\n              (Fifth Edition)\", World Wide Web Consortium\n               Recommendation REC-xml-20081126, November 2008,\n              <http://www.w3.org/TR/2008/REC-xml-20081126>.\n\n\n\n\nHardt                        Standards Track                   [Page 69]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n12.2.  Informative References\n\n   [OAuth-HTTP-MAC]\n              Hammer-Lahav, E., Ed., \"HTTP Authentication: MAC Access\n              Authentication\", Work in Progress, February 2012.\n\n   [OAuth-SAML2]\n              Campbell, B. and C. Mortimore, \"SAML 2.0 Bearer Assertion\n              Profiles for OAuth 2.0\", Work in Progress, September 2012.\n\n   [OAuth-THREATMODEL]\n              Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \"OAuth 2.0\n              Threat Model and Security Considerations\", Work\n              in Progress, October 2012.\n\n   [OAuth-WRAP]\n              Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, \"OAuth\n              Web Resource Authorization Profiles\", Work in Progress,\n              January 2010.\n\n   [RFC5849]  Hammer-Lahav, E., \"The OAuth 1.0 Protocol\", RFC 5849,\n              April 2010.\n\n   [RFC6750]  Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization\n              Framework: Bearer Token Usage\", RFC 6750, October 2012.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 70]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nAppendix A.  Augmented Backus-Naur Form (ABNF) Syntax\n\n   This section provides Augmented Backus-Naur Form (ABNF) syntax\n   descriptions for the elements defined in this specification using the\n   notation of [RFC5234].  The ABNF below is defined in terms of Unicode\n   code points [W3C.REC-xml-20081126]; these characters are typically\n   encoded in UTF-8.  Elements are presented in the order first defined.\n\n   Some of the definitions that follow use the \"URI-reference\"\n   definition from [RFC3986].\n\n   Some of the definitions that follow use these common definitions:\n\n     VSCHAR     = %x20-7E\n     NQCHAR     = %x21 / %x23-5B / %x5D-7E\n     NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E\n     UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /\n                         %xE000-FFFD / %x10000-10FFFF\n\n   (The UNICODECHARNOCRLF definition is based upon the Char definition\n   in Section 2.2 of [W3C.REC-xml-20081126], but omitting the Carriage\n   Return and Linefeed characters.)\n\nA.1.  \"client_id\" Syntax\n\n   The \"client_id\" element is defined in Section 2.3.1:\n\n     client-id     = *VSCHAR\n\nA.2.  \"client_secret\" Syntax\n\n   The \"client_secret\" element is defined in Section 2.3.1:\n\n     client-secret = *VSCHAR\n\nA.3.  \"response_type\" Syntax\n\n   The \"response_type\" element is defined in Sections 3.1.1 and 8.4:\n\n     response-type = response-name *( SP response-name )\n     response-name = 1*response-char\n     response-char = \"_\" / DIGIT / ALPHA\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 71]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.4.  \"scope\" Syntax\n\n   The \"scope\" element is defined in Section 3.3:\n\n     scope       = scope-token *( SP scope-token )\n     scope-token = 1*NQCHAR\n\nA.5.  \"state\" Syntax\n\n   The \"state\" element is defined in Sections 4.1.1, 4.1.2, 4.1.2.1,\n   4.2.1, 4.2.2, and 4.2.2.1:\n\n     state      = 1*VSCHAR\n\nA.6.  \"redirect_uri\" Syntax\n\n   The \"redirect_uri\" element is defined in Sections 4.1.1, 4.1.3,\n   and 4.2.1:\n\n     redirect-uri      = URI-reference\n\nA.7.  \"error\" Syntax\n\n   The \"error\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\n   7.2, and 8.5:\n\n     error             = 1*NQSCHAR\n\nA.8.  \"error_description\" Syntax\n\n   The \"error_description\" element is defined in Sections 4.1.2.1,\n   4.2.2.1, 5.2, and 7.2:\n\n     error-description = 1*NQSCHAR\n\nA.9.  \"error_uri\" Syntax\n\n   The \"error_uri\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\n   and 7.2:\n\n     error-uri         = URI-reference\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 72]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.10.  \"grant_type\" Syntax\n\n   The \"grant_type\" element is defined in Sections 4.1.3, 4.3.2, 4.4.2,\n   4.5, and 6:\n\n     grant-type = grant-name / URI-reference\n     grant-name = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nA.11.  \"code\" Syntax\n\n   The \"code\" element is defined in Section 4.1.3:\n\n     code       = 1*VSCHAR\n\nA.12.  \"access_token\" Syntax\n\n   The \"access_token\" element is defined in Sections 4.2.2 and 5.1:\n\n     access-token = 1*VSCHAR\n\nA.13.  \"token_type\" Syntax\n\n   The \"token_type\" element is defined in Sections 4.2.2, 5.1, and 8.1:\n\n     token-type = type-name / URI-reference\n     type-name  = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nA.14.  \"expires_in\" Syntax\n\n   The \"expires_in\" element is defined in Sections 4.2.2 and 5.1:\n\n     expires-in = 1*DIGIT\n\nA.15.  \"username\" Syntax\n\n   The \"username\" element is defined in Section 4.3.2:\n\n     username = *UNICODECHARNOCRLF\n\nA.16.  \"password\" Syntax\n\n   The \"password\" element is defined in Section 4.3.2:\n\n     password = *UNICODECHARNOCRLF\n\n\n\n\n\nHardt                        Standards Track                   [Page 73]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.17.  \"refresh_token\" Syntax\n\n   The \"refresh_token\" element is defined in Sections 5.1 and 6:\n\n     refresh-token = 1*VSCHAR\n\nA.18.  Endpoint Parameter Syntax\n\n   The syntax for new endpoint parameters is defined in Section 8.2:\n\n     param-name = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nAppendix B.  Use of application/x-www-form-urlencoded Media Type\n\n   At the time of publication of this specification, the\n   \"application/x-www-form-urlencoded\" media type was defined in\n   Section 17.13.4 of [W3C.REC-html401-19991224] but not registered in\n   the IANA MIME Media Types registry\n   (<http://www.iana.org/assignments/media-types>).  Furthermore, that\n   definition is incomplete, as it does not consider non-US-ASCII\n   characters.\n\n   To address this shortcoming when generating payloads using this media\n   type, names and values MUST be encoded using the UTF-8 character\n   encoding scheme [RFC3629] first; the resulting octet sequence then\n   needs to be further encoded using the escaping rules defined in\n   [W3C.REC-html401-19991224].\n\n   When parsing data from a payload using this media type, the names and\n   values resulting from reversing the name/value encoding consequently\n   need to be treated as octet sequences, to be decoded using the UTF-8\n   character encoding scheme.\n\n   For example, the value consisting of the six Unicode code points\n   (1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN),\n   (3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN),\n   (5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN) would be encoded\n   into the octet sequence below (using hexadecimal notation):\n\n     20 25 26 2B C2 A3 E2 82 AC\n\n   and then represented in the payload as:\n\n     +%25%26%2B%C2%A3%E2%82%AC\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 74]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nAppendix C.  Acknowledgements\n\n   The initial OAuth 2.0 protocol specification was edited by David\n   Recordon, based on two previous publications: the OAuth 1.0 community\n   specification [RFC5849], and OAuth WRAP (OAuth Web Resource\n   Authorization Profiles) [OAuth-WRAP].  Eran Hammer then edited many\n   of the intermediate drafts that evolved into this RFC.  The Security\n   Considerations section was drafted by Torsten Lodderstedt, Mark\n   McGloin, Phil Hunt, Anthony Nadalin, and John Bradley.  The section\n   on use of the \"application/x-www-form-urlencoded\" media type was\n   drafted by Julian Reschke.  The ABNF section was drafted by Michael\n   B. Jones.\n\n   The OAuth 1.0 community specification was edited by Eran Hammer and\n   authored by Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M.\n   Conlan, Blaine Cook, Leah Culver, Breno de Medeiros, Brian Eaton,\n   Kellan Elliott-McCrea, Larry Halff, Eran Hammer, Ben Laurie, Chris\n   Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,\n   Jonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.\n\n   The OAuth WRAP specification was edited by Dick Hardt and authored by\n   Brian Eaton, Yaron Y. Goland, Dick Hardt, and Allen Tom.\n\n   This specification is the work of the OAuth Working Group, which\n   includes dozens of active and dedicated participants.  In particular,\n   the following individuals contributed ideas, feedback, and wording\n   that shaped and formed the final specification:\n\n   Michael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden\n   Bell, John Bradley, Marcos Caceres, Brian Campbell, Scott Cantor,\n   Blaine Cook, Roger Crew, Leah Culver, Bill de hOra, Andre DeMarre,\n   Brian Eaton, Wesley Eddy, Wolter Eldering, Brian Ellin, Igor\n   Faynberg, George Fletcher, Tim Freeman, Luca Frosini, Evan Gilbert,\n   Yaron Y. Goland, Brent Goldman, Kristoffer Gronowski, Eran Hammer,\n   Dick Hardt, Justin Hart, Craig Heath, Phil Hunt, Michael B. Jones,\n   Terry Jones, John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara,\n   Rasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Casey Lucas, Paul\n   Madsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin,\n   Laurence Miao, William Mills, Chuck Mortimore, Anthony Nadalin,\n   Julian Reschke, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob\n   Sayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov,\n   Justin Smith, Haibin Song, Niv Steingarten, Christian Stuebner,\n   Jeremy Suriel, Paul Tarjan, Christopher Thomas, Henry S. Thompson,\n   Allen Tom, Franklin Tse, Nick Walker, Shane Weeden, and Skylar\n   Woodward.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 75]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   This document was produced under the chairmanship of Blaine Cook,\n   Peter Saint-Andre, Hannes Tschofenig, Barry Leiba, and Derek Atkins.\n   The area directors included Lisa Dusseault, Peter Saint-Andre, and\n   Stephen Farrell.\n\nAuthor's Address\n\n   Dick Hardt (editor)\n   Microsoft\n\n   EMail: dick.hardt@gmail.com\n   URI:   http://dickhardt.org/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 76]\n\f\n",
    "chunks": [
      {
        "chunk_id": "rfc_standards_complete_chunk_0",
        "original_index": 0,
        "content": "==================== RFC - HTTP ====================\n\n\n\n\n\n\n\nNetwork Working Group                                      R. Fielding\nRequest for Comments: 2616                                   UC Irvine\nObsoletes: 2068                                              J. Gettys\nCategory: Standards Track                                   Compaq/W3C\n                                                              J. Mogul\n                                                                Compaq\n                                                            H. Frystyk\n                                                               W3C/MIT\n                                                           L. Masinter\n                                                                 Xerox\n                                                              P. Leach\n                                                             Microsoft\n                                                        T. Berners-Lee\n                                                               W3C/MIT\n                                                             June 1999\n\n\n                Hypertext Transfer Protocol -- HTTP/1.1\n\nStatus of this Memo\n\n   This document specifies an Internet standards track protocol for the\n   Internet community, and requests discussion and suggestions for\n   improvements.  Please refer to the current edition of the \"Internet\n   Official Protocol Standards\" (STD 1) for the standardization state\n   and status of this protocol.  Distribution of this memo is unlimited.\n\nCopyright Notice\n\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n\nAbstract\n\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n   protocol for distributed, collaborative, hypermedia information\n   systems. It is a generic, stateless, protocol which can be used for\n   many tasks beyond its use for hypertext, such as name servers and\n   distributed object management systems, through extension of its\n   request methods, error codes and headers [47]. A feature of HTTP is\n   the typing and negotiation of data representation, allowing systems\n   to be built independently of the data being transferred.\n\n   HTTP has been in use by the World-Wide Web global information\n   initiative since 1990. This specification defines the protocol\n   referred to as \"HTTP/1.1\", and is an update to RFC 2068 [33].\n\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 1]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\nTable of Contents"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_1",
        "original_index": 1,
        "content": "Fielding, et al.            Standards Track                     [Page 1]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\nTable of Contents\n\n   1   Introduction ...................................................7\n   1.1    Purpose......................................................7\n   1.2   Requirements .................................................8\n   1.3   Terminology ..................................................8\n   1.4   Overall Operation ...........................................12\n   2   Notational Conventions and Generic Grammar ....................14\n   2.1   Augmented BNF ...............................................14\n   2.2   Basic Rules .................................................15\n   3   Protocol Parameters ...........................................17\n   3.1   HTTP Version ................................................17\n   3.2   Uniform Resource Identifiers ................................18\n   3.2.1    General Syntax ...........................................19\n   3.2.2    http URL .................................................19\n   3.2.3    URI Comparison ...........................................20\n   3.3   Date/Time Formats ...........................................20\n   3.3.1    Full Date ................................................20\n   3.3.2    Delta Seconds ............................................21\n   3.4   Character Sets ..............................................21\n   3.4.1    Missing Charset ..........................................22\n   3.5   Content Codings .............................................23\n   3.6   Transfer Codings ............................................24\n   3.6.1    Chunked Transfer Coding ..................................25\n   3.7   Media Types .................................................26\n   3.7.1    Canonicalization and Text Defaults .......................27\n   3.7.2    Multipart Types ..........................................27\n   3.8   Product Tokens ..............................................28\n   3.9   Quality Values ..............................................29\n   3.10  Language Tags ...............................................29\n   3.11  Entity Tags .................................................30\n   3.12  Range Units .................................................30\n   4   HTTP Message ..................................................31\n   4.1   Message Types ...............................................31\n   4.2   Message Headers .............................................31\n   4.3   Message Body ................................................32\n   4.4   Message Length ..............................................33\n   4.5   General Header Fields .......................................34\n   5   Request .......................................................35\n   5.1   Request-Line ................................................35\n   5.1.1    Method ...................................................36\n   5.1.2    Request-URI ..............................................36\n   5.2   The Resource Identified by a Request ........................38\n   5.3   Request Header Fields .......................................38\n   6   Response ......................................................39\n   6.1   Status-Line .................................................39\n   6.1.1    Status Code and Reason Phrase ............................39\n   6.2   Response Header Fields ......................................41\n\n\n\nFielding, et al.            Standards Track                     [Page 2]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_2",
        "original_index": 2,
        "content": "Fielding, et al.            Standards Track                     [Page 2]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   7   Entity ........................................................42\n   7.1   Entity Header Fields ........................................42\n   7.2   Entity Body .................................................43\n   7.2.1    Type .....................................................43\n   7.2.2    Entity Length ............................................43\n   8   Connections ...................................................44\n   8.1   Persistent Connections ......................................44\n   8.1.1    Purpose ..................................................44\n   8.1.2    Overall Operation ........................................45\n   8.1.3    Proxy Servers ............................................46\n   8.1.4    Practical Considerations .................................46\n   8.2   Message Transmission Requirements ...........................47\n   8.2.1    Persistent Connections and Flow Control ..................47\n   8.2.2    Monitoring Connections for Error Status Messages .........48\n   8.2.3    Use of the 100 (Continue) Status .........................48\n   8.2.4    Client Behavior if Server Prematurely Closes Connection ..50\n   9   Method Definitions ............................................51\n   9.1   Safe and Idempotent Methods .................................51\n   9.1.1    Safe Methods .............................................51\n   9.1.2    Idempotent Methods .......................................51\n   9.2   OPTIONS .....................................................52\n   9.3   GET .........................................................53\n   9.4   HEAD ........................................................54\n   9.5   POST ........................................................54\n   9.6   PUT .........................................................55\n   9.7   DELETE ......................................................56\n   9.8   TRACE .......................................................56\n   9.9   CONNECT .....................................................57\n   10   Status Code Definitions ......................................57\n   10.1  Informational 1xx ...........................................57\n   10.1.1   100 Continue .............................................58\n   10.1.2   101 Switching Protocols ..................................58\n   10.2  Successful 2xx ..............................................58\n   10.2.1   200 OK ...................................................58\n   10.2.2   201 Created ..............................................59\n   10.2.3   202 Accepted .............................................59\n   10.2.4   203 Non-Authoritative Information ........................59\n   10.2.5   204 No Content ...........................................60\n   10.2.6   205 Reset Content ........................................60\n   10.2.7   206 Partial Content ......................................60\n   10.3  Redirection 3xx .............................................61\n   10.3.1   300 Multiple Choices .....................................61\n   10.3.2   301 Moved Permanently ....................................62\n   10.3.3   302 Found ................................................62\n   10.3.4   303 See Other ............................................63\n   10.3.5   304 Not Modified .........................................63\n   10.3.6   305 Use Proxy ............................................64\n   10.3.7   306 (Unused) .............................................64\n\n\n\nFielding, et al.            Standards Track                     [Page 3]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_3",
        "original_index": 3,
        "content": "Fielding, et al.            Standards Track                     [Page 3]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   10.3.8   307 Temporary Redirect ...................................65\n   10.4  Client Error 4xx ............................................65\n   10.4.1    400 Bad Request .........................................65\n   10.4.2    401 Unauthorized ........................................66\n   10.4.3    402 Payment Required ....................................66\n   10.4.4    403 Forbidden ...........................................66\n   10.4.5    404 Not Found ...........................................66\n   10.4.6    405 Method Not Allowed ..................................66\n   10.4.7    406 Not Acceptable ......................................67\n   10.4.8    407 Proxy Authentication Required .......................67\n   10.4.9    408 Request Timeout .....................................67\n   10.4.10   409 Conflict ............................................67\n   10.4.11   410 Gone ................................................68\n   10.4.12   411 Length Required .....................................68\n   10.4.13   412 Precondition Failed .................................68\n   10.4.14   413 Request Entity Too Large ............................69\n   10.4.15   414 Request-URI Too Long ................................69\n   10.4.16   415 Unsupported Media Type ..............................69\n   10.4.17   416 Requested Range Not Satisfiable .....................69\n   10.4.18   417 Expectation Failed ..................................70\n   10.5  Server Error 5xx ............................................70\n   10.5.1   500 Internal Server Error ................................70\n   10.5.2   501 Not Implemented ......................................70\n   10.5.3   502 Bad Gateway ..........................................70\n   10.5.4   503 Service Unavailable ..................................70\n   10.5.5   504 Gateway Timeout ......................................71\n   10.5.6   505 HTTP Version Not Supported ...........................71\n   11   Access Authentication ........................................71\n   12   Content Negotiation ..........................................71\n   12.1  Server-driven Negotiation ...................................72\n   12.2  Agent-driven Negotiation ....................................73\n   12.3  Transparent Negotiation .....................................74\n   13   Caching in HTTP ..............................................74\n   13.1.1   Cache Correctness ........................................75\n   13.1.2   Warnings .................................................76\n   13.1.3   Cache-control Mechanisms .................................77\n   13.1.4   Explicit User Agent Warnings .............................78\n   13.1.5   Exceptions to the Rules and Warnings .....................78\n   13.1.6   Client-controlled Behavior ...............................79\n   13.2  Expiration Model ............................................79\n   13.2.1   Server-Specified Expiration ..............................79\n   13.2.2   Heuristic Expiration .....................................80\n   13.2.3   Age Calculations .........................................80\n   13.2.4   Expiration Calculations ..................................83\n   13.2.5   Disambiguating Expiration Values .........................84\n   13.2.6   Disambiguating Multiple Responses ........................84\n   13.3  Validation Model ............................................85\n   13.3.1   Last-Modified Dates ......................................86\n\n\n\nFielding, et al.            Standards Track                     [Page 4]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_4",
        "original_index": 4,
        "content": "Fielding, et al.            Standards Track                     [Page 4]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   13.3.2   Entity Tag Cache Validators ..............................86\n   13.3.3   Weak and Strong Validators ...............................86\n   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89\n   13.3.5   Non-validating Conditionals ..............................90\n   13.4  Response Cacheability .......................................91\n   13.5  Constructing Responses From Caches ..........................92\n   13.5.1   End-to-end and Hop-by-hop Headers ........................92\n   13.5.2   Non-modifiable Headers ...................................92\n   13.5.3   Combining Headers ........................................94\n   13.5.4   Combining Byte Ranges ....................................95\n   13.6  Caching Negotiated Responses ................................95\n   13.7  Shared and Non-Shared Caches ................................96\n   13.8  Errors or Incomplete Response Cache Behavior ................97\n   13.9  Side Effects of GET and HEAD ................................97\n   13.10   Invalidation After Updates or Deletions ...................97\n   13.11   Write-Through Mandatory ...................................98\n   13.12   Cache Replacement .........................................99\n   13.13   History Lists .............................................99\n   14   Header Field Definitions ....................................100\n   14.1  Accept .....................................................100\n   14.2  Accept-Charset .............................................102\n   14.3  Accept-Encoding ............................................102\n   14.4  Accept-Language ............................................104\n   14.5  Accept-Ranges ..............................................105\n   14.6  Age ........................................................106\n   14.7  Allow ......................................................106\n   14.8  Authorization ..............................................107\n   14.9  Cache-Control ..............................................108\n   14.9.1   What is Cacheable .......................................109\n   14.9.2   What May be Stored by Caches ............................110\n   14.9.3   Modifications of the Basic Expiration Mechanism .........111\n   14.9.4   Cache Revalidation and Reload Controls ..................113\n   14.9.5   No-Transform Directive ..................................115\n   14.9.6   Cache Control Extensions ................................116\n   14.10   Connection ...............................................117\n   14.11   Content-Encoding .........................................118\n   14.12   Content-Language .........................................118\n   14.13   Content-Length ...........................................119\n   14.14   Content-Location .........................................120\n   14.15   Content-MD5 ..............................................121\n   14.16   Content-Range ............................................122\n   14.17   Content-Type .............................................124\n   14.18   Date .....................................................124\n   14.18.1   Clockless Origin Server Operation ......................125\n   14.19   ETag .....................................................126\n   14.20   Expect ...................................................126\n   14.21   Expires ..................................................127\n   14.22   From .....................................................128\n\n\n\nFielding, et al.            Standards Track                     [Page 5]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_5",
        "original_index": 5,
        "content": "Fielding, et al.            Standards Track                     [Page 5]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   14.23   Host .....................................................128\n   14.24   If-Match .................................................129\n   14.25   If-Modified-Since ........................................130\n   14.26   If-None-Match ............................................132\n   14.27   If-Range .................................................133\n   14.28   If-Unmodified-Since ......................................134\n   14.29   Last-Modified ............................................134\n   14.30   Location .................................................135\n   14.31   Max-Forwards .............................................136\n   14.32   Pragma ...................................................136\n   14.33   Proxy-Authenticate .......................................137\n   14.34   Proxy-Authorization ......................................137\n   14.35   Range ....................................................138\n   14.35.1    Byte Ranges ...........................................138\n   14.35.2    Range Retrieval Requests ..............................139\n   14.36   Referer ..................................................140\n   14.37   Retry-After ..............................................141\n   14.38   Server ...................................................141\n   14.39   TE .......................................................142\n   14.40   Trailer ..................................................143\n   14.41  Transfer-Encoding..........................................143\n   14.42   Upgrade ..................................................144\n   14.43   User-Agent ...............................................145\n   14.44   Vary .....................................................145\n   14.45   Via ......................................................146\n   14.46   Warning ..................................................148\n   14.47   WWW-Authenticate .........................................150\n   15 Security Considerations .......................................150\n   15.1      Personal Information....................................151\n   15.1.1   Abuse of Server Log Information .........................151\n   15.1.2   Transfer of Sensitive Information .......................151\n   15.1.3   Encoding Sensitive Information in URI's .................152\n   15.1.4   Privacy Issues Connected to Accept Headers ..............152\n   15.2  Attacks Based On File and Path Names .......................153\n   15.3  DNS Spoofing ...............................................154\n   15.4  Location Headers and Spoofing ..............................154\n   15.5  Content-Disposition Issues .................................154\n   15.6  Authentication Credentials and Idle Clients ................155\n   15.7  Proxies and Caching ........................................155\n   15.7.1    Denial of Service Attacks on Proxies....................156\n   16   Acknowledgments .............................................156\n   17   References ..................................................158\n   18   Authors' Addresses ..........................................162\n   19   Appendices ..................................................164\n   19.1  Internet Media Type message/http and application/http ......164\n   19.2  Internet Media Type multipart/byteranges ...................165\n   19.3  Tolerant Applications ......................................166\n   19.4  Differences Between HTTP Entities and RFC 2045 Entities ....167\n\n\n\nFielding, et al.            Standards Track                     [Page 6]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_6",
        "original_index": 6,
        "content": "Fielding, et al.            Standards Track                     [Page 6]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   19.4.1   MIME-Version ............................................167\n   19.4.2   Conversion to Canonical Form ............................167\n   19.4.3   Conversion of Date Formats ..............................168\n   19.4.4   Introduction of Content-Encoding ........................168\n   19.4.5   No Content-Transfer-Encoding ............................168\n   19.4.6   Introduction of Transfer-Encoding .......................169\n   19.4.7   MHTML and Line Length Limitations .......................169\n   19.5  Additional Features ........................................169\n   19.5.1   Content-Disposition .....................................170\n   19.6  Compatibility with Previous Versions .......................170\n   19.6.1   Changes from HTTP/1.0 ...................................171\n   19.6.2   Compatibility with HTTP/1.0 Persistent Connections ......172\n   19.6.3   Changes from RFC 2068 ...................................172\n   20   Index .......................................................175\n   21   Full Copyright Statement ....................................176\n\n1 Introduction\n\n1.1 Purpose\n\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n   protocol for distributed, collaborative, hypermedia information\n   systems. HTTP has been in use by the World-Wide Web global\n   information initiative since 1990. The first version of HTTP,\n   referred to as HTTP/0.9, was a simple protocol for raw data transfer\n   across the Internet. HTTP/1.0, as defined by RFC 1945 [6], improved\n   the protocol by allowing messages to be in the format of MIME-like\n   messages, containing metainformation about the data transferred and\n   modifiers on the request/response semantics. However, HTTP/1.0 does\n   not sufficiently take into consideration the effects of hierarchical\n   proxies, caching, the need for persistent connections, or virtual\n   hosts. In addition, the proliferation of incompletely-implemented\n   applications calling themselves \"HTTP/1.0\" has necessitated a\n   protocol version change in order for two communicating applications\n   to determine each other's true capabilities.\n\n   This specification defines the protocol referred to as \"HTTP/1.1\".\n   This protocol includes more stringent requirements than HTTP/1.0 in\n   order to ensure reliable implementation of its features.\n\n   Practical information systems require more functionality than simple\n   retrieval, including search, front-end update, and annotation. HTTP\n   allows an open-ended set of methods and headers that indicate the\n   purpose of a request [47]. It builds on the discipline of reference\n   provided by the Uniform Resource Identifier (URI) [3], as a location\n   (URL) [4] or name (URN) [20], for indicating the resource to which a\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 7]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   method is to be applied. Messages are passed in a format similar to\n   that used by Internet mail [9] as defined by the Multipurpose\n   Internet Mail Extensions (MIME) [7].\n\n   HTTP is also used as a generic protocol for communication between\n   user agents and proxies/gateways to other Internet systems, including\n   those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2],\n   and WAIS [10] protocols. In this way, HTTP allows basic hypermedia\n   access to resources available from diverse applications.\n\n1.2 Requirements\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC 2119 [34]."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_7",
        "original_index": 7,
        "content": "An implementation is not compliant if it fails to satisfy one or more\n   of the MUST or REQUIRED level requirements for the protocols it\n   implements. An implementation that satisfies all the MUST or REQUIRED\n   level and all the SHOULD level requirements for its protocols is said\n   to be \"unconditionally compliant\"; one that satisfies all the MUST\n   level requirements but not all the SHOULD level requirements for its\n   protocols is said to be \"conditionally compliant.\"\n\n1.3 Terminology\n\n   This specification uses a number of terms to refer to the roles\n   played by participants in, and objects of, the HTTP communication.\n\n   connection\n      A transport layer virtual circuit established between two programs\n      for the purpose of communication.\n\n   message\n      The basic unit of HTTP communication, consisting of a structured\n      sequence of octets matching the syntax defined in section 4 and\n      transmitted via the connection.\n\n   request\n      An HTTP request message, as defined in section 5.\n\n   response\n      An HTTP response message, as defined in section 6.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                     [Page 8]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   resource\n      A network data object or service that can be identified by a URI,\n      as defined in section 3.2. Resources may be available in multiple\n      representations (e.g. multiple languages, data formats, size, and\n      resolutions) or vary in other ways.\n\n   entity\n      The information transferred as the payload of a request or\n      response. An entity consists of metainformation in the form of\n      entity-header fields and content in the form of an entity-body, as\n      described in section 7.\n\n   representation\n      An entity included with a response that is subject to content\n      negotiation, as described in section 12. There may exist multiple\n      representations associated with a particular response status.\n\n   content negotiation\n      The mechanism for selecting the appropriate representation when\n      servicing a request, as described in section 12. The\n      representation of entities in any response can be negotiated\n      (including error responses).\n\n   variant\n      A resource may have one, or more than one, representation(s)\n      associated with it at any given instant. Each of these\n      representations is termed a `varriant'.  Use of the term `variant'\n      does not necessarily imply that the resource is subject to content\n      negotiation.\n\n   client\n      A program that establishes connections for the purpose of sending\n      requests.\n\n   user agent\n      The client which initiates a request. These are often browsers,\n      editors, spiders (web-traversing robots), or other end user tools.\n\n   server\n      An application program that accepts connections in order to\n      service requests by sending back responses. Any given program may\n      be capable of being both a client and a server; our use of these\n      terms refers only to the role being performed by the program for a\n      particular connection, rather than to the program's capabilities\n      in general. Likewise, any server may act as an origin server,\n      proxy, gateway, or tunnel, switching behavior based on the nature\n      of each request.\n\n\n\n\nFielding, et al.            Standards Track                     [Page 9]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   origin server\n      The server on which a given resource resides or is to be created."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_8",
        "original_index": 8,
        "content": "origin server\n      The server on which a given resource resides or is to be created.\n\n   proxy\n      An intermediary program which acts as both a server and a client\n      for the purpose of making requests on behalf of other clients.\n      Requests are serviced internally or by passing them on, with\n      possible translation, to other servers. A proxy MUST implement\n      both the client and server requirements of this specification. A\n      \"transparent proxy\" is a proxy that does not modify the request or\n      response beyond what is required for proxy authentication and\n      identification. A \"non-transparent proxy\" is a proxy that modifies\n      the request or response in order to provide some added service to\n      the user agent, such as group annotation services, media type\n      transformation, protocol reduction, or anonymity filtering. Except\n      where either transparent or non-transparent behavior is explicitly\n      stated, the HTTP proxy requirements apply to both types of\n      proxies.\n\n   gateway\n      A server which acts as an intermediary for some other server.\n      Unlike a proxy, a gateway receives requests as if it were the\n      origin server for the requested resource; the requesting client\n      may not be aware that it is communicating with a gateway.\n\n   tunnel\n      An intermediary program which is acting as a blind relay between\n      two connections. Once active, a tunnel is not considered a party\n      to the HTTP communication, though the tunnel may have been\n      initiated by an HTTP request. The tunnel ceases to exist when both\n      ends of the relayed connections are closed.\n\n   cache\n      A program's local store of response messages and the subsystem\n      that controls its message storage, retrieval, and deletion. A\n      cache stores cacheable responses in order to reduce the response\n      time and network bandwidth consumption on future, equivalent\n      requests. Any client or server may include a cache, though a cache\n      cannot be used by a server that is acting as a tunnel.\n\n   cacheable\n      A response is cacheable if a cache is allowed to store a copy of\n      the response message for use in answering subsequent requests. The\n      rules for determining the cacheability of HTTP responses are\n      defined in section 13. Even if a resource is cacheable, there may\n      be additional constraints on whether a cache can use the cached\n      copy for a particular request.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 10]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   first-hand\n      A response is first-hand if it comes directly and without\n      unnecessary delay from the origin server, perhaps via one or more\n      proxies. A response is also first-hand if its validity has just\n      been checked directly with the origin server.\n\n   explicit expiration time\n      The time at which the origin server intends that an entity should\n      no longer be returned by a cache without further validation.\n\n   heuristic expiration time\n      An expiration time assigned by a cache when no explicit expiration\n      time is available.\n\n   age\n      The age of a response is the time since it was sent by, or\n      successfully validated with, the origin server.\n\n   freshness lifetime\n      The length of time between the generation of a response and its\n      expiration time.\n\n   fresh\n      A response is fresh if its age has not yet exceeded its freshness\n      lifetime.\n\n   stale\n      A response is stale if its age has passed its freshness lifetime."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_9",
        "original_index": 9,
        "content": "fresh\n      A response is fresh if its age has not yet exceeded its freshness\n      lifetime.\n\n   stale\n      A response is stale if its age has passed its freshness lifetime.\n\n   semantically transparent\n      A cache behaves in a \"semantically transparent\" manner, with\n      respect to a particular response, when its use affects neither the\n      requesting client nor the origin server, except to improve\n      performance. When a cache is semantically transparent, the client\n      receives exactly the same response (except for hop-by-hop headers)\n      that it would have received had its request been handled directly\n      by the origin server.\n\n   validator\n      A protocol element (e.g., an entity tag or a Last-Modified time)\n      that is used to find out whether a cache entry is an equivalent\n      copy of an entity.\n\n   upstream/downstream\n      Upstream and downstream describe the flow of a message: all\n      messages flow from upstream to downstream.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 11]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   inbound/outbound\n      Inbound and outbound refer to the request and response paths for\n      messages: \"inbound\" means \"traveling toward the origin server\",\n      and \"outbound\" means \"traveling toward the user agent\"\n\n1.4 Overall Operation\n\n   The HTTP protocol is a request/response protocol. A client sends a\n   request to the server in the form of a request method, URI, and\n   protocol version, followed by a MIME-like message containing request\n   modifiers, client information, and possible body content over a\n   connection with a server. The server responds with a status line,\n   including the message's protocol version and a success or error code,\n   followed by a MIME-like message containing server information, entity\n   metainformation, and possible entity-body content. The relationship\n   between HTTP and MIME is described in appendix 19.4.\n\n   Most HTTP communication is initiated by a user agent and consists of\n   a request to be applied to a resource on some origin server. In the\n   simplest case, this may be accomplished via a single connection (v)\n   between the user agent (UA) and the origin server (O).\n\n          request chain ------------------------>\n       UA -------------------v------------------- O\n          <----------------------- response chain\n\n   A more complicated situation occurs when one or more intermediaries\n   are present in the request/response chain. There are three common\n   forms of intermediary: proxy, gateway, and tunnel. A proxy is a\n   forwarding agent, receiving requests for a URI in its absolute form,\n   rewriting all or part of the message, and forwarding the reformatted\n   request toward the server identified by the URI. A gateway is a\n   receiving agent, acting as a layer above some other server(s) and, if\n   necessary, translating the requests to the underlying server's\n   protocol. A tunnel acts as a relay point between two connections\n   without changing the messages; tunnels are used when the\n   communication needs to pass through an intermediary (such as a\n   firewall) even when the intermediary cannot understand the contents\n   of the messages.\n\n          request chain -------------------------------------->\n       UA -----v----- A -----v----- B -----v----- C -----v----- O\n          <------------------------------------- response chain\n\n   The figure above shows three intermediaries (A, B, and C) between the\n   user agent and origin server. A request or response message that\n   travels the whole chain will pass through four separate connections.\n   This distinction is important because some HTTP communication options\n\n\n\nFielding, et al.            Standards Track                    [Page 12]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_10",
        "original_index": 10,
        "content": "Fielding, et al.            Standards Track                    [Page 12]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   may apply only to the connection with the nearest, non-tunnel\n   neighbor, only to the end-points of the chain, or to all connections\n   along the chain. Although the diagram is linear, each participant may\n   be engaged in multiple, simultaneous communications. For example, B\n   may be receiving requests from many clients other than A, and/or\n   forwarding requests to servers other than C, at the same time that it\n   is handling A's request.\n\n   Any party to the communication which is not acting as a tunnel may\n   employ an internal cache for handling requests. The effect of a cache\n   is that the request/response chain is shortened if one of the\n   participants along the chain has a cached response applicable to that\n   request. The following illustrates the resulting chain if B has a\n   cached copy of an earlier response from O (via C) for a request which\n   has not been cached by UA or A.\n\n          request chain ---------->\n       UA -----v----- A -----v----- B - - - - - - C - - - - - - O\n          <--------- response chain\n\n   Not all responses are usefully cacheable, and some requests may\n   contain modifiers which place special requirements on cache behavior.\n   HTTP requirements for cache behavior and cacheable responses are\n   defined in section 13.\n\n   In fact, there are a wide variety of architectures and configurations\n   of caches and proxies currently being experimented with or deployed\n   across the World Wide Web. These systems include national hierarchies\n   of proxy caches to save transoceanic bandwidth, systems that\n   broadcast or multicast cache entries, organizations that distribute\n   subsets of cached data via CD-ROM, and so on. HTTP systems are used\n   in corporate intranets over high-bandwidth links, and for access via\n   PDAs with low-power radio links and intermittent connectivity. The\n   goal of HTTP/1.1 is to support the wide diversity of configurations\n   already deployed while introducing protocol constructs that meet the\n   needs of those who build web applications that require high\n   reliability and, failing that, at least reliable indications of\n   failure.\n\n   HTTP communication usually takes place over TCP/IP connections. The\n   default port is TCP 80 [19], but other ports can be used. This does\n   not preclude HTTP from being implemented on top of any other protocol\n   on the Internet, or on other networks. HTTP only presumes a reliable\n   transport; any protocol that provides such guarantees can be used;\n   the mapping of the HTTP/1.1 request and response structures onto the\n   transport data units of the protocol in question is outside the scope\n   of this specification.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 13]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   In HTTP/1.0, most implementations used a new connection for each\n   request/response exchange. In HTTP/1.1, a connection may be used for\n   one or more request/response exchanges, although connections may be\n   closed for a variety of reasons (see section 8.1).\n\n2 Notational Conventions and Generic Grammar\n\n2.1 Augmented BNF\n\n   All of the mechanisms specified in this document are described in\n   both prose and an augmented Backus-Naur Form (BNF) similar to that\n   used by RFC 822 [9]. Implementors will need to be familiar with the\n   notation in order to understand this specification. The augmented BNF\n   includes the following constructs:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_11",
        "original_index": 11,
        "content": "name = definition\n      The name of a rule is simply the name itself (without any\n      enclosing \"<\" and \">\") and is separated from its definition by the\n      equal \"=\" character. White space is only significant in that\n      indentation of continuation lines is used to indicate a rule\n      definition that spans more than one line. Certain basic rules are\n      in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle\n      brackets are used within definitions whenever their presence will\n      facilitate discerning the use of rule names.\n\n   \"literal\"\n      Quotation marks surround literal text. Unless stated otherwise,\n      the text is case-insensitive.\n\n   rule1 | rule2\n      Elements separated by a bar (\"|\") are alternatives, e.g., \"yes |\n      no\" will accept yes or no.\n\n   (rule1 rule2)\n      Elements enclosed in parentheses are treated as a single element.\n      Thus, \"(elem (foo | bar) elem)\" allows the token sequences \"elem\n      foo elem\" and \"elem bar elem\".\n\n   *rule\n      The character \"*\" preceding an element indicates repetition. The\n      full form is \"<n>*<m>element\" indicating at least <n> and at most\n      <m> occurrences of element. Default values are 0 and infinity so\n      that \"*(element)\" allows any number, including zero; \"1*element\"\n      requires at least one; and \"1*2element\" allows one or two.\n\n   [rule]\n      Square brackets enclose optional elements; \"[foo bar]\" is\n      equivalent to \"*1(foo bar)\".\n\n\n\nFielding, et al.            Standards Track                    [Page 14]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   N rule\n      Specific repetition: \"<n>(element)\" is equivalent to\n      \"<n>*<n>(element)\"; that is, exactly <n> occurrences of (element).\n      Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three\n      alphabetic characters.\n\n   #rule\n      A construct \"#\" is defined, similar to \"*\", for defining lists of\n      elements. The full form is \"<n>#<m>element\" indicating at least\n      <n> and at most <m> elements, each separated by one or more commas\n      (\",\") and OPTIONAL linear white space (LWS). This makes the usual\n      form of lists very easy; a rule such as\n         ( *LWS element *( *LWS \",\" *LWS element ))\n      can be shown as\n         1#element\n      Wherever this construct is used, null elements are allowed, but do\n      not contribute to the count of elements present. That is,\n      \"(element), , (element) \" is permitted, but counts as only two\n      elements. Therefore, where at least one element is required, at\n      least one non-null element MUST be present. Default values are 0\n      and infinity so that \"#element\" allows any number, including zero;\n      \"1#element\" requires at least one; and \"1#2element\" allows one or\n      two.\n\n   ; comment\n      A semi-colon, set off some distance to the right of rule text,\n      starts a comment that continues to the end of line. This is a\n      simple way of including useful notes in parallel with the\n      specifications.\n\n   implied *LWS\n      The grammar described by this specification is word-based. Except\n      where noted otherwise, linear white space (LWS) can be included\n      between any two adjacent words (token or quoted-string), and\n      between adjacent words and separators, without changing the\n      interpretation of a field. At least one delimiter (LWS and/or\n\n      separators) MUST exist between any two tokens (for the definition\n      of \"token\" below), since they would otherwise be interpreted as a\n      single token.\n\n2.2 Basic Rules\n\n   The following rules are used throughout this specification to\n   describe basic parsing constructs. The US-ASCII coded character set\n   is defined by ANSI X3.4-1986 [21].\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 15]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_12",
        "original_index": 12,
        "content": "Fielding, et al.            Standards Track                    [Page 15]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       OCTET          = <any 8-bit sequence of data>\n       CHAR           = <any US-ASCII character (octets 0 - 127)>\n       UPALPHA        = <any US-ASCII uppercase letter \"A\"..\"Z\">\n       LOALPHA        = <any US-ASCII lowercase letter \"a\"..\"z\">\n       ALPHA          = UPALPHA | LOALPHA\n       DIGIT          = <any US-ASCII digit \"0\"..\"9\">\n       CTL            = <any US-ASCII control character\n                        (octets 0 - 31) and DEL (127)>\n       CR             = <US-ASCII CR, carriage return (13)>\n       LF             = <US-ASCII LF, linefeed (10)>\n       SP             = <US-ASCII SP, space (32)>\n       HT             = <US-ASCII HT, horizontal-tab (9)>\n       <\">            = <US-ASCII double-quote mark (34)>\n\n   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all\n   protocol elements except the entity-body (see appendix 19.3 for\n   tolerant applications). The end-of-line marker within an entity-body\n   is defined by its associated media type, as described in section 3.7.\n\n       CRLF           = CR LF\n\n   HTTP/1.1 header field values can be folded onto multiple lines if the\n   continuation line begins with a space or horizontal tab. All linear\n   white space, including folding, has the same semantics as SP. A\n   recipient MAY replace any linear white space with a single SP before\n   interpreting the field value or forwarding the message downstream.\n\n       LWS            = [CRLF] 1*( SP | HT )\n\n   The TEXT rule is only used for descriptive field contents and values\n   that are not intended to be interpreted by the message parser. Words\n   of *TEXT MAY contain characters from character sets other than ISO-\n   8859-1 [22] only when encoded according to the rules of RFC 2047\n   [14].\n\n       TEXT           = <any OCTET except CTLs,\n                        but including LWS>\n\n   A CRLF is allowed in the definition of TEXT only as part of a header\n   field continuation. It is expected that the folding LWS will be\n   replaced with a single SP before interpretation of the TEXT value.\n\n   Hexadecimal numeric characters are used in several protocol elements.\n\n       HEX            = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n                      | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | DIGIT\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 16]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Many HTTP/1.1 header field values consist of words separated by LWS\n   or special characters. These special characters MUST be in a quoted\n   string to be used within a parameter value (as defined in section\n   3.6).\n\n       token          = 1*<any CHAR except CTLs or separators>\n       separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                      | \"{\" | \"}\" | SP | HT\n\n   Comments can be included in some HTTP header fields by surrounding\n   the comment text with parentheses. Comments are only allowed in\n   fields containing \"comment\" as part of their field value definition.\n   In all other fields, parentheses are considered part of the field\n   value.\n\n       comment        = \"(\" *( ctext | quoted-pair | comment ) \")\"\n       ctext          = <any TEXT excluding \"(\" and \")\">\n\n   A string of text is parsed as a single word if it is quoted using\n   double-quote marks.\n\n       quoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n       qdtext         = <any TEXT except <\">>\n\n   The backslash character (\"\\\") MAY be used as a single-character\n   quoting mechanism only within quoted-string and comment constructs.\n\n       quoted-pair    = \"\\\" CHAR\n\n3 Protocol Parameters\n\n3.1 HTTP Version"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_13",
        "original_index": 13,
        "content": "quoted-pair    = \"\\\" CHAR\n\n3 Protocol Parameters\n\n3.1 HTTP Version\n\n   HTTP uses a \"<major>.<minor>\" numbering scheme to indicate versions\n   of the protocol. The protocol versioning policy is intended to allow\n   the sender to indicate the format of a message and its capacity for\n   understanding further HTTP communication, rather than the features\n   obtained via that communication. No change is made to the version\n   number for the addition of message components which do not affect\n   communication behavior or which only add to extensible field values.\n   The <minor> number is incremented when the changes made to the\n   protocol add features which do not change the general message parsing\n   algorithm, but which may add to the message semantics and imply\n   additional capabilities of the sender. The <major> number is\n   incremented when the format of a message within the protocol is\n   changed. See RFC 2145 [36] for a fuller explanation.\n\n\n\nFielding, et al.            Standards Track                    [Page 17]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The version of an HTTP message is indicated by an HTTP-Version field\n   in the first line of the message.\n\n       HTTP-Version   = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n\n   Note that the major and minor numbers MUST be treated as separate\n   integers and that each MAY be incremented higher than a single digit.\n   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is\n   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and\n   MUST NOT be sent.\n\n   An application that sends a request or response message that includes\n   HTTP-Version of \"HTTP/1.1\" MUST be at least conditionally compliant\n   with this specification. Applications that are at least conditionally\n   compliant with this specification SHOULD use an HTTP-Version of\n   \"HTTP/1.1\" in their messages, and MUST do so for any message that is\n   not compatible with HTTP/1.0. For more details on when to send\n   specific HTTP-Version values, see RFC 2145 [36].\n\n   The HTTP version of an application is the highest HTTP version for\n   which the application is at least conditionally compliant.\n\n   Proxy and gateway applications need to be careful when forwarding\n   messages in protocol versions different from that of the application.\n   Since the protocol version indicates the protocol capability of the\n   sender, a proxy/gateway MUST NOT send a message with a version\n   indicator which is greater than its actual version. If a higher\n   version request is received, the proxy/gateway MUST either downgrade\n   the request version, or respond with an error, or switch to tunnel\n   behavior.\n\n   Due to interoperability problems with HTTP/1.0 proxies discovered\n   since the publication of RFC 2068[33], caching proxies MUST, gateways\n   MAY, and tunnels MUST NOT upgrade the request to the highest version\n   they support. The proxy/gateway's response to that request MUST be in\n   the same major version as the request.\n\n      Note: Converting between versions of HTTP may involve modification\n      of header fields required or forbidden by the versions involved.\n\n3.2 Uniform Resource Identifiers\n\n   URIs have been known by many names: WWW addresses, Universal Document\n   Identifiers, Universal Resource Identifiers [3], and finally the\n   combination of Uniform Resource Locators (URL) [4] and Names (URN)\n   [20]. As far as HTTP is concerned, Uniform Resource Identifiers are\n   simply formatted strings which identify--via name, location, or any\n   other characteristic--a resource.\n\n\n\nFielding, et al.            Standards Track                    [Page 18]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.1 General Syntax"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_14",
        "original_index": 14,
        "content": "Fielding, et al.            Standards Track                    [Page 18]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.1 General Syntax\n\n   URIs in HTTP can be represented in absolute form or relative to some\n   known base URI [11], depending upon the context of their use. The two\n   forms are differentiated by the fact that absolute URIs always begin\n   with a scheme name followed by a colon. For definitive information on\n   URL syntax and semantics, see \"Uniform Resource Identifiers (URI):\n   Generic Syntax and Semantics,\" RFC 2396 [42] (which replaces RFCs\n   1738 [4] and RFC 1808 [11]). This specification adopts the\n   definitions of \"URI-reference\", \"absoluteURI\", \"relativeURI\", \"port\",\n   \"host\",\"abs_path\", \"rel_path\", and \"authority\" from that\n   specification.\n\n   The HTTP protocol does not place any a priori limit on the length of\n   a URI. Servers MUST be able to handle the URI of any resource they\n   serve, and SHOULD be able to handle URIs of unbounded length if they\n   provide GET-based forms that could generate such URIs. A server\n   SHOULD return 414 (Request-URI Too Long) status if a URI is longer\n   than the server can handle (see section 10.4.15).\n\n      Note: Servers ought to be cautious about depending on URI lengths\n      above 255 bytes, because some older client or proxy\n      implementations might not properly support these lengths.\n\n3.2.2 http URL\n\n   The \"http\" scheme is used to locate network resources via the HTTP\n   protocol. This section defines the scheme-specific syntax and\n   semantics for http URLs.\n\n   http_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query ]]\n\n   If the port is empty or not given, port 80 is assumed. The semantics\n   are that the identified resource is located at the server listening\n   for TCP connections on that port of that host, and the Request-URI\n   for the resource is abs_path (section 5.1.2). The use of IP addresses\n   in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]). If\n   the abs_path is not present in the URL, it MUST be given as \"/\" when\n   used as a Request-URI for a resource (section 5.1.2). If a proxy\n   receives a host name which is not a fully qualified domain name, it\n   MAY add its domain to the host name it received. If a proxy receives\n   a fully qualified domain name, the proxy MUST NOT change the host\n   name.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 19]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n3.2.3 URI Comparison\n\n   When comparing two URIs to decide if they match or not, a client\n   SHOULD use a case-sensitive octet-by-octet comparison of the entire\n   URIs, with these exceptions:\n\n      - A port that is empty or not given is equivalent to the default\n        port for that URI-reference;\n\n        - Comparisons of host names MUST be case-insensitive;\n\n        - Comparisons of scheme names MUST be case-insensitive;\n\n        - An empty abs_path is equivalent to an abs_path of \"/\".\n\n   Characters other than those in the \"reserved\" and \"unsafe\" sets (see\n   RFC 2396 [42]) are equivalent to their \"\"%\" HEX HEX\" encoding.\n\n   For example, the following three URIs are equivalent:\n\n      http://abc.com:80/~smith/home.html\n      http://ABC.com/%7Esmith/home.html\n      http://ABC.com:/%7esmith/home.html\n\n3.3 Date/Time Formats\n\n3.3.1 Full Date\n\n   HTTP applications have historically allowed three different formats\n   for the representation of date/time stamps:\n\n      Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n      Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036\n      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_15",
        "original_index": 15,
        "content": "The first format is preferred as an Internet standard and represents\n   a fixed-length subset of that defined by RFC 1123 [8] (an update to\n   RFC 822 [9]). The second format is in common use, but is based on the\n   obsolete RFC 850 [12] date format and lacks a four-digit year.\n   HTTP/1.1 clients and servers that parse the date value MUST accept\n   all three formats (for compatibility with HTTP/1.0), though they MUST\n   only generate the RFC 1123 format for representing HTTP-date values\n   in header fields. See section 19.3 for further information.\n\n      Note: Recipients of date values are encouraged to be robust in\n      accepting date values that may have been sent by non-HTTP\n      applications, as is sometimes the case when retrieving or posting\n      messages via proxies/gateways to SMTP or NNTP.\n\n\n\nFielding, et al.            Standards Track                    [Page 20]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   All HTTP date/time stamps MUST be represented in Greenwich Mean Time\n   (GMT), without exception. For the purposes of HTTP, GMT is exactly\n   equal to UTC (Coordinated Universal Time). This is indicated in the\n   first two formats by the inclusion of \"GMT\" as the three-letter\n   abbreviation for time zone, and MUST be assumed when reading the\n   asctime format. HTTP-date is case sensitive and MUST NOT include\n   additional LWS beyond that specifically included as SP in the\n   grammar.\n\n       HTTP-date    = rfc1123-date | rfc850-date | asctime-date\n       rfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\n       rfc850-date  = weekday \",\" SP date2 SP time SP \"GMT\"\n       asctime-date = wkday SP date3 SP time SP 4DIGIT\n       date1        = 2DIGIT SP month SP 4DIGIT\n                      ; day month year (e.g., 02 Jun 1982)\n       date2        = 2DIGIT \"-\" month \"-\" 2DIGIT\n                      ; day-month-year (e.g., 02-Jun-82)\n       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n                      ; month day (e.g., Jun  2)\n       time         = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n                      ; 00:00:00 - 23:59:59\n       wkday        = \"Mon\" | \"Tue\" | \"Wed\"\n                    | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\n       weekday      = \"Monday\" | \"Tuesday\" | \"Wednesday\"\n                    | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\"\n       month        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n                    | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n                    | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n\n      Note: HTTP requirements for the date/time stamp format apply only\n      to their usage within the protocol stream. Clients and servers are\n      not required to use these formats for user presentation, request\n      logging, etc.\n\n3.3.2 Delta Seconds\n\n   Some HTTP header fields allow a time value to be specified as an\n   integer number of seconds, represented in decimal, after the time\n   that the message was received.\n\n       delta-seconds  = 1*DIGIT\n\n3.4 Character Sets\n\n   HTTP uses the same definition of the term \"character set\" as that\n   described for MIME:\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 21]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_16",
        "original_index": 16,
        "content": "Fielding, et al.            Standards Track                    [Page 21]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The term \"character set\" is used in this document to refer to a\n   method used with one or more tables to convert a sequence of octets\n   into a sequence of characters. Note that unconditional conversion in\n   the other direction is not required, in that not all characters may\n   be available in a given character set and a character set may provide\n   more than one sequence of octets to represent a particular character.\n   This definition is intended to allow various kinds of character\n   encoding, from simple single-table mappings such as US-ASCII to\n   complex table switching methods such as those that use ISO-2022's\n   techniques. However, the definition associated with a MIME character\n   set name MUST fully specify the mapping to be performed from octets\n   to characters. In particular, use of external profiling information\n   to determine the exact mapping is not permitted.\n\n      Note: This use of the term \"character set\" is more commonly\n      referred to as a \"character encoding.\" However, since HTTP and\n      MIME share the same registry, it is important that the terminology\n      also be shared.\n\n   HTTP character sets are identified by case-insensitive tokens. The\n   complete set of tokens is defined by the IANA Character Set registry\n   [19].\n\n       charset = token\n\n   Although HTTP allows an arbitrary token to be used as a charset\n   value, any token that has a predefined value within the IANA\n   Character Set registry [19] MUST represent the character set defined\n   by that registry. Applications SHOULD limit their use of character\n   sets to those defined by the IANA registry.\n\n   Implementors should be aware of IETF character set requirements [38]\n   [41].\n\n3.4.1 Missing Charset\n\n   Some HTTP/1.0 software has interpreted a Content-Type header without\n   charset parameter incorrectly to mean \"recipient should guess.\"\n   Senders wishing to defeat this behavior MAY include a charset\n   parameter even when the charset is ISO-8859-1 and SHOULD do so when\n   it is known that it will not confuse the recipient.\n\n   Unfortunately, some older HTTP/1.0 clients did not deal properly with\n   an explicit charset parameter. HTTP/1.1 recipients MUST respect the\n   charset label provided by the sender; and those user agents that have\n   a provision to \"guess\" a charset MUST use the charset from the\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 22]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   content-type field if they support that charset, rather than the\n   recipient's preference, when initially displaying a document. See\n   section 3.7.1.\n\n3.5 Content Codings\n\n   Content coding values indicate an encoding transformation that has\n   been or can be applied to an entity. Content codings are primarily\n   used to allow a document to be compressed or otherwise usefully\n   transformed without losing the identity of its underlying media type\n   and without loss of information. Frequently, the entity is stored in\n   coded form, transmitted directly, and only decoded by the recipient.\n\n       content-coding   = token\n\n   All content-coding values are case-insensitive. HTTP/1.1 uses\n   content-coding values in the Accept-Encoding (section 14.3) and\n   Content-Encoding (section 14.11) header fields. Although the value\n   describes the content-coding, what is more important is that it\n   indicates what decoding mechanism will be required to remove the\n   encoding.\n\n   The Internet Assigned Numbers Authority (IANA) acts as a registry for\n   content-coding value tokens. Initially, the registry contains the\n   following tokens:\n\n   gzip An encoding format produced by the file compression program\n        \"gzip\" (GNU zip) as described in RFC 1952 [25]. This format is a\n        Lempel-Ziv coding (LZ77) with a 32 bit CRC."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_17",
        "original_index": 17,
        "content": "gzip An encoding format produced by the file compression program\n        \"gzip\" (GNU zip) as described in RFC 1952 [25]. This format is a\n        Lempel-Ziv coding (LZ77) with a 32 bit CRC.\n\n   compress\n        The encoding format produced by the common UNIX file compression\n        program \"compress\". This format is an adaptive Lempel-Ziv-Welch\n        coding (LZW).\n\n        Use of program names for the identification of encoding formats\n        is not desirable and is discouraged for future encodings. Their\n        use here is representative of historical practice, not good\n        design. For compatibility with previous implementations of HTTP,\n        applications SHOULD consider \"x-gzip\" and \"x-compress\" to be\n        equivalent to \"gzip\" and \"compress\" respectively.\n\n   deflate\n        The \"zlib\" format defined in RFC 1950 [31] in combination with\n        the \"deflate\" compression mechanism described in RFC 1951 [29].\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 23]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   identity\n        The default (identity) encoding; the use of no transformation\n        whatsoever. This content-coding is used only in the Accept-\n        Encoding header, and SHOULD NOT be used in the Content-Encoding\n        header.\n\n   New content-coding value tokens SHOULD be registered; to allow\n   interoperability between clients and servers, specifications of the\n   content coding algorithms needed to implement a new value SHOULD be\n   publicly available and adequate for independent implementation, and\n   conform to the purpose of content coding defined in this section.\n\n3.6 Transfer Codings\n\n   Transfer-coding values are used to indicate an encoding\n   transformation that has been, can be, or may need to be applied to an\n   entity-body in order to ensure \"safe transport\" through the network.\n   This differs from a content coding in that the transfer-coding is a\n   property of the message, not of the original entity.\n\n       transfer-coding         = \"chunked\" | transfer-extension\n       transfer-extension      = token *( \";\" parameter )\n\n   Parameters are in  the form of attribute/value pairs.\n\n       parameter               = attribute \"=\" value\n       attribute               = token\n       value                   = token | quoted-string\n\n   All transfer-coding values are case-insensitive. HTTP/1.1 uses\n   transfer-coding values in the TE header field (section 14.39) and in\n   the Transfer-Encoding header field (section 14.41).\n\n   Whenever a transfer-coding is applied to a message-body, the set of\n   transfer-codings MUST include \"chunked\", unless the message is\n   terminated by closing the connection. When the \"chunked\" transfer-\n   coding is used, it MUST be the last transfer-coding applied to the\n   message-body. The \"chunked\" transfer-coding MUST NOT be applied more\n   than once to a message-body. These rules allow the recipient to\n   determine the transfer-length of the message (section 4.4).\n\n   Transfer-codings are analogous to the Content-Transfer-Encoding\n   values of MIME [7], which were designed to enable safe transport of\n   binary data over a 7-bit transport service. However, safe transport\n   has a different focus for an 8bit-clean transfer protocol. In HTTP,\n   the only unsafe characteristic of message-bodies is the difficulty in\n   determining the exact body length (section 7.2.2), or the desire to\n   encrypt data over a shared transport.\n\n\n\nFielding, et al.            Standards Track                    [Page 24]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Internet Assigned Numbers Authority (IANA) acts as a registry for\n   transfer-coding value tokens. Initially, the registry contains the\n   following tokens: \"chunked\" (section 3.6.1), \"identity\" (section\n   3.6.2), \"gzip\" (section 3.5), \"compress\" (section 3.5), and \"deflate\"\n   (section 3.5)."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_18",
        "original_index": 18,
        "content": "New transfer-coding value tokens SHOULD be registered in the same way\n   as new content-coding value tokens (section 3.5).\n\n   A server which receives an entity-body with a transfer-coding it does\n   not understand SHOULD return 501 (Unimplemented), and close the\n   connection. A server MUST NOT send transfer-codings to an HTTP/1.0\n   client.\n\n3.6.1 Chunked Transfer Coding\n\n   The chunked encoding modifies the body of a message in order to\n   transfer it as a series of chunks, each with its own size indicator,\n   followed by an OPTIONAL trailer containing entity-header fields. This\n   allows dynamically produced content to be transferred along with the\n   information necessary for the recipient to verify that it has\n   received the full message.\n\n       Chunked-Body   = *chunk\n                        last-chunk\n                        trailer\n                        CRLF\n\n       chunk          = chunk-size [ chunk-extension ] CRLF\n                        chunk-data CRLF\n       chunk-size     = 1*HEX\n       last-chunk     = 1*(\"0\") [ chunk-extension ] CRLF\n\n       chunk-extension= *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )\n       chunk-ext-name = token\n       chunk-ext-val  = token | quoted-string\n       chunk-data     = chunk-size(OCTET)\n       trailer        = *(entity-header CRLF)\n\n   The chunk-size field is a string of hex digits indicating the size of\n   the chunk. The chunked encoding is ended by any chunk whose size is\n   zero, followed by the trailer, which is terminated by an empty line.\n\n   The trailer allows the sender to include additional HTTP header\n   fields at the end of the message. The Trailer header field can be\n   used to indicate which header fields are included in a trailer (see\n   section 14.40).\n\n\n\n\nFielding, et al.            Standards Track                    [Page 25]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A server using chunked transfer-coding in a response MUST NOT use the\n   trailer for any header fields unless at least one of the following is\n   true:\n\n   a)the request included a TE header field that indicates \"trailers\" is\n     acceptable in the transfer-coding of the  response, as described in\n     section 14.39; or,\n\n   b)the server is the origin server for the response, the trailer\n     fields consist entirely of optional metadata, and the recipient\n     could use the message (in a manner acceptable to the origin server)\n     without receiving this metadata.  In other words, the origin server\n     is willing to accept the possibility that the trailer fields might\n     be silently discarded along the path to the client.\n\n   This requirement prevents an interoperability failure when the\n   message is being received by an HTTP/1.1 (or later) proxy and\n   forwarded to an HTTP/1.0 recipient. It avoids a situation where\n   compliance with the protocol would have necessitated a possibly\n   infinite buffer on the proxy.\n\n   An example process for decoding a Chunked-Body is presented in\n   appendix 19.4.6.\n\n   All HTTP/1.1 applications MUST be able to receive and decode the\n   \"chunked\" transfer-coding, and MUST ignore chunk-extension extensions\n   they do not understand.\n\n3.7 Media Types\n\n   HTTP uses Internet Media Types [17] in the Content-Type (section\n   14.17) and Accept (section 14.1) header fields in order to provide\n   open and extensible data typing and type negotiation.\n\n       media-type     = type \"/\" subtype *( \";\" parameter )\n       type           = token\n       subtype        = token\n\n   Parameters MAY follow the type/subtype in the form of attribute/value\n   pairs (as defined in section 3.6)."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_19",
        "original_index": 19,
        "content": "Parameters MAY follow the type/subtype in the form of attribute/value\n   pairs (as defined in section 3.6).\n\n   The type, subtype, and parameter attribute names are case-\n   insensitive. Parameter values might or might not be case-sensitive,\n   depending on the semantics of the parameter name. Linear white space\n   (LWS) MUST NOT be used between the type and subtype, nor between an\n   attribute and its value. The presence or absence of a parameter might\n   be significant to the processing of a media-type, depending on its\n   definition within the media type registry.\n\n\n\nFielding, et al.            Standards Track                    [Page 26]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Note that some older HTTP applications do not recognize media type\n   parameters. When sending data to older HTTP applications,\n   implementations SHOULD only use media type parameters when they are\n   required by that type/subtype definition.\n\n   Media-type values are registered with the Internet Assigned Number\n   Authority (IANA [19]). The media type registration process is\n   outlined in RFC 1590 [17]. Use of non-registered media types is\n   discouraged.\n\n3.7.1 Canonicalization and Text Defaults\n\n   Internet media types are registered with a canonical form. An\n   entity-body transferred via HTTP messages MUST be represented in the\n   appropriate canonical form prior to its transmission except for\n   \"text\" types, as defined in the next paragraph.\n\n   When in canonical form, media subtypes of the \"text\" type use CRLF as\n   the text line break. HTTP relaxes this requirement and allows the\n   transport of text media with plain CR or LF alone representing a line\n   break when it is done consistently for an entire entity-body. HTTP\n   applications MUST accept CRLF, bare CR, and bare LF as being\n   representative of a line break in text media received via HTTP. In\n   addition, if the text is represented in a character set that does not\n   use octets 13 and 10 for CR and LF respectively, as is the case for\n   some multi-byte character sets, HTTP allows the use of whatever octet\n   sequences are defined by that character set to represent the\n   equivalent of CR and LF for line breaks. This flexibility regarding\n   line breaks applies only to text media in the entity-body; a bare CR\n   or LF MUST NOT be substituted for CRLF within any of the HTTP control\n   structures (such as header fields and multipart boundaries).\n\n   If an entity-body is encoded with a content-coding, the underlying\n   data MUST be in a form defined above prior to being encoded.\n\n   The \"charset\" parameter is used with some media types to define the\n   character set (section 3.4) of the data. When no explicit charset\n   parameter is provided by the sender, media subtypes of the \"text\"\n   type are defined to have a default charset value of \"ISO-8859-1\" when\n   received via HTTP. Data in character sets other than \"ISO-8859-1\" or\n   its subsets MUST be labeled with an appropriate charset value. See\n   section 3.4.1 for compatibility problems.\n\n3.7.2 Multipart Types\n\n   MIME provides for a number of \"multipart\" types -- encapsulations of\n   one or more entities within a single message-body. All multipart\n   types share a common syntax, as defined in section 5.1.1 of RFC 2046\n\n\n\nFielding, et al.            Standards Track                    [Page 27]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_20",
        "original_index": 20,
        "content": "Fielding, et al.            Standards Track                    [Page 27]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [40], and MUST include a boundary parameter as part of the media type\n   value. The message body is itself a protocol element and MUST\n   therefore use only CRLF to represent line breaks between body-parts.\n   Unlike in RFC 2046, the epilogue of any multipart message MUST be\n   empty; HTTP applications MUST NOT transmit the epilogue (even if the\n   original multipart contains an epilogue). These restrictions exist in\n   order to preserve the self-delimiting nature of a multipart message-\n   body, wherein the \"end\" of the message-body is indicated by the\n   ending multipart boundary.\n\n   In general, HTTP treats a multipart message-body no differently than\n   any other media type: strictly as payload. The one exception is the\n   \"multipart/byteranges\" type (appendix 19.2) when it appears in a 206\n   (Partial Content) response, which will be interpreted by some HTTP\n   caching mechanisms as described in sections 13.5.4 and 14.16. In all\n   other cases, an HTTP user agent SHOULD follow the same or similar\n   behavior as a MIME user agent would upon receipt of a multipart type.\n   The MIME header fields within each body-part of a multipart message-\n   body do not have any significance to HTTP beyond that defined by\n   their MIME semantics.\n\n   In general, an HTTP user agent SHOULD follow the same or similar\n   behavior as a MIME user agent would upon receipt of a multipart type.\n   If an application receives an unrecognized multipart subtype, the\n   application MUST treat it as being equivalent to \"multipart/mixed\".\n\n      Note: The \"multipart/form-data\" type has been specifically defined\n      for carrying form data suitable for processing via the POST\n      request method, as described in RFC 1867 [15].\n\n3.8 Product Tokens\n\n   Product tokens are used to allow communicating applications to\n   identify themselves by software name and version. Most fields using\n   product tokens also allow sub-products which form a significant part\n   of the application to be listed, separated by white space. By\n   convention, the products are listed in order of their significance\n   for identifying the application.\n\n       product         = token [\"/\" product-version]\n       product-version = token\n\n   Examples:\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n       Server: Apache/0.8.4\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 28]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Product tokens SHOULD be short and to the point. They MUST NOT be\n   used for advertising or other non-essential information. Although any\n   token character MAY appear in a product-version, this token SHOULD\n   only be used for a version identifier (i.e., successive versions of\n   the same product SHOULD only differ in the product-version portion of\n   the product value).\n\n3.9 Quality Values\n\n   HTTP content negotiation (section 12) uses short \"floating point\"\n   numbers to indicate the relative importance (\"weight\") of various\n   negotiable parameters.  A weight is normalized to a real number in\n   the range 0 through 1, where 0 is the minimum and 1 the maximum\n   value. If a parameter has a quality value of 0, then content with\n   this parameter is `not acceptable' for the client. HTTP/1.1\n   applications MUST NOT generate more than three digits after the\n   decimal point. User configuration of these values SHOULD also be\n   limited in this fashion.\n\n       qvalue         = ( \"0\" [ \".\" 0*3DIGIT ] )\n                      | ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n   \"Quality values\" is a misnomer, since these values merely represent\n   relative degradation in desired quality.\n\n3.10 Language Tags"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_21",
        "original_index": 21,
        "content": "\"Quality values\" is a misnomer, since these values merely represent\n   relative degradation in desired quality.\n\n3.10 Language Tags\n\n   A language tag identifies a natural language spoken, written, or\n   otherwise conveyed by human beings for communication of information\n   to other human beings. Computer languages are explicitly excluded.\n   HTTP uses language tags within the Accept-Language and Content-\n   Language fields.\n\n   The syntax and registry of HTTP language tags is the same as that\n   defined by RFC 1766 [1]. In summary, a language tag is composed of 1\n   or more parts: A primary language tag and a possibly empty series of\n   subtags:\n\n        language-tag  = primary-tag *( \"-\" subtag )\n        primary-tag   = 1*8ALPHA\n        subtag        = 1*8ALPHA\n\n   White space is not allowed within the tag and all tags are case-\n   insensitive. The name space of language tags is administered by the\n   IANA. Example tags include:\n\n       en, en-US, en-cockney, i-cherokee, x-pig-latin\n\n\n\n\nFielding, et al.            Standards Track                    [Page 29]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   where any two-letter primary-tag is an ISO-639 language abbreviation\n   and any two-letter initial subtag is an ISO-3166 country code. (The\n   last three tags above are not registered tags; all but the last are\n   examples of tags which could be registered in future.)\n\n3.11 Entity Tags\n\n   Entity tags are used for comparing two or more entities from the same\n   requested resource. HTTP/1.1 uses entity tags in the ETag (section\n   14.19), If-Match (section 14.24), If-None-Match (section 14.26), and\n   If-Range (section 14.27) header fields. The definition of how they\n   are used and compared as cache validators is in section 13.3.3. An\n   entity tag consists of an opaque quoted string, possibly prefixed by\n   a weakness indicator.\n\n      entity-tag = [ weak ] opaque-tag\n      weak       = \"W/\"\n      opaque-tag = quoted-string\n\n   A \"strong entity tag\" MAY be shared by two entities of a resource\n   only if they are equivalent by octet equality.\n\n   A \"weak entity tag,\" indicated by the \"W/\" prefix, MAY be shared by\n   two entities of a resource only if the entities are equivalent and\n   could be substituted for each other with no significant change in\n   semantics. A weak entity tag can only be used for weak comparison.\n\n   An entity tag MUST be unique across all versions of all entities\n   associated with a particular resource. A given entity tag value MAY\n   be used for entities obtained by requests on different URIs. The use\n   of the same entity tag value in conjunction with entities obtained by\n   requests on different URIs does not imply the equivalence of those\n   entities.\n\n3.12 Range Units\n\n   HTTP/1.1 allows a client to request that only part (a range of) the\n   response entity be included within the response. HTTP/1.1 uses range\n   units in the Range (section 14.35) and Content-Range (section 14.16)\n   header fields. An entity can be broken down into subranges according\n   to various structural units.\n\n      range-unit       = bytes-unit | other-range-unit\n      bytes-unit       = \"bytes\"\n      other-range-unit = token\n\n   The only range unit defined by HTTP/1.1 is \"bytes\". HTTP/1.1\n   implementations MAY ignore ranges specified using other units.\n\n\n\nFielding, et al.            Standards Track                    [Page 30]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 has been designed to allow implementations of applications\n   that do not depend on knowledge of ranges.\n\n4 HTTP Message\n\n4.1 Message Types\n\n   HTTP messages consist of requests from client to server and responses\n   from server to client.\n\n       HTTP-message   = Request | Response     ; HTTP/1.1 messages"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_22",
        "original_index": 22,
        "content": "4.1 Message Types\n\n   HTTP messages consist of requests from client to server and responses\n   from server to client.\n\n       HTTP-message   = Request | Response     ; HTTP/1.1 messages\n\n   Request (section 5) and Response (section 6) messages use the generic\n   message format of RFC 822 [9] for transferring entities (the payload\n   of the message). Both types of message consist of a start-line, zero\n   or more header fields (also known as \"headers\"), an empty line (i.e.,\n   a line with nothing preceding the CRLF) indicating the end of the\n   header fields, and possibly a message-body.\n\n        generic-message = start-line\n                          *(message-header CRLF)\n                          CRLF\n                          [ message-body ]\n        start-line      = Request-Line | Status-Line\n\n   In the interest of robustness, servers SHOULD ignore any empty\n   line(s) received where a Request-Line is expected. In other words, if\n   the server is reading the protocol stream at the beginning of a\n   message and receives a CRLF first, it should ignore the CRLF.\n\n   Certain buggy HTTP/1.0 client implementations generate extra CRLF's\n   after a POST request. To restate what is explicitly forbidden by the\n   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an\n   extra CRLF.\n\n4.2 Message Headers\n\n   HTTP header fields, which include general-header (section 4.5),\n   request-header (section 5.3), response-header (section 6.2), and\n   entity-header (section 7.1) fields, follow the same generic format as\n   that given in Section 3.1 of RFC 822 [9]. Each header field consists\n   of a name followed by a colon (\":\") and the field value. Field names\n   are case-insensitive. The field value MAY be preceded by any amount\n   of LWS, though a single SP is preferred. Header fields can be\n   extended over multiple lines by preceding each extra line with at\n   least one SP or HT. Applications ought to follow \"common form\", where\n   one is known or indicated, when generating HTTP constructs, since\n   there might exist some implementations that fail to accept anything\n\n\n\nFielding, et al.            Standards Track                    [Page 31]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   beyond the common forms.\n\n       message-header = field-name \":\" [ field-value ]\n       field-name     = token\n       field-value    = *( field-content | LWS )\n       field-content  = <the OCTETs making up the field-value\n                        and consisting of either *TEXT or combinations\n                        of token, separators, and quoted-string>\n\n   The field-content does not include any leading or trailing LWS:\n   linear white space occurring before the first non-whitespace\n   character of the field-value or after the last non-whitespace\n   character of the field-value. Such leading or trailing LWS MAY be\n   removed without changing the semantics of the field value. Any LWS\n   that occurs between field-content MAY be replaced with a single SP\n   before interpreting the field value or forwarding the message\n   downstream.\n\n   The order in which header fields with differing field names are\n   received is not significant. However, it is \"good practice\" to send\n   general-header fields first, followed by request-header or response-\n   header fields, and ending with the entity-header fields."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_23",
        "original_index": 23,
        "content": "Multiple message-header fields with the same field-name MAY be\n   present in a message if and only if the entire field-value for that\n   header field is defined as a comma-separated list [i.e., #(values)].\n   It MUST be possible to combine the multiple header fields into one\n   \"field-name: field-value\" pair, without changing the semantics of the\n   message, by appending each subsequent field-value to the first, each\n   separated by a comma. The order in which header fields with the same\n   field-name are received is therefore significant to the\n   interpretation of the combined field value, and thus a proxy MUST NOT\n   change the order of these field values when a message is forwarded.\n\n4.3 Message Body\n\n   The message-body (if any) of an HTTP message is used to carry the\n   entity-body associated with the request or response. The message-body\n   differs from the entity-body only when a transfer-coding has been\n   applied, as indicated by the Transfer-Encoding header field (section\n   14.41).\n\n       message-body = entity-body\n                    | <entity-body encoded as per Transfer-Encoding>\n\n   Transfer-Encoding MUST be used to indicate any transfer-codings\n   applied by an application to ensure safe and proper transfer of the\n   message. Transfer-Encoding is a property of the message, not of the\n\n\n\nFielding, et al.            Standards Track                    [Page 32]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   entity, and thus MAY be added or removed by any application along the\n   request/response chain. (However, section 3.6 places restrictions on\n   when certain transfer-codings may be used.)\n\n   The rules for when a message-body is allowed in a message differ for\n   requests and responses.\n\n   The presence of a message-body in a request is signaled by the\n   inclusion of a Content-Length or Transfer-Encoding header field in\n   the request's message-headers. A message-body MUST NOT be included in\n   a request if the specification of the request method (section 5.1.1)\n   does not allow sending an entity-body in requests. A server SHOULD\n   read and forward a message-body on any request; if the request method\n   does not include defined semantics for an entity-body, then the\n   message-body SHOULD be ignored when handling the request.\n\n   For response messages, whether or not a message-body is included with\n   a message is dependent on both the request method and the response\n   status code (section 6.1.1). All responses to the HEAD request method\n   MUST NOT include a message-body, even though the presence of entity-\n   header fields might lead one to believe they do. All 1xx\n   (informational), 204 (no content), and 304 (not modified) responses\n   MUST NOT include a message-body. All other responses do include a\n   message-body, although it MAY be of zero length.\n\n4.4 Message Length\n\n   The transfer-length of a message is the length of the message-body as\n   it appears in the message; that is, after any transfer-codings have\n   been applied. When a message-body is included with a message, the\n   transfer-length of that body is determined by one of the following\n   (in order of precedence):\n\n   1.Any response message which \"MUST NOT\" include a message-body (such\n     as the 1xx, 204, and 304 responses and any response to a HEAD\n     request) is always terminated by the first empty line after the\n     header fields, regardless of the entity-header fields present in\n     the message.\n\n   2.If a Transfer-Encoding header field (section 14.41) is present and\n     has any value other than \"identity\", then the transfer-length is\n     defined by use of the \"chunked\" transfer-coding (section 3.6),\n     unless the message is terminated by closing the connection."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_24",
        "original_index": 24,
        "content": "3.If a Content-Length header field (section 14.13) is present, its\n     decimal value in OCTETs represents both the entity-length and the\n     transfer-length. The Content-Length header field MUST NOT be sent\n     if these two lengths are different (i.e., if a Transfer-Encoding\n\n\n\nFielding, et al.            Standards Track                    [Page 33]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n     header field is present). If a message is received with both a\n     Transfer-Encoding header field and a Content-Length header field,\n     the latter MUST be ignored.\n\n   4.If the message uses the media type \"multipart/byteranges\", and the\n     ransfer-length is not otherwise specified, then this self-\n     elimiting media type defines the transfer-length. This media type\n     UST NOT be used unless the sender knows that the recipient can arse\n     it; the presence in a request of a Range header with ultiple byte-\n     range specifiers from a 1.1 client implies that the lient can parse\n     multipart/byteranges responses.\n\n       A range header might be forwarded by a 1.0 proxy that does not\n       understand multipart/byteranges; in this case the server MUST\n       delimit the message using methods defined in items 1,3 or 5 of\n       this section.\n\n   5.By the server closing the connection. (Closing the connection\n     cannot be used to indicate the end of a request body, since that\n     would leave no possibility for the server to send back a response.)\n\n   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests\n   containing a message-body MUST include a valid Content-Length header\n   field unless the server is known to be HTTP/1.1 compliant. If a\n   request contains a message-body and a Content-Length is not given,\n   the server SHOULD respond with 400 (bad request) if it cannot\n   determine the length of the message, or with 411 (length required) if\n   it wishes to insist on receiving a valid Content-Length.\n\n   All HTTP/1.1 applications that receive entities MUST accept the\n   \"chunked\" transfer-coding (section 3.6), thus allowing this mechanism\n   to be used for messages when the message length cannot be determined\n   in advance.\n\n   Messages MUST NOT include both a Content-Length header field and a\n   non-identity transfer-coding. If the message does include a non-\n   identity transfer-coding, the Content-Length MUST be ignored.\n\n   When a Content-Length is given in a message where a message-body is\n   allowed, its field value MUST exactly match the number of OCTETs in\n   the message-body. HTTP/1.1 user agents MUST notify the user when an\n   invalid length is received and detected.\n\n4.5 General Header Fields\n\n   There are a few header fields which have general applicability for\n   both request and response messages, but which do not apply to the\n   entity being transferred. These header fields apply only to the\n\n\n\nFielding, et al.            Standards Track                    [Page 34]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   message being transmitted.\n\n       general-header = Cache-Control            ; Section 14.9\n                      | Connection               ; Section 14.10\n                      | Date                     ; Section 14.18\n                      | Pragma                   ; Section 14.32\n                      | Trailer                  ; Section 14.40\n                      | Transfer-Encoding        ; Section 14.41\n                      | Upgrade                  ; Section 14.42\n                      | Via                      ; Section 14.45\n                      | Warning                  ; Section 14.46"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_25",
        "original_index": 25,
        "content": "General-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields may be given the semantics of general\n   header fields if all parties in the communication recognize them to\n   be general-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n5 Request\n\n   A request message from a client to a server includes, within the\n   first line of that message, the method to be applied to the resource,\n   the identifier of the resource, and the protocol version in use.\n\n        Request       = Request-Line              ; Section 5.1\n                        *(( general-header        ; Section 4.5\n                         | request-header         ; Section 5.3\n                         | entity-header ) CRLF)  ; Section 7.1\n                        CRLF\n                        [ message-body ]          ; Section 4.3\n\n5.1 Request-Line\n\n   The Request-Line begins with a method token, followed by the\n   Request-URI and the protocol version, and ending with CRLF. The\n   elements are separated by SP characters. No CR or LF is allowed\n   except in the final CRLF sequence.\n\n        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 35]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n5.1.1 Method\n\n   The Method  token indicates the method to be performed on the\n   resource identified by the Request-URI. The method is case-sensitive.\n\n       Method         = \"OPTIONS\"                ; Section 9.2\n                      | \"GET\"                    ; Section 9.3\n                      | \"HEAD\"                   ; Section 9.4\n                      | \"POST\"                   ; Section 9.5\n                      | \"PUT\"                    ; Section 9.6\n                      | \"DELETE\"                 ; Section 9.7\n                      | \"TRACE\"                  ; Section 9.8\n                      | \"CONNECT\"                ; Section 9.9\n                      | extension-method\n       extension-method = token\n\n   The list of methods allowed by a resource can be specified in an\n   Allow header field (section 14.7). The return code of the response\n   always notifies the client whether a method is currently allowed on a\n   resource, since the set of allowed methods can change dynamically. An\n   origin server SHOULD return the status code 405 (Method Not Allowed)\n   if the method is known by the origin server but not allowed for the\n   requested resource, and 501 (Not Implemented) if the method is\n   unrecognized or not implemented by the origin server. The methods GET\n   and HEAD MUST be supported by all general-purpose servers. All other\n   methods are OPTIONAL; however, if the above methods are implemented,\n   they MUST be implemented with the same semantics as those specified\n   in section 9.\n\n5.1.2 Request-URI\n\n   The Request-URI is a Uniform Resource Identifier (section 3.2) and\n   identifies the resource upon which to apply the request.\n\n       Request-URI    = \"*\" | absoluteURI | abs_path | authority\n\n   The four options for Request-URI are dependent on the nature of the\n   request. The asterisk \"*\" means that the request does not apply to a\n   particular resource, but to the server itself, and is only allowed\n   when the method used does not necessarily apply to a resource. One\n   example would be\n\n       OPTIONS * HTTP/1.1\n\n   The absoluteURI form is REQUIRED when the request is being made to a\n   proxy. The proxy is requested to forward the request or service it\n   from a valid cache, and return the response. Note that the proxy MAY\n   forward the request on to another proxy or directly to the server\n\n\n\nFielding, et al.            Standards Track                    [Page 36]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_26",
        "original_index": 26,
        "content": "Fielding, et al.            Standards Track                    [Page 36]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   specified by the absoluteURI. In order to avoid request loops, a\n   proxy MUST be able to recognize all of its server names, including\n   any aliases, local variations, and the numeric IP address. An example\n   Request-Line would be:\n\n       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1\n\n   To allow for transition to absoluteURIs in all requests in future\n   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI\n   form in requests, even though HTTP/1.1 clients will only generate\n   them in requests to proxies.\n\n   The authority form is only used by the CONNECT method (section 9.9).\n\n   The most common form of Request-URI is that used to identify a\n   resource on an origin server or gateway. In this case the absolute\n   path of the URI MUST be transmitted (see section 3.2.1, abs_path) as\n   the Request-URI, and the network location of the URI (authority) MUST\n   be transmitted in a Host header field. For example, a client wishing\n   to retrieve the resource above directly from the origin server would\n   create a TCP connection to port 80 of the host \"www.w3.org\" and send\n   the lines:\n\n       GET /pub/WWW/TheProject.html HTTP/1.1\n       Host: www.w3.org\n\n   followed by the remainder of the Request. Note that the absolute path\n   cannot be empty; if none is present in the original URI, it MUST be\n   given as \"/\" (the server root).\n\n   The Request-URI is transmitted in the format specified in section\n   3.2.1. If the Request-URI is encoded using the \"% HEX HEX\" encoding\n   [42], the origin server MUST decode the Request-URI in order to\n   properly interpret the request. Servers SHOULD respond to invalid\n   Request-URIs with an appropriate status code.\n\n   A transparent proxy MUST NOT rewrite the \"abs_path\" part of the\n   received Request-URI when forwarding it to the next inbound server,\n   except as noted above to replace a null abs_path with \"/\".\n\n      Note: The \"no rewrite\" rule prevents the proxy from changing the\n      meaning of the request when the origin server is improperly using\n      a non-reserved URI character for a reserved purpose.  Implementors\n      should be aware that some pre-HTTP/1.1 proxies have been known to\n      rewrite the Request-URI.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 37]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n5.2 The Resource Identified by a Request\n\n   The exact resource identified by an Internet request is determined by\n   examining both the Request-URI and the Host header field.\n\n   An origin server that does not allow resources to differ by the\n   requested host MAY ignore the Host header field value when\n   determining the resource identified by an HTTP/1.1 request. (But see\n   section 19.6.1.1 for other requirements on Host support in HTTP/1.1.)\n\n   An origin server that does differentiate resources based on the host\n   requested (sometimes referred to as virtual hosts or vanity host\n   names) MUST use the following rules for determining the requested\n   resource on an HTTP/1.1 request:\n\n   1. If Request-URI is an absoluteURI, the host is part of the\n     Request-URI. Any Host header field value in the request MUST be\n     ignored.\n\n   2. If the Request-URI is not an absoluteURI, and the request includes\n     a Host header field, the host is determined by the Host header\n     field value.\n\n   3. If the host as determined by rule 1 or 2 is not a valid host on\n     the server, the response MUST be a 400 (Bad Request) error message.\n\n   Recipients of an HTTP/1.0 request that lacks a Host header field MAY\n   attempt to use heuristics (e.g., examination of the URI path for\n   something unique to a particular host) in order to determine what\n   exact resource is being requested.\n\n5.3 Request Header Fields"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_27",
        "original_index": 27,
        "content": "5.3 Request Header Fields\n\n   The request-header fields allow the client to pass additional\n   information about the request, and about the client itself, to the\n   server. These fields act as request modifiers, with semantics\n   equivalent to the parameters on a programming language method\n   invocation.\n\n       request-header = Accept                   ; Section 14.1\n                      | Accept-Charset           ; Section 14.2\n                      | Accept-Encoding          ; Section 14.3\n                      | Accept-Language          ; Section 14.4\n                      | Authorization            ; Section 14.8\n                      | Expect                   ; Section 14.20\n                      | From                     ; Section 14.22\n                      | Host                     ; Section 14.23\n                      | If-Match                 ; Section 14.24\n\n\n\nFielding, et al.            Standards Track                    [Page 38]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                      | If-Modified-Since        ; Section 14.25\n                      | If-None-Match            ; Section 14.26\n                      | If-Range                 ; Section 14.27\n                      | If-Unmodified-Since      ; Section 14.28\n                      | Max-Forwards             ; Section 14.31\n                      | Proxy-Authorization      ; Section 14.34\n                      | Range                    ; Section 14.35\n                      | Referer                  ; Section 14.36\n                      | TE                       ; Section 14.39\n                      | User-Agent               ; Section 14.43\n\n   Request-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields MAY be given the semantics of request-\n   header fields if all parties in the communication recognize them to\n   be request-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n6 Response\n\n   After receiving and interpreting a request message, a server responds\n   with an HTTP response message.\n\n       Response      = Status-Line               ; Section 6.1\n                       *(( general-header        ; Section 4.5\n                        | response-header        ; Section 6.2\n                        | entity-header ) CRLF)  ; Section 7.1\n                       CRLF\n                       [ message-body ]          ; Section 7.2\n\n6.1 Status-Line\n\n   The first line of a Response message is the Status-Line, consisting\n   of the protocol version followed by a numeric status code and its\n   associated textual phrase, with each element separated by SP\n   characters. No CR or LF is allowed except in the final CRLF sequence.\n\n       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n\n6.1.1 Status Code and Reason Phrase\n\n   The Status-Code element is a 3-digit integer result code of the\n   attempt to understand and satisfy the request. These codes are fully\n   defined in section 10. The Reason-Phrase is intended to give a short\n   textual description of the Status-Code. The Status-Code is intended\n   for use by automata and the Reason-Phrase is intended for the human\n   user. The client is not required to examine or display the Reason-\n   Phrase.\n\n\n\nFielding, et al.            Standards Track                    [Page 39]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The first digit of the Status-Code defines the class of response. The\n   last two digits do not have any categorization role. There are 5\n   values for the first digit:\n\n      - 1xx: Informational - Request received, continuing process\n\n      - 2xx: Success - The action was successfully received,\n        understood, and accepted\n\n      - 3xx: Redirection - Further action must be taken in order to\n        complete the request"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_28",
        "original_index": 28,
        "content": "- 2xx: Success - The action was successfully received,\n        understood, and accepted\n\n      - 3xx: Redirection - Further action must be taken in order to\n        complete the request\n\n      - 4xx: Client Error - The request contains bad syntax or cannot\n        be fulfilled\n\n      - 5xx: Server Error - The server failed to fulfill an apparently\n        valid request\n\n   The individual values of the numeric status codes defined for\n   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are\n   presented below. The reason phrases listed here are only\n   recommendations -- they MAY be replaced by local equivalents without\n   affecting the protocol.\n\n      Status-Code    =\n            \"100\"  ; Section 10.1.1: Continue\n          | \"101\"  ; Section 10.1.2: Switching Protocols\n          | \"200\"  ; Section 10.2.1: OK\n          | \"201\"  ; Section 10.2.2: Created\n          | \"202\"  ; Section 10.2.3: Accepted\n          | \"203\"  ; Section 10.2.4: Non-Authoritative Information\n          | \"204\"  ; Section 10.2.5: No Content\n          | \"205\"  ; Section 10.2.6: Reset Content\n          | \"206\"  ; Section 10.2.7: Partial Content\n          | \"300\"  ; Section 10.3.1: Multiple Choices\n          | \"301\"  ; Section 10.3.2: Moved Permanently\n          | \"302\"  ; Section 10.3.3: Found\n          | \"303\"  ; Section 10.3.4: See Other\n          | \"304\"  ; Section 10.3.5: Not Modified\n          | \"305\"  ; Section 10.3.6: Use Proxy\n          | \"307\"  ; Section 10.3.8: Temporary Redirect\n          | \"400\"  ; Section 10.4.1: Bad Request\n          | \"401\"  ; Section 10.4.2: Unauthorized\n          | \"402\"  ; Section 10.4.3: Payment Required\n          | \"403\"  ; Section 10.4.4: Forbidden\n          | \"404\"  ; Section 10.4.5: Not Found\n          | \"405\"  ; Section 10.4.6: Method Not Allowed\n          | \"406\"  ; Section 10.4.7: Not Acceptable\n\n\n\nFielding, et al.            Standards Track                    [Page 40]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n          | \"407\"  ; Section 10.4.8: Proxy Authentication Required\n          | \"408\"  ; Section 10.4.9: Request Time-out\n          | \"409\"  ; Section 10.4.10: Conflict\n          | \"410\"  ; Section 10.4.11: Gone\n          | \"411\"  ; Section 10.4.12: Length Required\n          | \"412\"  ; Section 10.4.13: Precondition Failed\n          | \"413\"  ; Section 10.4.14: Request Entity Too Large\n          | \"414\"  ; Section 10.4.15: Request-URI Too Large\n          | \"415\"  ; Section 10.4.16: Unsupported Media Type\n          | \"416\"  ; Section 10.4.17: Requested range not satisfiable\n          | \"417\"  ; Section 10.4.18: Expectation Failed\n          | \"500\"  ; Section 10.5.1: Internal Server Error\n          | \"501\"  ; Section 10.5.2: Not Implemented\n          | \"502\"  ; Section 10.5.3: Bad Gateway\n          | \"503\"  ; Section 10.5.4: Service Unavailable\n          | \"504\"  ; Section 10.5.5: Gateway Time-out\n          | \"505\"  ; Section 10.5.6: HTTP Version not supported\n          | extension-code\n\n      extension-code = 3DIGIT\n      Reason-Phrase  = *<TEXT, excluding CR, LF>\n\n   HTTP status codes are extensible. HTTP applications are not required\n   to understand the meaning of all registered status codes, though such\n   understanding is obviously desirable. However, applications MUST\n   understand the class of any status code, as indicated by the first\n   digit, and treat any unrecognized response as being equivalent to the\n   x00 status code of that class, with the exception that an\n   unrecognized response MUST NOT be cached. For example, if an\n   unrecognized status code of 431 is received by the client, it can\n   safely assume that there was something wrong with its request and\n   treat the response as if it had received a 400 status code. In such\n   cases, user agents SHOULD present to the user the entity returned\n   with the response, since that entity is likely to include human-\n   readable information which will explain the unusual status."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_29",
        "original_index": 29,
        "content": "6.2 Response Header Fields\n\n   The response-header fields allow the server to pass additional\n   information about the response which cannot be placed in the Status-\n   Line. These header fields give information about the server and about\n   further access to the resource identified by the Request-URI.\n\n       response-header = Accept-Ranges           ; Section 14.5\n                       | Age                     ; Section 14.6\n                       | ETag                    ; Section 14.19\n                       | Location                ; Section 14.30\n                       | Proxy-Authenticate      ; Section 14.33\n\n\n\nFielding, et al.            Standards Track                    [Page 41]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                       | Retry-After             ; Section 14.37\n                       | Server                  ; Section 14.38\n                       | Vary                    ; Section 14.44\n                       | WWW-Authenticate        ; Section 14.47\n\n   Response-header field names can be extended reliably only in\n   combination with a change in the protocol version. However, new or\n   experimental header fields MAY be given the semantics of response-\n   header fields if all parties in the communication recognize them to\n   be response-header fields. Unrecognized header fields are treated as\n   entity-header fields.\n\n7 Entity\n\n   Request and Response messages MAY transfer an entity if not otherwise\n   restricted by the request method or response status code. An entity\n   consists of entity-header fields and an entity-body, although some\n   responses will only include the entity-headers.\n\n   In this section, both sender and recipient refer to either the client\n   or the server, depending on who sends and who receives the entity.\n\n7.1 Entity Header Fields\n\n   Entity-header fields define metainformation about the entity-body or,\n   if no body is present, about the resource identified by the request.\n   Some of this metainformation is OPTIONAL; some might be REQUIRED by\n   portions of this specification.\n\n       entity-header  = Allow                    ; Section 14.7\n                      | Content-Encoding         ; Section 14.11\n                      | Content-Language         ; Section 14.12\n                      | Content-Length           ; Section 14.13\n                      | Content-Location         ; Section 14.14\n                      | Content-MD5              ; Section 14.15\n                      | Content-Range            ; Section 14.16\n                      | Content-Type             ; Section 14.17\n                      | Expires                  ; Section 14.21\n                      | Last-Modified            ; Section 14.29\n                      | extension-header\n\n       extension-header = message-header\n\n   The extension-header mechanism allows additional entity-header fields\n   to be defined without changing the protocol, but these fields cannot\n   be assumed to be recognizable by the recipient. Unrecognized header\n   fields SHOULD be ignored by the recipient and MUST be forwarded by\n   transparent proxies.\n\n\n\nFielding, et al.            Standards Track                    [Page 42]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n7.2 Entity Body\n\n   The entity-body (if any) sent with an HTTP request or response is in\n   a format and encoding defined by the entity-header fields.\n\n       entity-body    = *OCTET\n\n   An entity-body is only present in a message when a message-body is\n   present, as described in section 4.3. The entity-body is obtained\n   from the message-body by decoding any Transfer-Encoding that might\n   have been applied to ensure safe and proper transfer of the message.\n\n7.2.1 Type\n\n   When an entity-body is included with a message, the data type of that\n   body is determined via the header fields Content-Type and Content-\n   Encoding. These define a two-layer, ordered encoding model:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_30",
        "original_index": 30,
        "content": "entity-body := Content-Encoding( Content-Type( data ) )\n\n   Content-Type specifies the media type of the underlying data.\n   Content-Encoding may be used to indicate any additional content\n   codings applied to the data, usually for the purpose of data\n   compression, that are a property of the requested resource. There is\n   no default encoding.\n\n   Any HTTP/1.1 message containing an entity-body SHOULD include a\n   Content-Type header field defining the media type of that body. If\n   and only if the media type is not given by a Content-Type field, the\n   recipient MAY attempt to guess the media type via inspection of its\n   content and/or the name extension(s) of the URI used to identify the\n   resource. If the media type remains unknown, the recipient SHOULD\n   treat it as type \"application/octet-stream\".\n\n7.2.2 Entity Length\n\n   The entity-length of a message is the length of the message-body\n   before any transfer-codings have been applied. Section 4.4 defines\n   how the transfer-length of a message-body is determined.\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 43]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8 Connections\n\n8.1 Persistent Connections\n\n8.1.1 Purpose\n\n   Prior to persistent connections, a separate TCP connection was\n   established to fetch each URL, increasing the load on HTTP servers\n   and causing congestion on the Internet. The use of inline images and\n   other associated data often require a client to make multiple\n   requests of the same server in a short amount of time. Analysis of\n   these performance problems and results from a prototype\n   implementation are available [26] [30]. Implementation experience and\n   measurements of actual HTTP/1.1 (RFC 2068) implementations show good\n   results [39]. Alternatives have also been explored, for example,\n   T/TCP [27].\n\n   Persistent HTTP connections have a number of advantages:\n\n      - By opening and closing fewer TCP connections, CPU time is saved\n        in routers and hosts (clients, servers, proxies, gateways,\n        tunnels, or caches), and memory used for TCP protocol control\n        blocks can be saved in hosts.\n\n      - HTTP requests and responses can be pipelined on a connection.\n        Pipelining allows a client to make multiple requests without\n        waiting for each response, allowing a single TCP connection to\n        be used much more efficiently, with much lower elapsed time.\n\n      - Network congestion is reduced by reducing the number of packets\n        caused by TCP opens, and by allowing TCP sufficient time to\n        determine the congestion state of the network.\n\n      - Latency on subsequent requests is reduced since there is no time\n        spent in TCP's connection opening handshake.\n\n      - HTTP can evolve more gracefully, since errors can be reported\n        without the penalty of closing the TCP connection. Clients using\n        future versions of HTTP might optimistically try a new feature,\n        but if communicating with an older server, retry with old\n        semantics after an error is reported.\n\n   HTTP implementations SHOULD implement persistent connections.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 44]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.1.2 Overall Operation\n\n   A significant difference between HTTP/1.1 and earlier versions of\n   HTTP is that persistent connections are the default behavior of any\n   HTTP connection. That is, unless otherwise indicated, the client\n   SHOULD assume that the server will maintain a persistent connection,\n   even after error responses from the server."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_31",
        "original_index": 31,
        "content": "Persistent connections provide a mechanism by which a client and a\n   server can signal the close of a TCP connection. This signaling takes\n   place using the Connection header field (section 14.10). Once a close\n   has been signaled, the client MUST NOT send any more requests on that\n   connection.\n\n8.1.2.1 Negotiation\n\n   An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to\n   maintain a persistent connection unless a Connection header including\n   the connection-token \"close\" was sent in the request. If the server\n   chooses to close the connection immediately after sending the\n   response, it SHOULD send a Connection header including the\n   connection-token close.\n\n   An HTTP/1.1 client MAY expect a connection to remain open, but would\n   decide to keep it open based on whether the response from a server\n   contains a Connection header with the connection-token close. In case\n   the client does not want to maintain a connection for more than that\n   request, it SHOULD send a Connection header including the\n   connection-token close.\n\n   If either the client or the server sends the close token in the\n   Connection header, that request becomes the last one for the\n   connection.\n\n   Clients and servers SHOULD NOT assume that a persistent connection is\n   maintained for HTTP versions less than 1.1 unless it is explicitly\n   signaled. See section 19.6.2 for more information on backward\n   compatibility with HTTP/1.0 clients.\n\n   In order to remain persistent, all messages on the connection MUST\n   have a self-defined message length (i.e., one not defined by closure\n   of the connection), as described in section 4.4.\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 45]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.1.2.2 Pipelining\n\n   A client that supports persistent connections MAY \"pipeline\" its\n   requests (i.e., send multiple requests without waiting for each\n   response). A server MUST send its responses to those requests in the\n   same order that the requests were received.\n\n   Clients which assume persistent connections and pipeline immediately\n   after connection establishment SHOULD be prepared to retry their\n   connection if the first pipelined attempt fails. If a client does\n   such a retry, it MUST NOT pipeline before it knows the connection is\n   persistent. Clients MUST also be prepared to resend their requests if\n   the server closes the connection before sending all of the\n   corresponding responses.\n\n   Clients SHOULD NOT pipeline requests using non-idempotent methods or\n   non-idempotent sequences of methods (see section 9.1.2). Otherwise, a\n   premature termination of the transport connection could lead to\n   indeterminate results. A client wishing to send a non-idempotent\n   request SHOULD wait to send that request until it has received the\n   response status for the previous request.\n\n8.1.3 Proxy Servers\n\n   It is especially important that proxies correctly implement the\n   properties of the Connection header field as specified in section\n   14.10.\n\n   The proxy server MUST signal persistent connections separately with\n   its clients and the origin servers (or other proxy servers) that it\n   connects to. Each persistent connection applies to only one transport\n   link.\n\n   A proxy server MUST NOT establish a HTTP/1.1 persistent connection\n   with an HTTP/1.0 client (but see RFC 2068 [33] for information and\n   discussion of the problems with the Keep-Alive header implemented by\n   many HTTP/1.0 clients).\n\n8.1.4 Practical Considerations"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_32",
        "original_index": 32,
        "content": "8.1.4 Practical Considerations\n\n   Servers will usually have some time-out value beyond which they will\n   no longer maintain an inactive connection. Proxy servers might make\n   this a higher value since it is likely that the client will be making\n   more connections through the same server. The use of persistent\n   connections places no requirements on the length (or existence) of\n   this time-out for either the client or the server.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 46]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   When a client or server wishes to time-out it SHOULD issue a graceful\n   close on the transport connection. Clients and servers SHOULD both\n   constantly watch for the other side of the transport close, and\n   respond to it as appropriate. If a client or server does not detect\n   the other side's close promptly it could cause unnecessary resource\n   drain on the network.\n\n   A client, server, or proxy MAY close the transport connection at any\n   time. For example, a client might have started to send a new request\n   at the same time that the server has decided to close the \"idle\"\n   connection. From the server's point of view, the connection is being\n   closed while it was idle, but from the client's point of view, a\n   request is in progress.\n\n   This means that clients, servers, and proxies MUST be able to recover\n   from asynchronous close events. Client software SHOULD reopen the\n   transport connection and retransmit the aborted sequence of requests\n   without user interaction so long as the request sequence is\n   idempotent (see section 9.1.2). Non-idempotent methods or sequences\n   MUST NOT be automatically retried, although user agents MAY offer a\n   human operator the choice of retrying the request(s). Confirmation by\n   user-agent software with semantic understanding of the application\n   MAY substitute for user confirmation. The automatic retry SHOULD NOT\n   be repeated if the second sequence of requests fails.\n\n   Servers SHOULD always respond to at least one request per connection,\n   if at all possible. Servers SHOULD NOT close a connection in the\n   middle of transmitting a response, unless a network or client failure\n   is suspected.\n\n   Clients that use persistent connections SHOULD limit the number of\n   simultaneous connections that they maintain to a given server. A\n   single-user client SHOULD NOT maintain more than 2 connections with\n   any server or proxy. A proxy SHOULD use up to 2*N connections to\n   another server or proxy, where N is the number of simultaneously\n   active users. These guidelines are intended to improve HTTP response\n   times and avoid congestion.\n\n8.2 Message Transmission Requirements\n\n8.2.1 Persistent Connections and Flow Control\n\n   HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's\n   flow control mechanisms to resolve temporary overloads, rather than\n   terminating connections with the expectation that clients will retry.\n   The latter technique can exacerbate network congestion.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 47]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n8.2.2 Monitoring Connections for Error Status Messages\n\n   An HTTP/1.1 (or later) client sending a message-body SHOULD monitor\n   the network connection for an error status while it is transmitting\n   the request. If the client sees an error status, it SHOULD\n   immediately cease transmitting the body. If the body is being sent\n   using a \"chunked\" encoding (section 3.6), a zero length chunk and\n   empty trailer MAY be used to prematurely mark the end of the message.\n   If the body was preceded by a Content-Length header, the client MUST\n   close the connection.\n\n8.2.3 Use of the 100 (Continue) Status"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_33",
        "original_index": 33,
        "content": "8.2.3 Use of the 100 (Continue) Status\n\n   The purpose of the 100 (Continue) status (see section 10.1.1) is to\n   allow a client that is sending a request message with a request body\n   to determine if the origin server is willing to accept the request\n   (based on the request headers) before the client sends the request\n   body. In some cases, it might either be inappropriate or highly\n   inefficient for the client to send the body if the server will reject\n   the message without looking at the body.\n\n   Requirements for HTTP/1.1 clients:\n\n      - If a client will wait for a 100 (Continue) response before\n        sending the request body, it MUST send an Expect request-header\n        field (section 14.20) with the \"100-continue\" expectation.\n\n      - A client MUST NOT send an Expect request-header field (section\n        14.20) with the \"100-continue\" expectation if it does not intend\n        to send a request body.\n\n   Because of the presence of older implementations, the protocol allows\n   ambiguous situations in which a client may send \"Expect: 100-\n   continue\" without receiving either a 417 (Expectation Failed) status\n   or a 100 (Continue) status. Therefore, when a client sends this\n   header field to an origin server (possibly via a proxy) from which it\n   has never seen a 100 (Continue) status, the client SHOULD NOT wait\n   for an indefinite period before sending the request body.\n\n   Requirements for HTTP/1.1 origin servers:\n\n      - Upon receiving a request which includes an Expect request-header\n        field with the \"100-continue\" expectation, an origin server MUST\n        either respond with 100 (Continue) status and continue to read\n        from the input stream, or respond with a final status code. The\n        origin server MUST NOT wait for the request body before sending\n        the 100 (Continue) response. If it responds with a final status\n        code, it MAY close the transport connection or it MAY continue\n\n\n\nFielding, et al.            Standards Track                    [Page 48]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n        to read and discard the rest of the request.  It MUST NOT\n        perform the requested method if it returns a final status code.\n\n      - An origin server SHOULD NOT send a 100 (Continue) response if\n        the request message does not include an Expect request-header\n        field with the \"100-continue\" expectation, and MUST NOT send a\n        100 (Continue) response if such a request comes from an HTTP/1.0\n        (or earlier) client. There is an exception to this rule: for\n        compatibility with RFC 2068, a server MAY send a 100 (Continue)\n        status in response to an HTTP/1.1 PUT or POST request that does\n        not include an Expect request-header field with the \"100-\n        continue\" expectation. This exception, the purpose of which is\n        to minimize any client processing delays associated with an\n        undeclared wait for 100 (Continue) status, applies only to\n        HTTP/1.1 requests, and not to requests with any other HTTP-\n        version value.\n\n      - An origin server MAY omit a 100 (Continue) response if it has\n        already received some or all of the request body for the\n        corresponding request.\n\n      - An origin server that sends a 100 (Continue) response MUST\n        ultimately send a final status code, once the request body is\n        received and processed, unless it terminates the transport\n        connection prematurely."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_34",
        "original_index": 34,
        "content": "- If an origin server receives a request that does not include an\n        Expect request-header field with the \"100-continue\" expectation,\n        the request includes a request body, and the server responds\n        with a final status code before reading the entire request body\n        from the transport connection, then the server SHOULD NOT close\n        the transport connection until it has read the entire request,\n        or until the client closes the connection. Otherwise, the client\n        might not reliably receive the response message. However, this\n        requirement is not be construed as preventing a server from\n        defending itself against denial-of-service attacks, or from\n        badly broken client implementations.\n\n   Requirements for HTTP/1.1 proxies:\n\n      - If a proxy receives a request that includes an Expect request-\n        header field with the \"100-continue\" expectation, and the proxy\n        either knows that the next-hop server complies with HTTP/1.1 or\n        higher, or does not know the HTTP version of the next-hop\n        server, it MUST forward the request, including the Expect header\n        field.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 49]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If the proxy knows that the version of the next-hop server is\n        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST\n        respond with a 417 (Expectation Failed) status.\n\n      - Proxies SHOULD maintain a cache recording the HTTP version\n        numbers received from recently-referenced next-hop servers.\n\n      - A proxy MUST NOT forward a 100 (Continue) response if the\n        request message was received from an HTTP/1.0 (or earlier)\n        client and did not include an Expect request-header field with\n        the \"100-continue\" expectation. This requirement overrides the\n        general rule for forwarding of 1xx responses (see section 10.1).\n\n8.2.4 Client Behavior if Server Prematurely Closes Connection\n\n   If an HTTP/1.1 client sends a request which includes a request body,\n   but which does not include an Expect request-header field with the\n   \"100-continue\" expectation, and if the client is not directly\n   connected to an HTTP/1.1 origin server, and if the client sees the\n   connection close before receiving any status from the server, the\n   client SHOULD retry the request.  If the client does retry this\n   request, it MAY use the following \"binary exponential backoff\"\n   algorithm to be assured of obtaining a reliable response:\n\n      1. Initiate a new connection to the server\n\n      2. Transmit the request-headers\n\n      3. Initialize a variable R to the estimated round-trip time to the\n         server (e.g., based on the time it took to establish the\n         connection), or to a constant value of 5 seconds if the round-\n         trip time is not available.\n\n      4. Compute T = R * (2**N), where N is the number of previous\n         retries of this request.\n\n      5. Wait either for an error response from the server, or for T\n         seconds (whichever comes first)\n\n      6. If no error response is received, after T seconds transmit the\n         body of the request.\n\n      7. If client sees that the connection is closed prematurely,\n         repeat from step 1 until the request is accepted, an error\n         response is received, or the user becomes impatient and\n         terminates the retry process.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 50]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If at any point an error status is received, the client\n\n      - SHOULD NOT continue and\n\n      - SHOULD close the connection if it has not completed sending the\n        request message.\n\n9 Method Definitions"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_35",
        "original_index": 35,
        "content": "- SHOULD NOT continue and\n\n      - SHOULD close the connection if it has not completed sending the\n        request message.\n\n9 Method Definitions\n\n   The set of common methods for HTTP/1.1 is defined below. Although\n   this set can be expanded, additional methods cannot be assumed to\n   share the same semantics for separately extended clients and servers.\n\n   The Host request-header field (section 14.23) MUST accompany all\n   HTTP/1.1 requests.\n\n9.1 Safe and Idempotent Methods\n\n9.1.1 Safe Methods\n\n   Implementors should be aware that the software represents the user in\n   their interactions over the Internet, and should be careful to allow\n   the user to be aware of any actions they might take which may have an\n   unexpected significance to themselves or others.\n\n   In particular, the convention has been established that the GET and\n   HEAD methods SHOULD NOT have the significance of taking an action\n   other than retrieval. These methods ought to be considered \"safe\".\n   This allows user agents to represent other methods, such as POST, PUT\n   and DELETE, in a special way, so that the user is made aware of the\n   fact that a possibly unsafe action is being requested.\n\n   Naturally, it is not possible to ensure that the server does not\n   generate side-effects as a result of performing a GET request; in\n   fact, some dynamic resources consider that a feature. The important\n   distinction here is that the user did not request the side-effects,\n   so therefore cannot be held accountable for them.\n\n9.1.2 Idempotent Methods\n\n   Methods can also have the property of \"idempotence\" in that (aside\n   from error or expiration issues) the side-effects of N > 0 identical\n   requests is the same as for a single request. The methods GET, HEAD,\n   PUT and DELETE share this property. Also, the methods OPTIONS and\n   TRACE SHOULD NOT have side effects, and so are inherently idempotent.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 51]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   However, it is possible that a sequence of several requests is non-\n   idempotent, even if all of the methods executed in that sequence are\n   idempotent. (A sequence is idempotent if a single execution of the\n   entire sequence always yields a result that is not changed by a\n   reexecution of all, or part, of that sequence.) For example, a\n   sequence is non-idempotent if its result depends on a value that is\n   later modified in the same sequence.\n\n   A sequence that never has side effects is idempotent, by definition\n   (provided that no concurrent operations are being executed on the\n   same set of resources).\n\n9.2 OPTIONS\n\n   The OPTIONS method represents a request for information about the\n   communication options available on the request/response chain\n   identified by the Request-URI. This method allows the client to\n   determine the options and/or requirements associated with a resource,\n   or the capabilities of a server, without implying a resource action\n   or initiating a resource retrieval.\n\n   Responses to this method are not cacheable.\n\n   If the OPTIONS request includes an entity-body (as indicated by the\n   presence of Content-Length or Transfer-Encoding), then the media type\n   MUST be indicated by a Content-Type field. Although this\n   specification does not define any use for such a body, future\n   extensions to HTTP might use the OPTIONS body to make more detailed\n   queries on the server. A server that does not support such an\n   extension MAY discard the request body."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_36",
        "original_index": 36,
        "content": "If the Request-URI is an asterisk (\"*\"), the OPTIONS request is\n   intended to apply to the server in general rather than to a specific\n   resource. Since a server's communication options typically depend on\n   the resource, the \"*\" request is only useful as a \"ping\" or \"no-op\"\n   type of method; it does nothing beyond allowing the client to test\n   the capabilities of the server. For example, this can be used to test\n   a proxy for HTTP/1.1 compliance (or lack thereof).\n\n   If the Request-URI is not an asterisk, the OPTIONS request applies\n   only to the options that are available when communicating with that\n   resource.\n\n   A 200 response SHOULD include any header fields that indicate\n   optional features implemented by the server and applicable to that\n   resource (e.g., Allow), possibly including extensions not defined by\n   this specification. The response body, if any, SHOULD also include\n   information about the communication options. The format for such a\n\n\n\nFielding, et al.            Standards Track                    [Page 52]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   body is not defined by this specification, but might be defined by\n   future extensions to HTTP. Content negotiation MAY be used to select\n   the appropriate response format. If no response body is included, the\n   response MUST include a Content-Length field with a field-value of\n   \"0\".\n\n   The Max-Forwards request-header field MAY be used to target a\n   specific proxy in the request chain. When a proxy receives an OPTIONS\n   request on an absoluteURI for which request forwarding is permitted,\n   the proxy MUST check for a Max-Forwards field. If the Max-Forwards\n   field-value is zero (\"0\"), the proxy MUST NOT forward the message;\n   instead, the proxy SHOULD respond with its own communication options.\n   If the Max-Forwards field-value is an integer greater than zero, the\n   proxy MUST decrement the field-value when it forwards the request. If\n   no Max-Forwards field is present in the request, then the forwarded\n   request MUST NOT include a Max-Forwards field.\n\n9.3 GET\n\n   The GET method means retrieve whatever information (in the form of an\n   entity) is identified by the Request-URI. If the Request-URI refers\n   to a data-producing process, it is the produced data which shall be\n   returned as the entity in the response and not the source text of the\n   process, unless that text happens to be the output of the process.\n\n   The semantics of the GET method change to a \"conditional GET\" if the\n   request message includes an If-Modified-Since, If-Unmodified-Since,\n   If-Match, If-None-Match, or If-Range header field. A conditional GET\n   method requests that the entity be transferred only under the\n   circumstances described by the conditional header field(s). The\n   conditional GET method is intended to reduce unnecessary network\n   usage by allowing cached entities to be refreshed without requiring\n   multiple requests or transferring data already held by the client.\n\n   The semantics of the GET method change to a \"partial GET\" if the\n   request message includes a Range header field. A partial GET requests\n   that only part of the entity be transferred, as described in section\n   14.35. The partial GET method is intended to reduce unnecessary\n   network usage by allowing partially-retrieved entities to be\n   completed without transferring data already held by the client.\n\n   The response to a GET request is cacheable if and only if it meets\n   the requirements for HTTP caching described in section 13.\n\n   See section 15.1.3 for security considerations when used for forms.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 53]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n9.4 HEAD"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_37",
        "original_index": 37,
        "content": "Fielding, et al.            Standards Track                    [Page 53]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n9.4 HEAD\n\n   The HEAD method is identical to GET except that the server MUST NOT\n   return a message-body in the response. The metainformation contained\n   in the HTTP headers in response to a HEAD request SHOULD be identical\n   to the information sent in response to a GET request. This method can\n   be used for obtaining metainformation about the entity implied by the\n   request without transferring the entity-body itself. This method is\n   often used for testing hypertext links for validity, accessibility,\n   and recent modification.\n\n   The response to a HEAD request MAY be cacheable in the sense that the\n   information contained in the response MAY be used to update a\n   previously cached entity from that resource. If the new field values\n   indicate that the cached entity differs from the current entity (as\n   would be indicated by a change in Content-Length, Content-MD5, ETag\n   or Last-Modified), then the cache MUST treat the cache entry as\n   stale.\n\n9.5 POST\n\n   The POST method is used to request that the origin server accept the\n   entity enclosed in the request as a new subordinate of the resource\n   identified by the Request-URI in the Request-Line. POST is designed\n   to allow a uniform method to cover the following functions:\n\n      - Annotation of existing resources;\n\n      - Posting a message to a bulletin board, newsgroup, mailing list,\n        or similar group of articles;\n\n      - Providing a block of data, such as the result of submitting a\n        form, to a data-handling process;\n\n      - Extending a database through an append operation.\n\n   The actual function performed by the POST method is determined by the\n   server and is usually dependent on the Request-URI. The posted entity\n   is subordinate to that URI in the same way that a file is subordinate\n   to a directory containing it, a news article is subordinate to a\n   newsgroup to which it is posted, or a record is subordinate to a\n   database.\n\n   The action performed by the POST method might not result in a\n   resource that can be identified by a URI. In this case, either 200\n   (OK) or 204 (No Content) is the appropriate response status,\n   depending on whether or not the response includes an entity that\n   describes the result.\n\n\n\nFielding, et al.            Standards Track                    [Page 54]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If a resource has been created on the origin server, the response\n   SHOULD be 201 (Created) and contain an entity which describes the\n   status of the request and refers to the new resource, and a Location\n   header (see section 14.30).\n\n   Responses to this method are not cacheable, unless the response\n   includes appropriate Cache-Control or Expires header fields. However,\n   the 303 (See Other) response can be used to direct the user agent to\n   retrieve a cacheable resource.\n\n   POST requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   See section 15.1.3 for security considerations.\n\n9.6 PUT"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_38",
        "original_index": 38,
        "content": "POST requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   See section 15.1.3 for security considerations.\n\n9.6 PUT\n\n   The PUT method requests that the enclosed entity be stored under the\n   supplied Request-URI. If the Request-URI refers to an already\n   existing resource, the enclosed entity SHOULD be considered as a\n   modified version of the one residing on the origin server. If the\n   Request-URI does not point to an existing resource, and that URI is\n   capable of being defined as a new resource by the requesting user\n   agent, the origin server can create the resource with that URI. If a\n   new resource is created, the origin server MUST inform the user agent\n   via the 201 (Created) response. If an existing resource is modified,\n   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent\n   to indicate successful completion of the request. If the resource\n   could not be created or modified with the Request-URI, an appropriate\n   error response SHOULD be given that reflects the nature of the\n   problem. The recipient of the entity MUST NOT ignore any Content-*\n   (e.g. Content-Range) headers that it does not understand or implement\n   and MUST return a 501 (Not Implemented) response in such cases.\n\n   If the request passes through a cache and the Request-URI identifies\n   one or more currently cached entities, those entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\n   The fundamental difference between the POST and PUT requests is\n   reflected in the different meaning of the Request-URI. The URI in a\n   POST request identifies the resource that will handle the enclosed\n   entity. That resource might be a data-accepting process, a gateway to\n   some other protocol, or a separate entity that accepts annotations.\n   In contrast, the URI in a PUT request identifies the entity enclosed\n   with the request -- the user agent knows what URI is intended and the\n   server MUST NOT attempt to apply the request to some other resource.\n   If the server desires that the request be applied to a different URI,\n\n\n\n\nFielding, et al.            Standards Track                    [Page 55]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   it MUST send a 301 (Moved Permanently) response; the user agent MAY\n   then make its own decision regarding whether or not to redirect the\n   request.\n\n   A single resource MAY be identified by many different URIs. For\n   example, an article might have a URI for identifying \"the current\n   version\" which is separate from the URI identifying each particular\n   version. In this case, a PUT request on a general URI might result in\n   several other URIs being defined by the origin server.\n\n   HTTP/1.1 does not define how a PUT method affects the state of an\n   origin server.\n\n   PUT requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   Unless otherwise specified for a particular entity-header, the\n   entity-headers in the PUT request SHOULD be applied to the resource\n   created or modified by the PUT.\n\n9.7 DELETE\n\n   The DELETE method requests that the origin server delete the resource\n   identified by the Request-URI. This method MAY be overridden by human\n   intervention (or other means) on the origin server. The client cannot\n   be guaranteed that the operation has been carried out, even if the\n   status code returned from the origin server indicates that the action\n   has been completed successfully. However, the server SHOULD NOT\n   indicate success unless, at the time the response is given, it\n   intends to delete the resource or move it to an inaccessible\n   location.\n\n   A successful response SHOULD be 200 (OK) if the response includes an\n   entity describing the status, 202 (Accepted) if the action has not\n   yet been enacted, or 204 (No Content) if the action has been enacted\n   but the response does not include an entity."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_39",
        "original_index": 39,
        "content": "If the request passes through a cache and the Request-URI identifies\n   one or more currently cached entities, those entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\n9.8 TRACE\n\n   The TRACE method is used to invoke a remote, application-layer loop-\n   back of the request message. The final recipient of the request\n   SHOULD reflect the message received back to the client as the\n   entity-body of a 200 (OK) response. The final recipient is either the\n\n\n\n\nFielding, et al.            Standards Track                    [Page 56]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   origin server or the first proxy or gateway to receive a Max-Forwards\n   value of zero (0) in the request (see section 14.31). A TRACE request\n   MUST NOT include an entity.\n\n   TRACE allows the client to see what is being received at the other\n   end of the request chain and use that data for testing or diagnostic\n   information. The value of the Via header field (section 14.45) is of\n   particular interest, since it acts as a trace of the request chain.\n   Use of the Max-Forwards header field allows the client to limit the\n   length of the request chain, which is useful for testing a chain of\n   proxies forwarding messages in an infinite loop.\n\n   If the request is valid, the response SHOULD contain the entire\n   request message in the entity-body, with a Content-Type of\n   \"message/http\". Responses to this method MUST NOT be cached.\n\n9.9 CONNECT\n\n   This specification reserves the method name CONNECT for use with a\n   proxy that can dynamically switch to being a tunnel (e.g. SSL\n   tunneling [44]).\n\n10 Status Code Definitions\n\n   Each Status-Code is described below, including a description of which\n   method(s) it can follow and any metainformation required in the\n   response.\n\n10.1 Informational 1xx\n\n   This class of status code indicates a provisional response,\n   consisting only of the Status-Line and optional headers, and is\n   terminated by an empty line. There are no required headers for this\n   class of status code. Since HTTP/1.0 did not define any 1xx status\n   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client\n   except under experimental conditions.\n\n   A client MUST be prepared to accept one or more 1xx status responses\n   prior to a regular response, even if the client does not expect a 100\n   (Continue) status message. Unexpected 1xx status responses MAY be\n   ignored by a user agent.\n\n   Proxies MUST forward 1xx responses, unless the connection between the\n   proxy and its client has been closed, or unless the proxy itself\n   requested the generation of the 1xx response. (For example, if a\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 57]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   proxy adds a \"Expect: 100-continue\" field when it forwards a request,\n   then it need not forward the corresponding 100 (Continue)\n   response(s).)\n\n10.1.1 100 Continue\n\n   The client SHOULD continue with its request. This interim response is\n   used to inform the client that the initial part of the request has\n   been received and has not yet been rejected by the server. The client\n   SHOULD continue by sending the remainder of the request or, if the\n   request has already been completed, ignore this response. The server\n   MUST send a final response after the request has been completed. See\n   section 8.2.3 for detailed discussion of the use and handling of this\n   status code.\n\n10.1.2 101 Switching Protocols\n\n   The server understands and is willing to comply with the client's\n   request, via the Upgrade message header field (section 14.42), for a\n   change in the application protocol being used on this connection. The\n   server will switch protocols to those defined by the response's\n   Upgrade header field immediately after the empty line which\n   terminates the 101 response."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_40",
        "original_index": 40,
        "content": "The protocol SHOULD be switched only when it is advantageous to do\n   so. For example, switching to a newer version of HTTP is advantageous\n   over older versions, and switching to a real-time, synchronous\n   protocol might be advantageous when delivering resources that use\n   such features.\n\n10.2 Successful 2xx\n\n   This class of status code indicates that the client's request was\n   successfully received, understood, and accepted.\n\n10.2.1 200 OK\n\n   The request has succeeded. The information returned with the response\n   is dependent on the method used in the request, for example:\n\n   GET    an entity corresponding to the requested resource is sent in\n          the response;\n\n   HEAD   the entity-header fields corresponding to the requested\n          resource are sent in the response without any message-body;\n\n   POST   an entity describing or containing the result of the action;\n\n\n\n\nFielding, et al.            Standards Track                    [Page 58]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   TRACE  an entity containing the request message as received by the\n          end server.\n\n10.2.2 201 Created\n\n   The request has been fulfilled and resulted in a new resource being\n   created. The newly created resource can be referenced by the URI(s)\n   returned in the entity of the response, with the most specific URI\n   for the resource given by a Location header field. The response\n   SHOULD include an entity containing a list of resource\n   characteristics and location(s) from which the user or user agent can\n   choose the one most appropriate. The entity format is specified by\n   the media type given in the Content-Type header field. The origin\n   server MUST create the resource before returning the 201 status code.\n   If the action cannot be carried out immediately, the server SHOULD\n   respond with 202 (Accepted) response instead.\n\n   A 201 response MAY contain an ETag response header field indicating\n   the current value of the entity tag for the requested variant just\n   created, see section 14.19.\n\n10.2.3 202 Accepted\n\n   The request has been accepted for processing, but the processing has\n   not been completed.  The request might or might not eventually be\n   acted upon, as it might be disallowed when processing actually takes\n   place. There is no facility for re-sending a status code from an\n   asynchronous operation such as this.\n\n   The 202 response is intentionally non-committal. Its purpose is to\n   allow a server to accept a request for some other process (perhaps a\n   batch-oriented process that is only run once per day) without\n   requiring that the user agent's connection to the server persist\n   until the process is completed. The entity returned with this\n   response SHOULD include an indication of the request's current status\n   and either a pointer to a status monitor or some estimate of when the\n   user can expect the request to be fulfilled.\n\n10.2.4 203 Non-Authoritative Information\n\n   The returned metainformation in the entity-header is not the\n   definitive set as available from the origin server, but is gathered\n   from a local or a third-party copy. The set presented MAY be a subset\n   or superset of the original version. For example, including local\n   annotation information about the resource might result in a superset\n   of the metainformation known by the origin server. Use of this\n   response code is not required and is only appropriate when the\n   response would otherwise be 200 (OK).\n\n\n\nFielding, et al.            Standards Track                    [Page 59]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.2.5 204 No Content\n\n   The server has fulfilled the request but does not need to return an\n   entity-body, and might want to return updated metainformation. The\n   response MAY include new or updated metainformation in the form of\n   entity-headers, which if present SHOULD be associated with the\n   requested variant."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_41",
        "original_index": 41,
        "content": "If the client is a user agent, it SHOULD NOT change its document view\n   from that which caused the request to be sent. This response is\n   primarily intended to allow input for actions to take place without\n   causing a change to the user agent's active document view, although\n   any new or updated metainformation SHOULD be applied to the document\n   currently in the user agent's active view.\n\n   The 204 response MUST NOT include a message-body, and thus is always\n   terminated by the first empty line after the header fields.\n\n10.2.6 205 Reset Content\n\n   The server has fulfilled the request and the user agent SHOULD reset\n   the document view which caused the request to be sent. This response\n   is primarily intended to allow input for actions to take place via\n   user input, followed by a clearing of the form in which the input is\n   given so that the user can easily initiate another input action. The\n   response MUST NOT include an entity.\n\n10.2.7 206 Partial Content\n\n   The server has fulfilled the partial GET request for the resource.\n   The request MUST have included a Range header field (section 14.35)\n   indicating the desired range, and MAY have included an If-Range\n   header field (section 14.27) to make the request conditional.\n\n   The response MUST include the following header fields:\n\n      - Either a Content-Range header field (section 14.16) indicating\n        the range included with this response, or a multipart/byteranges\n        Content-Type including Content-Range fields for each part. If a\n        Content-Length header field is present in the response, its\n        value MUST match the actual number of OCTETs transmitted in the\n        message-body.\n\n      - Date\n\n      - ETag and/or Content-Location, if the header would have been sent\n        in a 200 response to the same request\n\n\n\n\nFielding, et al.            Standards Track                    [Page 60]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - Expires, Cache-Control, and/or Vary, if the field-value might\n        differ from that sent in any previous response for the same\n        variant\n\n   If the 206 response is the result of an If-Range request that used a\n   strong cache validator (see section 13.3.3), the response SHOULD NOT\n   include other entity-headers. If the response is the result of an\n   If-Range request that used a weak validator, the response MUST NOT\n   include other entity-headers; this prevents inconsistencies between\n   cached entity-bodies and updated headers. Otherwise, the response\n   MUST include all of the entity-headers that would have been returned\n   with a 200 (OK) response to the same request.\n\n   A cache MUST NOT combine a 206 response with other previously cached\n   content if the ETag or Last-Modified headers do not match exactly,\n   see 13.5.4.\n\n   A cache that does not support the Range and Content-Range headers\n   MUST NOT cache 206 (Partial) responses.\n\n10.3 Redirection 3xx\n\n   This class of status code indicates that further action needs to be\n   taken by the user agent in order to fulfill the request.  The action\n   required MAY be carried out by the user agent without interaction\n   with the user if and only if the method used in the second request is\n   GET or HEAD. A client SHOULD detect infinite redirection loops, since\n   such loops generate network traffic for each redirection.\n\n      Note: previous versions of this specification recommended a\n      maximum of five redirections. Content developers should be aware\n      that there might be clients that implement such a fixed\n      limitation.\n\n10.3.1 300 Multiple Choices\n\n   The requested resource corresponds to any one of a set of\n   representations, each with its own specific location, and agent-\n   driven negotiation information (section 12) is being provided so that\n   the user (or user agent) can select a preferred representation and\n   redirect its request to that location."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_42",
        "original_index": 42,
        "content": "Unless it was a HEAD request, the response SHOULD include an entity\n   containing a list of resource characteristics and location(s) from\n   which the user or user agent can choose the one most appropriate. The\n   entity format is specified by the media type given in the Content-\n   Type header field. Depending upon the format and the capabilities of\n\n\n\n\nFielding, et al.            Standards Track                    [Page 61]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the user agent, selection of the most appropriate choice MAY be\n   performed automatically. However, this specification does not define\n   any standard for such automatic selection.\n\n   If the server has a preferred choice of representation, it SHOULD\n   include the specific URI for that representation in the Location\n   field; user agents MAY use the Location field value for automatic\n   redirection. This response is cacheable unless indicated otherwise.\n\n10.3.2 301 Moved Permanently\n\n   The requested resource has been assigned a new permanent URI and any\n   future references to this resource SHOULD use one of the returned\n   URIs.  Clients with link editing capabilities ought to automatically\n   re-link references to the Request-URI to one or more of the new\n   references returned by the server, where possible. This response is\n   cacheable unless indicated otherwise.\n\n   The new permanent URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n   If the 301 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n      Note: When automatically redirecting a POST request after\n      receiving a 301 status code, some existing HTTP/1.0 user agents\n      will erroneously change it into a GET request.\n\n10.3.3 302 Found\n\n   The requested resource resides temporarily under a different URI.\n   Since the redirection might be altered on occasion, the client SHOULD\n   continue to use the Request-URI for future requests.  This response\n   is only cacheable if indicated by a Cache-Control or Expires header\n   field.\n\n   The temporary URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 62]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the 302 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n      Note: RFC 1945 and RFC 2068 specify that the client is not allowed\n      to change the method on the redirected request.  However, most\n      existing user agent implementations treat 302 as if it were a 303\n      response, performing a GET on the Location field-value regardless\n      of the original request method. The status codes 303 and 307 have\n      been added for servers that wish to make unambiguously clear which\n      kind of reaction is expected of the client.\n\n10.3.4 303 See Other"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_43",
        "original_index": 43,
        "content": "10.3.4 303 See Other\n\n   The response to the request can be found under a different URI and\n   SHOULD be retrieved using a GET method on that resource. This method\n   exists primarily to allow the output of a POST-activated script to\n   redirect the user agent to a selected resource. The new URI is not a\n   substitute reference for the originally requested resource. The 303\n   response MUST NOT be cached, but the response to the second\n   (redirected) request might be cacheable.\n\n   The different URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s).\n\n      Note: Many pre-HTTP/1.1 user agents do not understand the 303\n      status. When interoperability with such clients is a concern, the\n      302 status code may be used instead, since most user agents react\n      to a 302 response as described here for 303.\n\n10.3.5 304 Not Modified\n\n   If the client has performed a conditional GET request and access is\n   allowed, but the document has not been modified, the server SHOULD\n   respond with this status code. The 304 response MUST NOT contain a\n   message-body, and thus is always terminated by the first empty line\n   after the header fields.\n\n   The response MUST include the following header fields:\n\n      - Date, unless its omission is required by section 14.18.1\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 63]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If a clockless origin server obeys these rules, and proxies and\n   clients add their own Date to any response received without one (as\n   already specified by [RFC 2068], section 14.19), caches will operate\n   correctly.\n\n      - ETag and/or Content-Location, if the header would have been sent\n        in a 200 response to the same request\n\n      - Expires, Cache-Control, and/or Vary, if the field-value might\n        differ from that sent in any previous response for the same\n        variant\n\n   If the conditional GET used a strong cache validator (see section\n   13.3.3), the response SHOULD NOT include other entity-headers.\n   Otherwise (i.e., the conditional GET used a weak validator), the\n   response MUST NOT include other entity-headers; this prevents\n   inconsistencies between cached entity-bodies and updated headers.\n\n   If a 304 response indicates an entity not currently cached, then the\n   cache MUST disregard the response and repeat the request without the\n   conditional.\n\n   If a cache uses a received 304 response to update a cache entry, the\n   cache MUST update the entry to reflect any new field values given in\n   the response.\n\n10.3.6 305 Use Proxy\n\n   The requested resource MUST be accessed through the proxy given by\n   the Location field. The Location field gives the URI of the proxy.\n   The recipient is expected to repeat this single request via the\n   proxy. 305 responses MUST only be generated by origin servers.\n\n      Note: RFC 2068 was not clear that 305 was intended to redirect a\n      single request, and to be generated by origin servers only.  Not\n      observing these limitations has significant security consequences.\n\n10.3.7 306 (Unused)\n\n   The 306 status code was used in a previous version of the\n   specification, is no longer used, and the code is reserved.\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 64]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.3.8 307 Temporary Redirect\n\n   The requested resource resides temporarily under a different URI.\n   Since the redirection MAY be altered on occasion, the client SHOULD\n   continue to use the Request-URI for future requests.  This response\n   is only cacheable if indicated by a Cache-Control or Expires header\n   field."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_44",
        "original_index": 44,
        "content": "The temporary URI SHOULD be given by the Location field in the\n   response. Unless the request method was HEAD, the entity of the\n   response SHOULD contain a short hypertext note with a hyperlink to\n   the new URI(s) , since many pre-HTTP/1.1 user agents do not\n   understand the 307 status. Therefore, the note SHOULD contain the\n   information necessary for a user to repeat the original request on\n   the new URI.\n\n   If the 307 status code is received in response to a request other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n   request unless it can be confirmed by the user, since this might\n   change the conditions under which the request was issued.\n\n10.4 Client Error 4xx\n\n   The 4xx class of status code is intended for cases in which the\n   client seems to have erred. Except when responding to a HEAD request,\n   the server SHOULD include an entity containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n   condition. These status codes are applicable to any request method.\n   User agents SHOULD display any included entity to the user.\n\n   If the client is sending data, a server implementation using TCP\n   SHOULD be careful to ensure that the client acknowledges receipt of\n   the packet(s) containing the response, before the server closes the\n   input connection. If the client continues sending data to the server\n   after the close, the server's TCP stack will send a reset packet to\n   the client, which may erase the client's unacknowledged input buffers\n   before they can be read and interpreted by the HTTP application.\n\n10.4.1 400 Bad Request\n\n   The request could not be understood by the server due to malformed\n   syntax. The client SHOULD NOT repeat the request without\n   modifications.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 65]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.2 401 Unauthorized\n\n   The request requires user authentication. The response MUST include a\n   WWW-Authenticate header field (section 14.47) containing a challenge\n   applicable to the requested resource. The client MAY repeat the\n   request with a suitable Authorization header field (section 14.8). If\n   the request already included Authorization credentials, then the 401\n   response indicates that authorization has been refused for those\n   credentials. If the 401 response contains the same challenge as the\n   prior response, and the user agent has already attempted\n   authentication at least once, then the user SHOULD be presented the\n   entity that was given in the response, since that entity might\n   include relevant diagnostic information. HTTP access authentication\n   is explained in \"HTTP Authentication: Basic and Digest Access\n   Authentication\" [43].\n\n10.4.3 402 Payment Required\n\n   This code is reserved for future use.\n\n10.4.4 403 Forbidden\n\n   The server understood the request, but is refusing to fulfill it.\n   Authorization will not help and the request SHOULD NOT be repeated.\n   If the request method was not HEAD and the server wishes to make\n   public why the request has not been fulfilled, it SHOULD describe the\n   reason for the refusal in the entity.  If the server does not wish to\n   make this information available to the client, the status code 404\n   (Not Found) can be used instead.\n\n10.4.5 404 Not Found\n\n   The server has not found anything matching the Request-URI. No\n   indication is given of whether the condition is temporary or\n   permanent. The 410 (Gone) status code SHOULD be used if the server\n   knows, through some internally configurable mechanism, that an old\n   resource is permanently unavailable and has no forwarding address.\n   This status code is commonly used when the server does not wish to\n   reveal exactly why the request has been refused, or when no other\n   response is applicable.\n\n10.4.6 405 Method Not Allowed"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_45",
        "original_index": 45,
        "content": "10.4.6 405 Method Not Allowed\n\n   The method specified in the Request-Line is not allowed for the\n   resource identified by the Request-URI. The response MUST include an\n   Allow header containing a list of valid methods for the requested\n   resource.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 66]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.7 406 Not Acceptable\n\n   The resource identified by the request is only capable of generating\n   response entities which have content characteristics not acceptable\n   according to the accept headers sent in the request.\n\n   Unless it was a HEAD request, the response SHOULD include an entity\n   containing a list of available entity characteristics and location(s)\n   from which the user or user agent can choose the one most\n   appropriate. The entity format is specified by the media type given\n   in the Content-Type header field. Depending upon the format and the\n   capabilities of the user agent, selection of the most appropriate\n   choice MAY be performed automatically. However, this specification\n   does not define any standard for such automatic selection.\n\n      Note: HTTP/1.1 servers are allowed to return responses which are\n      not acceptable according to the accept headers sent in the\n      request. In some cases, this may even be preferable to sending a\n      406 response. User agents are encouraged to inspect the headers of\n      an incoming response to determine if it is acceptable.\n\n   If the response could be unacceptable, a user agent SHOULD\n   temporarily stop receipt of more data and query the user for a\n   decision on further actions.\n\n10.4.8 407 Proxy Authentication Required\n\n   This code is similar to 401 (Unauthorized), but indicates that the\n   client must first authenticate itself with the proxy. The proxy MUST\n   return a Proxy-Authenticate header field (section 14.33) containing a\n   challenge applicable to the proxy for the requested resource. The\n   client MAY repeat the request with a suitable Proxy-Authorization\n   header field (section 14.34). HTTP access authentication is explained\n   in \"HTTP Authentication: Basic and Digest Access Authentication\"\n   [43].\n\n10.4.9 408 Request Timeout\n\n   The client did not produce a request within the time that the server\n   was prepared to wait. The client MAY repeat the request without\n   modifications at any later time.\n\n10.4.10 409 Conflict\n\n   The request could not be completed due to a conflict with the current\n   state of the resource. This code is only allowed in situations where\n   it is expected that the user might be able to resolve the conflict\n   and resubmit the request. The response body SHOULD include enough\n\n\n\nFielding, et al.            Standards Track                    [Page 67]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   information for the user to recognize the source of the conflict.\n   Ideally, the response entity would include enough information for the\n   user or user agent to fix the problem; however, that might not be\n   possible and is not required.\n\n   Conflicts are most likely to occur in response to a PUT request. For\n   example, if versioning were being used and the entity being PUT\n   included changes to a resource which conflict with those made by an\n   earlier (third-party) request, the server might use the 409 response\n   to indicate that it can't complete the request. In this case, the\n   response entity would likely contain a list of the differences\n   between the two versions in a format defined by the response\n   Content-Type.\n\n10.4.11 410 Gone"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_46",
        "original_index": 46,
        "content": "10.4.11 410 Gone\n\n   The requested resource is no longer available at the server and no\n   forwarding address is known. This condition is expected to be\n   considered permanent. Clients with link editing capabilities SHOULD\n   delete references to the Request-URI after user approval. If the\n   server does not know, or has no facility to determine, whether or not\n   the condition is permanent, the status code 404 (Not Found) SHOULD be\n   used instead. This response is cacheable unless indicated otherwise.\n\n   The 410 response is primarily intended to assist the task of web\n   maintenance by notifying the recipient that the resource is\n   intentionally unavailable and that the server owners desire that\n   remote links to that resource be removed. Such an event is common for\n   limited-time, promotional services and for resources belonging to\n   individuals no longer working at the server's site. It is not\n   necessary to mark all permanently unavailable resources as \"gone\" or\n   to keep the mark for any length of time -- that is left to the\n   discretion of the server owner.\n\n10.4.12 411 Length Required\n\n   The server refuses to accept the request without a defined Content-\n   Length. The client MAY repeat the request if it adds a valid\n   Content-Length header field containing the length of the message-body\n   in the request message.\n\n10.4.13 412 Precondition Failed\n\n   The precondition given in one or more of the request-header fields\n   evaluated to false when it was tested on the server. This response\n   code allows the client to place preconditions on the current resource\n   metainformation (header field data) and thus prevent the requested\n   method from being applied to a resource other than the one intended.\n\n\n\nFielding, et al.            Standards Track                    [Page 68]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.14 413 Request Entity Too Large\n\n   The server is refusing to process a request because the request\n   entity is larger than the server is willing or able to process. The\n   server MAY close the connection to prevent the client from continuing\n   the request.\n\n   If the condition is temporary, the server SHOULD include a Retry-\n   After header field to indicate that it is temporary and after what\n   time the client MAY try again.\n\n10.4.15 414 Request-URI Too Long\n\n   The server is refusing to service the request because the Request-URI\n   is longer than the server is willing to interpret. This rare\n   condition is only likely to occur when a client has improperly\n   converted a POST request to a GET request with long query\n   information, when the client has descended into a URI \"black hole\" of\n   redirection (e.g., a redirected URI prefix that points to a suffix of\n   itself), or when the server is under attack by a client attempting to\n   exploit security holes present in some servers using fixed-length\n   buffers for reading or manipulating the Request-URI.\n\n10.4.16 415 Unsupported Media Type\n\n   The server is refusing to service the request because the entity of\n   the request is in a format not supported by the requested resource\n   for the requested method.\n\n10.4.17 416 Requested Range Not Satisfiable\n\n   A server SHOULD return a response with this status code if a request\n   included a Range request-header field (section 14.35), and none of\n   the range-specifier values in this field overlap the current extent\n   of the selected resource, and the request did not include an If-Range\n   request-header field. (For byte-ranges, this means that the first-\n   byte-pos of all of the byte-range-spec values were greater than the\n   current length of the selected resource.)\n\n   When this status code is returned for a byte-range request, the\n   response SHOULD include a Content-Range entity-header field\n   specifying the current length of the selected resource (see section\n   14.16). This response MUST NOT use the multipart/byteranges content-\n   type."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_47",
        "original_index": 47,
        "content": "Fielding, et al.            Standards Track                    [Page 69]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.4.18 417 Expectation Failed\n\n   The expectation given in an Expect request-header field (see section\n   14.20) could not be met by this server, or, if the server is a proxy,\n   the server has unambiguous evidence that the request could not be met\n   by the next-hop server.\n\n10.5 Server Error 5xx\n\n   Response status codes beginning with the digit \"5\" indicate cases in\n   which the server is aware that it has erred or is incapable of\n   performing the request. Except when responding to a HEAD request, the\n   server SHOULD include an entity containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n   condition. User agents SHOULD display any included entity to the\n   user. These response codes are applicable to any request method.\n\n10.5.1 500 Internal Server Error\n\n   The server encountered an unexpected condition which prevented it\n   from fulfilling the request.\n\n10.5.2 501 Not Implemented\n\n   The server does not support the functionality required to fulfill the\n   request. This is the appropriate response when the server does not\n   recognize the request method and is not capable of supporting it for\n   any resource.\n\n10.5.3 502 Bad Gateway\n\n   The server, while acting as a gateway or proxy, received an invalid\n   response from the upstream server it accessed in attempting to\n   fulfill the request.\n\n10.5.4 503 Service Unavailable\n\n   The server is currently unable to handle the request due to a\n   temporary overloading or maintenance of the server. The implication\n   is that this is a temporary condition which will be alleviated after\n   some delay. If known, the length of the delay MAY be indicated in a\n   Retry-After header. If no Retry-After is given, the client SHOULD\n   handle the response as it would for a 500 response.\n\n      Note: The existence of the 503 status code does not imply that a\n      server must use it when becoming overloaded. Some servers may wish\n      to simply refuse the connection.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 70]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n10.5.5 504 Gateway Timeout\n\n   The server, while acting as a gateway or proxy, did not receive a\n   timely response from the upstream server specified by the URI (e.g.\n   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed\n   to access in attempting to complete the request.\n\n      Note: Note to implementors: some deployed proxies are known to\n      return 400 or 500 when DNS lookups time out.\n\n10.5.6 505 HTTP Version Not Supported\n\n   The server does not support, or refuses to support, the HTTP protocol\n   version that was used in the request message. The server is\n   indicating that it is unable or unwilling to complete the request\n   using the same major version as the client, as described in section\n   3.1, other than with this error message. The response SHOULD contain\n   an entity describing why that version is not supported and what other\n   protocols are supported by that server.\n\n11 Access Authentication\n\n   HTTP provides several OPTIONAL challenge-response authentication\n   mechanisms which can be used by a server to challenge a client\n   request and by a client to provide authentication information. The\n   general framework for access authentication, and the specification of\n   \"basic\" and \"digest\" authentication, are specified in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. This\n   specification adopts the definitions of \"challenge\" and \"credentials\"\n   from that specification.\n\n12 Content Negotiation"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_48",
        "original_index": 48,
        "content": "12 Content Negotiation\n\n   Most HTTP responses include an entity which contains information for\n   interpretation by a human user. Naturally, it is desirable to supply\n   the user with the \"best available\" entity corresponding to the\n   request. Unfortunately for servers and caches, not all users have the\n   same preferences for what is \"best,\" and not all user agents are\n   equally capable of rendering all entity types. For that reason, HTTP\n   has provisions for several mechanisms for \"content negotiation\" --\n   the process of selecting the best representation for a given response\n   when there are multiple representations available.\n\n      Note: This is not called \"format negotiation\" because the\n      alternate representations may be of the same media type, but use\n      different capabilities of that type, be in different languages,\n      etc.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 71]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Any response containing an entity-body MAY be subject to negotiation,\n   including error responses.\n\n   There are two kinds of content negotiation which are possible in\n   HTTP: server-driven and agent-driven negotiation. These two kinds of\n   negotiation are orthogonal and thus may be used separately or in\n   combination. One method of combination, referred to as transparent\n   negotiation, occurs when a cache uses the agent-driven negotiation\n   information provided by the origin server in order to provide\n   server-driven negotiation for subsequent requests.\n\n12.1 Server-driven Negotiation\n\n   If the selection of the best representation for a response is made by\n   an algorithm located at the server, it is called server-driven\n   negotiation. Selection is based on the available representations of\n   the response (the dimensions over which it can vary; e.g. language,\n   content-coding, etc.) and the contents of particular header fields in\n   the request message or on other information pertaining to the request\n   (such as the network address of the client).\n\n   Server-driven negotiation is advantageous when the algorithm for\n   selecting from among the available representations is difficult to\n   describe to the user agent, or when the server desires to send its\n   \"best guess\" to the client along with the first response (hoping to\n   avoid the round-trip delay of a subsequent request if the \"best\n   guess\" is good enough for the user). In order to improve the server's\n   guess, the user agent MAY include request header fields (Accept,\n   Accept-Language, Accept-Encoding, etc.) which describe its\n   preferences for such a response.\n\n   Server-driven negotiation has disadvantages:\n\n      1. It is impossible for the server to accurately determine what\n         might be \"best\" for any given user, since that would require\n         complete knowledge of both the capabilities of the user agent\n         and the intended use for the response (e.g., does the user want\n         to view it on screen or print it on paper?).\n\n      2. Having the user agent describe its capabilities in every\n         request can be both very inefficient (given that only a small\n         percentage of responses have multiple representations) and a\n         potential violation of the user's privacy.\n\n      3. It complicates the implementation of an origin server and the\n         algorithms for generating responses to a request.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 72]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      4. It may limit a public cache's ability to use the same response\n         for multiple user's requests."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_49",
        "original_index": 49,
        "content": "4. It may limit a public cache's ability to use the same response\n         for multiple user's requests.\n\n   HTTP/1.1 includes the following request-header fields for enabling\n   server-driven negotiation through description of user agent\n   capabilities and user preferences: Accept (section 14.1), Accept-\n   Charset (section 14.2), Accept-Encoding (section 14.3), Accept-\n   Language (section 14.4), and User-Agent (section 14.43). However, an\n   origin server is not limited to these dimensions and MAY vary the\n   response based on any aspect of the request, including information\n   outside the request-header fields or within extension header fields\n   not defined by this specification.\n\n   The Vary  header field can be used to express the parameters the\n   server uses to select a representation that is subject to server-\n   driven negotiation. See section 13.6 for use of the Vary header field\n   by caches and section 14.44 for use of the Vary header field by\n   servers.\n\n12.2 Agent-driven Negotiation\n\n   With agent-driven negotiation, selection of the best representation\n   for a response is performed by the user agent after receiving an\n   initial response from the origin server. Selection is based on a list\n   of the available representations of the response included within the\n   header fields or entity-body of the initial response, with each\n   representation identified by its own URI. Selection from among the\n   representations may be performed automatically (if the user agent is\n   capable of doing so) or manually by the user selecting from a\n   generated (possibly hypertext) menu.\n\n   Agent-driven negotiation is advantageous when the response would vary\n   over commonly-used dimensions (such as type, language, or encoding),\n   when the origin server is unable to determine a user agent's\n   capabilities from examining the request, and generally when public\n   caches are used to distribute server load and reduce network usage.\n\n   Agent-driven negotiation suffers from the disadvantage of needing a\n   second request to obtain the best alternate representation. This\n   second request is only efficient when caching is used. In addition,\n   this specification does not define any mechanism for supporting\n   automatic selection, though it also does not prevent any such\n   mechanism from being developed as an extension and used within\n   HTTP/1.1.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 73]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)\n   status codes for enabling agent-driven negotiation when the server is\n   unwilling or unable to provide a varying response using server-driven\n   negotiation.\n\n12.3 Transparent Negotiation\n\n   Transparent negotiation is a combination of both server-driven and\n   agent-driven negotiation. When a cache is supplied with a form of the\n   list of available representations of the response (as in agent-driven\n   negotiation) and the dimensions of variance are completely understood\n   by the cache, then the cache becomes capable of performing server-\n   driven negotiation on behalf of the origin server for subsequent\n   requests on that resource.\n\n   Transparent negotiation has the advantage of distributing the\n   negotiation work that would otherwise be required of the origin\n   server and also removing the second request delay of agent-driven\n   negotiation when the cache is able to correctly guess the right\n   response.\n\n   This specification does not define any mechanism for transparent\n   negotiation, though it also does not prevent any such mechanism from\n   being developed as an extension that could be used within HTTP/1.1.\n\n13 Caching in HTTP"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_50",
        "original_index": 50,
        "content": "13 Caching in HTTP\n\n   HTTP is typically used for distributed information systems, where\n   performance can be improved by the use of response caches. The\n   HTTP/1.1 protocol includes a number of elements intended to make\n   caching work as well as possible. Because these elements are\n   inextricable from other aspects of the protocol, and because they\n   interact with each other, it is useful to describe the basic caching\n   design of HTTP separately from the detailed descriptions of methods,\n   headers, response codes, etc.\n\n   Caching would be useless if it did not significantly improve\n   performance. The goal of caching in HTTP/1.1 is to eliminate the need\n   to send requests in many cases, and to eliminate the need to send\n   full responses in many other cases. The former reduces the number of\n   network round-trips required for many operations; we use an\n   \"expiration\" mechanism for this purpose (see section 13.2). The\n   latter reduces network bandwidth requirements; we use a \"validation\"\n   mechanism for this purpose (see section 13.3).\n\n   Requirements for performance, availability, and disconnected\n   operation require us to be able to relax the goal of semantic\n   transparency. The HTTP/1.1 protocol allows origin servers, caches,\n\n\n\nFielding, et al.            Standards Track                    [Page 74]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   and clients to explicitly reduce transparency when necessary.\n   However, because non-transparent operation may confuse non-expert\n   users, and might be incompatible with certain server applications\n   (such as those for ordering merchandise), the protocol requires that\n   transparency be relaxed\n\n      - only by an explicit protocol-level request when relaxed by\n        client or origin server\n\n      - only with an explicit warning to the end user when relaxed by\n        cache or client\n\n   Therefore, the HTTP/1.1 protocol provides these important elements:\n\n      1. Protocol features that provide full semantic transparency when\n         this is required by all parties.\n\n      2. Protocol features that allow an origin server or user agent to\n         explicitly request and control non-transparent operation.\n\n      3. Protocol features that allow a cache to attach warnings to\n         responses that do not preserve the requested approximation of\n         semantic transparency.\n\n   A basic principle is that it must be possible for the clients to\n   detect any potential relaxation of semantic transparency.\n\n      Note: The server, cache, or client implementor might be faced with\n      design decisions not explicitly discussed in this specification.\n      If a decision might affect semantic transparency, the implementor\n      ought to err on the side of maintaining transparency unless a\n      careful and complete analysis shows significant benefits in\n      breaking transparency.\n\n13.1.1 Cache Correctness\n\n   A correct cache MUST respond to a request with the most up-to-date\n   response held by the cache that is appropriate to the request (see\n   sections 13.2.5, 13.2.6, and 13.12) which meets one of the following\n   conditions:\n\n      1. It has been checked for equivalence with what the origin server\n         would have returned by revalidating the response with the\n         origin server (section 13.3);\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 75]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      2. It is \"fresh enough\" (see section 13.2). In the default case,\n         this means it meets the least restrictive freshness requirement\n         of the client, origin server, and cache (see section 14.9); if\n         the origin server so specifies, it is the freshness requirement\n         of the origin server alone."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_51",
        "original_index": 51,
        "content": "If a stored response is not \"fresh enough\" by the most\n         restrictive freshness requirement of both the client and the\n         origin server, in carefully considered circumstances the cache\n         MAY still return the response with the appropriate Warning\n         header (see section 13.1.5 and 14.46), unless such a response\n         is prohibited (e.g., by a \"no-store\" cache-directive, or by a\n         \"no-cache\" cache-request-directive; see section 14.9).\n\n      3. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect),\n         or error (4xx or 5xx) response message.\n\n   If the cache can not communicate with the origin server, then a\n   correct cache SHOULD respond as above if the response can be\n   correctly served from the cache; if not it MUST return an error or\n   warning indicating that there was a communication failure.\n\n   If a cache receives a response (either an entire response, or a 304\n   (Not Modified) response) that it would normally forward to the\n   requesting client, and the received response is no longer fresh, the\n   cache SHOULD forward it to the requesting client without adding a new\n   Warning (but without removing any existing Warning headers). A cache\n   SHOULD NOT attempt to revalidate a response simply because that\n   response became stale in transit; this might lead to an infinite\n   loop. A user agent that receives a stale response without a Warning\n   MAY display a warning indication to the user.\n\n13.1.2 Warnings\n\n   Whenever a cache returns a response that is neither first-hand nor\n   \"fresh enough\" (in the sense of condition 2 in section 13.1.1), it\n   MUST attach a warning to that effect, using a Warning general-header.\n   The Warning header and the currently defined warnings are described\n   in section 14.46. The warning allows clients to take appropriate\n   action.\n\n   Warnings MAY be used for other purposes, both cache-related and\n   otherwise. The use of a warning, rather than an error status code,\n   distinguish these responses from true failures.\n\n   Warnings are assigned three digit warn-codes. The first digit\n   indicates whether the Warning MUST or MUST NOT be deleted from a\n   stored cache entry after a successful revalidation:\n\n\n\nFielding, et al.            Standards Track                    [Page 76]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   1xx  Warnings that describe the freshness or revalidation status of\n     the response, and so MUST be deleted after a successful\n     revalidation. 1XX warn-codes MAY be generated by a cache only when\n     validating a cached entry. It MUST NOT be generated by clients.\n\n   2xx  Warnings that describe some aspect of the entity body or entity\n     headers that is not rectified by a revalidation (for example, a\n     lossy compression of the entity bodies) and which MUST NOT be\n     deleted after a successful revalidation.\n\n   See section 14.46 for the definitions of the codes themselves.\n\n   HTTP/1.0 caches will cache all Warnings in responses, without\n   deleting the ones in the first category. Warnings in responses that\n   are passed to HTTP/1.0 caches carry an extra warning-date field,\n   which prevents a future HTTP/1.1 recipient from believing an\n   erroneously cached Warning.\n\n   Warnings also carry a warning text. The text MAY be in any\n   appropriate natural language (perhaps based on the client's Accept\n   headers), and include an OPTIONAL indication of what character set is\n   used.\n\n   Multiple warnings MAY be attached to a response (either by the origin\n   server or by a cache), including multiple warnings with the same code\n   number. For example, a server might provide the same warning with\n   texts in both English and Basque."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_52",
        "original_index": 52,
        "content": "When multiple warnings are attached to a response, it might not be\n   practical or reasonable to display all of them to the user. This\n   version of HTTP does not specify strict priority rules for deciding\n   which warnings to display and in what order, but does suggest some\n   heuristics.\n\n13.1.3 Cache-control Mechanisms\n\n   The basic cache mechanisms in HTTP/1.1 (server-specified expiration\n   times and validators) are implicit directives to caches. In some\n   cases, a server or client might need to provide explicit directives\n   to the HTTP caches. We use the Cache-Control header for this purpose.\n\n   The Cache-Control header allows a client or server to transmit a\n   variety of directives in either requests or responses. These\n   directives typically override the default caching algorithms. As a\n   general rule, if there is any apparent conflict between header\n   values, the most restrictive interpretation is applied (that is, the\n   one that is most likely to preserve semantic transparency). However,\n\n\n\n\nFielding, et al.            Standards Track                    [Page 77]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   in some cases, cache-control directives are explicitly specified as\n   weakening the approximation of semantic transparency (for example,\n   \"max-stale\" or \"public\").\n\n   The cache-control directives are described in detail in section 14.9.\n\n13.1.4 Explicit User Agent Warnings\n\n   Many user agents make it possible for users to override the basic\n   caching mechanisms. For example, the user agent might allow the user\n   to specify that cached entities (even explicitly stale ones) are\n   never validated. Or the user agent might habitually add \"Cache-\n   Control: max-stale=3600\" to every request. The user agent SHOULD NOT\n   default to either non-transparent behavior, or behavior that results\n   in abnormally ineffective caching, but MAY be explicitly configured\n   to do so by an explicit action of the user.\n\n   If the user has overridden the basic caching mechanisms, the user\n   agent SHOULD explicitly indicate to the user whenever this results in\n   the display of information that might not meet the server's\n   transparency requirements (in particular, if the displayed entity is\n   known to be stale). Since the protocol normally allows the user agent\n   to determine if responses are stale or not, this indication need only\n   be displayed when this actually happens. The indication need not be a\n   dialog box; it could be an icon (for example, a picture of a rotting\n   fish) or some other indicator.\n\n   If the user has overridden the caching mechanisms in a way that would\n   abnormally reduce the effectiveness of caches, the user agent SHOULD\n   continually indicate this state to the user (for example, by a\n   display of a picture of currency in flames) so that the user does not\n   inadvertently consume excess resources or suffer from excessive\n   latency.\n\n13.1.5 Exceptions to the Rules and Warnings\n\n   In some cases, the operator of a cache MAY choose to configure it to\n   return stale responses even when not requested by clients. This\n   decision ought not be made lightly, but may be necessary for reasons\n   of availability or performance, especially when the cache is poorly\n   connected to the origin server. Whenever a cache returns a stale\n   response, it MUST mark it as such (using a Warning header) enabling\n   the client software to alert the user that there might be a potential\n   problem.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 78]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   It also allows the user agent to take steps to obtain a first-hand or\n   fresh response. For this reason, a cache SHOULD NOT return a stale\n   response if the client explicitly requests a first-hand or fresh one,\n   unless it is impossible to comply for technical or policy reasons.\n\n13.1.6 Client-controlled Behavior"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_53",
        "original_index": 53,
        "content": "13.1.6 Client-controlled Behavior\n\n   While the origin server (and to a lesser extent, intermediate caches,\n   by their contribution to the age of a response) are the primary\n   source of expiration information, in some cases the client might need\n   to control a cache's decision about whether to return a cached\n   response without validating it. Clients do this using several\n   directives of the Cache-Control header.\n\n   A client's request MAY specify the maximum age it is willing to\n   accept of an unvalidated response; specifying a value of zero forces\n   the cache(s) to revalidate all responses. A client MAY also specify\n   the minimum time remaining before a response expires. Both of these\n   options increase constraints on the behavior of caches, and so cannot\n   further relax the cache's approximation of semantic transparency.\n\n   A client MAY also specify that it will accept stale responses, up to\n   some maximum amount of staleness. This loosens the constraints on the\n   caches, and so might violate the origin server's specified\n   constraints on semantic transparency, but might be necessary to\n   support disconnected operation, or high availability in the face of\n   poor connectivity.\n\n13.2 Expiration Model\n\n13.2.1 Server-Specified Expiration\n\n   HTTP caching works best when caches can entirely avoid making\n   requests to the origin server. The primary mechanism for avoiding\n   requests is for an origin server to provide an explicit expiration\n   time in the future, indicating that a response MAY be used to satisfy\n   subsequent requests. In other words, a cache can return a fresh\n   response without first contacting the server.\n\n   Our expectation is that servers will assign future explicit\n   expiration times to responses in the belief that the entity is not\n   likely to change, in a semantically significant way, before the\n   expiration time is reached. This normally preserves semantic\n   transparency, as long as the server's expiration times are carefully\n   chosen.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 79]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The expiration mechanism applies only to responses taken from a cache\n   and not to first-hand responses forwarded immediately to the\n   requesting client.\n\n   If an origin server wishes to force a semantically transparent cache\n   to validate every request, it MAY assign an explicit expiration time\n   in the past. This means that the response is always stale, and so the\n   cache SHOULD validate it before using it for subsequent requests. See\n   section 14.9.4 for a more restrictive way to force revalidation.\n\n   If an origin server wishes to force any HTTP/1.1 cache, no matter how\n   it is configured, to validate every request, it SHOULD use the \"must-\n   revalidate\" cache-control directive (see section 14.9).\n\n   Servers specify explicit expiration times using either the Expires\n   header, or the max-age directive of the Cache-Control header.\n\n   An expiration time cannot be used to force a user agent to refresh\n   its display or reload a resource; its semantics apply only to caching\n   mechanisms, and such mechanisms need only check a resource's\n   expiration status when a new request for that resource is initiated.\n   See section 13.13 for an explanation of the difference between caches\n   and history mechanisms.\n\n13.2.2 Heuristic Expiration"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_54",
        "original_index": 54,
        "content": "13.2.2 Heuristic Expiration\n\n   Since origin servers do not always provide explicit expiration times,\n   HTTP caches typically assign heuristic expiration times, employing\n   algorithms that use other header values (such as the Last-Modified\n   time) to estimate a plausible expiration time. The HTTP/1.1\n   specification does not provide specific algorithms, but does impose\n   worst-case constraints on their results. Since heuristic expiration\n   times might compromise semantic transparency, they ought to used\n   cautiously, and we encourage origin servers to provide explicit\n   expiration times as much as possible.\n\n13.2.3 Age Calculations\n\n   In order to know if a cached entry is fresh, a cache needs to know if\n   its age exceeds its freshness lifetime. We discuss how to calculate\n   the latter in section 13.2.4; this section describes how to calculate\n   the age of a response or cache entry.\n\n   In this discussion, we use the term \"now\" to mean \"the current value\n   of the clock at the host performing the calculation.\" Hosts that use\n   HTTP, but especially hosts running origin servers and caches, SHOULD\n   use NTP [28] or some similar protocol to synchronize their clocks to\n   a globally accurate time standard.\n\n\n\nFielding, et al.            Standards Track                    [Page 80]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   HTTP/1.1 requires origin servers to send a Date header, if possible,\n   with every response, giving the time at which the response was\n   generated (see section 14.18). We use the term \"date_value\" to denote\n   the value of the Date header, in a form appropriate for arithmetic\n   operations.\n\n   HTTP/1.1 uses the Age response-header to convey the estimated age of\n   the response message when obtained from a cache. The Age field value\n   is the cache's estimate of the amount of time since the response was\n   generated or revalidated by the origin server.\n\n   In essence, the Age value is the sum of the time that the response\n   has been resident in each of the caches along the path from the\n   origin server, plus the amount of time it has been in transit along\n   network paths.\n\n   We use the term \"age_value\" to denote the value of the Age header, in\n   a form appropriate for arithmetic operations.\n\n   A response's age can be calculated in two entirely independent ways:\n\n      1. now minus date_value, if the local clock is reasonably well\n         synchronized to the origin server's clock. If the result is\n         negative, the result is replaced by zero.\n\n      2. age_value, if all of the caches along the response path\n         implement HTTP/1.1.\n\n   Given that we have two independent ways to compute the age of a\n   response when it is received, we can combine these as\n\n       corrected_received_age = max(now - date_value, age_value)\n\n   and as long as we have either nearly synchronized clocks or all-\n   HTTP/1.1 paths, one gets a reliable (conservative) result.\n\n   Because of network-imposed delays, some significant interval might\n   pass between the time that a server generates a response and the time\n   it is received at the next outbound cache or client. If uncorrected,\n   this delay could result in improperly low ages.\n\n   Because the request that resulted in the returned Age value must have\n   been initiated prior to that Age value's generation, we can correct\n   for delays imposed by the network by recording the time at which the\n   request was initiated. Then, when an Age value is received, it MUST\n   be interpreted relative to the time the request was initiated, not\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 81]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the time that the response was received. This algorithm results in\n   conservative behavior no matter how much delay is experienced. So, we\n   compute:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_55",
        "original_index": 55,
        "content": "the time that the response was received. This algorithm results in\n   conservative behavior no matter how much delay is experienced. So, we\n   compute:\n\n      corrected_initial_age = corrected_received_age\n                            + (now - request_time)\n\n   where \"request_time\" is the time (according to the local clock) when\n   the request that elicited this response was sent.\n\n   Summary of age calculation algorithm, when a cache receives a\n   response:\n\n      /*\n       * age_value\n       *      is the value of Age: header received by the cache with\n       *              this response.\n       * date_value\n       *      is the value of the origin server's Date: header\n       * request_time\n       *      is the (local) time when the cache made the request\n       *              that resulted in this cached response\n       * response_time\n       *      is the (local) time when the cache received the\n       *              response\n       * now\n       *      is the current (local) time\n       */\n\n      apparent_age = max(0, response_time - date_value);\n      corrected_received_age = max(apparent_age, age_value);\n      response_delay = response_time - request_time;\n      corrected_initial_age = corrected_received_age + response_delay;\n      resident_time = now - response_time;\n      current_age   = corrected_initial_age + resident_time;\n\n   The current_age of a cache entry is calculated by adding the amount\n   of time (in seconds) since the cache entry was last validated by the\n   origin server to the corrected_initial_age. When a response is\n   generated from a cache entry, the cache MUST include a single Age\n   header field in the response with a value equal to the cache entry's\n   current_age.\n\n   The presence of an Age header field in a response implies that a\n   response is not first-hand. However, the converse is not true, since\n   the lack of an Age header field in a response does not imply that the\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 82]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   response is first-hand unless all caches along the request path are\n   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement\n   the Age header field).\n\n13.2.4 Expiration Calculations\n\n   In order to decide whether a response is fresh or stale, we need to\n   compare its freshness lifetime to its age. The age is calculated as\n   described in section 13.2.3; this section describes how to calculate\n   the freshness lifetime, and to determine if a response has expired.\n   In the discussion below, the values can be represented in any form\n   appropriate for arithmetic operations.\n\n   We use the term \"expires_value\" to denote the value of the Expires\n   header. We use the term \"max_age_value\" to denote an appropriate\n   value of the number of seconds carried by the \"max-age\" directive of\n   the Cache-Control header in a response (see section 14.9.3).\n\n   The max-age directive takes priority over Expires, so if max-age is\n   present in a response, the calculation is simply:\n\n      freshness_lifetime = max_age_value\n\n   Otherwise, if Expires is present in the response, the calculation is:\n\n      freshness_lifetime = expires_value - date_value\n\n   Note that neither of these calculations is vulnerable to clock skew,\n   since all of the information comes from the origin server.\n\n   If none of Expires, Cache-Control: max-age, or Cache-Control: s-\n   maxage (see section 14.9.3) appears in the response, and the response\n   does not include other restrictions on caching, the cache MAY compute\n   a freshness lifetime using a heuristic. The cache MUST attach Warning\n   113 to any response whose age is more than 24 hours if such warning\n   has not already been added."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_56",
        "original_index": 56,
        "content": "Also, if the response does have a Last-Modified time, the heuristic\n   expiration value SHOULD be no more than some fraction of the interval\n   since that time. A typical setting of this fraction might be 10%.\n\n   The calculation to determine if a response has expired is quite\n   simple:\n\n      response_is_fresh = (freshness_lifetime > current_age)\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 83]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.2.5 Disambiguating Expiration Values\n\n   Because expiration values are assigned optimistically, it is possible\n   for two caches to contain fresh values for the same resource that are\n   different.\n\n   If a client performing a retrieval receives a non-first-hand response\n   for a request that was already fresh in its own cache, and the Date\n   header in its existing cache entry is newer than the Date on the new\n   response, then the client MAY ignore the response. If so, it MAY\n   retry the request with a \"Cache-Control: max-age=0\" directive (see\n   section 14.9), to force a check with the origin server.\n\n   If a cache has two fresh responses for the same representation with\n   different validators, it MUST use the one with the more recent Date\n   header. This situation might arise because the cache is pooling\n   responses from other caches, or because a client has asked for a\n   reload or a revalidation of an apparently fresh cache entry.\n\n13.2.6 Disambiguating Multiple Responses\n\n   Because a client might be receiving responses via multiple paths, so\n   that some responses flow through one set of caches and other\n   responses flow through a different set of caches, a client might\n   receive responses in an order different from that in which the origin\n   server sent them. We would like the client to use the most recently\n   generated response, even if older responses are still apparently\n   fresh.\n\n   Neither the entity tag nor the expiration value can impose an\n   ordering on responses, since it is possible that a later response\n   intentionally carries an earlier expiration time. The Date values are\n   ordered to a granularity of one second.\n\n   When a client tries to revalidate a cache entry, and the response it\n   receives contains a Date header that appears to be older than the one\n   for the existing entry, then the client SHOULD repeat the request\n   unconditionally, and include\n\n       Cache-Control: max-age=0\n\n   to force any intermediate caches to validate their copies directly\n   with the origin server, or\n\n       Cache-Control: no-cache\n\n   to force any intermediate caches to obtain a new copy from the origin\n   server.\n\n\n\nFielding, et al.            Standards Track                    [Page 84]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the Date values are equal, then the client MAY use either response\n   (or MAY, if it is being extremely prudent, request a new response).\n   Servers MUST NOT depend on clients being able to choose\n   deterministically between responses generated during the same second,\n   if their expiration times overlap.\n\n13.3 Validation Model\n\n   When a cache has a stale entry that it would like to use as a\n   response to a client's request, it first has to check with the origin\n   server (or possibly an intermediate cache with a fresh response) to\n   see if its cached entry is still usable. We call this \"validating\"\n   the cache entry. Since we do not want to have to pay the overhead of\n   retransmitting the full response if the cached entry is good, and we\n   do not want to pay the overhead of an extra round trip if the cached\n   entry is invalid, the HTTP/1.1 protocol supports the use of\n   conditional methods."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_57",
        "original_index": 57,
        "content": "The key protocol features for supporting conditional methods are\n   those concerned with \"cache validators.\" When an origin server\n   generates a full response, it attaches some sort of validator to it,\n   which is kept with the cache entry. When a client (user agent or\n   proxy cache) makes a conditional request for a resource for which it\n   has a cache entry, it includes the associated validator in the\n   request.\n\n   The server then checks that validator against the current validator\n   for the entity, and, if they match (see section 13.3.3), it responds\n   with a special status code (usually, 304 (Not Modified)) and no\n   entity-body. Otherwise, it returns a full response (including\n   entity-body). Thus, we avoid transmitting the full response if the\n   validator matches, and we avoid an extra round trip if it does not\n   match.\n\n   In HTTP/1.1, a conditional request looks exactly the same as a normal\n   request for the same resource, except that it carries a special\n   header (which includes the validator) that implicitly turns the\n   method (usually, GET) into a conditional.\n\n   The protocol includes both positive and negative senses of cache-\n   validating conditions. That is, it is possible to request either that\n   a method be performed if and only if a validator matches or if and\n   only if no validators match.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 85]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      Note: a response that lacks a validator may still be cached, and\n      served from cache until it expires, unless this is explicitly\n      prohibited by a cache-control directive. However, a cache cannot\n      do a conditional retrieval if it does not have a validator for the\n      entity, which means it will not be refreshable after it expires.\n\n13.3.1 Last-Modified Dates\n\n   The Last-Modified entity-header field value is often used as a cache\n   validator. In simple terms, a cache entry is considered to be valid\n   if the entity has not been modified since the Last-Modified value.\n\n13.3.2 Entity Tag Cache Validators\n\n   The ETag response-header field value, an entity tag, provides for an\n   \"opaque\" cache validator. This might allow more reliable validation\n   in situations where it is inconvenient to store modification dates,\n   where the one-second resolution of HTTP date values is not\n   sufficient, or where the origin server wishes to avoid certain\n   paradoxes that might arise from the use of modification dates.\n\n   Entity Tags are described in section 3.11. The headers used with\n   entity tags are described in sections 14.19, 14.24, 14.26 and 14.44.\n\n13.3.3 Weak and Strong Validators\n\n   Since both origin servers and caches will compare two validators to\n   decide if they represent the same or different entities, one normally\n   would expect that if the entity (the entity-body or any entity-\n   headers) changes in any way, then the associated validator would\n   change as well. If this is true, then we call this validator a\n   \"strong validator.\"\n\n   However, there might be cases when a server prefers to change the\n   validator only on semantically significant changes, and not when\n   insignificant aspects of the entity change. A validator that does not\n   always change when the resource changes is a \"weak validator.\"\n\n   Entity tags are normally \"strong validators,\" but the protocol\n   provides a mechanism to tag an entity tag as \"weak.\" One can think of\n   a strong validator as one that changes whenever the bits of an entity\n   changes, while a weak value changes whenever the meaning of an entity\n   changes. Alternatively, one can think of a strong validator as part\n   of an identifier for a specific entity, while a weak validator is\n   part of an identifier for a set of semantically equivalent entities."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_58",
        "original_index": 58,
        "content": "Note: One example of a strong validator is an integer that is\n      incremented in stable storage every time an entity is changed.\n\n\n\nFielding, et al.            Standards Track                    [Page 86]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      An entity's modification time, if represented with one-second\n      resolution, could be a weak validator, since it is possible that\n      the resource might be modified twice during a single second.\n\n      Support for weak validators is optional. However, weak validators\n      allow for more efficient caching of equivalent objects; for\n      example, a hit counter on a site is probably good enough if it is\n      updated every few days or weeks, and any value during that period\n      is likely \"good enough\" to be equivalent.\n\n   A \"use\" of a validator is either when a client generates a request\n   and includes the validator in a validating header field, or when a\n   server compares two validators.\n\n   Strong validators are usable in any context. Weak validators are only\n   usable in contexts that do not depend on exact equality of an entity.\n   For example, either kind is usable for a conditional GET of a full\n   entity. However, only a strong validator is usable for a sub-range\n   retrieval, since otherwise the client might end up with an internally\n   inconsistent entity.\n\n   Clients MAY issue simple (non-subrange) GET requests with either weak\n   validators or strong validators. Clients MUST NOT use weak validators\n   in other forms of request.\n\n   The only function that the HTTP/1.1 protocol defines on validators is\n   comparison. There are two validator comparison functions, depending\n   on whether the comparison context allows the use of weak validators\n   or not:\n\n      - The strong comparison function: in order to be considered equal,\n        both validators MUST be identical in every way, and both MUST\n        NOT be weak.\n\n      - The weak comparison function: in order to be considered equal,\n        both validators MUST be identical in every way, but either or\n        both of them MAY be tagged as \"weak\" without affecting the\n        result.\n\n   An entity tag is strong unless it is explicitly tagged as weak.\n   Section 3.11 gives the syntax for entity tags.\n\n   A Last-Modified time, when used as a validator in a request, is\n   implicitly weak unless it is possible to deduce that it is strong,\n   using the following rules:\n\n      - The validator is being compared by an origin server to the\n        actual current validator for the entity and,\n\n\n\nFielding, et al.            Standards Track                    [Page 87]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - That origin server reliably knows that the associated entity did\n        not change twice during the second covered by the presented\n        validator.\n\n   or\n\n      - The validator is about to be used by a client in an If-\n        Modified-Since or If-Unmodified-Since header, because the client\n        has a cache entry for the associated entity, and\n\n      - That cache entry includes a Date value, which gives the time\n        when the origin server sent the original response, and\n\n      - The presented Last-Modified time is at least 60 seconds before\n        the Date value.\n\n   or\n\n      - The validator is being compared by an intermediate cache to the\n        validator stored in its cache entry for the entity, and\n\n      - That cache entry includes a Date value, which gives the time\n        when the origin server sent the original response, and\n\n      - The presented Last-Modified time is at least 60 seconds before\n        the Date value."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_59",
        "original_index": 59,
        "content": "- The presented Last-Modified time is at least 60 seconds before\n        the Date value.\n\n   This method relies on the fact that if two different responses were\n   sent by the origin server during the same second, but both had the\n   same Last-Modified time, then at least one of those responses would\n   have a Date value equal to its Last-Modified time. The arbitrary 60-\n   second limit guards against the possibility that the Date and Last-\n   Modified values are generated from different clocks, or at somewhat\n   different times during the preparation of the response. An\n   implementation MAY use a value larger than 60 seconds, if it is\n   believed that 60 seconds is too short.\n\n   If a client wishes to perform a sub-range retrieval on a value for\n   which it has only a Last-Modified time and no opaque validator, it\n   MAY do this only if the Last-Modified time is strong in the sense\n   described here.\n\n   A cache or origin server receiving a conditional request, other than\n   a full-body GET request, MUST use the strong comparison function to\n   evaluate the condition.\n\n   These rules allow HTTP/1.1 caches and clients to safely perform sub-\n   range retrievals on values that have been obtained from HTTP/1.0\n\n\n\nFielding, et al.            Standards Track                    [Page 88]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   servers.\n\n13.3.4 Rules for When to Use Entity Tags and Last-Modified Dates\n\n   We adopt a set of rules and recommendations for origin servers,\n   clients, and caches regarding when various validator types ought to\n   be used, and for what purposes.\n\n   HTTP/1.1 origin servers:\n\n      - SHOULD send an entity tag validator unless it is not feasible to\n        generate one.\n\n      - MAY send a weak entity tag instead of a strong entity tag, if\n        performance considerations support the use of weak entity tags,\n        or if it is unfeasible to send a strong entity tag.\n\n      - SHOULD send a Last-Modified value if it is feasible to send one,\n        unless the risk of a breakdown in semantic transparency that\n        could result from using this date in an If-Modified-Since header\n        would lead to serious problems.\n\n   In other words, the preferred behavior for an HTTP/1.1 origin server\n   is to send both a strong entity tag and a Last-Modified value.\n\n   In order to be legal, a strong entity tag MUST change whenever the\n   associated entity value changes in any way. A weak entity tag SHOULD\n   change whenever the associated entity changes in a semantically\n   significant way.\n\n      Note: in order to provide semantically transparent caching, an\n      origin server must avoid reusing a specific strong entity tag\n      value for two different entities, or reusing a specific weak\n      entity tag value for two semantically different entities. Cache\n      entries might persist for arbitrarily long periods, regardless of\n      expiration times, so it might be inappropriate to expect that a\n      cache will never again attempt to validate an entry using a\n      validator that it obtained at some point in the past.\n\n   HTTP/1.1 clients:\n\n      - If an entity tag has been provided by the origin server, MUST\n        use that entity tag in any cache-conditional request (using If-\n        Match or If-None-Match).\n\n      - If only a Last-Modified value has been provided by the origin\n        server, SHOULD use that value in non-subrange cache-conditional\n        requests (using If-Modified-Since).\n\n\n\nFielding, et al.            Standards Track                    [Page 89]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If only a Last-Modified value has been provided by an HTTP/1.0\n        origin server, MAY use that value in subrange cache-conditional\n        requests (using If-Unmodified-Since:). The user agent SHOULD\n        provide a way to disable this, in case of difficulty."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_60",
        "original_index": 60,
        "content": "- If both an entity tag and a Last-Modified value have been\n        provided by the origin server, SHOULD use both validators in\n        cache-conditional requests. This allows both HTTP/1.0 and\n        HTTP/1.1 caches to respond appropriately.\n\n   An HTTP/1.1 origin server, upon receiving a conditional request that\n   includes both a Last-Modified date (e.g., in an If-Modified-Since or\n   If-Unmodified-Since header field) and one or more entity tags (e.g.,\n   in an If-Match, If-None-Match, or If-Range header field) as cache\n   validators, MUST NOT return a response status of 304 (Not Modified)\n   unless doing so is consistent with all of the conditional header\n   fields in the request.\n\n   An HTTP/1.1 caching proxy, upon receiving a conditional request that\n   includes both a Last-Modified date and one or more entity tags as\n   cache validators, MUST NOT return a locally cached response to the\n   client unless that cached response is consistent with all of the\n   conditional header fields in the request.\n\n      Note: The general principle behind these rules is that HTTP/1.1\n      servers and clients should transmit as much non-redundant\n      information as is available in their responses and requests.\n      HTTP/1.1 systems receiving this information will make the most\n      conservative assumptions about the validators they receive.\n\n      HTTP/1.0 clients and caches will ignore entity tags. Generally,\n      last-modified values received or used by these systems will\n      support transparent and efficient caching, and so HTTP/1.1 origin\n      servers should provide Last-Modified values. In those rare cases\n      where the use of a Last-Modified value as a validator by an\n      HTTP/1.0 system could result in a serious problem, then HTTP/1.1\n      origin servers should not provide one.\n\n13.3.5 Non-validating Conditionals\n\n   The principle behind entity tags is that only the service author\n   knows the semantics of a resource well enough to select an\n   appropriate cache validation mechanism, and the specification of any\n   validator comparison function more complex than byte-equality would\n   open up a can of worms. Thus, comparisons of any other headers\n   (except Last-Modified, for compatibility with HTTP/1.0) are never\n   used for purposes of validating a cache entry.\n\n\n\n\nFielding, et al.            Standards Track                    [Page 90]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.4 Response Cacheability\n\n   Unless specifically constrained by a cache-control (section 14.9)\n   directive, a caching system MAY always store a successful response\n   (see section 13.8) as a cache entry, MAY return it without validation\n   if it is fresh, and MAY return it after successful validation. If\n   there is neither a cache validator nor an explicit expiration time\n   associated with a response, we do not expect it to be cached, but\n   certain caches MAY violate this expectation (for example, when little\n   or no network connectivity is available). A client can usually detect\n   that such a response was taken from a cache by comparing the Date\n   header to the current time.\n\n      Note: some HTTP/1.0 caches are known to violate this expectation\n      without providing any Warning.\n\n   However, in some cases it might be inappropriate for a cache to\n   retain an entity, or to return it in response to a subsequent\n   request. This might be because absolute semantic transparency is\n   deemed necessary by the service author, or because of security or\n   privacy considerations. Certain cache-control directives are\n   therefore provided so that the server can indicate that certain\n   resource entities, or portions thereof, are not to be cached\n   regardless of other considerations.\n\n   Note that section 14.8 normally prevents a shared cache from saving\n   and returning a response to a previous request if that request\n   included an Authorization header."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_61",
        "original_index": 61,
        "content": "Note that section 14.8 normally prevents a shared cache from saving\n   and returning a response to a previous request if that request\n   included an Authorization header.\n\n   A response received with a status code of 200, 203, 206, 300, 301 or\n   410 MAY be stored by a cache and used in reply to a subsequent\n   request, subject to the expiration mechanism, unless a cache-control\n   directive prohibits caching. However, a cache that does not support\n   the Range and Content-Range headers MUST NOT cache 206 (Partial\n   Content) responses.\n\n   A response received with any other status code (e.g. status codes 302\n   and 307) MUST NOT be returned in a reply to a subsequent request\n   unless there are cache-control directives or another header(s) that\n   explicitly allow it. For example, these include the following: an\n   Expires header (section 14.21); a \"max-age\", \"s-maxage\",  \"must-\n   revalidate\", \"proxy-revalidate\", \"public\" or \"private\" cache-control\n   directive (section 14.9).\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 91]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5 Constructing Responses From Caches\n\n   The purpose of an HTTP cache is to store information received in\n   response to requests for use in responding to future requests. In\n   many cases, a cache simply returns the appropriate parts of a\n   response to the requester. However, if the cache holds a cache entry\n   based on a previous response, it might have to combine parts of a new\n   response with what is held in the cache entry.\n\n13.5.1 End-to-end and Hop-by-hop Headers\n\n   For the purpose of defining the behavior of caches and non-caching\n   proxies, we divide HTTP headers into two categories:\n\n      - End-to-end headers, which are  transmitted to the ultimate\n        recipient of a request or response. End-to-end headers in\n        responses MUST be stored as part of a cache entry and MUST be\n        transmitted in any response formed from a cache entry.\n\n      - Hop-by-hop headers, which are meaningful only for a single\n        transport-level connection, and are not stored by caches or\n        forwarded by proxies.\n\n   The following HTTP/1.1 headers are hop-by-hop headers:\n\n      - Connection\n      - Keep-Alive\n      - Proxy-Authenticate\n      - Proxy-Authorization\n      - TE\n      - Trailers\n      - Transfer-Encoding\n      - Upgrade\n\n   All other headers defined by HTTP/1.1 are end-to-end headers.\n\n   Other hop-by-hop headers MUST be listed in a Connection header,\n   (section 14.10) to be introduced into HTTP/1.1 (or later).\n\n13.5.2 Non-modifiable Headers\n\n   Some features of the HTTP/1.1 protocol, such as Digest\n   Authentication, depend on the value of certain end-to-end headers. A\n   transparent proxy SHOULD NOT modify an end-to-end header unless the\n   definition of that header requires or specifically allows that.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 92]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A transparent proxy MUST NOT modify any of the following fields in a\n   request or response, and it MUST NOT add any of these fields if not\n   already present:\n\n      - Content-Location\n\n      - Content-MD5\n\n      - ETag\n\n      - Last-Modified\n\n   A transparent proxy MUST NOT modify any of the following fields in a\n   response:\n\n      - Expires\n\n   but it MAY add any of these fields if not already present. If an\n   Expires header is added, it MUST be given a field-value identical to\n   that of the Date header in that response.\n\n   A  proxy MUST NOT modify or add any of the following fields in a\n   message that contains the no-transform cache-control directive, or in\n   any request:\n\n      - Content-Encoding\n\n      - Content-Range\n\n      - Content-Type"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_62",
        "original_index": 62,
        "content": "- Content-Encoding\n\n      - Content-Range\n\n      - Content-Type\n\n   A non-transparent proxy MAY modify or add these fields to a message\n   that does not include no-transform, but if it does so, it MUST add a\n   Warning 214 (Transformation applied) if one does not already appear\n   in the message (see section 14.46).\n\n      Warning: unnecessary modification of end-to-end headers might\n      cause authentication failures if stronger authentication\n      mechanisms are introduced in later versions of HTTP. Such\n      authentication mechanisms MAY rely on the values of header fields\n      not listed here.\n\n   The Content-Length field of a request or response is added or deleted\n   according to the rules in section 4.4. A transparent proxy MUST\n   preserve the entity-length (section 7.2.2) of the entity-body,\n   although it MAY change the transfer-length (section 4.4).\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 93]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5.3 Combining Headers\n\n   When a cache makes a validating request to a server, and the server\n   provides a 304 (Not Modified) response or a 206 (Partial Content)\n   response, the cache then constructs a response to send to the\n   requesting client.\n\n   If the status code is 304 (Not Modified), the cache uses the entity-\n   body stored in the cache entry as the entity-body of this outgoing\n   response. If the status code is 206 (Partial Content) and the ETag or\n   Last-Modified headers match exactly, the cache MAY combine the\n   contents stored in the cache entry with the new contents received in\n   the response and use the result as the entity-body of this outgoing\n   response, (see 13.5.4).\n\n   The end-to-end headers stored in the cache entry are used for the\n   constructed response, except that\n\n      - any stored Warning headers with warn-code 1xx (see section\n        14.46) MUST be deleted from the cache entry and the forwarded\n        response.\n\n      - any stored Warning headers with warn-code 2xx MUST be retained\n        in the cache entry and the forwarded response.\n\n      - any end-to-end headers provided in the 304 or 206 response MUST\n        replace the corresponding headers from the cache entry.\n\n   Unless the cache decides to remove the cache entry, it MUST also\n   replace the end-to-end headers stored with the cache entry with\n   corresponding headers received in the incoming response, except for\n   Warning headers as described immediately above. If a header field-\n   name in the incoming response matches more than one header in the\n   cache entry, all such old headers MUST be replaced.\n\n   In other words, the set of end-to-end headers received in the\n   incoming response overrides all corresponding end-to-end headers\n   stored with the cache entry (except for stored Warning headers with\n   warn-code 1xx, which are deleted even if not overridden).\n\n      Note: this rule allows an origin server to use a 304 (Not\n      Modified) or a 206 (Partial Content) response to update any header\n      associated with a previous response for the same entity or sub-\n      ranges thereof, although it might not always be meaningful or\n      correct to do so. This rule does not allow an origin server to use\n      a 304 (Not Modified) or a 206 (Partial Content) response to\n      entirely delete a header that it had provided with a previous\n      response.\n\n\n\nFielding, et al.            Standards Track                    [Page 94]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.5.4 Combining Byte Ranges\n\n   A response might transfer only a subrange of the bytes of an entity-\n   body, either because the request included one or more Range\n   specifications, or because a connection was broken prematurely. After\n   several such transfers, a cache might have received several ranges of\n   the same entity-body."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_63",
        "original_index": 63,
        "content": "If a cache has a stored non-empty set of subranges for an entity, and\n   an incoming response transfers another subrange, the cache MAY\n   combine the new subrange with the existing set if both the following\n   conditions are met:\n\n      - Both the incoming response and the cache entry have a cache\n        validator.\n\n      - The two cache validators match using the strong comparison\n        function (see section 13.3.3).\n\n   If either requirement is not met, the cache MUST use only the most\n   recent partial response (based on the Date values transmitted with\n   every response, and using the incoming response if these values are\n   equal or missing), and MUST discard the other partial information.\n\n13.6 Caching Negotiated Responses\n\n   Use of server-driven content negotiation (section 12.1), as indicated\n   by the presence of a Vary header field in a response, alters the\n   conditions and procedure by which a cache can use the response for\n   subsequent requests. See section 14.44 for use of the Vary header\n   field by servers.\n\n   A server SHOULD use the Vary header field to inform a cache of what\n   request-header fields were used to select among multiple\n   representations of a cacheable response subject to server-driven\n   negotiation. The set of header fields named by the Vary field value\n   is known as the \"selecting\" request-headers.\n\n   When the cache receives a subsequent request whose Request-URI\n   specifies one or more cache entries including a Vary header field,\n   the cache MUST NOT use such a cache entry to construct a response to\n   the new request unless all of the selecting request-headers present\n   in the new request match the corresponding stored request-headers in\n   the original request.\n\n   The selecting request-headers from two requests are defined to match\n   if and only if the selecting request-headers in the first request can\n   be transformed to the selecting request-headers in the second request\n\n\n\nFielding, et al.            Standards Track                    [Page 95]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   by adding or removing linear white space (LWS) at places where this\n   is allowed by the corresponding BNF, and/or combining multiple\n   message-header fields with the same field name following the rules\n   about message headers in section 4.2.\n\n   A Vary header field-value of \"*\" always fails to match and subsequent\n   requests on that resource can only be properly interpreted by the\n   origin server.\n\n   If the selecting request header fields for the cached entry do not\n   match the selecting request header fields of the new request, then\n   the cache MUST NOT use a cached entry to satisfy the request unless\n   it first relays the new request to the origin server in a conditional\n   request and the server responds with 304 (Not Modified), including an\n   entity tag or Content-Location that indicates the entity to be used.\n\n   If an entity tag was assigned to a cached representation, the\n   forwarded request SHOULD be conditional and include the entity tags\n   in an If-None-Match header field from all its cache entries for the\n   resource. This conveys to the server the set of entities currently\n   held by the cache, so that if any one of these entities matches the\n   requested entity, the server can use the ETag header field in its 304\n   (Not Modified) response to tell the cache which entry is appropriate.\n   If the entity-tag of the new response matches that of an existing\n   entry, the new response SHOULD be used to update the header fields of\n   the existing entry, and the result MUST be returned to the client.\n\n   If any of the existing cache entries contains only partial content\n   for the associated entity, its entity-tag SHOULD NOT be included in\n   the If-None-Match header field unless the request is for a range that\n   would be fully satisfied by that entry."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_64",
        "original_index": 64,
        "content": "If a cache receives a successful response whose Content-Location\n   field matches that of an existing cache entry for the same Request-\n   ]URI, whose entity-tag differs from that of the existing entry, and\n   whose Date is more recent than that of the existing entry, the\n   existing entry SHOULD NOT be returned in response to future requests\n   and SHOULD be deleted from the cache.\n\n13.7 Shared and Non-Shared Caches\n\n   For reasons of security and privacy, it is necessary to make a\n   distinction between \"shared\" and \"non-shared\" caches. A non-shared\n   cache is one that is accessible only to a single user. Accessibility\n   in this case SHOULD be enforced by appropriate security mechanisms.\n   All other caches are considered to be \"shared.\" Other sections of\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 96]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   this specification place certain constraints on the operation of\n   shared caches in order to prevent loss of privacy or failure of\n   access controls.\n\n13.8 Errors or Incomplete Response Cache Behavior\n\n   A cache that receives an incomplete response (for example, with fewer\n   bytes of data than specified in a Content-Length header) MAY store\n   the response. However, the cache MUST treat this as a partial\n   response. Partial responses MAY be combined as described in section\n   13.5.4; the result might be a full response or might still be\n   partial. A cache MUST NOT return a partial response to a client\n   without explicitly marking it as such, using the 206 (Partial\n   Content) status code. A cache MUST NOT return a partial response\n   using a status code of 200 (OK).\n\n   If a cache receives a 5xx response while attempting to revalidate an\n   entry, it MAY either forward this response to the requesting client,\n   or act as if the server failed to respond. In the latter case, it MAY\n   return a previously received response unless the cached entry\n   includes the \"must-revalidate\" cache-control directive (see section\n   14.9).\n\n13.9 Side Effects of GET and HEAD\n\n   Unless the origin server explicitly prohibits the caching of their\n   responses, the application of GET and HEAD methods to any resources\n   SHOULD NOT have side effects that would lead to erroneous behavior if\n   these responses are taken from a cache. They MAY still have side\n   effects, but a cache is not required to consider such side effects in\n   its caching decisions. Caches are always expected to observe an\n   origin server's explicit restrictions on caching.\n\n   We note one exception to this rule: since some applications have\n   traditionally used GETs and HEADs with query URLs (those containing a\n   \"?\" in the rel_path part) to perform operations with significant side\n   effects, caches MUST NOT treat responses to such URIs as fresh unless\n   the server provides an explicit expiration time. This specifically\n   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT\n   be taken from a cache. See section 9.1.1 for related information.\n\n13.10 Invalidation After Updates or Deletions\n\n   The effect of certain methods performed on a resource at the origin\n   server might cause one or more existing cache entries to become non-\n   transparently invalid. That is, although they might continue to be\n   \"fresh,\" they do not accurately reflect what the origin server would\n   return for a new request on that resource.\n\n\n\nFielding, et al.            Standards Track                    [Page 97]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   There is no way for the HTTP protocol to guarantee that all such\n   cache entries are marked invalid. For example, the request that\n   caused the change at the origin server might not have gone through\n   the proxy where a cache entry is stored. However, several rules help\n   reduce the likelihood of erroneous behavior."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_65",
        "original_index": 65,
        "content": "In this section, the phrase \"invalidate an entity\" means that the\n   cache will either remove all instances of that entity from its\n   storage, or will mark these as \"invalid\" and in need of a mandatory\n   revalidation before they can be returned in response to a subsequent\n   request.\n\n   Some HTTP methods MUST cause a cache to invalidate an entity. This is\n   either the entity referred to by the Request-URI, or by the Location\n   or Content-Location headers (if present). These methods are:\n\n      - PUT\n\n      - DELETE\n\n      - POST\n\n   In order to prevent denial of service attacks, an invalidation based\n   on the URI in a Location or Content-Location header MUST only be\n   performed if the host part is the same as in the Request-URI.\n\n   A cache that passes through requests for methods it does not\n   understand SHOULD invalidate any entities referred to by the\n   Request-URI.\n\n13.11 Write-Through Mandatory\n\n   All methods that might be expected to cause modifications to the\n   origin server's resources MUST be written through to the origin\n   server. This currently includes all methods except for GET and HEAD.\n   A cache MUST NOT reply to such a request from a client before having\n   transmitted the request to the inbound server, and having received a\n   corresponding response from the inbound server. This does not prevent\n   a proxy cache from sending a 100 (Continue) response before the\n   inbound server has sent its final reply.\n\n   The alternative (known as \"write-back\" or \"copy-back\" caching) is not\n   allowed in HTTP/1.1, due to the difficulty of providing consistent\n   updates and the problems arising from server, cache, or network\n   failure prior to write-back.\n\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 98]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n13.12 Cache Replacement\n\n   If a new cacheable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8)\n   response is received from a resource while any existing responses for\n   the same resource are cached, the cache SHOULD use the new response\n   to reply to the current request. It MAY insert it into cache storage\n   and MAY, if it meets all other requirements, use it to respond to any\n   future requests that would previously have caused the old response to\n   be returned. If it inserts the new response into cache storage  the\n   rules in section 13.5.3 apply.\n\n      Note: a new response that has an older Date header value than\n      existing cached responses is not cacheable.\n\n13.13 History Lists\n\n   User agents often have history mechanisms, such as \"Back\" buttons and\n   history lists, which can be used to redisplay an entity retrieved\n   earlier in a session.\n\n   History mechanisms and caches are different. In particular history\n   mechanisms SHOULD NOT try to show a semantically transparent view of\n   the current state of a resource. Rather, a history mechanism is meant\n   to show exactly what the user saw at the time when the resource was\n   retrieved.\n\n   By default, an expiration time does not apply to history mechanisms.\n   If the entity is still in storage, a history mechanism SHOULD display\n   it even if the entity has expired, unless the user has specifically\n   configured the agent to refresh expired history documents.\n\n   This is not to be construed to prohibit the history mechanism from\n   telling the user that a view might be stale."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_66",
        "original_index": 66,
        "content": "This is not to be construed to prohibit the history mechanism from\n   telling the user that a view might be stale.\n\n      Note: if history list mechanisms unnecessarily prevent users from\n      viewing stale resources, this will tend to force service authors\n      to avoid using HTTP expiration controls and cache controls when\n      they would otherwise like to. Service authors may consider it\n      important that users not be presented with error messages or\n      warning messages when they use navigation controls (such as BACK)\n      to view previously fetched resources. Even though sometimes such\n      resources ought not to cached, or ought to expire quickly, user\n      interface considerations may force service authors to resort to\n      other means of preventing caching (e.g. \"once-only\" URLs) in order\n      not to suffer the effects of improperly functioning history\n      mechanisms.\n\n\n\n\n\nFielding, et al.            Standards Track                    [Page 99]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14 Header Field Definitions\n\n   This section defines the syntax and semantics of all standard\n   HTTP/1.1 header fields. For entity-header fields, both sender and\n   recipient refer to either the client or the server, depending on who\n   sends and who receives the entity.\n\n14.1 Accept\n\n   The Accept request-header field can be used to specify certain media\n   types which are acceptable for the response. Accept headers can be\n   used to indicate that the request is specifically limited to a small\n   set of desired types, as in the case of a request for an in-line\n   image.\n\n       Accept         = \"Accept\" \":\"\n                        #( media-range [ accept-params ] )\n\n       media-range    = ( \"*/*\"\n                        | ( type \"/\" \"*\" )\n                        | ( type \"/\" subtype )\n                        ) *( \";\" parameter )\n       accept-params  = \";\" \"q\" \"=\" qvalue *( accept-extension )\n       accept-extension = \";\" token [ \"=\" ( token | quoted-string ) ]\n\n   The asterisk \"*\" character is used to group media types into ranges,\n   with \"*/*\" indicating all media types and \"type/*\" indicating all\n   subtypes of that type. The media-range MAY include media type\n   parameters that are applicable to that range.\n\n   Each media-range MAY be followed by one or more accept-params,\n   beginning with the \"q\" parameter for indicating a relative quality\n   factor. The first \"q\" parameter (if any) separates the media-range\n   parameter(s) from the accept-params. Quality factors allow the user\n   or user agent to indicate the relative degree of preference for that\n   media-range, using the qvalue scale from 0 to 1 (section 3.9). The\n   default value is q=1.\n\n      Note: Use of the \"q\" parameter name to separate media type\n      parameters from Accept extension parameters is due to historical\n      practice. Although this prevents any media type parameter named\n      \"q\" from being used with a media range, such an event is believed\n      to be unlikely given the lack of any \"q\" parameters in the IANA\n      media type registry and the rare usage of any media type\n      parameters in Accept. Future media types are discouraged from\n      registering any parameter named \"q\".\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 100]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The example\n\n       Accept: audio/*; q=0.2, audio/basic\n\n   SHOULD be interpreted as \"I prefer audio/basic, but send me any audio\n   type if it is the best available after an 80% mark-down in quality.\"\n\n   If no Accept header field is present, then it is assumed that the\n   client accepts all media types. If an Accept header field is present,\n   and if the server cannot send a response which is acceptable\n   according to the combined Accept field value, then the server SHOULD\n   send a 406 (not acceptable) response.\n\n   A more elaborate example is"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_67",
        "original_index": 67,
        "content": "A more elaborate example is\n\n       Accept: text/plain; q=0.5, text/html,\n               text/x-dvi; q=0.8, text/x-c\n\n   Verbally, this would be interpreted as \"text/html and text/x-c are\n   the preferred media types, but if they do not exist, then send the\n   text/x-dvi entity, and if that does not exist, send the text/plain\n   entity.\"\n\n   Media ranges can be overridden by more specific media ranges or\n   specific media types. If more than one media range applies to a given\n   type, the most specific reference has precedence. For example,\n\n       Accept: text/*, text/html, text/html;level=1, */*\n\n   have the following precedence:\n\n       1) text/html;level=1\n       2) text/html\n       3) text/*\n       4) */*\n\n   The media type quality factor associated with a given type is\n   determined by finding the media range with the highest precedence\n   which matches that type. For example,\n\n       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,\n               text/html;level=2;q=0.4, */*;q=0.5\n\n   would cause the following values to be associated:\n\n       text/html;level=1         = 1\n       text/html                 = 0.7\n       text/plain                = 0.3\n\n\n\nFielding, et al.            Standards Track                   [Page 101]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       image/jpeg                = 0.5\n       text/html;level=2         = 0.4\n       text/html;level=3         = 0.7\n\n      Note: A user agent might be provided with a default set of quality\n      values for certain media ranges. However, unless the user agent is\n      a closed system which cannot interact with other rendering agents,\n      this default set ought to be configurable by the user.\n\n14.2 Accept-Charset\n\n   The Accept-Charset request-header field can be used to indicate what\n   character sets are acceptable for the response. This field allows\n   clients capable of understanding more comprehensive or special-\n   purpose character sets to signal that capability to a server which is\n   capable of representing documents in those character sets.\n\n      Accept-Charset = \"Accept-Charset\" \":\"\n              1#( ( charset | \"*\" )[ \";\" \"q\" \"=\" qvalue ] )\n\n\n   Character set values are described in section 3.4. Each charset MAY\n   be given an associated quality value which represents the user's\n   preference for that charset. The default value is q=1. An example is\n\n      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n\n   The special value \"*\", if present in the Accept-Charset field,\n   matches every character set (including ISO-8859-1) which is not\n   mentioned elsewhere in the Accept-Charset field. If no \"*\" is present\n   in an Accept-Charset field, then all character sets not explicitly\n   mentioned get a quality value of 0, except for ISO-8859-1, which gets\n   a quality value of 1 if not explicitly mentioned.\n\n   If no Accept-Charset header is present, the default is that any\n   character set is acceptable. If an Accept-Charset header is present,\n   and if the server cannot send a response which is acceptable\n   according to the Accept-Charset header, then the server SHOULD send\n   an error response with the 406 (not acceptable) status code, though\n   the sending of an unacceptable response is also allowed.\n\n14.3 Accept-Encoding\n\n   The Accept-Encoding request-header field is similar to Accept, but\n   restricts the content-codings (section 3.5) that are acceptable in\n   the response.\n\n       Accept-Encoding  = \"Accept-Encoding\" \":\"\n\n\n\nFielding, et al.            Standards Track                   [Page 102]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n                          1#( codings [ \";\" \"q\" \"=\" qvalue ] )\n       codings          = ( content-coding | \"*\" )\n\n   Examples of its use are:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_68",
        "original_index": 68,
        "content": "1#( codings [ \";\" \"q\" \"=\" qvalue ] )\n       codings          = ( content-coding | \"*\" )\n\n   Examples of its use are:\n\n       Accept-Encoding: compress, gzip\n       Accept-Encoding:\n       Accept-Encoding: *\n       Accept-Encoding: compress;q=0.5, gzip;q=1.0\n       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n\n   A server tests whether a content-coding is acceptable, according to\n   an Accept-Encoding field, using these rules:\n\n      1. If the content-coding is one of the content-codings listed in\n         the Accept-Encoding field, then it is acceptable, unless it is\n         accompanied by a qvalue of 0. (As defined in section 3.9, a\n         qvalue of 0 means \"not acceptable.\")\n\n      2. The special \"*\" symbol in an Accept-Encoding field matches any\n         available content-coding not explicitly listed in the header\n         field.\n\n      3. If multiple content-codings are acceptable, then the acceptable\n         content-coding with the highest non-zero qvalue is preferred.\n\n      4. The \"identity\" content-coding is always acceptable, unless\n         specifically refused because the Accept-Encoding field includes\n         \"identity;q=0\", or because the field includes \"*;q=0\" and does\n         not explicitly include the \"identity\" content-coding. If the\n         Accept-Encoding field-value is empty, then only the \"identity\"\n         encoding is acceptable.\n\n   If an Accept-Encoding field is present in a request, and if the\n   server cannot send a response which is acceptable according to the\n   Accept-Encoding header, then the server SHOULD send an error response\n   with the 406 (Not Acceptable) status code.\n\n   If no Accept-Encoding field is present in a request, the server MAY\n   assume that the client will accept any content coding. In this case,\n   if \"identity\" is one of the available content-codings, then the\n   server SHOULD use the \"identity\" content-coding, unless it has\n   additional information that a different content-coding is meaningful\n   to the client.\n\n      Note: If the request does not include an Accept-Encoding field,\n      and if the \"identity\" content-coding is unavailable, then\n      content-codings commonly understood by HTTP/1.0 clients (i.e.,\n\n\n\nFielding, et al.            Standards Track                   [Page 103]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      \"gzip\" and \"compress\") are preferred; some older clients\n      improperly display messages sent with other content-codings.  The\n      server might also make this decision based on information about\n      the particular user-agent or client.\n\n      Note: Most HTTP/1.0 applications do not recognize or obey qvalues\n      associated with content-codings. This means that qvalues will not\n      work and are not permitted with x-gzip or x-compress.\n\n14.4 Accept-Language\n\n   The Accept-Language request-header field is similar to Accept, but\n   restricts the set of natural languages that are preferred as a\n   response to the request. Language tags are defined in section 3.10.\n\n       Accept-Language = \"Accept-Language\" \":\"\n                         1#( language-range [ \";\" \"q\" \"=\" qvalue ] )\n       language-range  = ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) | \"*\" )\n\n   Each language-range MAY be given an associated quality value which\n   represents an estimate of the user's preference for the languages\n   specified by that range. The quality value defaults to \"q=1\". For\n   example,\n\n       Accept-Language: da, en-gb;q=0.8, en;q=0.7\n\n   would mean: \"I prefer Danish, but will accept British English and\n   other types of English.\" A language-range matches a language-tag if\n   it exactly equals the tag, or if it exactly equals a prefix of the\n   tag such that the first tag character following the prefix is \"-\".\n   The special range \"*\", if present in the Accept-Language field,\n   matches every tag not matched by any other range present in the\n   Accept-Language field."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_69",
        "original_index": 69,
        "content": "Note: This use of a prefix matching rule does not imply that\n      language tags are assigned to languages in such a way that it is\n      always true that if a user understands a language with a certain\n      tag, then this user will also understand all languages with tags\n      for which this tag is a prefix. The prefix rule simply allows the\n      use of prefix tags if this is the case.\n\n   The language quality factor assigned to a language-tag by the\n   Accept-Language field is the quality value of the longest language-\n   range in the field that matches the language-tag. If no language-\n   range in the field matches the tag, the language quality factor\n   assigned is 0. If no Accept-Language header is present in the\n   request, the server\n\n\n\n\nFielding, et al.            Standards Track                   [Page 104]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   SHOULD assume that all languages are equally acceptable. If an\n   Accept-Language header is present, then all languages which are\n   assigned a quality factor greater than 0 are acceptable.\n\n   It might be contrary to the privacy expectations of the user to send\n   an Accept-Language header with the complete linguistic preferences of\n   the user in every request. For a discussion of this issue, see\n   section 15.1.4.\n\n   As intelligibility is highly dependent on the individual user, it is\n   recommended that client applications make the choice of linguistic\n   preference available to the user. If the choice is not made\n   available, then the Accept-Language header field MUST NOT be given in\n   the request.\n\n      Note: When making the choice of linguistic preference available to\n      the user, we remind implementors of  the fact that users are not\n      familiar with the details of language matching as described above,\n      and should provide appropriate guidance. As an example, users\n      might assume that on selecting \"en-gb\", they will be served any\n      kind of English document if British English is not available. A\n      user agent might suggest in such a case to add \"en\" to get the\n      best matching behavior.\n\n14.5 Accept-Ranges\n\n      The Accept-Ranges response-header field allows the server to\n      indicate its acceptance of range requests for a resource:\n\n          Accept-Ranges     = \"Accept-Ranges\" \":\" acceptable-ranges\n          acceptable-ranges = 1#range-unit | \"none\"\n\n      Origin servers that accept byte-range requests MAY send\n\n          Accept-Ranges: bytes\n\n      but are not required to do so. Clients MAY generate byte-range\n      requests without having received this header for the resource\n      involved. Range units are defined in section 3.12.\n\n      Servers that do not accept any kind of range request for a\n      resource MAY send\n\n          Accept-Ranges: none\n\n      to advise the client not to attempt a range request.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 105]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.6 Age\n\n      The Age response-header field conveys the sender's estimate of the\n      amount of time since the response (or its revalidation) was\n      generated at the origin server. A cached response is \"fresh\" if\n      its age does not exceed its freshness lifetime. Age values are\n      calculated as specified in section 13.2.3.\n\n           Age = \"Age\" \":\" age-value\n           age-value = delta-seconds\n\n      Age values are non-negative decimal integers, representing time in\n      seconds.\n\n      If a cache receives a value larger than the largest positive\n      integer it can represent, or if any of its age calculations\n      overflows, it MUST transmit an Age header with a value of\n      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST\n      include an Age header field in every response generated from its\n      own cache. Caches SHOULD use an arithmetic type of at least 31\n      bits of range.\n\n14.7 Allow"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_70",
        "original_index": 70,
        "content": "14.7 Allow\n\n      The Allow entity-header field lists the set of methods supported\n      by the resource identified by the Request-URI. The purpose of this\n      field is strictly to inform the recipient of valid methods\n      associated with the resource. An Allow header field MUST be\n      present in a 405 (Method Not Allowed) response.\n\n          Allow   = \"Allow\" \":\" #Method\n\n      Example of use:\n\n          Allow: GET, HEAD, PUT\n\n      This field cannot prevent a client from trying other methods.\n      However, the indications given by the Allow header field value\n      SHOULD be followed. The actual set of allowed methods is defined\n      by the origin server at the time of each request.\n\n      The Allow header field MAY be provided with a PUT request to\n      recommend the methods to be supported by the new or modified\n      resource. The server is not required to support these methods and\n      SHOULD include an Allow header in the response giving the actual\n      supported methods.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 106]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      A proxy MUST NOT modify the Allow header field even if it does not\n      understand all the methods specified, since the user agent might\n      have other means of communicating with the origin server.\n\n14.8 Authorization\n\n      A user agent that wishes to authenticate itself with a server--\n      usually, but not necessarily, after receiving a 401 response--does\n      so by including an Authorization request-header field with the\n      request.  The Authorization field value consists of credentials\n      containing the authentication information of the user agent for\n      the realm of the resource being requested.\n\n          Authorization  = \"Authorization\" \":\" credentials\n\n      HTTP access authentication is described in \"HTTP Authentication:\n      Basic and Digest Access Authentication\" [43]. If a request is\n      authenticated and a realm specified, the same credentials SHOULD\n      be valid for all other requests within this realm (assuming that\n      the authentication scheme itself does not require otherwise, such\n      as credentials that vary according to a challenge value or using\n      synchronized clocks).\n\n      When a shared cache (see section 13.7) receives a request\n      containing an Authorization field, it MUST NOT return the\n      corresponding response as a reply to any other request, unless one\n      of the following specific exceptions holds:\n\n      1. If the response includes the \"s-maxage\" cache-control\n         directive, the cache MAY use that response in replying to a\n         subsequent request. But (if the specified maximum age has\n         passed) a proxy cache MUST first revalidate it with the origin\n         server, using the request-headers from the new request to allow\n         the origin server to authenticate the new request. (This is the\n         defined behavior for s-maxage.) If the response includes \"s-\n         maxage=0\", the proxy MUST always revalidate it before re-using\n         it.\n\n      2. If the response includes the \"must-revalidate\" cache-control\n         directive, the cache MAY use that response in replying to a\n         subsequent request. But if the response is stale, all caches\n         MUST first revalidate it with the origin server, using the\n         request-headers from the new request to allow the origin server\n         to authenticate the new request.\n\n      3. If the response includes the \"public\" cache-control directive,\n         it MAY be returned in reply to any subsequent request.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 107]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.9 Cache-Control"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_71",
        "original_index": 71,
        "content": "Fielding, et al.            Standards Track                   [Page 107]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.9 Cache-Control\n\n   The Cache-Control general-header field is used to specify directives\n   that MUST be obeyed by all caching mechanisms along the\n   request/response chain. The directives specify behavior intended to\n   prevent caches from adversely interfering with the request or\n   response. These directives typically override the default caching\n   algorithms. Cache directives are unidirectional in that the presence\n   of a directive in a request does not imply that the same directive is\n   to be given in the response.\n\n      Note that HTTP/1.0 caches might not implement Cache-Control and\n      might only implement Pragma: no-cache (see section 14.32).\n\n   Cache directives MUST be passed through by a proxy or gateway\n   application, regardless of their significance to that application,\n   since the directives might be applicable to all recipients along the\n   request/response chain. It is not possible to specify a cache-\n   directive for a specific cache.\n\n    Cache-Control   = \"Cache-Control\" \":\" 1#cache-directive\n\n    cache-directive = cache-request-directive\n         | cache-response-directive\n\n    cache-request-directive =\n           \"no-cache\"                          ; Section 14.9.1\n         | \"no-store\"                          ; Section 14.9.2\n         | \"max-age\" \"=\" delta-seconds         ; Section 14.9.3, 14.9.4\n         | \"max-stale\" [ \"=\" delta-seconds ]   ; Section 14.9.3\n         | \"min-fresh\" \"=\" delta-seconds       ; Section 14.9.3\n         | \"no-transform\"                      ; Section 14.9.5\n         | \"only-if-cached\"                    ; Section 14.9.4\n         | cache-extension                     ; Section 14.9.6\n\n     cache-response-directive =\n           \"public\"                               ; Section 14.9.1\n         | \"private\" [ \"=\" <\"> 1#field-name <\"> ] ; Section 14.9.1\n         | \"no-cache\" [ \"=\" <\"> 1#field-name <\"> ]; Section 14.9.1\n         | \"no-store\"                             ; Section 14.9.2\n         | \"no-transform\"                         ; Section 14.9.5\n         | \"must-revalidate\"                      ; Section 14.9.4\n         | \"proxy-revalidate\"                     ; Section 14.9.4\n         | \"max-age\" \"=\" delta-seconds            ; Section 14.9.3\n         | \"s-maxage\" \"=\" delta-seconds           ; Section 14.9.3\n         | cache-extension                        ; Section 14.9.6\n\n    cache-extension = token [ \"=\" ( token | quoted-string ) ]\n\n\n\nFielding, et al.            Standards Track                   [Page 108]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   When a directive appears without any 1#field-name parameter, the\n   directive applies to the entire request or response. When such a\n   directive appears with a 1#field-name parameter, it applies only to\n   the named field or fields, and not to the rest of the request or\n   response. This mechanism supports extensibility; implementations of\n   future versions of the HTTP protocol might apply these directives to\n   header fields not defined in HTTP/1.1.\n\n   The cache-control directives can be broken down into these general\n   categories:\n\n      - Restrictions on what are cacheable; these may only be imposed by\n        the origin server.\n\n      - Restrictions on what may be stored by a cache; these may be\n        imposed by either the origin server or the user agent.\n\n      - Modifications of the basic expiration mechanism; these may be\n        imposed by either the origin server or the user agent.\n\n      - Controls over cache revalidation and reload; these may only be\n        imposed by a user agent.\n\n      - Control over transformation of entities.\n\n      - Extensions to the caching system.\n\n14.9.1 What is Cacheable"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_72",
        "original_index": 72,
        "content": "- Control over transformation of entities.\n\n      - Extensions to the caching system.\n\n14.9.1 What is Cacheable\n\n   By default, a response is cacheable if the requirements of the\n   request method, request header fields, and the response status\n   indicate that it is cacheable. Section 13.4 summarizes these defaults\n   for cacheability. The following Cache-Control response directives\n   allow an origin server to override the default cacheability of a\n   response:\n\n   public\n      Indicates that the response MAY be cached by any cache, even if it\n      would normally be non-cacheable or cacheable only within a non-\n      shared cache. (See also Authorization, section 14.8, for\n      additional details.)\n\n   private\n      Indicates that all or part of the response message is intended for\n      a single user and MUST NOT be cached by a shared cache. This\n      allows an origin server to state that the specified parts of the\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 109]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      response are intended for only one user and are not a valid\n      response for requests by other users. A private (non-shared) cache\n      MAY cache the response.\n\n       Note: This usage of the word private only controls where the\n       response may be cached, and cannot ensure the privacy of the\n       message content.\n\n   no-cache\n       If the no-cache directive does not specify a field-name, then a\n      cache MUST NOT use the response to satisfy a subsequent request\n      without successful revalidation with the origin server. This\n      allows an origin server to prevent caching even by caches that\n      have been configured to return stale responses to client requests.\n\n      If the no-cache directive does specify one or more field-names,\n      then a cache MAY use the response to satisfy a subsequent request,\n      subject to any other restrictions on caching. However, the\n      specified field-name(s) MUST NOT be sent in the response to a\n      subsequent request without successful revalidation with the origin\n      server. This allows an origin server to prevent the re-use of\n      certain header fields in a response, while still allowing caching\n      of the rest of the response.\n\n       Note: Most HTTP/1.0 caches will not recognize or obey this\n       directive.\n\n14.9.2 What May be Stored by Caches\n\n   no-store\n      The purpose of the no-store directive is to prevent the\n      inadvertent release or retention of sensitive information (for\n      example, on backup tapes). The no-store directive applies to the\n      entire message, and MAY be sent either in a response or in a\n      request. If sent in a request, a cache MUST NOT store any part of\n      either this request or any response to it. If sent in a response,\n      a cache MUST NOT store any part of either this response or the\n      request that elicited it. This directive applies to both non-\n      shared and shared caches. \"MUST NOT store\" in this context means\n      that the cache MUST NOT intentionally store the information in\n      non-volatile storage, and MUST make a best-effort attempt to\n      remove the information from volatile storage as promptly as\n      possible after forwarding it.\n\n      Even when this directive is associated with a response, users\n      might explicitly store such a response outside of the caching\n      system (e.g., with a \"Save As\" dialog). History buffers MAY store\n      such responses as part of their normal operation.\n\n\n\nFielding, et al.            Standards Track                   [Page 110]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_73",
        "original_index": 73,
        "content": "Fielding, et al.            Standards Track                   [Page 110]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      The purpose of this directive is to meet the stated requirements\n      of certain users and service authors who are concerned about\n      accidental releases of information via unanticipated accesses to\n      cache data structures. While the use of this directive might\n      improve privacy in some cases, we caution that it is NOT in any\n      way a reliable or sufficient mechanism for ensuring privacy. In\n      particular, malicious or compromised caches might not recognize or\n      obey this directive, and communications networks might be\n      vulnerable to eavesdropping.\n\n14.9.3 Modifications of the Basic Expiration Mechanism\n\n   The expiration time of an entity MAY be specified by the origin\n   server using the Expires header (see section 14.21). Alternatively,\n   it MAY be specified using the max-age directive in a response. When\n   the max-age cache-control directive is present in a cached response,\n   the response is stale if its current age is greater than the age\n   value given (in seconds) at the time of a new request for that\n   resource. The max-age directive on a response implies that the\n   response is cacheable (i.e., \"public\") unless some other, more\n   restrictive cache directive is also present.\n\n   If a response includes both an Expires header and a max-age\n   directive, the max-age directive overrides the Expires header, even\n   if the Expires header is more restrictive. This rule allows an origin\n   server to provide, for a given response, a longer expiration time to\n   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be\n   useful if certain HTTP/1.0 caches improperly calculate ages or\n   expiration times, perhaps due to desynchronized clocks.\n\n   Many HTTP/1.0 cache implementations will treat an Expires value that\n   is less than or equal to the response Date value as being equivalent\n   to the Cache-Control response directive \"no-cache\". If an HTTP/1.1\n   cache receives such a response, and the response does not include a\n   Cache-Control header field, it SHOULD consider the response to be\n   non-cacheable in order to retain compatibility with HTTP/1.0 servers.\n\n       Note: An origin server might wish to use a relatively new HTTP\n       cache control feature, such as the \"private\" directive, on a\n       network including older caches that do not understand that\n       feature. The origin server will need to combine the new feature\n       with an Expires field whose value is less than or equal to the\n       Date value. This will prevent older caches from improperly\n       caching the response.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 111]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   s-maxage\n       If a response includes an s-maxage directive, then for a shared\n       cache (but not for a private cache), the maximum age specified by\n       this directive overrides the maximum age specified by either the\n       max-age directive or the Expires header. The s-maxage directive\n       also implies the semantics of the proxy-revalidate directive (see\n       section 14.9.4), i.e., that the shared cache must not use the\n       entry after it becomes stale to respond to a subsequent request\n       without first revalidating it with the origin server. The s-\n       maxage directive is always ignored by a private cache.\n\n   Note that most older caches, not compliant with this specification,\n   do not implement any cache-control directives. An origin server\n   wishing to use a cache-control directive that restricts, but does not\n   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the\n   requirement that the max-age directive overrides the Expires header,\n   and the fact that pre-HTTP/1.1-compliant caches do not observe the\n   max-age directive."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_74",
        "original_index": 74,
        "content": "Other directives allow a user agent to modify the basic expiration\n   mechanism. These directives MAY be specified on a request:\n\n   max-age\n      Indicates that the client is willing to accept a response whose\n      age is no greater than the specified time in seconds. Unless max-\n      stale directive is also included, the client is not willing to\n      accept a stale response.\n\n   min-fresh\n      Indicates that the client is willing to accept a response whose\n      freshness lifetime is no less than its current age plus the\n      specified time in seconds. That is, the client wants a response\n      that will still be fresh for at least the specified number of\n      seconds.\n\n   max-stale\n      Indicates that the client is willing to accept a response that has\n      exceeded its expiration time. If max-stale is assigned a value,\n      then the client is willing to accept a response that has exceeded\n      its expiration time by no more than the specified number of\n      seconds. If no value is assigned to max-stale, then the client is\n      willing to accept a stale response of any age.\n\n   If a cache returns a stale response, either because of a max-stale\n   directive on a request, or because the cache is configured to\n   override the expiration time of a response, the cache MUST attach a\n   Warning header to the stale response, using Warning 110 (Response is\n   stale).\n\n\n\nFielding, et al.            Standards Track                   [Page 112]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A cache MAY be configured to return stale responses without\n   validation, but only if this does not conflict with any \"MUST\"-level\n   requirements concerning cache validation (e.g., a \"must-revalidate\"\n   cache-control directive).\n\n   If both the new request and the cached entry include \"max-age\"\n   directives, then the lesser of the two values is used for determining\n   the freshness of the cached entry for that request.\n\n14.9.4 Cache Revalidation and Reload Controls\n\n   Sometimes a user agent might want or need to insist that a cache\n   revalidate its cache entry with the origin server (and not just with\n   the next cache along the path to the origin server), or to reload its\n   cache entry from the origin server. End-to-end revalidation might be\n   necessary if either the cache or the origin server has overestimated\n   the expiration time of the cached response. End-to-end reload may be\n   necessary if the cache entry has become corrupted for some reason.\n\n   End-to-end revalidation may be requested either when the client does\n   not have its own local cached copy, in which case we call it\n   \"unspecified end-to-end revalidation\", or when the client does have a\n   local cached copy, in which case we call it \"specific end-to-end\n   revalidation.\"\n\n   The client can specify these three kinds of action using Cache-\n   Control request directives:\n\n   End-to-end reload\n      The request includes a \"no-cache\" cache-control directive or, for\n      compatibility with HTTP/1.0 clients, \"Pragma: no-cache\". Field\n      names MUST NOT be included with the no-cache directive in a\n      request. The server MUST NOT use a cached copy when responding to\n      such a request.\n\n   Specific end-to-end revalidation\n      The request includes a \"max-age=0\" cache-control directive, which\n      forces each cache along the path to the origin server to\n      revalidate its own entry, if any, with the next cache or server.\n      The initial request includes a cache-validating conditional with\n      the client's current validator.\n\n   Unspecified end-to-end revalidation\n      The request includes \"max-age=0\" cache-control directive, which\n      forces each cache along the path to the origin server to\n      revalidate its own entry, if any, with the next cache or server.\n      The initial request does not include a cache-validating"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_75",
        "original_index": 75,
        "content": "Fielding, et al.            Standards Track                   [Page 113]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      conditional; the first cache along the path (if any) that holds a\n      cache entry for this resource includes a cache-validating\n      conditional with its current validator.\n\n   max-age\n      When an intermediate cache is forced, by means of a max-age=0\n      directive, to revalidate its own cache entry, and the client has\n      supplied its own validator in the request, the supplied validator\n      might differ from the validator currently stored with the cache\n      entry. In this case, the cache MAY use either validator in making\n      its own request without affecting semantic transparency.\n\n      However, the choice of validator might affect performance. The\n      best approach is for the intermediate cache to use its own\n      validator when making its request. If the server replies with 304\n      (Not Modified), then the cache can return its now validated copy\n      to the client with a 200 (OK) response. If the server replies with\n      a new entity and cache validator, however, the intermediate cache\n      can compare the returned validator with the one provided in the\n      client's request, using the strong comparison function. If the\n      client's validator is equal to the origin server's, then the\n      intermediate cache simply returns 304 (Not Modified). Otherwise,\n      it returns the new entity with a 200 (OK) response.\n\n      If a request includes the no-cache directive, it SHOULD NOT\n      include min-fresh, max-stale, or max-age.\n\n   only-if-cached\n      In some cases, such as times of extremely poor network\n      connectivity, a client may want a cache to return only those\n      responses that it currently has stored, and not to reload or\n      revalidate with the origin server. To do this, the client may\n      include the only-if-cached directive in a request. If it receives\n      this directive, a cache SHOULD either respond using a cached entry\n      that is consistent with the other constraints of the request, or\n      respond with a 504 (Gateway Timeout) status. However, if a group\n      of caches is being operated as a unified system with good internal\n      connectivity, such a request MAY be forwarded within that group of\n      caches.\n\n   must-revalidate\n      Because a cache MAY be configured to ignore a server's specified\n      expiration time, and because a client request MAY include a max-\n      stale directive (which has a similar effect), the protocol also\n      includes a mechanism for the origin server to require revalidation\n      of a cache entry on any subsequent use. When the must-revalidate\n      directive is present in a response received by a cache, that cache\n      MUST NOT use the entry after it becomes stale to respond to a\n\n\n\nFielding, et al.            Standards Track                   [Page 114]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      subsequent request without first revalidating it with the origin\n      server. (I.e., the cache MUST do an end-to-end revalidation every\n      time, if, based solely on the origin server's Expires or max-age\n      value, the cached response is stale.)\n\n      The must-revalidate directive is necessary to support reliable\n      operation for certain protocol features. In all circumstances an\n      HTTP/1.1 cache MUST obey the must-revalidate directive; in\n      particular, if the cache cannot reach the origin server for any\n      reason, it MUST generate a 504 (Gateway Timeout) response."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_76",
        "original_index": 76,
        "content": "Servers SHOULD send the must-revalidate directive if and only if\n      failure to revalidate a request on the entity could result in\n      incorrect operation, such as a silently unexecuted financial\n      transaction. Recipients MUST NOT take any automated action that\n      violates this directive, and MUST NOT automatically provide an\n      unvalidated copy of the entity if revalidation fails.\n\n      Although this is not recommended, user agents operating under\n      severe connectivity constraints MAY violate this directive but, if\n      so, MUST explicitly warn the user that an unvalidated response has\n      been provided. The warning MUST be provided on each unvalidated\n      access, and SHOULD require explicit user confirmation.\n\n   proxy-revalidate\n      The proxy-revalidate directive has the same meaning as the must-\n      revalidate directive, except that it does not apply to non-shared\n      user agent caches. It can be used on a response to an\n      authenticated request to permit the user's cache to store and\n      later return the response without needing to revalidate it (since\n      it has already been authenticated once by that user), while still\n      requiring proxies that service many users to revalidate each time\n      (in order to make sure that each user has been authenticated).\n      Note that such authenticated responses also need the public cache\n      control directive in order to allow them to be cached at all.\n\n14.9.5 No-Transform Directive\n\n   no-transform\n      Implementors of intermediate caches (proxies) have found it useful\n      to convert the media type of certain entity bodies. A non-\n      transparent proxy might, for example, convert between image\n      formats in order to save cache space or to reduce the amount of\n      traffic on a slow link.\n\n      Serious operational problems occur, however, when these\n      transformations are applied to entity bodies intended for certain\n      kinds of applications. For example, applications for medical\n\n\n\nFielding, et al.            Standards Track                   [Page 115]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      imaging, scientific data analysis and those using end-to-end\n      authentication, all depend on receiving an entity body that is bit\n      for bit identical to the original entity-body.\n\n      Therefore, if a message includes the no-transform directive, an\n      intermediate cache or proxy MUST NOT change those headers that are\n      listed in section 13.5.2 as being subject to the no-transform\n      directive. This implies that the cache or proxy MUST NOT change\n      any aspect of the entity-body that is specified by these headers,\n      including the value of the entity-body itself.\n\n14.9.6 Cache Control Extensions\n\n   The Cache-Control header field can be extended through the use of one\n   or more cache-extension tokens, each with an optional assigned value.\n   Informational extensions (those which do not require a change in\n   cache behavior) MAY be added without changing the semantics of other\n   directives. Behavioral extensions are designed to work by acting as\n   modifiers to the existing base of cache directives. Both the new\n   directive and the standard directive are supplied, such that\n   applications which do not understand the new directive will default\n   to the behavior specified by the standard directive, and those that\n   understand the new directive will recognize it as modifying the\n   requirements associated with the standard directive. In this way,\n   extensions to the cache-control directives can be made without\n   requiring changes to the base protocol.\n\n   This extension mechanism depends on an HTTP cache obeying all of the\n   cache-control directives defined for its native HTTP-version, obeying\n   certain extensions, and ignoring all directives that it does not\n   understand."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_77",
        "original_index": 77,
        "content": "For example, consider a hypothetical new response directive called\n   community which acts as a modifier to the private directive. We\n   define this new directive to mean that, in addition to any non-shared\n   cache, any cache which is shared only by members of the community\n   named within its value may cache the response. An origin server\n   wishing to allow the UCI community to use an otherwise private\n   response in their shared cache(s) could do so by including\n\n       Cache-Control: private, community=\"UCI\"\n\n   A cache seeing this header field will act correctly even if the cache\n   does not understand the community cache-extension, since it will also\n   see and understand the private directive and thus default to the safe\n   behavior.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 116]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Unrecognized cache-directives MUST be ignored; it is assumed that any\n   cache-directive likely to be unrecognized by an HTTP/1.1 cache will\n   be combined with standard directives (or the response's default\n   cacheability) such that the cache behavior will remain minimally\n   correct even if the cache does not understand the extension(s).\n\n14.10 Connection\n\n   The Connection general-header field allows the sender to specify\n   options that are desired for that particular connection and MUST NOT\n   be communicated by proxies over further connections.\n\n   The Connection header has the following grammar:\n\n       Connection = \"Connection\" \":\" 1#(connection-token)\n       connection-token  = token\n\n   HTTP/1.1 proxies MUST parse the Connection header field before a\n   message is forwarded and, for each connection-token in this field,\n   remove any header field(s) from the message with the same name as the\n   connection-token. Connection options are signaled by the presence of\n   a connection-token in the Connection header field, not by any\n   corresponding additional header field(s), since the additional header\n   field may not be sent if there are no parameters associated with that\n   connection option.\n\n   Message headers listed in the Connection header MUST NOT include\n   end-to-end headers, such as Cache-Control.\n\n   HTTP/1.1 defines the \"close\" connection option for the sender to\n   signal that the connection will be closed after completion of the\n   response. For example,\n\n       Connection: close\n\n   in either the request or the response header fields indicates that\n   the connection SHOULD NOT be considered `persistent' (section 8.1)\n   after the current request/response is complete.\n\n   HTTP/1.1 applications that do not support persistent connections MUST\n   include the \"close\" connection option in every message.\n\n   A system receiving an HTTP/1.0 (or lower-version) message that\n   includes a Connection header MUST, for each connection-token in this\n   field, remove and ignore any header field(s) from the message with\n   the same name as the connection-token. This protects against mistaken\n   forwarding of such header fields by pre-HTTP/1.1 proxies. See section\n   19.6.2.\n\n\n\nFielding, et al.            Standards Track                   [Page 117]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.11 Content-Encoding\n\n   The Content-Encoding entity-header field is used as a modifier to the\n   media-type. When present, its value indicates what additional content\n   codings have been applied to the entity-body, and thus what decoding\n   mechanisms must be applied in order to obtain the media-type\n   referenced by the Content-Type header field. Content-Encoding is\n   primarily used to allow a document to be compressed without losing\n   the identity of its underlying media type.\n\n       Content-Encoding  = \"Content-Encoding\" \":\" 1#content-coding\n\n   Content codings are defined in section 3.5. An example of its use is\n\n       Content-Encoding: gzip"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_78",
        "original_index": 78,
        "content": "Content-Encoding  = \"Content-Encoding\" \":\" 1#content-coding\n\n   Content codings are defined in section 3.5. An example of its use is\n\n       Content-Encoding: gzip\n\n   The content-coding is a characteristic of the entity identified by\n   the Request-URI. Typically, the entity-body is stored with this\n   encoding and is only decoded before rendering or analogous usage.\n   However, a non-transparent proxy MAY modify the content-coding if the\n   new coding is known to be acceptable to the recipient, unless the\n   \"no-transform\" cache-control directive is present in the message.\n\n   If the content-coding of an entity is not \"identity\", then the\n   response MUST include a Content-Encoding entity-header (section\n   14.11) that lists the non-identity content-coding(s) used.\n\n   If the content-coding of an entity in a request message is not\n   acceptable to the origin server, the server SHOULD respond with a\n   status code of 415 (Unsupported Media Type).\n\n   If multiple encodings have been applied to an entity, the content\n   codings MUST be listed in the order in which they were applied.\n   Additional information about the encoding parameters MAY be provided\n   by other entity-header fields not defined by this specification.\n\n14.12 Content-Language\n\n   The Content-Language entity-header field describes the natural\n   language(s) of the intended audience for the enclosed entity. Note\n   that this might not be equivalent to all the languages used within\n   the entity-body.\n\n       Content-Language  = \"Content-Language\" \":\" 1#language-tag\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 118]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Language tags are defined in section 3.10. The primary purpose of\n   Content-Language is to allow a user to identify and differentiate\n   entities according to the user's own preferred language. Thus, if the\n   body content is intended only for a Danish-literate audience, the\n   appropriate field is\n\n       Content-Language: da\n\n   If no Content-Language is specified, the default is that the content\n   is intended for all language audiences. This might mean that the\n   sender does not consider it to be specific to any natural language,\n   or that the sender does not know for which language it is intended.\n\n   Multiple languages MAY be listed for content that is intended for\n   multiple audiences. For example, a rendition of the \"Treaty of\n   Waitangi,\" presented simultaneously in the original Maori and English\n   versions, would call for\n\n       Content-Language: mi, en\n\n   However, just because multiple languages are present within an entity\n   does not mean that it is intended for multiple linguistic audiences.\n   An example would be a beginner's language primer, such as \"A First\n   Lesson in Latin,\" which is clearly intended to be used by an\n   English-literate audience. In this case, the Content-Language would\n   properly only include \"en\".\n\n   Content-Language MAY be applied to any media type -- it is not\n   limited to textual documents.\n\n14.13 Content-Length\n\n   The Content-Length entity-header field indicates the size of the\n   entity-body, in decimal number of OCTETs, sent to the recipient or,\n   in the case of the HEAD method, the size of the entity-body that\n   would have been sent had the request been a GET.\n\n       Content-Length    = \"Content-Length\" \":\" 1*DIGIT\n\n   An example is\n\n       Content-Length: 3495\n\n   Applications SHOULD use this field to indicate the transfer-length of\n   the message-body, unless this is prohibited by the rules in section\n   4.4.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 119]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Any Content-Length greater than or equal to zero is a valid value.\n   Section 4.4 describes how to determine the length of a message-body\n   if a Content-Length is not given."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_79",
        "original_index": 79,
        "content": "Any Content-Length greater than or equal to zero is a valid value.\n   Section 4.4 describes how to determine the length of a message-body\n   if a Content-Length is not given.\n\n   Note that the meaning of this field is significantly different from\n   the corresponding definition in MIME, where it is an optional field\n   used within the \"message/external-body\" content-type. In HTTP, it\n   SHOULD be sent whenever the message's length can be determined prior\n   to being transferred, unless this is prohibited by the rules in\n   section 4.4.\n\n14.14 Content-Location\n\n   The Content-Location entity-header field MAY be used to supply the\n   resource location for the entity enclosed in the message when that\n   entity is accessible from a location separate from the requested\n   resource's URI. A server SHOULD provide a Content-Location for the\n   variant corresponding to the response entity; especially in the case\n   where a resource has multiple entities associated with it, and those\n   entities actually have separate locations by which they might be\n   individually accessed, the server SHOULD provide a Content-Location\n   for the particular variant which is returned.\n\n       Content-Location = \"Content-Location\" \":\"\n                         ( absoluteURI | relativeURI )\n\n   The value of Content-Location also defines the base URI for the\n   entity.\n\n   The Content-Location value is not a replacement for the original\n   requested URI; it is only a statement of the location of the resource\n   corresponding to this particular entity at the time of the request.\n   Future requests MAY specify the Content-Location URI as the request-\n   URI if the desire is to identify the source of that particular\n   entity.\n\n   A cache cannot assume that an entity with a Content-Location\n   different from the URI used to retrieve it can be used to respond to\n   later requests on that Content-Location URI. However, the Content-\n   Location can be used to differentiate between multiple entities\n   retrieved from a single requested resource, as described in section\n   13.6.\n\n   If the Content-Location is a relative URI, the relative URI is\n   interpreted relative to the Request-URI.\n\n   The meaning of the Content-Location header in PUT or POST requests is\n   undefined; servers are free to ignore it in those cases.\n\n\n\nFielding, et al.            Standards Track                   [Page 120]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.15 Content-MD5\n\n   The Content-MD5 entity-header field, as defined in RFC 1864 [23], is\n   an MD5 digest of the entity-body for the purpose of providing an\n   end-to-end message integrity check (MIC) of the entity-body. (Note: a\n   MIC is good for detecting accidental modification of the entity-body\n   in transit, but is not proof against malicious attacks.)\n\n        Content-MD5   = \"Content-MD5\" \":\" md5-digest\n        md5-digest   = <base64 of 128 bit MD5 digest as per RFC 1864>\n\n   The Content-MD5 header field MAY be generated by an origin server or\n   client to function as an integrity check of the entity-body. Only\n   origin servers or clients MAY generate the Content-MD5 header field;\n   proxies and gateways MUST NOT generate it, as this would defeat its\n   value as an end-to-end integrity check. Any recipient of the entity-\n   body, including gateways and proxies, MAY check that the digest value\n   in this header field matches that of the entity-body as received.\n\n   The MD5 digest is computed based on the content of the entity-body,\n   including any content-coding that has been applied, but not including\n   any transfer-encoding applied to the message-body. If the message is\n   received with a transfer-encoding, that encoding MUST be removed\n   prior to checking the Content-MD5 value against the received entity."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_80",
        "original_index": 80,
        "content": "This has the result that the digest is computed on the octets of the\n   entity-body exactly as, and in the order that, they would be sent if\n   no transfer-encoding were being applied.\n\n   HTTP extends RFC 1864 to permit the digest to be computed for MIME\n   composite media-types (e.g., multipart/* and message/rfc822), but\n   this does not change how the digest is computed as defined in the\n   preceding paragraph.\n\n   There are several consequences of this. The entity-body for composite\n   types MAY contain many body-parts, each with its own MIME and HTTP\n   headers (including Content-MD5, Content-Transfer-Encoding, and\n   Content-Encoding headers). If a body-part has a Content-Transfer-\n   Encoding or Content-Encoding header, it is assumed that the content\n   of the body-part has had the encoding applied, and the body-part is\n   included in the Content-MD5 digest as is -- i.e., after the\n   application. The Transfer-Encoding header field is not allowed within\n   body-parts.\n\n   Conversion of all line breaks to CRLF MUST NOT be done before\n   computing or checking the digest: the line break convention used in\n   the text actually transmitted MUST be left unaltered when computing\n   the digest.\n\n\n\nFielding, et al.            Standards Track                   [Page 121]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      Note: while the definition of Content-MD5 is exactly the same for\n      HTTP as in RFC 1864 for MIME entity-bodies, there are several ways\n      in which the application of Content-MD5 to HTTP entity-bodies\n      differs from its application to MIME entity-bodies. One is that\n      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and\n      does use Transfer-Encoding and Content-Encoding. Another is that\n      HTTP more frequently uses binary content types than MIME, so it is\n      worth noting that, in such cases, the byte order used to compute\n      the digest is the transmission byte order defined for the type.\n      Lastly, HTTP allows transmission of text types with any of several\n      line break conventions and not just the canonical form using CRLF.\n\n14.16 Content-Range\n\n   The Content-Range entity-header is sent with a partial entity-body to\n   specify where in the full entity-body the partial body should be\n   applied. Range units are defined in section 3.12.\n\n       Content-Range = \"Content-Range\" \":\" content-range-spec\n\n       content-range-spec      = byte-content-range-spec\n       byte-content-range-spec = bytes-unit SP\n                                 byte-range-resp-spec \"/\"\n                                 ( instance-length | \"*\" )\n\n       byte-range-resp-spec = (first-byte-pos \"-\" last-byte-pos)\n                                      | \"*\"\n       instance-length           = 1*DIGIT\n\n   The header SHOULD indicate the total length of the full entity-body,\n   unless this length is unknown or difficult to determine. The asterisk\n   \"*\" character means that the instance-length is unknown at the time\n   when the response was generated.\n\n   Unlike byte-ranges-specifier values (see section 14.35.1), a byte-\n   range-resp-spec MUST only specify one range, and MUST contain\n   absolute byte positions for both the first and last byte of the\n   range.\n\n   A byte-content-range-spec with a byte-range-resp-spec whose last-\n   byte-pos value is less than its first-byte-pos value, or whose\n   instance-length value is less than or equal to its last-byte-pos\n   value, is invalid. The recipient of an invalid byte-content-range-\n   spec MUST ignore it and any content transferred along with it.\n\n   A server sending a response with status code 416 (Requested range not\n   satisfiable) SHOULD include a Content-Range field with a byte-range-\n   resp-spec of \"*\". The instance-length specifies the current length of\n\n\n\nFielding, et al.            Standards Track                   [Page 122]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_81",
        "original_index": 81,
        "content": "Fielding, et al.            Standards Track                   [Page 122]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the selected resource. A response with status code 206 (Partial\n   Content) MUST NOT include a Content-Range field with a byte-range-\n   resp-spec of \"*\".\n\n   Examples of byte-content-range-spec values, assuming that the entity\n   contains a total of 1234 bytes:\n\n      . The first 500 bytes:\n       bytes 0-499/1234\n\n      . The second 500 bytes:\n       bytes 500-999/1234\n\n      . All except for the first 500 bytes:\n       bytes 500-1233/1234\n\n      . The last 500 bytes:\n       bytes 734-1233/1234\n\n   When an HTTP message includes the content of a single range (for\n   example, a response to a request for a single range, or to a request\n   for a set of ranges that overlap without any holes), this content is\n   transmitted with a Content-Range header, and a Content-Length header\n   showing the number of bytes actually transferred. For example,\n\n       HTTP/1.1 206 Partial content\n       Date: Wed, 15 Nov 1995 06:25:24 GMT\n       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n       Content-Range: bytes 21010-47021/47022\n       Content-Length: 26012\n       Content-Type: image/gif\n\n   When an HTTP message includes the content of multiple ranges (for\n   example, a response to a request for multiple non-overlapping\n   ranges), these are transmitted as a multipart message. The multipart\n   media type used for this purpose is \"multipart/byteranges\" as defined\n   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.\n\n   A response to a request for a single range MUST NOT be sent using the\n   multipart/byteranges media type.  A response to a request for\n   multiple ranges, whose result is a single range, MAY be sent as a\n   multipart/byteranges media type with one part. A client that cannot\n   decode a multipart/byteranges message MUST NOT ask for multiple\n   byte-ranges in a single request.\n\n   When a client requests multiple byte-ranges in one request, the\n   server SHOULD return them in the order that they appeared in the\n   request.\n\n\n\nFielding, et al.            Standards Track                   [Page 123]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the server ignores a byte-range-spec because it is syntactically\n   invalid, the server SHOULD treat the request as if the invalid Range\n   header field did not exist. (Normally, this means return a 200\n   response containing the full entity).\n\n   If the server receives a request (other than one including an If-\n   Range request-header field) with an unsatisfiable Range request-\n   header field (that is, all of whose byte-range-spec values have a\n   first-byte-pos value greater than the current length of the selected\n   resource), it SHOULD return a response code of 416 (Requested range\n   not satisfiable) (section 10.4.17).\n\n      Note: clients cannot depend on servers to send a 416 (Requested\n      range not satisfiable) response instead of a 200 (OK) response for\n      an unsatisfiable Range request-header, since not all servers\n      implement this request-header.\n\n14.17 Content-Type\n\n   The Content-Type entity-header field indicates the media type of the\n   entity-body sent to the recipient or, in the case of the HEAD method,\n   the media type that would have been sent had the request been a GET.\n\n       Content-Type   = \"Content-Type\" \":\" media-type\n\n   Media types are defined in section 3.7. An example of the field is\n\n       Content-Type: text/html; charset=ISO-8859-4\n\n   Further discussion of methods for identifying the media type of an\n   entity is provided in section 7.2.1.\n\n14.18 Date\n\n   The Date general-header field represents the date and time at which\n   the message was originated, having the same semantics as orig-date in\n   RFC 822. The field value is an HTTP-date, as described in section\n   3.3.1; it MUST be sent in RFC 1123 [8]-date format."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_82",
        "original_index": 82,
        "content": "Date  = \"Date\" \":\" HTTP-date\n\n   An example is\n\n       Date: Tue, 15 Nov 1994 08:12:31 GMT\n\n   Origin servers MUST include a Date header field in all responses,\n   except in these cases:\n\n\n\n\nFielding, et al.            Standards Track                   [Page 124]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      1. If the response status code is 100 (Continue) or 101 (Switching\n         Protocols), the response MAY include a Date header field, at\n         the server's option.\n\n      2. If the response status code conveys a server error, e.g. 500\n         (Internal Server Error) or 503 (Service Unavailable), and it is\n         inconvenient or impossible to generate a valid Date.\n\n      3. If the server does not have a clock that can provide a\n         reasonable approximation of the current time, its responses\n         MUST NOT include a Date header field. In this case, the rules\n         in section 14.18.1 MUST be followed.\n\n   A received message that does not have a Date header field MUST be\n   assigned one by the recipient if the message will be cached by that\n   recipient or gatewayed via a protocol which requires a Date. An HTTP\n   implementation without a clock MUST NOT cache responses without\n   revalidating them on every use. An HTTP cache, especially a shared\n   cache, SHOULD use a mechanism, such as NTP [28], to synchronize its\n   clock with a reliable external standard.\n\n   Clients SHOULD only send a Date header field in messages that include\n   an entity-body, as in the case of the PUT and POST requests, and even\n   then it is optional. A client without a clock MUST NOT send a Date\n   header field in a request.\n\n   The HTTP-date sent in a Date header SHOULD NOT represent a date and\n   time subsequent to the generation of the message. It SHOULD represent\n   the best available approximation of the date and time of message\n   generation, unless the implementation has no means of generating a\n   reasonably accurate date and time. In theory, the date ought to\n   represent the moment just before the entity is generated. In\n   practice, the date can be generated at any time during the message\n   origination without affecting its semantic value.\n\n14.18.1 Clockless Origin Server Operation\n\n   Some origin server implementations might not have a clock available.\n   An origin server without a clock MUST NOT assign Expires or Last-\n   Modified values to a response, unless these values were associated\n   with the resource by a system or user with a reliable clock. It MAY\n   assign an Expires value that is known, at or before server\n   configuration time, to be in the past (this allows \"pre-expiration\"\n   of responses without storing separate Expires values for each\n   resource).\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 125]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.19 ETag\n\n   The ETag response-header field provides the current value of the\n   entity tag for the requested variant. The headers used with entity\n   tags are described in sections 14.24, 14.26 and 14.44. The entity tag\n   MAY be used for comparison with other entities from the same resource\n   (see section 13.3.3).\n\n      ETag = \"ETag\" \":\" entity-tag\n\n   Examples:\n\n      ETag: \"xyzzy\"\n      ETag: W/\"xyzzy\"\n      ETag: \"\"\n\n14.20 Expect\n\n   The Expect request-header field is used to indicate that particular\n   server behaviors are required by the client.\n\n      Expect       =  \"Expect\" \":\" 1#expectation\n\n      expectation  =  \"100-continue\" | expectation-extension\n      expectation-extension =  token [ \"=\" ( token | quoted-string )\n                               *expect-params ]\n      expect-params =  \";\" token [ \"=\" ( token | quoted-string ) ]"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_83",
        "original_index": 83,
        "content": "A server that does not understand or is unable to comply with any of\n   the expectation values in the Expect field of a request MUST respond\n   with appropriate error status. The server MUST respond with a 417\n   (Expectation Failed) status if any of the expectations cannot be met\n   or, if there are other problems with the request, some other 4xx\n   status.\n\n   This header field is defined with extensible syntax to allow for\n   future extensions. If a server receives a request containing an\n   Expect field that includes an expectation-extension that it does not\n   support, it MUST respond with a 417 (Expectation Failed) status.\n\n   Comparison of expectation values is case-insensitive for unquoted\n   tokens (including the 100-continue token), and is case-sensitive for\n   quoted-string expectation-extensions.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 126]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST\n   return a 417 (Expectation Failed) status if it receives a request\n   with an expectation that it cannot meet. However, the Expect\n   request-header itself is end-to-end; it MUST be forwarded if the\n   request is forwarded.\n\n   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the\n   Expect header.\n\n   See section 8.2.3 for the use of the 100 (continue) status.\n\n14.21 Expires\n\n   The Expires entity-header field gives the date/time after which the\n   response is considered stale. A stale cache entry may not normally be\n   returned by a cache (either a proxy cache or a user agent cache)\n   unless it is first validated with the origin server (or with an\n   intermediate cache that has a fresh copy of the entity). See section\n   13.2 for further discussion of the expiration model.\n\n   The presence of an Expires field does not imply that the original\n   resource will change or cease to exist at, before, or after that\n   time.\n\n   The format is an absolute date and time as defined by HTTP-date in\n   section 3.3.1; it MUST be in RFC 1123 date format:\n\n      Expires = \"Expires\" \":\" HTTP-date\n\n   An example of its use is\n\n      Expires: Thu, 01 Dec 1994 16:00:00 GMT\n\n      Note: if a response includes a Cache-Control field with the max-\n      age directive (see section 14.9.3), that directive overrides the\n      Expires field.\n\n   HTTP/1.1 clients and caches MUST treat other invalid date formats,\n   especially including the value \"0\", as in the past (i.e., \"already\n   expired\").\n\n   To mark a response as \"already expired,\" an origin server sends an\n   Expires date that is equal to the Date header value. (See the rules\n   for expiration calculations in section 13.2.4.)\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 127]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   To mark a response as \"never expires,\" an origin server sends an\n   Expires date approximately one year from the time the response is\n   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one\n   year in the future.\n\n   The presence of an Expires header field with a date value of some\n   time in the future on a response that otherwise would by default be\n   non-cacheable indicates that the response is cacheable, unless\n   indicated otherwise by a Cache-Control header field (section 14.9).\n\n14.22 From\n\n   The From request-header field, if given, SHOULD contain an Internet\n   e-mail address for the human user who controls the requesting user\n   agent. The address SHOULD be machine-usable, as defined by \"mailbox\"\n   in RFC 822 [9] as updated by RFC 1123 [8]:\n\n       From   = \"From\" \":\" mailbox\n\n   An example is:\n\n       From: webmaster@w3.org"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_84",
        "original_index": 84,
        "content": "From   = \"From\" \":\" mailbox\n\n   An example is:\n\n       From: webmaster@w3.org\n\n   This header field MAY be used for logging purposes and as a means for\n   identifying the source of invalid or unwanted requests. It SHOULD NOT\n   be used as an insecure form of access protection. The interpretation\n   of this field is that the request is being performed on behalf of the\n   person given, who accepts responsibility for the method performed. In\n   particular, robot agents SHOULD include this header so that the\n   person responsible for running the robot can be contacted if problems\n   occur on the receiving end.\n\n   The Internet e-mail address in this field MAY be separate from the\n   Internet host which issued the request. For example, when a request\n   is passed through a proxy the original issuer's address SHOULD be\n   used.\n\n   The client SHOULD NOT send the From header field without the user's\n   approval, as it might conflict with the user's privacy interests or\n   their site's security policy. It is strongly recommended that the\n   user be able to disable, enable, and modify the value of this field\n   at any time prior to a request.\n\n14.23 Host\n\n   The Host request-header field specifies the Internet host and port\n   number of the resource being requested, as obtained from the original\n   URI given by the user or referring resource (generally an HTTP URL,\n\n\n\nFielding, et al.            Standards Track                   [Page 128]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   as described in section 3.2.2). The Host field value MUST represent\n   the naming authority of the origin server or gateway given by the\n   original URL. This allows the origin server or gateway to\n   differentiate between internally-ambiguous URLs, such as the root \"/\"\n   URL of a server for multiple host names on a single IP address.\n\n       Host = \"Host\" \":\" host [ \":\" port ] ; Section 3.2.2\n\n   A \"host\" without any trailing port information implies the default\n   port for the service requested (e.g., \"80\" for an HTTP URL). For\n   example, a request on the origin server for\n   <http://www.w3.org/pub/WWW/> would properly include:\n\n       GET /pub/WWW/ HTTP/1.1\n       Host: www.w3.org\n\n   A client MUST include a Host header field in all HTTP/1.1 request\n   messages . If the requested URI does not include an Internet host\n   name for the service being requested, then the Host header field MUST\n   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any\n   request message it forwards does contain an appropriate Host header\n   field that identifies the service being requested by the proxy. All\n   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)\n   status code to any HTTP/1.1 request message which lacks a Host header\n   field.\n\n   See sections 5.2 and 19.6.1.1 for other requirements relating to\n   Host.\n\n14.24 If-Match\n\n   The If-Match request-header field is used with a method to make it\n   conditional. A client that has one or more entities previously\n   obtained from the resource can verify that one of those entities is\n   current by including a list of their associated entity tags in the\n   If-Match header field. Entity tags are defined in section 3.11. The\n   purpose of this feature is to allow efficient updates of cached\n   information with a minimum amount of transaction overhead. It is also\n   used, on updating requests, to prevent inadvertent modification of\n   the wrong version of a resource. As a special case, the value \"*\"\n   matches any current entity of the resource.\n\n       If-Match = \"If-Match\" \":\" ( \"*\" | 1#entity-tag )\n\n   If any of the entity tags match the entity tag of the entity that\n   would have been returned in the response to a similar GET request\n   (without the If-Match header) on that resource, or if \"*\" is given"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_85",
        "original_index": 85,
        "content": "Fielding, et al.            Standards Track                   [Page 129]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   and any current entity exists for that resource, then the server MAY\n   perform the requested method as if the If-Match header field did not\n   exist.\n\n   A server MUST use the strong comparison function (see section 13.3.3)\n   to compare the entity tags in If-Match.\n\n   If none of the entity tags match, or if \"*\" is given and no current\n   entity exists, the server MUST NOT perform the requested method, and\n   MUST return a 412 (Precondition Failed) response. This behavior is\n   most useful when the client wants to prevent an updating method, such\n   as PUT, from modifying a resource that has changed since the client\n   last retrieved it.\n\n   If the request would, without the If-Match header field, result in\n   anything other than a 2xx or 412 status, then the If-Match header\n   MUST be ignored.\n\n   The meaning of \"If-Match: *\" is that the method SHOULD be performed\n   if the representation selected by the origin server (or by a cache,\n   possibly using the Vary mechanism, see section 14.44) exists, and\n   MUST NOT be performed if the representation does not exist.\n\n   A request intended to update a resource (e.g., a PUT) MAY include an\n   If-Match header field to signal that the request method MUST NOT be\n   applied if the entity corresponding to the If-Match value (a single\n   entity tag) is no longer a representation of that resource. This\n   allows the user to indicate that they do not wish the request to be\n   successful if the resource has been changed without their knowledge.\n   Examples:\n\n       If-Match: \"xyzzy\"\n       If-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n       If-Match: *\n\n   The result of a request having both an If-Match header field and\n   either an If-None-Match or an If-Modified-Since header fields is\n   undefined by this specification.\n\n14.25 If-Modified-Since\n\n   The If-Modified-Since request-header field is used with a method to\n   make it conditional: if the requested variant has not been modified\n   since the time specified in this field, an entity will not be\n   returned from the server; instead, a 304 (not modified) response will\n   be returned without any message-body.\n\n       If-Modified-Since = \"If-Modified-Since\" \":\" HTTP-date\n\n\n\nFielding, et al.            Standards Track                   [Page 130]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   An example of the field is:\n\n       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n   A GET method with an If-Modified-Since header and no Range header\n   requests that the identified entity be transferred only if it has\n   been modified since the date given by the If-Modified-Since header.\n   The algorithm for determining this includes the following cases:\n\n      a) If the request would normally result in anything other than a\n         200 (OK) status, or if the passed If-Modified-Since date is\n         invalid, the response is exactly the same as for a normal GET.\n         A date which is later than the server's current time is\n         invalid.\n\n      b) If the variant has been modified since the If-Modified-Since\n         date, the response is exactly the same as for a normal GET.\n\n      c) If the variant has not been modified since a valid If-\n         Modified-Since date, the server SHOULD return a 304 (Not\n         Modified) response.\n\n   The purpose of this feature is to allow efficient updates of cached\n   information with a minimum amount of transaction overhead.\n\n      Note: The Range request-header field modifies the meaning of If-\n      Modified-Since; see section 14.35 for full details.\n\n      Note: If-Modified-Since times are interpreted by the server, whose\n      clock might not be synchronized with the client."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_86",
        "original_index": 86,
        "content": "Note: If-Modified-Since times are interpreted by the server, whose\n      clock might not be synchronized with the client.\n\n      Note: When handling an If-Modified-Since header field, some\n      servers will use an exact date comparison function, rather than a\n      less-than function, for deciding whether to send a 304 (Not\n      Modified) response. To get best results when sending an If-\n      Modified-Since header field for cache validation, clients are\n      advised to use the exact date string received in a previous Last-\n      Modified header field whenever possible.\n\n      Note: If a client uses an arbitrary date in the If-Modified-Since\n      header instead of a date taken from the Last-Modified header for\n      the same request, the client should be aware of the fact that this\n      date is interpreted in the server's understanding of time. The\n      client should consider unsynchronized clocks and rounding problems\n      due to the different encodings of time between the client and\n      server. This includes the possibility of race conditions if the\n      document has changed between the time it was first requested and\n      the If-Modified-Since date of a subsequent request, and the\n\n\n\nFielding, et al.            Standards Track                   [Page 131]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      possibility of clock-skew-related problems if the If-Modified-\n      Since date is derived from the client's clock without correction\n      to the server's clock. Corrections for different time bases\n      between client and server are at best approximate due to network\n      latency.\n\n   The result of a request having both an If-Modified-Since header field\n   and either an If-Match or an If-Unmodified-Since header fields is\n   undefined by this specification.\n\n14.26 If-None-Match\n\n   The If-None-Match request-header field is used with a method to make\n   it conditional. A client that has one or more entities previously\n   obtained from the resource can verify that none of those entities is\n   current by including a list of their associated entity tags in the\n   If-None-Match header field. The purpose of this feature is to allow\n   efficient updates of cached information with a minimum amount of\n   transaction overhead. It is also used to prevent a method (e.g. PUT)\n   from inadvertently modifying an existing resource when the client\n   believes that the resource does not exist.\n\n   As a special case, the value \"*\" matches any current entity of the\n   resource.\n\n       If-None-Match = \"If-None-Match\" \":\" ( \"*\" | 1#entity-tag )\n\n   If any of the entity tags match the entity tag of the entity that\n   would have been returned in the response to a similar GET request\n   (without the If-None-Match header) on that resource, or if \"*\" is\n   given and any current entity exists for that resource, then the\n   server MUST NOT perform the requested method, unless required to do\n   so because the resource's modification date fails to match that\n   supplied in an If-Modified-Since header field in the request.\n   Instead, if the request method was GET or HEAD, the server SHOULD\n   respond with a 304 (Not Modified) response, including the cache-\n   related header fields (particularly ETag) of one of the entities that\n   matched. For all other request methods, the server MUST respond with\n   a status of 412 (Precondition Failed).\n\n   See section 13.3.3 for rules on how to determine if two entities tags\n   match. The weak comparison function can only be used with GET or HEAD\n   requests.\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 132]\n\f\nRFC 2616                        HTTP/1.1                       June 1999"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_87",
        "original_index": 87,
        "content": "Fielding, et al.            Standards Track                   [Page 132]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If none of the entity tags match, then the server MAY perform the\n   requested method as if the If-None-Match header field did not exist,\n   but MUST also ignore any If-Modified-Since header field(s) in the\n   request. That is, if no entity tags match, then the server MUST NOT\n   return a 304 (Not Modified) response.\n\n   If the request would, without the If-None-Match header field, result\n   in anything other than a 2xx or 304 status, then the If-None-Match\n   header MUST be ignored. (See section 13.3.4 for a discussion of\n   server behavior when both If-Modified-Since and If-None-Match appear\n   in the same request.)\n\n   The meaning of \"If-None-Match: *\" is that the method MUST NOT be\n   performed if the representation selected by the origin server (or by\n   a cache, possibly using the Vary mechanism, see section 14.44)\n   exists, and SHOULD be performed if the representation does not exist.\n   This feature is intended to be useful in preventing races between PUT\n   operations.\n\n   Examples:\n\n       If-None-Match: \"xyzzy\"\n       If-None-Match: W/\"xyzzy\"\n       If-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n       If-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"\n       If-None-Match: *\n\n   The result of a request having both an If-None-Match header field and\n   either an If-Match or an If-Unmodified-Since header fields is\n   undefined by this specification.\n\n14.27 If-Range\n\n   If a client has a partial copy of an entity in its cache, and wishes\n   to have an up-to-date copy of the entire entity in its cache, it\n   could use the Range request-header with a conditional GET (using\n   either or both of If-Unmodified-Since and If-Match.) However, if the\n   condition fails because the entity has been modified, the client\n   would then have to make a second request to obtain the entire current\n   entity-body.\n\n   The If-Range header allows a client to \"short-circuit\" the second\n   request. Informally, its meaning is `if the entity is unchanged, send\n   me the part(s) that I am missing; otherwise, send me the entire new\n   entity'.\n\n        If-Range = \"If-Range\" \":\" ( entity-tag | HTTP-date )\n\n\n\n\nFielding, et al.            Standards Track                   [Page 133]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the client has no entity tag for an entity, but does have a Last-\n   Modified date, it MAY use that date in an If-Range header. (The\n   server can distinguish between a valid HTTP-date and any form of\n   entity-tag by examining no more than two characters.) The If-Range\n   header SHOULD only be used together with a Range header, and MUST be\n   ignored if the request does not include a Range header, or if the\n   server does not support the sub-range operation.\n\n   If the entity tag given in the If-Range header matches the current\n   entity tag for the entity, then the server SHOULD provide the\n   specified sub-range of the entity using a 206 (Partial content)\n   response. If the entity tag does not match, then the server SHOULD\n   return the entire entity using a 200 (OK) response.\n\n14.28 If-Unmodified-Since\n\n   The If-Unmodified-Since request-header field is used with a method to\n   make it conditional. If the requested resource has not been modified\n   since the time specified in this field, the server SHOULD perform the\n   requested operation as if the If-Unmodified-Since header were not\n   present.\n\n   If the requested variant has been modified since the specified time,\n   the server MUST NOT perform the requested operation, and MUST return\n   a 412 (Precondition Failed).\n\n      If-Unmodified-Since = \"If-Unmodified-Since\" \":\" HTTP-date\n\n   An example of the field is:\n\n       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_88",
        "original_index": 88,
        "content": "If-Unmodified-Since = \"If-Unmodified-Since\" \":\" HTTP-date\n\n   An example of the field is:\n\n       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n   If the request normally (i.e., without the If-Unmodified-Since\n   header) would result in anything other than a 2xx or 412 status, the\n   If-Unmodified-Since header SHOULD be ignored.\n\n   If the specified date is invalid, the header is ignored.\n\n   The result of a request having both an If-Unmodified-Since header\n   field and either an If-None-Match or an If-Modified-Since header\n   fields is undefined by this specification.\n\n14.29 Last-Modified\n\n   The Last-Modified entity-header field indicates the date and time at\n   which the origin server believes the variant was last modified.\n\n       Last-Modified  = \"Last-Modified\" \":\" HTTP-date\n\n\n\nFielding, et al.            Standards Track                   [Page 134]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   An example of its use is\n\n       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n\n   The exact meaning of this header field depends on the implementation\n   of the origin server and the nature of the original resource. For\n   files, it may be just the file system last-modified time. For\n   entities with dynamically included parts, it may be the most recent\n   of the set of last-modify times for its component parts. For database\n   gateways, it may be the last-update time stamp of the record. For\n   virtual objects, it may be the last time the internal state changed.\n\n   An origin server MUST NOT send a Last-Modified date which is later\n   than the server's time of message origination. In such cases, where\n   the resource's last modification would indicate some time in the\n   future, the server MUST replace that date with the message\n   origination date.\n\n   An origin server SHOULD obtain the Last-Modified value of the entity\n   as close as possible to the time that it generates the Date value of\n   its response. This allows a recipient to make an accurate assessment\n   of the entity's modification time, especially if the entity changes\n   near the time that the response is generated.\n\n   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.\n\n14.30 Location\n\n   The Location response-header field is used to redirect the recipient\n   to a location other than the Request-URI for completion of the\n   request or identification of a new resource. For 201 (Created)\n   responses, the Location is that of the new resource which was created\n   by the request. For 3xx responses, the location SHOULD indicate the\n   server's preferred URI for automatic redirection to the resource. The\n   field value consists of a single absolute URI.\n\n       Location       = \"Location\" \":\" absoluteURI\n\n   An example is:\n\n       Location: http://www.w3.org/pub/WWW/People.html\n\n      Note: The Content-Location header field (section 14.14) differs\n      from Location in that the Content-Location identifies the original\n      location of the entity enclosed in the request. It is therefore\n      possible for a response to contain header fields for both Location\n      and Content-Location. Also see section 13.10 for cache\n      requirements of some methods.\n\n\n\nFielding, et al.            Standards Track                   [Page 135]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.31 Max-Forwards\n\n   The Max-Forwards request-header field provides a mechanism with the\n   TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit the\n   number of proxies or gateways that can forward the request to the\n   next inbound server. This can be useful when the client is attempting\n   to trace a request chain which appears to be failing or looping in\n   mid-chain.\n\n       Max-Forwards   = \"Max-Forwards\" \":\" 1*DIGIT\n\n   The Max-Forwards value is a decimal integer indicating the remaining\n   number of times this request message may be forwarded."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_89",
        "original_index": 89,
        "content": "Max-Forwards   = \"Max-Forwards\" \":\" 1*DIGIT\n\n   The Max-Forwards value is a decimal integer indicating the remaining\n   number of times this request message may be forwarded.\n\n   Each proxy or gateway recipient of a TRACE or OPTIONS request\n   containing a Max-Forwards header field MUST check and update its\n   value prior to forwarding the request. If the received value is zero\n   (0), the recipient MUST NOT forward the request; instead, it MUST\n   respond as the final recipient. If the received Max-Forwards value is\n   greater than zero, then the forwarded message MUST contain an updated\n   Max-Forwards field with a value decremented by one (1).\n\n   The Max-Forwards header field MAY be ignored for all other methods\n   defined by this specification and for any extension methods for which\n   it is not explicitly referred to as part of that method definition.\n\n14.32 Pragma\n\n   The Pragma general-header field is used to include implementation-\n   specific directives that might apply to any recipient along the\n   request/response chain. All pragma directives specify optional\n   behavior from the viewpoint of the protocol; however, some systems\n   MAY require that behavior be consistent with the directives.\n\n       Pragma            = \"Pragma\" \":\" 1#pragma-directive\n       pragma-directive  = \"no-cache\" | extension-pragma\n       extension-pragma  = token [ \"=\" ( token | quoted-string ) ]\n\n   When the no-cache directive is present in a request message, an\n   application SHOULD forward the request toward the origin server even\n   if it has a cached copy of what is being requested. This pragma\n   directive has the same semantics as the no-cache cache-directive (see\n   section 14.9) and is defined here for backward compatibility with\n   HTTP/1.0. Clients SHOULD include both header fields when a no-cache\n   request is sent to a server not known to be HTTP/1.1 compliant.\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 136]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Pragma directives MUST be passed through by a proxy or gateway\n   application, regardless of their significance to that application,\n   since the directives might be applicable to all recipients along the\n   request/response chain. It is not possible to specify a pragma for a\n   specific recipient; however, any pragma directive not relevant to a\n   recipient SHOULD be ignored by that recipient.\n\n   HTTP/1.1 caches SHOULD treat \"Pragma: no-cache\" as if the client had\n   sent \"Cache-Control: no-cache\". No new Pragma directives will be\n   defined in HTTP.\n\n      Note: because the meaning of \"Pragma: no-cache as a response\n      header field is not actually specified, it does not provide a\n      reliable replacement for \"Cache-Control: no-cache\" in a response\n\n14.33 Proxy-Authenticate\n\n   The Proxy-Authenticate response-header field MUST be included as part\n   of a 407 (Proxy Authentication Required) response. The field value\n   consists of a challenge that indicates the authentication scheme and\n   parameters applicable to the proxy for this Request-URI.\n\n       Proxy-Authenticate  = \"Proxy-Authenticate\" \":\" 1#challenge\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. Unlike\n   WWW-Authenticate, the Proxy-Authenticate header field applies only to\n   the current connection and SHOULD NOT be passed on to downstream\n   clients. However, an intermediate proxy might need to obtain its own\n   credentials by requesting them from the downstream client, which in\n   some circumstances will appear as if the proxy is forwarding the\n   Proxy-Authenticate header field.\n\n14.34 Proxy-Authorization"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_90",
        "original_index": 90,
        "content": "14.34 Proxy-Authorization\n\n   The Proxy-Authorization request-header field allows the client to\n   identify itself (or its user) to a proxy which requires\n   authentication. The Proxy-Authorization field value consists of\n   credentials containing the authentication information of the user\n   agent for the proxy and/or realm of the resource being requested.\n\n       Proxy-Authorization     = \"Proxy-Authorization\" \":\" credentials\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43] . Unlike\n   Authorization, the Proxy-Authorization header field applies only to\n   the next outbound proxy that demanded authentication using the Proxy-\n   Authenticate field. When multiple proxies are used in a chain, the\n\n\n\nFielding, et al.            Standards Track                   [Page 137]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Proxy-Authorization header field is consumed by the first outbound\n   proxy that was expecting to receive credentials. A proxy MAY relay\n   the credentials from the client request to the next proxy if that is\n   the mechanism by which the proxies cooperatively authenticate a given\n   request.\n\n14.35 Range\n\n14.35.1 Byte Ranges\n\n   Since all HTTP entities are represented in HTTP messages as sequences\n   of bytes, the concept of a byte range is meaningful for any HTTP\n   entity. (However, not all clients and servers need to support byte-\n   range operations.)\n\n   Byte range specifications in HTTP apply to the sequence of bytes in\n   the entity-body (not necessarily the same as the message-body).\n\n   A byte range operation MAY specify a single range of bytes, or a set\n   of ranges within a single entity.\n\n       ranges-specifier = byte-ranges-specifier\n       byte-ranges-specifier = bytes-unit \"=\" byte-range-set\n       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )\n       byte-range-spec = first-byte-pos \"-\" [last-byte-pos]\n       first-byte-pos  = 1*DIGIT\n       last-byte-pos   = 1*DIGIT\n\n   The first-byte-pos value in a byte-range-spec gives the byte-offset\n   of the first byte in a range. The last-byte-pos value gives the\n   byte-offset of the last byte in the range; that is, the byte\n   positions specified are inclusive. Byte offsets start at zero.\n\n   If the last-byte-pos value is present, it MUST be greater than or\n   equal to the first-byte-pos in that byte-range-spec, or the byte-\n   range-spec is syntactically invalid. The recipient of a byte-range-\n   set that includes one or more syntactically invalid byte-range-spec\n   values MUST ignore the header field that includes that byte-range-\n   set.\n\n   If the last-byte-pos value is absent, or if the value is greater than\n   or equal to the current length of the entity-body, last-byte-pos is\n   taken to be equal to one less than the current length of the entity-\n   body in bytes.\n\n   By its choice of last-byte-pos, a client can limit the number of\n   bytes retrieved without knowing the size of the entity.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 138]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       suffix-byte-range-spec = \"-\" suffix-length\n       suffix-length = 1*DIGIT\n\n   A suffix-byte-range-spec is used to specify the suffix of the\n   entity-body, of a length given by the suffix-length value. (That is,\n   this form specifies the last N bytes of an entity-body.) If the\n   entity is shorter than the specified suffix-length, the entire\n   entity-body is used."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_91",
        "original_index": 91,
        "content": "If a syntactically valid byte-range-set includes at least one byte-\n   range-spec whose first-byte-pos is less than the current length of\n   the entity-body, or at least one suffix-byte-range-spec with a non-\n   zero suffix-length, then the byte-range-set is satisfiable.\n   Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set\n   is unsatisfiable, the server SHOULD return a response with a status\n   of 416 (Requested range not satisfiable). Otherwise, the server\n   SHOULD return a response with a status of 206 (Partial Content)\n   containing the satisfiable ranges of the entity-body.\n\n   Examples of byte-ranges-specifier values (assuming an entity-body of\n   length 10000):\n\n      - The first 500 bytes (byte offsets 0-499, inclusive):  bytes=0-\n        499\n\n      - The second 500 bytes (byte offsets 500-999, inclusive):\n        bytes=500-999\n\n      - The final 500 bytes (byte offsets 9500-9999, inclusive):\n        bytes=-500\n\n      - Or bytes=9500-\n\n      - The first and last bytes only (bytes 0 and 9999):  bytes=0-0,-1\n\n      - Several legal but not canonical specifications of the second 500\n        bytes (byte offsets 500-999, inclusive):\n         bytes=500-600,601-999\n         bytes=500-700,601-999\n\n14.35.2 Range Retrieval Requests\n\n   HTTP retrieval requests using conditional or unconditional GET\n   methods MAY request one or more sub-ranges of the entity, instead of\n   the entire entity, using the Range request header, which applies to\n   the entity returned as the result of the request:\n\n      Range = \"Range\" \":\" ranges-specifier\n\n\n\nFielding, et al.            Standards Track                   [Page 139]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   A server MAY ignore the Range header. However, HTTP/1.1 origin\n   servers and intermediate caches ought to support byte ranges when\n   possible, since Range supports efficient recovery from partially\n   failed transfers, and supports efficient partial retrieval of large\n   entities.\n\n   If the server supports the Range header and the specified range or\n   ranges are appropriate for the entity:\n\n      - The presence of a Range header in an unconditional GET modifies\n        what is returned if the GET is otherwise successful. In other\n        words, the response carries a status code of 206 (Partial\n        Content) instead of 200 (OK).\n\n      - The presence of a Range header in a conditional GET (a request\n        using one or both of If-Modified-Since and If-None-Match, or\n        one or both of If-Unmodified-Since and If-Match) modifies what\n        is returned if the GET is otherwise successful and the\n        condition is true. It does not affect the 304 (Not Modified)\n        response returned if the conditional is false.\n\n   In some cases, it might be more appropriate to use the If-Range\n   header (see section 14.27) in addition to the Range header.\n\n   If a proxy that supports ranges receives a Range request, forwards\n   the request to an inbound server, and receives an entire entity in\n   reply, it SHOULD only return the requested range to its client. It\n   SHOULD store the entire received response in its cache if that is\n   consistent with its cache allocation policies.\n\n14.36 Referer\n\n   The Referer[sic] request-header field allows the client to specify,\n   for the server's benefit, the address (URI) of the resource from\n   which the Request-URI was obtained (the \"referrer\", although the\n   header field is misspelled.) The Referer request-header allows a\n   server to generate lists of back-links to resources for interest,\n   logging, optimized caching, etc. It also allows obsolete or mistyped\n   links to be traced for maintenance. The Referer field MUST NOT be\n   sent if the Request-URI was obtained from a source that does not have\n   its own URI, such as input from the user keyboard.\n\n       Referer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\n\n   Example:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_92",
        "original_index": 92,
        "content": "Referer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\n\n   Example:\n\n       Referer: http://www.w3.org/hypertext/DataSources/Overview.html\n\n\n\n\nFielding, et al.            Standards Track                   [Page 140]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If the field value is a relative URI, it SHOULD be interpreted\n   relative to the Request-URI. The URI MUST NOT include a fragment. See\n   section 15.1.3 for security considerations.\n\n14.37 Retry-After\n\n   The Retry-After response-header field can be used with a 503 (Service\n   Unavailable) response to indicate how long the service is expected to\n   be unavailable to the requesting client. This field MAY also be used\n   with any 3xx (Redirection) response to indicate the minimum time the\n   user-agent is asked wait before issuing the redirected request. The\n   value of this field can be either an HTTP-date or an integer number\n   of seconds (in decimal) after the time of the response.\n\n       Retry-After  = \"Retry-After\" \":\" ( HTTP-date | delta-seconds )\n\n   Two examples of its use are\n\n       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT\n       Retry-After: 120\n\n   In the latter example, the delay is 2 minutes.\n\n14.38 Server\n\n   The Server response-header field contains information about the\n   software used by the origin server to handle the request. The field\n   can contain multiple product tokens (section 3.8) and comments\n   identifying the server and any significant subproducts. The product\n   tokens are listed in order of their significance for identifying the\n   application.\n\n       Server         = \"Server\" \":\" 1*( product | comment )\n\n   Example:\n\n       Server: CERN/3.0 libwww/2.17\n\n   If the response is being forwarded through a proxy, the proxy\n   application MUST NOT modify the Server response-header. Instead, it\n   SHOULD include a Via field (as described in section 14.45).\n\n      Note: Revealing the specific software version of the server might\n      allow the server machine to become more vulnerable to attacks\n      against software that is known to contain security holes. Server\n      implementors are encouraged to make this field a configurable\n      option.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 141]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n14.39 TE\n\n   The TE request-header field indicates what extension transfer-codings\n   it is willing to accept in the response and whether or not it is\n   willing to accept trailer fields in a chunked transfer-coding. Its\n   value may consist of the keyword \"trailers\" and/or a comma-separated\n   list of extension transfer-coding names with optional accept\n   parameters (as described in section 3.6).\n\n       TE        = \"TE\" \":\" #( t-codings )\n       t-codings = \"trailers\" | ( transfer-extension [ accept-params ] )\n\n   The presence of the keyword \"trailers\" indicates that the client is\n   willing to accept trailer fields in a chunked transfer-coding, as\n   defined in section 3.6.1. This keyword is reserved for use with\n   transfer-coding values even though it does not itself represent a\n   transfer-coding.\n\n   Examples of its use are:\n\n       TE: deflate\n       TE:\n       TE: trailers, deflate;q=0.5\n\n   The TE header field only applies to the immediate connection.\n   Therefore, the keyword MUST be supplied within a Connection header\n   field (section 14.10) whenever TE is present in an HTTP/1.1 message.\n\n   A server tests whether a transfer-coding is acceptable, according to\n   a TE field, using these rules:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_93",
        "original_index": 93,
        "content": "A server tests whether a transfer-coding is acceptable, according to\n   a TE field, using these rules:\n\n      1. The \"chunked\" transfer-coding is always acceptable. If the\n         keyword \"trailers\" is listed, the client indicates that it is\n         willing to accept trailer fields in the chunked response on\n         behalf of itself and any downstream clients. The implication is\n         that, if given, the client is stating that either all\n         downstream clients are willing to accept trailer fields in the\n         forwarded response, or that it will attempt to buffer the\n         response on behalf of downstream recipients.\n\n         Note: HTTP/1.1 does not define any means to limit the size of a\n         chunked response such that a client can be assured of buffering\n         the entire response.\n\n      2. If the transfer-coding being tested is one of the transfer-\n         codings listed in the TE field, then it is acceptable unless it\n         is accompanied by a qvalue of 0. (As defined in section 3.9, a\n         qvalue of 0 means \"not acceptable.\")\n\n\n\nFielding, et al.            Standards Track                   [Page 142]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      3. If multiple transfer-codings are acceptable, then the\n         acceptable transfer-coding with the highest non-zero qvalue is\n         preferred.  The \"chunked\" transfer-coding always has a qvalue\n         of 1.\n\n   If the TE field-value is empty or if no TE field is present, the only\n   transfer-coding  is \"chunked\". A message with no transfer-coding is\n   always acceptable.\n\n14.40 Trailer\n\n   The Trailer general field value indicates that the given set of\n   header fields is present in the trailer of a message encoded with\n   chunked transfer-coding.\n\n       Trailer  = \"Trailer\" \":\" 1#field-name\n\n   An HTTP/1.1 message SHOULD include a Trailer header field in a\n   message using chunked transfer-coding with a non-empty trailer. Doing\n   so allows the recipient to know which header fields to expect in the\n   trailer.\n\n   If no Trailer header field is present, the trailer SHOULD NOT include\n   any header fields. See section 3.6.1 for restrictions on the use of\n   trailer fields in a \"chunked\" transfer-coding.\n\n   Message header fields listed in the Trailer header field MUST NOT\n   include the following header fields:\n\n      . Transfer-Encoding\n\n      . Content-Length\n\n      . Trailer\n\n14.41 Transfer-Encoding\n\n   The Transfer-Encoding general-header field indicates what (if any)\n   type of transformation has been applied to the message body in order\n   to safely transfer it between the sender and the recipient. This\n   differs from the content-coding in that the transfer-coding is a\n   property of the message, not of the entity.\n\n     Transfer-Encoding       = \"Transfer-Encoding\" \":\" 1#transfer-coding\n\n   Transfer-codings are defined in section 3.6. An example is:\n\n     Transfer-Encoding: chunked\n\n\n\nFielding, et al.            Standards Track                   [Page 143]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   If multiple encodings have been applied to an entity, the transfer-\n   codings MUST be listed in the order in which they were applied.\n   Additional information about the encoding parameters MAY be provided\n   by other entity-header fields not defined by this specification.\n\n   Many older HTTP/1.0 applications do not understand the Transfer-\n   Encoding header.\n\n14.42 Upgrade\n\n   The Upgrade general-header allows the client to specify what\n   additional communication protocols it supports and would like to use\n   if the server finds it appropriate to switch protocols. The server\n   MUST use the Upgrade header field within a 101 (Switching Protocols)\n   response to indicate which protocol(s) are being switched.\n\n       Upgrade        = \"Upgrade\" \":\" 1#product\n\n   For example,\n\n       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_94",
        "original_index": 94,
        "content": "Upgrade        = \"Upgrade\" \":\" 1#product\n\n   For example,\n\n       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\n\n   The Upgrade header field is intended to provide a simple mechanism\n   for transition from HTTP/1.1 to some other, incompatible protocol. It\n   does so by allowing the client to advertise its desire to use another\n   protocol, such as a later version of HTTP with a higher major version\n   number, even though the current request has been made using HTTP/1.1.\n   This eases the difficult transition between incompatible protocols by\n   allowing the client to initiate a request in the more commonly\n   supported protocol while indicating to the server that it would like\n   to use a \"better\" protocol if available (where \"better\" is determined\n   by the server, possibly according to the nature of the method and/or\n   resource being requested).\n\n   The Upgrade header field only applies to switching application-layer\n   protocols upon the existing transport-layer connection. Upgrade\n   cannot be used to insist on a protocol change; its acceptance and use\n   by the server is optional. The capabilities and nature of the\n   application-layer communication after the protocol change is entirely\n   dependent upon the new protocol chosen, although the first action\n   after changing the protocol MUST be a response to the initial HTTP\n   request containing the Upgrade header field.\n\n   The Upgrade header field only applies to the immediate connection.\n   Therefore, the upgrade keyword MUST be supplied within a Connection\n   header field (section 14.10) whenever Upgrade is present in an\n   HTTP/1.1 message.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 144]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Upgrade header field cannot be used to indicate a switch to a\n   protocol on a different connection. For that purpose, it is more\n   appropriate to use a 301, 302, 303, or 305 redirection response.\n\n   This specification only defines the protocol name \"HTTP\" for use by\n   the family of Hypertext Transfer Protocols, as defined by the HTTP\n   version rules of section 3.1 and future updates to this\n   specification. Any token can be used as a protocol name; however, it\n   will only be useful if both the client and server associate the name\n   with the same protocol.\n\n14.43 User-Agent\n\n   The User-Agent request-header field contains information about the\n   user agent originating the request. This is for statistical purposes,\n   the tracing of protocol violations, and automated recognition of user\n   agents for the sake of tailoring responses to avoid particular user\n   agent limitations. User agents SHOULD include this field with\n   requests. The field can contain multiple product tokens (section 3.8)\n   and comments identifying the agent and any subproducts which form a\n   significant part of the user agent. By convention, the product tokens\n   are listed in order of their significance for identifying the\n   application.\n\n       User-Agent     = \"User-Agent\" \":\" 1*( product | comment )\n\n   Example:\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n\n14.44 Vary\n\n   The Vary field value indicates the set of request-header fields that\n   fully determines, while the response is fresh, whether a cache is\n   permitted to use the response to reply to a subsequent request\n   without revalidation. For uncacheable or stale responses, the Vary\n   field value advises the user agent about the criteria that were used\n   to select the representation. A Vary field value of \"*\" implies that\n   a cache cannot determine from the request headers of a subsequent\n   request whether this response is the appropriate representation. See\n   section 13.6 for use of the Vary header field by caches.\n\n       Vary  = \"Vary\" \":\" ( \"*\" | 1#field-name )"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_95",
        "original_index": 95,
        "content": "Vary  = \"Vary\" \":\" ( \"*\" | 1#field-name )\n\n   An HTTP/1.1 server SHOULD include a Vary header field with any\n   cacheable response that is subject to server-driven negotiation.\n   Doing so allows a cache to properly interpret future requests on that\n   resource and informs the user agent about the presence of negotiation\n\n\n\nFielding, et al.            Standards Track                   [Page 145]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   on that resource. A server MAY include a Vary header field with a\n   non-cacheable response that is subject to server-driven negotiation,\n   since this might provide the user agent with useful information about\n   the dimensions over which the response varies at the time of the\n   response.\n\n   A Vary field value consisting of a list of field-names signals that\n   the representation selected for the response is based on a selection\n   algorithm which considers ONLY the listed request-header field values\n   in selecting the most appropriate representation. A cache MAY assume\n   that the same selection will be made for future requests with the\n   same values for the listed field names, for the duration of time for\n   which the response is fresh.\n\n   The field-names given are not limited to the set of standard\n   request-header fields defined by this specification. Field names are\n   case-insensitive.\n\n   A Vary field value of \"*\" signals that unspecified parameters not\n   limited to the request-headers (e.g., the network address of the\n   client), play a role in the selection of the response representation.\n   The \"*\" value MUST NOT be generated by a proxy server; it may only be\n   generated by an origin server.\n\n14.45  Via\n\n   The Via general-header field MUST be used by gateways and proxies to\n   indicate the intermediate protocols and recipients between the user\n   agent and the server on requests, and between the origin server and\n   the client on responses. It is analogous to the \"Received\" field of\n   RFC 822 [9] and is intended to be used for tracking message forwards,\n   avoiding request loops, and identifying the protocol capabilities of\n   all senders along the request/response chain.\n\n      Via =  \"Via\" \":\" 1#( received-protocol received-by [ comment ] )\n      received-protocol = [ protocol-name \"/\" ] protocol-version\n      protocol-name     = token\n      protocol-version  = token\n      received-by       = ( host [ \":\" port ] ) | pseudonym\n      pseudonym         = token\n\n   The received-protocol indicates the protocol version of the message\n   received by the server or client along each segment of the\n   request/response chain. The received-protocol version is appended to\n   the Via field value when the message is forwarded so that information\n   about the protocol capabilities of upstream applications remains\n   visible to all recipients.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 146]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The protocol-name is optional if and only if it would be \"HTTP\". The\n   received-by field is normally the host and optional port number of a\n   recipient server or client that subsequently forwarded the message.\n   However, if the real host is considered to be sensitive information,\n   it MAY be replaced by a pseudonym. If the port is not given, it MAY\n   be assumed to be the default port of the received-protocol.\n\n   Multiple Via field values represents each proxy or gateway that has\n   forwarded the message. Each recipient MUST append its information\n   such that the end result is ordered according to the sequence of\n   forwarding applications.\n\n   Comments MAY be used in the Via header field to identify the software\n   of the recipient proxy or gateway, analogous to the User-Agent and\n   Server header fields. However, all comments in the Via field are\n   optional and MAY be removed by any recipient prior to forwarding the\n   message."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_96",
        "original_index": 96,
        "content": "For example, a request message could be sent from an HTTP/1.0 user\n   agent to an internal proxy code-named \"fred\", which uses HTTP/1.1 to\n   forward the request to a public proxy at nowhere.com, which completes\n   the request by forwarding it to the origin server at www.ics.uci.edu.\n   The request received by www.ics.uci.edu would then have the following\n   Via header field:\n\n       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\n\n   Proxies and gateways used as a portal through a network firewall\n   SHOULD NOT, by default, forward the names and ports of hosts within\n   the firewall region. This information SHOULD only be propagated if\n   explicitly enabled. If not enabled, the received-by host of any host\n   behind the firewall SHOULD be replaced by an appropriate pseudonym\n   for that host.\n\n   For organizations that have strong privacy requirements for hiding\n   internal structures, a proxy MAY combine an ordered subsequence of\n   Via header field entries with identical received-protocol values into\n   a single such entry. For example,\n\n       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy\n\n        could be collapsed to\n\n       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 147]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Applications SHOULD NOT combine multiple entries unless they are all\n   under the same organizational control and the hosts have already been\n   replaced by pseudonyms. Applications MUST NOT combine entries which\n   have different received-protocol values.\n\n14.46 Warning\n\n   The Warning general-header field is used to carry additional\n   information about the status or transformation of a message which\n   might not be reflected in the message. This information is typically\n   used to warn about a possible lack of semantic transparency from\n   caching operations or transformations applied to the entity body of\n   the message.\n\n   Warning headers are sent with responses using:\n\n       Warning    = \"Warning\" \":\" 1#warning-value\n\n       warning-value = warn-code SP warn-agent SP warn-text\n                                             [SP warn-date]\n\n       warn-code  = 3DIGIT\n       warn-agent = ( host [ \":\" port ] ) | pseudonym\n                       ; the name or pseudonym of the server adding\n                       ; the Warning header, for use in debugging\n       warn-text  = quoted-string\n       warn-date  = <\"> HTTP-date <\">\n\n   A response MAY carry more than one Warning header.\n\n   The warn-text SHOULD be in a natural language and character set that\n   is most likely to be intelligible to the human user receiving the\n   response. This decision MAY be based on any available knowledge, such\n   as the location of the cache or user, the Accept-Language field in a\n   request, the Content-Language field in a response, etc. The default\n   language is English and the default character set is ISO-8859-1.\n\n   If a character set other than ISO-8859-1 is used, it MUST be encoded\n   in the warn-text using the method described in RFC 2047 [14].\n\n   Warning headers can in general be applied to any message, however\n   some specific warn-codes are specific to caches and can only be\n   applied to response messages. New Warning headers SHOULD be added\n   after any existing Warning headers. A cache MUST NOT delete any\n   Warning header that it received with a message. However, if a cache\n   successfully validates a cache entry, it SHOULD remove any Warning\n   headers previously attached to that entry except as specified for\n\n\n\n\nFielding, et al.            Standards Track                   [Page 148]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   specific Warning codes. It MUST then add any Warning headers received\n   in the validating response. In other words, Warning headers are those\n   that would be attached to the most recent relevant response."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_97",
        "original_index": 97,
        "content": "When multiple Warning headers are attached to a response, the user\n   agent ought to inform the user of as many of them as possible, in the\n   order that they appear in the response. If it is not possible to\n   inform the user of all of the warnings, the user agent SHOULD follow\n   these heuristics:\n\n      - Warnings that appear early in the response take priority over\n        those appearing later in the response.\n\n      - Warnings in the user's preferred character set take priority\n        over warnings in other character sets but with identical warn-\n        codes and warn-agents.\n\n   Systems that generate multiple Warning headers SHOULD order them with\n   this user agent behavior in mind.\n\n   Requirements for the behavior of caches with respect to Warnings are\n   stated in section 13.1.2.\n\n   This is a list of the currently-defined warn-codes, each with a\n   recommended warn-text in English, and a description of its meaning.\n\n   110 Response is stale\n     MUST be included whenever the returned response is stale.\n\n   111 Revalidation failed\n     MUST be included if a cache returns a stale response because an\n     attempt to revalidate the response failed, due to an inability to\n     reach the server.\n\n   112 Disconnected operation\n     SHOULD be included if the cache is intentionally disconnected from\n     the rest of the network for a period of time.\n\n   113 Heuristic expiration\n     MUST be included if the cache heuristically chose a freshness\n     lifetime greater than 24 hours and the response's age is greater\n     than 24 hours.\n\n   199 Miscellaneous warning\n     The warning text MAY include arbitrary information to be presented\n     to a human user, or logged. A system receiving this warning MUST\n     NOT take any automated action, besides presenting the warning to\n     the user.\n\n\n\nFielding, et al.            Standards Track                   [Page 149]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   214 Transformation applied\n     MUST be added by an intermediate cache or proxy if it applies any\n     transformation changing the content-coding (as specified in the\n     Content-Encoding header) or media-type (as specified in the\n     Content-Type header) of the response, or the entity-body of the\n     response, unless this Warning code already appears in the response.\n\n   299 Miscellaneous persistent warning\n     The warning text MAY include arbitrary information to be presented\n     to a human user, or logged. A system receiving this warning MUST\n     NOT take any automated action.\n\n   If an implementation sends a message with one or more Warning headers\n   whose version is HTTP/1.0 or lower, then the sender MUST include in\n   each warning-value a warn-date that matches the date in the response.\n\n   If an implementation receives a message with a warning-value that\n   includes a warn-date, and that warn-date is different from the Date\n   value in the response, then that warning-value MUST be deleted from\n   the message before storing, forwarding, or using it. (This prevents\n   bad consequences of naive caching of Warning header fields.) If all\n   of the warning-values are deleted for this reason, the Warning header\n   MUST be deleted as well.\n\n14.47 WWW-Authenticate\n\n   The WWW-Authenticate response-header field MUST be included in 401\n   (Unauthorized) response messages. The field value consists of at\n   least one challenge that indicates the authentication scheme(s) and\n   parameters applicable to the Request-URI.\n\n       WWW-Authenticate  = \"WWW-Authenticate\" \":\" 1#challenge"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_98",
        "original_index": 98,
        "content": "WWW-Authenticate  = \"WWW-Authenticate\" \":\" 1#challenge\n\n   The HTTP access authentication process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. User\n   agents are advised to take special care in parsing the WWW-\n   Authenticate field value as it might contain more than one challenge,\n   or if more than one WWW-Authenticate header field is provided, the\n   contents of a challenge itself can contain a comma-separated list of\n   authentication parameters.\n\n15 Security Considerations\n\n   This section is meant to inform application developers, information\n   providers, and users of the security limitations in HTTP/1.1 as\n   described by this document. The discussion does not include\n   definitive solutions to the problems revealed, though it does make\n   some suggestions for reducing security risks.\n\n\n\nFielding, et al.            Standards Track                   [Page 150]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.1 Personal Information\n\n   HTTP clients are often privy to large amounts of personal information\n   (e.g. the user's name, location, mail address, passwords, encryption\n   keys, etc.), and SHOULD be very careful to prevent unintentional\n   leakage of this information via the HTTP protocol to other sources.\n   We very strongly recommend that a convenient interface be provided\n   for the user to control dissemination of such information, and that\n   designers and implementors be particularly careful in this area.\n   History shows that errors in this area often create serious security\n   and/or privacy problems and generate highly adverse publicity for the\n   implementor's company.\n\n15.1.1 Abuse of Server Log Information\n\n   A server is in the position to save personal data about a user's\n   requests which might identify their reading patterns or subjects of\n   interest. This information is clearly confidential in nature and its\n   handling can be constrained by law in certain countries. People using\n   the HTTP protocol to provide data are responsible for ensuring that\n   such material is not distributed without the permission of any\n   individuals that are identifiable by the published results.\n\n15.1.2 Transfer of Sensitive Information\n\n   Like any generic data transfer protocol, HTTP cannot regulate the\n   content of the data that is transferred, nor is there any a priori\n   method of determining the sensitivity of any particular piece of\n   information within the context of any given request. Therefore,\n   applications SHOULD supply as much control over this information as\n   possible to the provider of that information. Four header fields are\n   worth special mention in this context: Server, Via, Referer and From.\n\n   Revealing the specific software version of the server might allow the\n   server machine to become more vulnerable to attacks against software\n   that is known to contain security holes. Implementors SHOULD make the\n   Server header field a configurable option.\n\n   Proxies which serve as a portal through a network firewall SHOULD\n   take special precautions regarding the transfer of header information\n   that identifies the hosts behind the firewall. In particular, they\n   SHOULD remove, or replace with sanitized versions, any Via fields\n   generated behind the firewall.\n\n   The Referer header allows reading patterns to be studied and reverse\n   links drawn. Although it can be very useful, its power can be abused\n   if user details are not separated from the information contained in\n\n\n\n\nFielding, et al.            Standards Track                   [Page 151]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   the Referer. Even when the personal information has been removed, the\n   Referer header might indicate a private document's URI whose\n   publication would be inappropriate."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_99",
        "original_index": 99,
        "content": "the Referer. Even when the personal information has been removed, the\n   Referer header might indicate a private document's URI whose\n   publication would be inappropriate.\n\n   The information sent in the From field might conflict with the user's\n   privacy interests or their site's security policy, and hence it\n   SHOULD NOT be transmitted without the user being able to disable,\n   enable, and modify the contents of the field. The user MUST be able\n   to set the contents of this field within a user preference or\n   application defaults configuration.\n\n   We suggest, though do not require, that a convenient toggle interface\n   be provided for the user to enable or disable the sending of From and\n   Referer information.\n\n   The User-Agent (section 14.43) or Server (section 14.38) header\n   fields can sometimes be used to determine that a specific client or\n   server have a particular security hole which might be exploited.\n   Unfortunately, this same information is often used for other valuable\n   purposes for which HTTP currently has no better mechanism.\n\n15.1.3 Encoding Sensitive Information in URI's\n\n   Because the source of a link might be private information or might\n   reveal an otherwise private information source, it is strongly\n   recommended that the user be able to select whether or not the\n   Referer field is sent. For example, a browser client could have a\n   toggle switch for browsing openly/anonymously, which would\n   respectively enable/disable the sending of Referer and From\n   information.\n\n   Clients SHOULD NOT include a Referer header field in a (non-secure)\n   HTTP request if the referring page was transferred with a secure\n   protocol.\n\n   Authors of services which use the HTTP protocol SHOULD NOT use GET\n   based forms for the submission of sensitive data, because this will\n   cause this data to be encoded in the Request-URI. Many existing\n   servers, proxies, and user agents will log the request URI in some\n   place where it might be visible to third parties. Servers can use\n   POST-based form submission instead\n\n15.1.4 Privacy Issues Connected to Accept Headers\n\n   Accept request-headers can reveal information about the user to all\n   servers which are accessed. The Accept-Language header in particular\n   can reveal information the user would consider to be of a private\n   nature, because the understanding of particular languages is often\n\n\n\nFielding, et al.            Standards Track                   [Page 152]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   strongly correlated to the membership of a particular ethnic group.\n   User agents which offer the option to configure the contents of an\n   Accept-Language header to be sent in every request are strongly\n   encouraged to let the configuration process include a message which\n   makes the user aware of the loss of privacy involved.\n\n   An approach that limits the loss of privacy would be for a user agent\n   to omit the sending of Accept-Language headers by default, and to ask\n   the user whether or not to start sending Accept-Language headers to a\n   server if it detects, by looking for any Vary response-header fields\n   generated by the server, that such sending could improve the quality\n   of service."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_100",
        "original_index": 100,
        "content": "Elaborate user-customized accept header fields sent in every request,\n   in particular if these include quality values, can be used by servers\n   as relatively reliable and long-lived user identifiers. Such user\n   identifiers would allow content providers to do click-trail tracking,\n   and would allow collaborating content providers to match cross-server\n   click-trails or form submissions of individual users. Note that for\n   many users not behind a proxy, the network address of the host\n   running the user agent will also serve as a long-lived user\n   identifier. In environments where proxies are used to enhance\n   privacy, user agents ought to be conservative in offering accept\n   header configuration options to end users. As an extreme privacy\n   measure, proxies could filter the accept headers in relayed requests.\n   General purpose user agents which provide a high degree of header\n   configurability SHOULD warn users about the loss of privacy which can\n   be involved.\n\n15.2 Attacks Based On File and Path Names\n\n   Implementations of HTTP origin servers SHOULD be careful to restrict\n   the documents returned by HTTP requests to be only those that were\n   intended by the server administrators. If an HTTP server translates\n   HTTP URIs directly into file system calls, the server MUST take\n   special care not to serve files that were not intended to be\n   delivered to HTTP clients. For example, UNIX, Microsoft Windows, and\n   other operating systems use \"..\" as a path component to indicate a\n   directory level above the current one. On such a system, an HTTP\n   server MUST disallow any such construct in the Request-URI if it\n   would otherwise allow access to a resource outside those intended to\n   be accessible via the HTTP server. Similarly, files intended for\n   reference only internally to the server (such as access control\n   files, configuration files, and script code) MUST be protected from\n   inappropriate retrieval, since they might contain sensitive\n   information. Experience has shown that minor bugs in such HTTP server\n   implementations have turned into security risks.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 153]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.3 DNS Spoofing\n\n   Clients using HTTP rely heavily on the Domain Name Service, and are\n   thus generally prone to security attacks based on the deliberate\n   mis-association of IP addresses and DNS names. Clients need to be\n   cautious in assuming the continuing validity of an IP number/DNS name\n   association.\n\n   In particular, HTTP clients SHOULD rely on their name resolver for\n   confirmation of an IP number/DNS name association, rather than\n   caching the result of previous host name lookups. Many platforms\n   already can cache host name lookups locally when appropriate, and\n   they SHOULD be configured to do so. It is proper for these lookups to\n   be cached, however, only when the TTL (Time To Live) information\n   reported by the name server makes it likely that the cached\n   information will remain useful.\n\n   If HTTP clients cache the results of host name lookups in order to\n   achieve a performance improvement, they MUST observe the TTL\n   information reported by DNS.\n\n   If HTTP clients do not observe this rule, they could be spoofed when\n   a previously-accessed server's IP address changes. As network\n   renumbering is expected to become increasingly common [24], the\n   possibility of this form of attack will grow. Observing this\n   requirement thus reduces this potential security vulnerability.\n\n   This requirement also improves the load-balancing behavior of clients\n   for replicated servers using the same DNS name and reduces the\n   likelihood of a user's experiencing failure in accessing sites which\n   use that strategy.\n\n15.4 Location Headers and Spoofing"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_101",
        "original_index": 101,
        "content": "15.4 Location Headers and Spoofing\n\n   If a single server supports multiple organizations that do not trust\n   one another, then it MUST check the values of Location and Content-\n   Location headers in responses that are generated under control of\n   said organizations to make sure that they do not attempt to\n   invalidate resources over which they have no authority.\n\n15.5 Content-Disposition Issues\n\n   RFC 1806 [35], from which the often implemented Content-Disposition\n   (see section 19.5.1) header in HTTP is derived, has a number of very\n   serious security considerations. Content-Disposition is not part of\n   the HTTP standard, but since it is widely implemented, we are\n   documenting its use and risks for implementors. See RFC 2183 [49]\n   (which updates RFC 1806) for details.\n\n\n\nFielding, et al.            Standards Track                   [Page 154]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n15.6 Authentication Credentials and Idle Clients\n\n   Existing HTTP clients and user agents typically retain authentication\n   information indefinitely. HTTP/1.1. does not provide a method for a\n   server to direct clients to discard these cached credentials. This is\n   a significant defect that requires further extensions to HTTP.\n   Circumstances under which credential caching can interfere with the\n   application's security model include but are not limited to:\n\n      - Clients which have been idle for an extended period following\n        which the server might wish to cause the client to reprompt the\n        user for credentials.\n\n      - Applications which include a session termination indication\n        (such as a `logout' or `commit' button on a page) after which\n        the server side of the application `knows' that there is no\n        further reason for the client to retain the credentials.\n\n   This is currently under separate study. There are a number of work-\n   arounds to parts of this problem, and we encourage the use of\n   password protection in screen savers, idle time-outs, and other\n   methods which mitigate the security problems inherent in this\n   problem. In particular, user agents which cache credentials are\n   encouraged to provide a readily accessible mechanism for discarding\n   cached credentials under user control.\n\n15.7 Proxies and Caching\n\n   By their very nature, HTTP proxies are men-in-the-middle, and\n   represent an opportunity for man-in-the-middle attacks. Compromise of\n   the systems on which the proxies run can result in serious security\n   and privacy problems. Proxies have access to security-related\n   information, personal information about individual users and\n   organizations, and proprietary information belonging to users and\n   content providers. A compromised proxy, or a proxy implemented or\n   configured without regard to security and privacy considerations,\n   might be used in the commission of a wide range of potential attacks.\n\n   Proxy operators should protect the systems on which proxies run as\n   they would protect any system that contains or transports sensitive\n   information. In particular, log information gathered at proxies often\n   contains highly sensitive personal information, and/or information\n   about organizations. Log information should be carefully guarded, and\n   appropriate guidelines for use developed and followed. (Section\n   15.1.1).\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 155]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Caching proxies provide additional potential vulnerabilities, since\n   the contents of the cache represent an attractive target for\n   malicious exploitation. Because cache contents persist after an HTTP\n   request is complete, an attack on the cache can reveal information\n   long after a user believes that the information has been removed from\n   the network. Therefore, cache contents should be protected as\n   sensitive information."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_102",
        "original_index": 102,
        "content": "Proxy implementors should consider the privacy and security\n   implications of their design and coding decisions, and of the\n   configuration options they provide to proxy operators (especially the\n   default configuration).\n\n   Users of a proxy need to be aware that they are no trustworthier than\n   the people who run the proxy; HTTP itself cannot solve this problem.\n\n   The judicious use of cryptography, when appropriate, may suffice to\n   protect against a broad range of security and privacy attacks. Such\n   cryptography is beyond the scope of the HTTP/1.1 specification.\n\n15.7.1 Denial of Service Attacks on Proxies\n\n   They exist. They are hard to defend against. Research continues.\n   Beware.\n\n16 Acknowledgments\n\n   This specification makes heavy use of the augmented BNF and generic\n   constructs defined by David H. Crocker for RFC 822 [9]. Similarly, it\n   reuses many of the definitions provided by Nathaniel Borenstein and\n   Ned Freed for MIME [7]. We hope that their inclusion in this\n   specification will help reduce past confusion over the relationship\n   between HTTP and Internet mail message formats.\n\n   The HTTP protocol has evolved considerably over the years. It has\n   benefited from a large and active developer community--the many\n   people who have participated on the www-talk mailing list--and it is\n   that community which has been most responsible for the success of\n   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert\n   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois\n   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob\n   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc\n   VanHeyningen deserve special recognition for their efforts in\n   defining early aspects of the protocol.\n\n   This document has benefited greatly from the comments of all those\n   participating in the HTTP-WG. In addition to those already mentioned,\n   the following individuals have contributed to this specification:\n\n\n\nFielding, et al.            Standards Track                   [Page 156]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n       Gary Adams                  Ross Patterson\n       Harald Tveit Alvestrand     Albert Lunde\n       Keith Ball                  John C. Mallery\n       Brian Behlendorf            Jean-Philippe Martin-Flatin\n       Paul Burchard               Mitra\n       Maurizio Codogno            David Morris\n       Mike Cowlishaw              Gavin Nicol\n       Roman Czyborra              Bill Perry\n       Michael A. Dolan            Jeffrey Perry\n       David J. Fiander            Scott Powers\n       Alan Freier                 Owen Rees\n       Marc Hedlund                Luigi Rizzo\n       Greg Herlihy                David Robinson\n       Koen Holtman                Marc Salomon\n       Alex Hopmann                Rich Salz\n       Bob Jernigan                Allan M. Schiffman\n       Shel Kaphan                 Jim Seidman\n       Rohit Khare                 Chuck Shotton\n       John Klensin                Eric W. Sink\n       Martijn Koster              Simon E. Spero\n       Alexei Kosut                Richard N. Taylor\n       David M. Kristol            Robert S. Thau\n       Daniel LaLiberte            Bill (BearHeart) Weinman\n       Ben Laurie                  Francois Yergeau\n       Paul J. Leach               Mary Ellen Zurko\n       Daniel DuBois               Josh Cohen\n\n\n   Much of the content and presentation of the caching design is due to\n   suggestions and comments from individuals including: Shel Kaphan,\n   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.\n\n   Most of the specification of ranges is based on work originally done\n   by Ari Luotonen and John Franks, with additional input from Steve\n   Zilles.\n\n   Thanks to the \"cave men\" of Palo Alto. You know who you are."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_103",
        "original_index": 103,
        "content": "Thanks to the \"cave men\" of Palo Alto. You know who you are.\n\n   Jim Gettys (the current editor of this document) wishes particularly\n   to thank Roy Fielding, the previous editor of this document, along\n   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen\n   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and\n   Larry Masinter for their help. And thanks go particularly to Jeff\n   Mogul and Scott Lawrence for performing the \"MUST/MAY/SHOULD\" audit.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 157]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik\n   Frystyk implemented RFC 2068 early, and we wish to thank them for the\n   discovery of many of the problems that this document attempts to\n   rectify.\n\n17 References\n\n   [1] Alvestrand, H., \"Tags for the Identification of Languages\", RFC\n       1766, March 1995.\n\n   [2] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,\n       D. and B. Alberti, \"The Internet Gopher Protocol (a distributed\n       document search and retrieval protocol)\", RFC 1436, March 1993.\n\n   [3] Berners-Lee, T., \"Universal Resource Identifiers in WWW\", RFC\n       1630, June 1994.\n\n   [4] Berners-Lee, T., Masinter, L. and M. McCahill, \"Uniform Resource\n       Locators (URL)\", RFC 1738, December 1994.\n\n   [5] Berners-Lee, T. and D. Connolly, \"Hypertext Markup Language -\n       2.0\", RFC 1866, November 1995.\n\n   [6] Berners-Lee, T., Fielding, R. and H. Frystyk, \"Hypertext Transfer\n       Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n\n   [7] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n       Extensions (MIME) Part One: Format of Internet Message Bodies\",\n       RFC 2045, November 1996.\n\n   [8] Braden, R., \"Requirements for Internet Hosts -- Communication\n       Layers\", STD 3, RFC 1123, October 1989.\n\n   [9] Crocker, D., \"Standard for The Format of ARPA Internet Text\n       Messages\", STD 11, RFC 822, August 1982.\n\n   [10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,\n        Sui, J., and M. Grinbaum, \"WAIS Interface Protocol Prototype\n        Functional Specification,\" (v1.5), Thinking Machines\n        Corporation, April 1990.\n\n   [11] Fielding, R., \"Relative Uniform Resource Locators\", RFC 1808,\n        June 1995.\n\n   [12] Horton, M. and R. Adams, \"Standard for Interchange of USENET\n        Messages\", RFC 1036, December 1987.\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 158]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [13] Kantor, B. and P. Lapsley, \"Network News Transfer Protocol\", RFC\n        977, February 1986.\n\n   [14] Moore, K., \"MIME (Multipurpose Internet Mail Extensions) Part\n        Three: Message Header Extensions for Non-ASCII Text\", RFC 2047,\n        November 1996.\n\n   [15] Nebel, E. and L. Masinter, \"Form-based File Upload in HTML\", RFC\n        1867, November 1995.\n\n   [16] Postel, J., \"Simple Mail Transfer Protocol\", STD 10, RFC 821,\n        August 1982.\n\n   [17] Postel, J., \"Media Type Registration Procedure\", RFC 1590,\n        November 1996.\n\n   [18] Postel, J. and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC\n        959, October 1985.\n\n   [19] Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700,\n        October 1994.\n\n   [20] Sollins, K. and L. Masinter, \"Functional Requirements for\n        Uniform Resource Names\", RFC 1737, December 1994.\n\n   [21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for\n        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_104",
        "original_index": 104,
        "content": "[21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for\n        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.\n\n   [22] ISO-8859. International Standard -- Information Processing --\n        8-bit Single-Byte Coded Graphic Character Sets --\n        Part 1: Latin alphabet No. 1, ISO-8859-1:1987.\n        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.\n        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.\n        Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.\n        Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.\n        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.\n        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.\n        Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.\n        Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.\n\n   [23] Meyers, J. and M. Rose, \"The Content-MD5 Header Field\", RFC\n        1864, October 1995.\n\n   [24] Carpenter, B. and Y. Rekhter, \"Renumbering Needs Work\", RFC\n        1900, February 1996.\n\n   [25] Deutsch, P., \"GZIP file format specification version 4.3\", RFC\n        1952, May 1996.\n\n\n\nFielding, et al.            Standards Track                   [Page 159]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [26] Venkata N. Padmanabhan, and Jeffrey C. Mogul. \"Improving HTTP\n        Latency\", Computer Networks and ISDN Systems, v. 28, pp. 25-35,\n        Dec. 1995. Slightly revised version of paper in Proc. 2nd\n        International WWW Conference '94: Mosaic and the Web, Oct. 1994,\n        which is available at\n        http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat\n        ency.html.\n\n   [27] Joe Touch, John Heidemann, and Katia Obraczka. \"Analysis of HTTP\n        Performance\", <URL: http://www.isi.edu/touch/pubs/http-perf96/>,\n        ISI Research Report ISI/RR-98-463, (original report dated Aug.\n        1996), USC/Information Sciences Institute, August 1998.\n\n   [28] Mills, D., \"Network Time Protocol (Version 3) Specification,\n        Implementation and Analysis\", RFC 1305, March 1992.\n\n   [29] Deutsch, P., \"DEFLATE Compressed Data Format Specification\n        version 1.3\", RFC 1951, May 1996.\n\n   [30] S. Spero, \"Analysis of HTTP Performance Problems,\"\n        http://sunsite.unc.edu/mdma-release/http-prob.html.\n\n   [31] Deutsch, P. and J. Gailly, \"ZLIB Compressed Data Format\n        Specification version 3.3\", RFC 1950, May 1996.\n\n   [32] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,\n        Luotonen, A., Sink, E. and L. Stewart, \"An Extension to HTTP:\n        Digest Access Authentication\", RFC 2069, January 1997.\n\n   [33] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T.\n        Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC\n        2068, January 1997.\n\n   [34] Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n\n   [35] Troost, R. and Dorner, S., \"Communicating Presentation\n        Information in Internet Messages: The Content-Disposition\n        Header\", RFC 1806, June 1995.\n\n   [36] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, \"Use and\n        Interpretation of HTTP Version Numbers\", RFC 2145, May 1997.\n        [jg639]\n\n   [37] Palme, J., \"Common Internet Message Headers\", RFC 2076, February\n        1997. [jg640]\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 160]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   [38] Yergeau, F., \"UTF-8, a transformation format of Unicode and\n        ISO-10646\", RFC 2279, January 1998. [jg641]\n\n   [39] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E.,\n        Lie, H., and C. Lilley. \"Network Performance Effects of\n        HTTP/1.1, CSS1, and PNG,\" Proceedings of ACM SIGCOMM '97, Cannes\n        France, September 1997.[jg642]\n\n   [40] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Two: Media Types\", RFC 2046, November\n        1996. [jg643]"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_105",
        "original_index": 105,
        "content": "[40] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Two: Media Types\", RFC 2046, November\n        1996. [jg643]\n\n   [41] Alvestrand, H., \"IETF Policy on Character Sets and Languages\",\n        BCP 18, RFC 2277, January 1998. [jg644]\n\n   [42] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource\n        Identifiers (URI): Generic Syntax and Semantics\", RFC 2396,\n        August 1998. [jg645]\n\n   [43] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n        Leach, P., Luotonen, A., Sink, E. and L. Stewart, \"HTTP\n        Authentication: Basic and Digest Access Authentication\", RFC\n        2617, June 1999. [jg646]\n\n   [44] Luotonen, A., \"Tunneling TCP based protocols through Web proxy\n        servers,\" Work in Progress. [jg647]\n\n   [45] Palme, J. and A. Hopmann, \"MIME E-mail Encapsulation of\n        Aggregate Documents, such as HTML (MHTML)\", RFC 2110, March\n        1997.\n\n   [46] Bradner, S., \"The Internet Standards Process -- Revision 3\", BCP\n        9, RFC 2026, October 1996.\n\n   [47] Masinter, L., \"Hyper Text Coffee Pot Control Protocol\n        (HTCPCP/1.0)\", RFC 2324, 1 April 1998.\n\n   [48] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions (MIME) Part Five: Conformance Criteria and Examples\",\n        RFC 2049, November 1996.\n\n   [49] Troost, R., Dorner, S. and K. Moore, \"Communicating Presentation\n        Information in Internet Messages: The Content-Disposition Header\n        Field\", RFC 2183, August 1997.\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 161]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n18 Authors' Addresses\n\n   Roy T. Fielding\n   Information and Computer Science\n   University of California, Irvine\n   Irvine, CA 92697-3425, USA\n\n   Fax: +1 (949) 824-1715\n   EMail: fielding@ics.uci.edu\n\n\n   James Gettys\n   World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: jg@w3.org\n\n\n   Jeffrey C. Mogul\n   Western Research Laboratory\n   Compaq Computer Corporation\n   250 University Avenue\n   Palo Alto, California, 94305, USA\n\n   EMail: mogul@wrl.dec.com\n\n\n   Henrik Frystyk Nielsen\n   World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: frystyk@w3.org\n\n\n   Larry Masinter\n   Xerox Corporation\n   3333 Coyote Hill Road\n   Palo Alto, CA 94034, USA\n\n   EMail: masinter@parc.xerox.com\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 162]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Paul J. Leach\n   Microsoft Corporation\n   1 Microsoft Way\n   Redmond, WA 98052, USA\n\n   EMail: paulle@microsoft.com\n\n\n   Tim Berners-Lee\n   Director, World Wide Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\n   Fax: +1 (617) 258 8682\n   EMail: timbl@w3.org\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 163]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n19 Appendices\n\n19.1 Internet Media Type message/http and application/http\n\n   In addition to defining the HTTP/1.1 protocol, this document serves\n   as the specification for the Internet media type \"message/http\" and\n   \"application/http\". The message/http type can be used to enclose a\n   single HTTP request or response message, provided that it obeys the\n   MIME restrictions for all \"message\" types regarding line length and\n   encodings. The application/http type can be used to enclose a\n   pipeline of one or more HTTP request or response messages (not\n   intermixed). The following is to be registered with IANA [17]."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_106",
        "original_index": 106,
        "content": "Media Type name:         message\n       Media subtype name:      http\n       Required parameters:     none\n       Optional parameters:     version, msgtype\n        version: The HTTP-Version number of the enclosed message\n                 (e.g., \"1.1\"). If not present, the version can be\n                 determined from the first line of the body.\n        msgtype: The message type -- \"request\" or \"response\". If not\n                 present, the type can be determined from the first\n                 line of the body.\n       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                                permitted\n       Security considerations: none\n\n       Media Type name:         application\n       Media subtype name:      http\n       Required parameters:     none\n       Optional parameters:     version, msgtype\n        version: The HTTP-Version number of the enclosed messages\n                 (e.g., \"1.1\"). If not present, the version can be\n                 determined from the first line of the body.\n        msgtype: The message type -- \"request\" or \"response\". If not\n                 present, the type can be determined from the first\n                 line of the body.\n       Encoding considerations: HTTP messages enclosed by this type\n                 are in \"binary\" format; use of an appropriate\n                 Content-Transfer-Encoding is required when\n                 transmitted via E-mail.\n       Security considerations: none\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 164]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n19.2 Internet Media Type multipart/byteranges\n\n   When an HTTP 206 (Partial Content) response message includes the\n   content of multiple ranges (a response to a request for multiple\n   non-overlapping ranges), these are transmitted as a multipart\n   message-body. The media type for this purpose is called\n   \"multipart/byteranges\".\n\n   The multipart/byteranges media type includes two or more parts, each\n   with its own Content-Type and Content-Range fields. The required\n   boundary parameter specifies the boundary string used to separate\n   each body-part.\n\n       Media Type name:         multipart\n       Media subtype name:      byteranges\n       Required parameters:     boundary\n       Optional parameters:     none\n       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                                permitted\n       Security considerations: none\n\n\n   For example:\n\n   HTTP/1.1 206 Partial Content\n   Date: Wed, 15 Nov 1995 06:25:24 GMT\n   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n\n   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n   Content-range: bytes 500-999/8000\n\n   ...the first range...\n   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n   Content-range: bytes 7000-7999/8000\n\n   ...the second range\n   --THIS_STRING_SEPARATES--\n\n      Notes:\n\n      1) Additional CRLFs may precede the first boundary string in the\n         entity.\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 165]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      2) Although RFC 2046 [40] permits the boundary string to be\n         quoted, some existing implementations handle a quoted boundary\n         string incorrectly.\n\n      3) A number of browsers and servers were coded to an early draft\n         of the byteranges specification to use a media type of\n         multipart/x-byteranges, which is almost, but not quite\n         compatible with the version documented in HTTP/1.1.\n\n19.3 Tolerant Applications"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_107",
        "original_index": 107,
        "content": "19.3 Tolerant Applications\n\n   Although this document specifies the requirements for the generation\n   of HTTP/1.1 messages, not all applications will be correct in their\n   implementation. We therefore recommend that operational applications\n   be tolerant of deviations whenever those deviations can be\n   interpreted unambiguously.\n\n   Clients SHOULD be tolerant in parsing the Status-Line and servers\n   tolerant when parsing the Request-Line. In particular, they SHOULD\n   accept any amount of SP or HT characters between fields, even though\n   only a single SP is required.\n\n   The line terminator for message-header fields is the sequence CRLF.\n   However, we recommend that applications, when parsing such headers,\n   recognize a single LF as a line terminator and ignore the leading CR.\n\n   The character set of an entity-body SHOULD be labeled as the lowest\n   common denominator of the character codes used within that body, with\n   the exception that not labeling the entity is preferred over labeling\n   the entity with the labels US-ASCII or ISO-8859-1. See section 3.7.1\n   and 3.4.1.\n\n   Additional rules for requirements on parsing and encoding of dates\n   and other potential problems with date encodings include:\n\n      - HTTP/1.1 clients and caches SHOULD assume that an RFC-850 date\n        which appears to be more than 50 years in the future is in fact\n        in the past (this helps solve the \"year 2000\" problem).\n\n      - An HTTP/1.1 implementation MAY internally represent a parsed\n        Expires date as earlier than the proper value, but MUST NOT\n        internally represent a parsed Expires date as later than the\n        proper value.\n\n      - All expiration-related calculations MUST be done in GMT. The\n        local time zone MUST NOT influence the calculation or comparison\n        of an age or expiration time.\n\n\n\n\nFielding, et al.            Standards Track                   [Page 166]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - If an HTTP header incorrectly carries a date value with a time\n        zone other than GMT, it MUST be converted into GMT using the\n        most conservative possible conversion.\n\n19.4 Differences Between HTTP Entities and RFC 2045 Entities\n\n   HTTP/1.1 uses many of the constructs defined for Internet Mail (RFC\n   822 [9]) and the Multipurpose Internet Mail Extensions (MIME [7]) to\n   allow entities to be transmitted in an open variety of\n   representations and with extensible mechanisms. However, RFC 2045\n   discusses mail, and HTTP has a few features that are different from\n   those described in RFC 2045. These differences were carefully chosen\n   to optimize performance over binary connections, to allow greater\n   freedom in the use of new media types, to make date comparisons\n   easier, and to acknowledge the practice of some early HTTP servers\n   and clients.\n\n   This appendix describes specific areas where HTTP differs from RFC\n   2045. Proxies and gateways to strict MIME environments SHOULD be\n   aware of these differences and provide the appropriate conversions\n   where necessary. Proxies and gateways from MIME environments to HTTP\n   also need to be aware of the differences because some conversions\n   might be required.\n\n19.4.1 MIME-Version\n\n   HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY\n   include a single MIME-Version general-header field to indicate what\n   version of the MIME protocol was used to construct the message. Use\n   of the MIME-Version header field indicates that the message is in\n   full compliance with the MIME protocol (as defined in RFC 2045[7]).\n   Proxies/gateways are responsible for ensuring full compliance (where\n   possible) when exporting HTTP messages to strict MIME environments.\n\n       MIME-Version   = \"MIME-Version\" \":\" 1*DIGIT \".\" 1*DIGIT"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_108",
        "original_index": 108,
        "content": "MIME-Version   = \"MIME-Version\" \":\" 1*DIGIT \".\" 1*DIGIT\n\n   MIME version \"1.0\" is the default for use in HTTP/1.1. However,\n   HTTP/1.1 message parsing and semantics are defined by this document\n   and not the MIME specification.\n\n19.4.2 Conversion to Canonical Form\n\n   RFC 2045 [7] requires that an Internet mail entity be converted to\n   canonical form prior to being transferred, as described in section 4\n   of RFC 2049 [48]. Section 3.7.1 of this document describes the forms\n   allowed for subtypes of the \"text\" media type when transmitted over\n   HTTP. RFC 2046 requires that content with a type of \"text\" represent\n   line breaks as CRLF and forbids the use of CR or LF outside of line\n\n\n\nFielding, et al.            Standards Track                   [Page 167]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a\n   line break within text content when a message is transmitted over\n   HTTP.\n\n   Where it is possible, a proxy or gateway from HTTP to a strict MIME\n   environment SHOULD translate all line breaks within the text media\n   types described in section 3.7.1 of this document to the RFC 2049\n   canonical form of CRLF. Note, however, that this might be complicated\n   by the presence of a Content-Encoding and by the fact that HTTP\n   allows the use of some character sets which do not use octets 13 and\n   10 to represent CR and LF, as is the case for some multi-byte\n   character sets.\n\n   Implementors should note that conversion will break any cryptographic\n   checksums applied to the original content unless the original content\n   is already in canonical form. Therefore, the canonical form is\n   recommended for any content that uses such checksums in HTTP.\n\n19.4.3 Conversion of Date Formats\n\n   HTTP/1.1 uses a restricted set of date formats (section 3.3.1) to\n   simplify the process of date comparison. Proxies and gateways from\n   other protocols SHOULD ensure that any Date header field present in a\n   message conforms to one of the HTTP/1.1 formats and rewrite the date\n   if necessary.\n\n19.4.4 Introduction of Content-Encoding\n\n   RFC 2045 does not include any concept equivalent to HTTP/1.1's\n   Content-Encoding header field. Since this acts as a modifier on the\n   media type, proxies and gateways from HTTP to MIME-compliant\n   protocols MUST either change the value of the Content-Type header\n   field or decode the entity-body before forwarding the message. (Some\n   experimental applications of Content-Type for Internet mail have used\n   a media-type parameter of \";conversions=<content-coding>\" to perform\n   a function equivalent to Content-Encoding. However, this parameter is\n   not part of RFC 2045.)\n\n19.4.5 No Content-Transfer-Encoding\n\n   HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC\n   2045. Proxies and gateways from MIME-compliant protocols to HTTP MUST\n   remove any non-identity CTE (\"quoted-printable\" or \"base64\") encoding\n   prior to delivering the response message to an HTTP client.\n\n   Proxies and gateways from HTTP to MIME-compliant protocols are\n   responsible for ensuring that the message is in the correct format\n   and encoding for safe transport on that protocol, where \"safe\n\n\n\nFielding, et al.            Standards Track                   [Page 168]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   transport\" is defined by the limitations of the protocol being used.\n   Such a proxy or gateway SHOULD label the data with an appropriate\n   Content-Transfer-Encoding if doing so will improve the likelihood of\n   safe transport over the destination protocol.\n\n19.4.6 Introduction of Transfer-Encoding\n\n   HTTP/1.1 introduces the Transfer-Encoding header field (section\n   14.41). Proxies/gateways MUST remove any transfer-coding prior to\n   forwarding a message via a MIME-compliant protocol."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_109",
        "original_index": 109,
        "content": "HTTP/1.1 introduces the Transfer-Encoding header field (section\n   14.41). Proxies/gateways MUST remove any transfer-coding prior to\n   forwarding a message via a MIME-compliant protocol.\n\n   A process for decoding the \"chunked\" transfer-coding (section 3.6)\n   can be represented in pseudo-code as:\n\n       length := 0\n       read chunk-size, chunk-extension (if any) and CRLF\n       while (chunk-size > 0) {\n          read chunk-data and CRLF\n          append chunk-data to entity-body\n          length := length + chunk-size\n          read chunk-size and CRLF\n       }\n       read entity-header\n       while (entity-header not empty) {\n          append entity-header to existing header fields\n          read entity-header\n       }\n       Content-Length := length\n       Remove \"chunked\" from Transfer-Encoding\n\n19.4.7 MHTML and Line Length Limitations\n\n   HTTP implementations which share code with MHTML [45] implementations\n   need to be aware of MIME line length limitations. Since HTTP does not\n   have this limitation, HTTP does not fold long lines. MHTML messages\n   being transported by HTTP follow all conventions of MHTML, including\n   line length limitations and folding, canonicalization, etc., since\n   HTTP transports all message-bodies as payload (see section 3.7.2) and\n   does not interpret the content or any MIME header lines that might be\n   contained therein.\n\n19.5 Additional Features\n\n   RFC 1945 and RFC 2068 document protocol elements used by some\n   existing HTTP implementations, but not consistently and correctly\n   across most HTTP/1.1 applications. Implementors are advised to be\n   aware of these features, but cannot rely upon their presence in, or\n   interoperability with, other HTTP/1.1 applications. Some of these\n\n\n\nFielding, et al.            Standards Track                   [Page 169]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   describe proposed experimental features, and some describe features\n   that experimental deployment found lacking that are now addressed in\n   the base HTTP/1.1 specification.\n\n   A number of other headers, such as Content-Disposition and Title,\n   from SMTP and MIME are also often implemented (see RFC 2076 [37]).\n\n19.5.1 Content-Disposition\n\n   The Content-Disposition response-header field has been proposed as a\n   means for the origin server to suggest a default filename if the user\n   requests that the content is saved to a file. This usage is derived\n   from the definition of Content-Disposition in RFC 1806 [35].\n\n        content-disposition = \"Content-Disposition\" \":\"\n                              disposition-type *( \";\" disposition-parm )\n        disposition-type = \"attachment\" | disp-extension-token\n        disposition-parm = filename-parm | disp-extension-parm\n        filename-parm = \"filename\" \"=\" quoted-string\n        disp-extension-token = token\n        disp-extension-parm = token \"=\" ( token | quoted-string )\n\n   An example is\n\n        Content-Disposition: attachment; filename=\"fname.ext\"\n\n   The receiving user agent SHOULD NOT respect any directory path\n   information present in the filename-parm parameter, which is the only\n   parameter believed to apply to HTTP implementations at this time. The\n   filename SHOULD be treated as a terminal component only.\n\n   If this header is used in a response with the application/octet-\n   stream content-type, the implied suggestion is that the user agent\n   should not display the response, but directly enter a `save response\n   as...' dialog.\n\n   See section 15.5 for Content-Disposition security issues.\n\n19.6 Compatibility with Previous Versions\n\n   It is beyond the scope of a protocol specification to mandate\n   compliance with previous versions. HTTP/1.1 was deliberately\n   designed, however, to make supporting previous versions easy. It is\n   worth noting that, at the time of composing this specification\n   (1996), we would expect commercial HTTP/1.1 servers to:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_110",
        "original_index": 110,
        "content": "- recognize the format of the Request-Line for HTTP/0.9, 1.0, and\n        1.1 requests;\n\n\n\nFielding, et al.            Standards Track                   [Page 170]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n      - understand any valid request in the format of HTTP/0.9, 1.0, or\n        1.1;\n\n      - respond appropriately with a message in the same major version\n        used by the client.\n\n   And we would expect HTTP/1.1 clients to:\n\n      - recognize the format of the Status-Line for HTTP/1.0 and 1.1\n        responses;\n\n      - understand any valid response in the format of HTTP/0.9, 1.0, or\n        1.1.\n\n   For most implementations of HTTP/1.0, each connection is established\n   by the client prior to the request and closed by the server after\n   sending the response. Some implementations implement the Keep-Alive\n   version of persistent connections described in section 19.7.1 of RFC\n   2068 [33].\n\n19.6.1 Changes from HTTP/1.0\n\n   This section summarizes major differences between versions HTTP/1.0\n   and HTTP/1.1.\n\n19.6.1.1 Changes to Simplify Multi-homed Web Servers and Conserve IP\n         Addresses\n\n   The requirements that clients and servers support the Host request-\n   header, report an error if the Host request-header (section 14.23) is\n   missing from an HTTP/1.1 request, and accept absolute URIs (section\n   5.1.2) are among the most important changes defined by this\n   specification.\n\n   Older HTTP/1.0 clients assumed a one-to-one relationship of IP\n   addresses and servers; there was no other established mechanism for\n   distinguishing the intended server of a request than the IP address\n   to which that request was directed. The changes outlined above will\n   allow the Internet, once older HTTP clients are no longer common, to\n   support multiple Web sites from a single IP address, greatly\n   simplifying large operational Web servers, where allocation of many\n   IP addresses to a single host has created serious problems. The\n   Internet will also be able to recover the IP addresses that have been\n   allocated for the sole purpose of allowing special-purpose domain\n   names to be used in root-level HTTP URLs. Given the rate of growth of\n   the Web, and the number of servers already deployed, it is extremely\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 171]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   important that all implementations of HTTP (including updates to\n   existing HTTP/1.0 applications) correctly implement these\n   requirements:\n\n      - Both clients and servers MUST support the Host request-header.\n\n      - A client that sends an HTTP/1.1 request MUST send a Host header.\n\n      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1\n        request does not include a Host request-header.\n\n      - Servers MUST accept absolute URIs.\n\n19.6.2 Compatibility with HTTP/1.0 Persistent Connections\n\n   Some clients and servers might wish to be compatible with some\n   previous implementations of persistent connections in HTTP/1.0\n   clients and servers. Persistent connections in HTTP/1.0 are\n   explicitly negotiated as they are not the default behavior. HTTP/1.0\n   experimental implementations of persistent connections are faulty,\n   and the new facilities in HTTP/1.1 are designed to rectify these\n   problems. The problem was that some existing 1.0 clients may be\n   sending Keep-Alive to a proxy server that doesn't understand\n   Connection, which would then erroneously forward it to the next\n   inbound server, which would establish the Keep-Alive connection and\n   result in a hung HTTP/1.0 proxy waiting for the close on the\n   response. The result is that HTTP/1.0 clients must be prevented from\n   using Keep-Alive when talking to proxies."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_111",
        "original_index": 111,
        "content": "However, talking to proxies is the most important use of persistent\n   connections, so that prohibition is clearly unacceptable. Therefore,\n   we need some other mechanism for indicating a persistent connection\n   is desired, which is safe to use even when talking to an old proxy\n   that ignores Connection. Persistent connections are the default for\n   HTTP/1.1 messages; we introduce a new keyword (Connection: close) for\n   declaring non-persistence. See section 14.10.\n\n   The original HTTP/1.0 form of persistent connections (the Connection:\n   Keep-Alive and Keep-Alive header) is documented in RFC 2068. [33]\n\n19.6.3 Changes from RFC 2068\n\n   This specification has been carefully audited to correct and\n   disambiguate key word usage; RFC 2068 had many problems in respect to\n   the conventions laid out in RFC 2119 [34].\n\n   Clarified which error code should be used for inbound server failures\n   (e.g. DNS failures). (Section 10.5.5).\n\n\n\nFielding, et al.            Standards Track                   [Page 172]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   CREATE had a race that required an Etag be sent when a resource is\n   first created. (Section 10.2.2).\n\n   Content-Base was deleted from the specification: it was not\n   implemented widely, and there is no simple, safe way to introduce it\n   without a robust extension mechanism. In addition, it is used in a\n   similar, but not identical fashion in MHTML [45].\n\n   Transfer-coding and message lengths all interact in ways that\n   required fixing exactly when chunked encoding is used (to allow for\n   transfer encoding that may not be self delimiting); it was important\n   to straighten out exactly how message lengths are computed. (Sections\n   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)\n\n   A content-coding of \"identity\" was introduced, to solve problems\n   discovered in caching. (section 3.5)\n\n   Quality Values of zero should indicate that \"I don't want something\"\n   to allow clients to refuse a representation. (Section 3.9)\n\n   The use and interpretation of HTTP version numbers has been clarified\n   by RFC 2145. Require proxies to upgrade requests to highest protocol\n   version they support to deal with problems discovered in HTTP/1.0\n   implementations (Section 3.1)\n\n   Charset wildcarding is introduced to avoid explosion of character set\n   names in accept headers. (Section 14.2)\n\n   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage\n   was introduced to add this missing case. (Sections 13.4, 14.8, 14.9,\n   14.9.3)\n\n   The Cache-Control: max-age directive was not properly defined for\n   responses. (Section 14.9.3)\n\n   There are situations where a server (especially a proxy) does not\n   know the full length of a response but is capable of serving a\n   byterange request. We therefore need a mechanism to allow byteranges\n   with a content-range not indicating the full length of the message.\n   (Section 14.16)\n\n   Range request responses would become very verbose if all meta-data\n   were always returned; by allowing the server to only send needed\n   headers in a 206 response, this problem can be avoided. (Section\n   10.2.7, 13.5.3, and 14.27)\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 173]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Fix problem with unsatisfiable range requests; there are two cases:\n   syntactic problems, and range doesn't exist in the document. The 416\n   status code was needed to resolve this ambiguity needed to indicate\n   an error for a byte range request that falls outside of the actual\n   contents of a document. (Section 10.4.17, 14.16)\n\n   Rewrite of message transmission requirements to make it much harder\n   for implementors to get it wrong, as the consequences of errors here\n   can have significant impact on the Internet, and to deal with the\n   following problems:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_112",
        "original_index": 112,
        "content": "1. Changing \"HTTP/1.1 or later\" to \"HTTP/1.1\", in contexts where\n         this was incorrectly placing a requirement on the behavior of\n         an implementation of a future version of HTTP/1.x\n\n      2. Made it clear that user-agents should retry requests, not\n         \"clients\" in general.\n\n      3. Converted requirements for clients to ignore unexpected 100\n         (Continue) responses, and for proxies to forward 100 responses,\n         into a general requirement for 1xx responses.\n\n      4. Modified some TCP-specific language, to make it clearer that\n         non-TCP transports are possible for HTTP.\n\n      5. Require that the origin server MUST NOT wait for the request\n         body before it sends a required 100 (Continue) response.\n\n      6. Allow, rather than require, a server to omit 100 (Continue) if\n         it has already seen some of the request body.\n\n      7. Allow servers to defend against denial-of-service attacks and\n         broken clients.\n\n   This change adds the Expect header and 417 status code. The message\n   transmission requirements fixes are in sections 8.2, 10.4.18,\n   8.1.2.2, 13.11, and 14.20.\n\n   Proxies should be able to add Content-Length when appropriate.\n   (Section 13.5.2)\n\n   Clean up confusion between 403 and 404 responses. (Section 10.4.4,\n   10.4.5, and 10.4.11)\n\n   Warnings could be cached incorrectly, or not updated appropriately.\n   (Section 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning\n   also needed to be a general header, as PUT or other methods may have\n   need for it in requests.\n\n\n\nFielding, et al.            Standards Track                   [Page 174]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n   Transfer-coding had significant problems, particularly with\n   interactions with chunked encoding. The solution is that transfer-\n   codings become as full fledged as content-codings. This involves\n   adding an IANA registry for transfer-codings (separate from content\n   codings), a new header field (TE) and enabling trailer headers in the\n   future. Transfer encoding is a major performance benefit, so it was\n   worth fixing [39]. TE also solves another, obscure, downward\n   interoperability problem that could have occurred due to interactions\n   between authentication trailers, chunked encoding and HTTP/1.0\n   clients.(Section 3.6, 3.6.1, and 14.39)\n\n   The PATCH, LINK, UNLINK methods were defined but not commonly\n   implemented in previous versions of this specification. See RFC 2068\n   [33].\n\n   The Alternates, Content-Version, Derived-From, Link, URI, Public and\n   Content-Base header fields were defined in previous versions of this\n   specification, but not commonly implemented. See RFC 2068 [33].\n\n20 Index\n\n   Please see the PostScript version of this RFC for the INDEX.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 175]\n\f\nRFC 2616                        HTTP/1.1                       June 1999\n\n\n21.  Full Copyright Statement\n\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n\n   This document and translations of it may be copied and furnished to\n   others, and derivative works that comment on or otherwise explain it\n   or assist in its implementation may be prepared, copied, published\n   and distributed, in whole or in part, without restriction of any\n   kind, provided that the above copyright notice and this paragraph are\n   included on all such copies and derivative works.  However, this\n   document itself may not be modified in any way, such as by removing\n   the copyright notice or references to the Internet Society or other\n   Internet organizations, except as needed for the purpose of\n   developing Internet standards in which case the procedures for\n   copyrights defined in the Internet Standards process must be\n   followed, or as required to translate it into languages other than\n   English."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_113",
        "original_index": 113,
        "content": "The limited permissions granted above are perpetual and will not be\n   revoked by the Internet Society or its successors or assigns.\n\n   This document and the information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\nAcknowledgement\n\n   Funding for the RFC Editor function is currently provided by the\n   Internet Society.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding, et al.            Standards Track                   [Page 176]\n\f\n\n\n==================== RFC - JSON ====================\n\n\n\n\n\n\n\nInternet Engineering Task Force (IETF)                      T. Bray, Ed.\nRequest for Comments: 8259                                    Textuality\nObsoletes: 7159                                            December 2017\nCategory: Standards Track\nISSN: 2070-1721\n\n\n     The JavaScript Object Notation (JSON) Data Interchange Format\n\nAbstract\n\n   JavaScript Object Notation (JSON) is a lightweight, text-based,\n   language-independent data interchange format.  It was derived from\n   the ECMAScript Programming Language Standard.  JSON defines a small\n   set of formatting rules for the portable representation of structured\n   data.\n\n   This document removes inconsistencies with other specifications of\n   JSON, repairs specification errors, and offers experience-based\n   interoperability guidance.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8259.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 1]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nCopyright Notice\n\n   Copyright (c) 2017 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(s) controlling the copyright in some of this\n   material may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 2]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nTable of Contents"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_114",
        "original_index": 114,
        "content": "Bray                         Standards Track                    [Page 2]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nTable of Contents\n\n   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n     1.1.  Conventions Used in This Document . . . . . . . . . . . .   4\n     1.2.  Specifications of JSON  . . . . . . . . . . . . . . . . .   4\n     1.3.  Introduction to This Revision . . . . . . . . . . . . . .   5\n   2.  JSON Grammar  . . . . . . . . . . . . . . . . . . . . . . . .   5\n   3.  Values  . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n   4.  Objects . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n   5.  Arrays  . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n   6.  Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n   7.  Strings . . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n   8.  String and Character Issues . . . . . . . . . . . . . . . . .   9\n     8.1.  Character Encoding  . . . . . . . . . . . . . . . . . . .   9\n     8.2.  Unicode Characters  . . . . . . . . . . . . . . . . . . .  10\n     8.3.  String Comparison . . . . . . . . . . . . . . . . . . . .  10\n   9.  Parsers . . . . . . . . . . . . . . . . . . . . . . . . . . .  10\n   10. Generators  . . . . . . . . . . . . . . . . . . . . . . . . .  10\n   11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  11\n   12. Security Considerations . . . . . . . . . . . . . . . . . . .  12\n   13. Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  12\n   14. References  . . . . . . . . . . . . . . . . . . . . . . . . .  14\n     14.1.  Normative References . . . . . . . . . . . . . . . . . .  14\n     14.2.  Informative References . . . . . . . . . . . . . . . . .  14\n   Appendix A.  Changes from RFC 7159  . . . . . . . . . . . . . . .  16\n   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  16\n   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  16\n\n1.  Introduction\n\n   JavaScript Object Notation (JSON) is a text format for the\n   serialization of structured data.  It is derived from the object\n   literals of JavaScript, as defined in the ECMAScript Programming\n   Language Standard, Third Edition [ECMA-262].\n\n   JSON can represent four primitive types (strings, numbers, booleans,\n   and null) and two structured types (objects and arrays).\n\n   A string is a sequence of zero or more Unicode characters [UNICODE].\n   Note that this citation references the latest version of Unicode\n   rather than a specific release.  It is not expected that future\n   changes in the Unicode specification will impact the syntax of JSON.\n\n   An object is an unordered collection of zero or more name/value\n   pairs, where a name is a string and a value is a string, number,\n   boolean, null, object, or array.\n\n   An array is an ordered sequence of zero or more values.\n\n\n\nBray                         Standards Track                    [Page 3]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   The terms \"object\" and \"array\" come from the conventions of\n   JavaScript.\n\n   JSON's design goals were for it to be minimal, portable, textual, and\n   a subset of JavaScript.\n\n1.1.  Conventions Used in This Document\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described in BCP\n   14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals, as shown here.\n\n   The grammatical rules in this document are to be interpreted as\n   described in [RFC5234].\n\n1.2.  Specifications of JSON\n\n   This document replaces [RFC7159].  [RFC7159] obsoleted [RFC4627],\n   which originally described JSON and registered the media type\n   \"application/json\".\n\n   JSON is also described in [ECMA-404]."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_115",
        "original_index": 115,
        "content": "This document replaces [RFC7159].  [RFC7159] obsoleted [RFC4627],\n   which originally described JSON and registered the media type\n   \"application/json\".\n\n   JSON is also described in [ECMA-404].\n\n   The reference to ECMA-404 in the previous sentence is normative, not\n   with the usual meaning that implementors need to consult it in order\n   to understand this document, but to emphasize that there are no\n   inconsistencies in the definition of the term \"JSON text\" in any of\n   its specifications.  Note, however, that ECMA-404 allows several\n   practices that this specification recommends avoiding in the\n   interests of maximal interoperability.\n\n   The intent is that the grammar is the same between the two documents,\n   although different descriptions are used.  If there is a difference\n   found between them, ECMA and the IETF will work together to update\n   both documents.\n\n   If an error is found with either document, the other should be\n   examined to see if it has a similar error; if it does, it should be\n   fixed, if possible.\n\n   If either document is changed in the future, ECMA and the IETF will\n   work together to ensure that the two documents stay aligned through\n   the change.\n\n\n\n\n\n\nBray                         Standards Track                    [Page 4]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n1.3.  Introduction to This Revision\n\n   In the years since the publication of RFC 4627, JSON has found very\n   wide use.  This experience has revealed certain patterns that, while\n   allowed by its specifications, have caused interoperability problems.\n\n   Also, a small number of errata have been reported regarding RFC 4627\n   (see RFC Errata IDs 607 [Err607] and 3607 [Err3607]) and regarding\n   RFC 7159 (see RFC Errata IDs 3915 [Err3915], 4264 [Err4264], 4336\n   [Err4336], and 4388 [Err4388]).\n\n   This document's goal is to apply the errata, remove inconsistencies\n   with other specifications of JSON, and highlight practices that can\n   lead to interoperability problems.\n\n2.  JSON Grammar\n\n   A JSON text is a sequence of tokens.  The set of tokens includes six\n   structural characters, strings, numbers, and three literal names.\n\n   A JSON text is a serialized value.  Note that certain previous\n   specifications of JSON constrained a JSON text to be an object or an\n   array.  Implementations that generate only objects or arrays where a\n   JSON text is called for will be interoperable in the sense that all\n   implementations will accept these as conforming JSON texts.\n\n      JSON-text = ws value ws\n\n   These are the six structural characters:\n\n      begin-array     = ws %x5B ws  ; [ left square bracket\n\n      begin-object    = ws %x7B ws  ; { left curly bracket\n\n      end-array       = ws %x5D ws  ; ] right square bracket\n\n      end-object      = ws %x7D ws  ; } right curly bracket\n\n      name-separator  = ws %x3A ws  ; : colon\n\n      value-separator = ws %x2C ws  ; , comma\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 5]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   Insignificant whitespace is allowed before or after any of the six\n   structural characters.\n\n      ws = *(\n              %x20 /              ; Space\n              %x09 /              ; Horizontal tab\n              %x0A /              ; Line feed or New line\n              %x0D )              ; Carriage return\n\n3.  Values\n\n   A JSON value MUST be an object, array, number, or string, or one of\n   the following three literal names:\n\n      false\n      null\n      true\n\n   The literal names MUST be lowercase.  No other literal names are\n   allowed.\n\n      value = false / null / true / object / array / number / string\n\n      false = %x66.61.6c.73.65   ; false\n\n      null  = %x6e.75.6c.6c      ; null\n\n      true  = %x74.72.75.65      ; true\n\n4.  Objects"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_116",
        "original_index": 116,
        "content": "false = %x66.61.6c.73.65   ; false\n\n      null  = %x6e.75.6c.6c      ; null\n\n      true  = %x74.72.75.65      ; true\n\n4.  Objects\n\n   An object structure is represented as a pair of curly brackets\n   surrounding zero or more name/value pairs (or members).  A name is a\n   string.  A single colon comes after each name, separating the name\n   from the value.  A single comma separates a value from a following\n   name.  The names within an object SHOULD be unique.\n\n      object = begin-object [ member *( value-separator member ) ]\n               end-object\n\n      member = string name-separator value\n\n   An object whose names are all unique is interoperable in the sense\n   that all software implementations receiving that object will agree on\n   the name-value mappings.  When the names within an object are not\n   unique, the behavior of software that receives such an object is\n   unpredictable.  Many implementations report the last name/value pair\n   only.  Other implementations report an error or fail to parse the\n\n\n\nBray                         Standards Track                    [Page 6]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   object, and some implementations report all of the name/value pairs,\n   including duplicates.\n\n   JSON parsing libraries have been observed to differ as to whether or\n   not they make the ordering of object members visible to calling\n   software.  Implementations whose behavior does not depend on member\n   ordering will be interoperable in the sense that they will not be\n   affected by these differences.\n\n5.  Arrays\n\n   An array structure is represented as square brackets surrounding zero\n   or more values (or elements).  Elements are separated by commas.\n\n   array = begin-array [ value *( value-separator value ) ] end-array\n\n   There is no requirement that the values in an array be of the same\n   type.\n\n6.  Numbers\n\n   The representation of numbers is similar to that used in most\n   programming languages.  A number is represented in base 10 using\n   decimal digits.  It contains an integer component that may be\n   prefixed with an optional minus sign, which may be followed by a\n   fraction part and/or an exponent part.  Leading zeros are not\n   allowed.\n\n   A fraction part is a decimal point followed by one or more digits.\n\n   An exponent part begins with the letter E in uppercase or lowercase,\n   which may be followed by a plus or minus sign.  The E and optional\n   sign are followed by one or more digits.\n\n   Numeric values that cannot be represented in the grammar below (such\n   as Infinity and NaN) are not permitted.\n\n      number = [ minus ] int [ frac ] [ exp ]\n\n      decimal-point = %x2E       ; .\n\n      digit1-9 = %x31-39         ; 1-9\n\n      e = %x65 / %x45            ; e E\n\n      exp = e [ minus / plus ] 1*DIGIT\n\n      frac = decimal-point 1*DIGIT\n\n\n\nBray                         Standards Track                    [Page 7]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n      int = zero / ( digit1-9 *DIGIT )\n\n      minus = %x2D               ; -\n\n      plus = %x2B                ; +\n\n      zero = %x30                ; 0\n\n   This specification allows implementations to set limits on the range\n   and precision of numbers accepted.  Since software that implements\n   IEEE 754 binary64 (double precision) numbers [IEEE754] is generally\n   available and widely used, good interoperability can be achieved by\n   implementations that expect no more precision or range than these\n   provide, in the sense that implementations will approximate JSON\n   numbers within the expected precision.  A JSON number such as 1E400\n   or 3.141592653589793238462643383279 may indicate potential\n   interoperability problems, since it suggests that the software that\n   created it expects receiving software to have greater capabilities\n   for numeric magnitude and precision than is widely available."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_117",
        "original_index": 117,
        "content": "Note that when such software is used, numbers that are integers and\n   are in the range [-(2**53)+1, (2**53)-1] are interoperable in the\n   sense that implementations will agree exactly on their numeric\n   values.\n\n7.  Strings\n\n   The representation of strings is similar to conventions used in the C\n   family of programming languages.  A string begins and ends with\n   quotation marks.  All Unicode characters may be placed within the\n   quotation marks, except for the characters that MUST be escaped:\n   quotation mark, reverse solidus, and the control characters (U+0000\n   through U+001F).\n\n   Any character may be escaped.  If the character is in the Basic\n   Multilingual Plane (U+0000 through U+FFFF), then it may be\n   represented as a six-character sequence: a reverse solidus, followed\n   by the lowercase letter u, followed by four hexadecimal digits that\n   encode the character's code point.  The hexadecimal letters A through\n   F can be uppercase or lowercase.  So, for example, a string\n   containing only a single reverse solidus character may be represented\n   as \"\\u005C\".\n\n   Alternatively, there are two-character sequence escape\n   representations of some popular characters.  So, for example, a\n   string containing only a single reverse solidus character may be\n   represented more compactly as \"\\\\\".\n\n\n\n\nBray                         Standards Track                    [Page 8]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   To escape an extended character that is not in the Basic Multilingual\n   Plane, the character is represented as a 12-character sequence,\n   encoding the UTF-16 surrogate pair.  So, for example, a string\n   containing only the G clef character (U+1D11E) may be represented as\n   \"\\uD834\\uDD1E\".\n\n      string = quotation-mark *char quotation-mark\n\n      char = unescaped /\n          escape (\n              %x22 /          ; \"    quotation mark  U+0022\n              %x5C /          ; \\    reverse solidus U+005C\n              %x2F /          ; /    solidus         U+002F\n              %x62 /          ; b    backspace       U+0008\n              %x66 /          ; f    form feed       U+000C\n              %x6E /          ; n    line feed       U+000A\n              %x72 /          ; r    carriage return U+000D\n              %x74 /          ; t    tab             U+0009\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\n\n      escape = %x5C              ; \\\n\n      quotation-mark = %x22      ; \"\n\n      unescaped = %x20-21 / %x23-5B / %x5D-10FFFF\n\n8.  String and Character Issues\n\n8.1.  Character Encoding\n\n   JSON text exchanged between systems that are not part of a closed\n   ecosystem MUST be encoded using UTF-8 [RFC3629].\n\n   Previous specifications of JSON have not required the use of UTF-8\n   when transmitting JSON text.  However, the vast majority of JSON-\n   based software implementations have chosen to use the UTF-8 encoding,\n   to the extent that it is the only encoding that achieves\n   interoperability.\n\n   Implementations MUST NOT add a byte order mark (U+FEFF) to the\n   beginning of a networked-transmitted JSON text.  In the interests of\n   interoperability, implementations that parse JSON texts MAY ignore\n   the presence of a byte order mark rather than treating it as an\n   error.\n\n\n\n\n\n\n\nBray                         Standards Track                    [Page 9]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n8.2.  Unicode Characters\n\n   When all the strings represented in a JSON text are composed entirely\n   of Unicode characters [UNICODE] (however escaped), then that JSON\n   text is interoperable in the sense that all software implementations\n   that parse it will agree on the contents of names and of string\n   values in objects and arrays."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_118",
        "original_index": 118,
        "content": "However, the ABNF in this specification allows member names and\n   string values to contain bit sequences that cannot encode Unicode\n   characters; for example, \"\\uDEAD\" (a single unpaired UTF-16\n   surrogate).  Instances of this have been observed, for example, when\n   a library truncates a UTF-16 string without checking whether the\n   truncation split a surrogate pair.  The behavior of software that\n   receives JSON texts containing such values is unpredictable; for\n   example, implementations might return different values for the length\n   of a string value or even suffer fatal runtime exceptions.\n\n8.3.  String Comparison\n\n   Software implementations are typically required to test names of\n   object members for equality.  Implementations that transform the\n   textual representation into sequences of Unicode code units and then\n   perform the comparison numerically, code unit by code unit, are\n   interoperable in the sense that implementations will agree in all\n   cases on equality or inequality of two strings.  For example,\n   implementations that compare strings with escaped characters\n   unconverted may incorrectly find that \"a\\\\b\" and \"a\\u005Cb\" are not\n   equal.\n\n9.  Parsers\n\n   A JSON parser transforms a JSON text into another representation.  A\n   JSON parser MUST accept all texts that conform to the JSON grammar.\n   A JSON parser MAY accept non-JSON forms or extensions.\n\n   An implementation may set limits on the size of texts that it\n   accepts.  An implementation may set limits on the maximum depth of\n   nesting.  An implementation may set limits on the range and precision\n   of numbers.  An implementation may set limits on the length and\n   character contents of strings.\n\n10.  Generators\n\n   A JSON generator produces JSON text.  The resulting text MUST\n   strictly conform to the JSON grammar.\n\n\n\n\n\nBray                         Standards Track                   [Page 10]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n11.  IANA Considerations\n\n   The media type for JSON text is application/json.\n\n   Type name:  application\n\n   Subtype name:  json\n\n   Required parameters:  n/a\n\n   Optional parameters:  n/a\n\n   Encoding considerations:  binary\n\n   Security considerations:  See RFC 8259, Section 12\n\n   Interoperability considerations:  Described in RFC 8259\n\n   Published specification:  RFC 8259\n\n   Applications that use this media type:\n      JSON has been used to exchange data between applications written\n      in all of these programming languages: ActionScript, C, C#,\n      Clojure, ColdFusion, Common Lisp, E, Erlang, Go, Java, JavaScript,\n      Lua, Objective CAML, Perl, PHP, Python, Rebol, Ruby, Scala, and\n      Scheme.\n\n   Additional information:\n      Magic number(s): n/a\n      File extension(s): .json\n      Macintosh file type code(s): TEXT\n\n   Person & email address to contact for further information:\n      IESG\n      <iesg@ietf.org>\n\n   Intended usage:  COMMON\n\n   Restrictions on usage:  none\n\n   Author:\n      Douglas Crockford\n      <douglas@crockford.com>\n\n   Change controller:\n      IESG\n      <iesg@ietf.org>\n\n\n\n\nBray                         Standards Track                   [Page 11]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   Note:  No \"charset\" parameter is defined for this registration.\n      Adding one really has no effect on compliant recipients.\n\n12.  Security Considerations\n\n   Generally, there are security issues with scripting languages.  JSON\n   is a subset of JavaScript but excludes assignment and invocation."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_119",
        "original_index": 119,
        "content": "12.  Security Considerations\n\n   Generally, there are security issues with scripting languages.  JSON\n   is a subset of JavaScript but excludes assignment and invocation.\n\n   Since JSON's syntax is borrowed from JavaScript, it is possible to\n   use that language's \"eval()\" function to parse most JSON texts (but\n   not all; certain characters such as U+2028 LINE SEPARATOR and U+2029\n   PARAGRAPH SEPARATOR are legal in JSON but not JavaScript).  This\n   generally constitutes an unacceptable security risk, since the text\n   could contain executable code along with data declarations.  The same\n   consideration applies to the use of eval()-like functions in any\n   other programming language in which JSON texts conform to that\n   language's syntax.\n\n13.  Examples\n\n   This is a JSON object:\n\n      {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n          }\n      }\n\n   Its Image member is an object whose Thumbnail member is an object and\n   whose IDs member is an array of numbers.\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 12]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   This is a JSON array containing two objects:\n\n      [\n        {\n           \"precision\": \"zip\",\n           \"Latitude\":  37.7668,\n           \"Longitude\": -122.3959,\n           \"Address\":   \"\",\n           \"City\":      \"SAN FRANCISCO\",\n           \"State\":     \"CA\",\n           \"Zip\":       \"94107\",\n           \"Country\":   \"US\"\n        },\n        {\n           \"precision\": \"zip\",\n           \"Latitude\":  37.371991,\n           \"Longitude\": -122.026020,\n           \"Address\":   \"\",\n           \"City\":      \"SUNNYVALE\",\n           \"State\":     \"CA\",\n           \"Zip\":       \"94085\",\n           \"Country\":   \"US\"\n        }\n      ]\n\n   Here are three small JSON texts containing only values:\n\n   \"Hello world!\"\n\n   42\n\n   true\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 13]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n14.  References\n\n14.1.  Normative References\n\n   [ECMA-404] Ecma International, \"The JSON Data Interchange Format\",\n              Standard ECMA-404,\n              <http://www.ecma-international.org/publications/\n              standards/Ecma-404.htm>.\n\n   [IEEE754]  IEEE, \"IEEE Standard for Floating-Point Arithmetic\",\n              IEEE 754.\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n              2003, <https://www.rfc-editor.org/info/rfc3629>.\n\n   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234, January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n\n   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n\n   [UNICODE]  The Unicode Consortium, \"The Unicode Standard\",\n              <http://www.unicode.org/versions/latest/>.\n\n14.2.  Informative References"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_120",
        "original_index": 120,
        "content": "[UNICODE]  The Unicode Consortium, \"The Unicode Standard\",\n              <http://www.unicode.org/versions/latest/>.\n\n14.2.  Informative References\n\n   [ECMA-262] Ecma International, \"ECMAScript Language Specification\",\n              Standard ECMA-262, Third Edition, December 1999,\n              <http://www.ecma-international.org/publications/files/\n              ECMA-ST-ARCH/\n              ECMA-262,%203rd%20edition,%20December%201999.pdf>.\n\n   [Err3607]  RFC Errata, Erratum ID 3607, RFC 4627,\n              <https://www.rfc-editor.org/errata/eid3607>.\n\n   [Err3915]  RFC Errata, Erratum ID 3915, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid3915>.\n\n\n\n\n\nBray                         Standards Track                   [Page 14]\n\f\nRFC 8259                          JSON                     December 2017\n\n\n   [Err4264]  RFC Errata, Erratum ID 4264, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4264>.\n\n   [Err4336]  RFC Errata, Erratum ID 4336, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4336>.\n\n   [Err4388]  RFC Errata, Erratum ID 4388, RFC 7159,\n              <https://www.rfc-editor.org/errata/eid4388>.\n\n   [Err607]   RFC Errata, Erratum ID 607, RFC 4627,\n              <https://www.rfc-editor.org/errata/eid607>.\n\n   [RFC4627]  Crockford, D., \"The application/json Media Type for\n              JavaScript Object Notation (JSON)\", RFC 4627,\n              DOI 10.17487/RFC4627, July 2006,\n              <https://www.rfc-editor.org/info/rfc4627>.\n\n   [RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n              Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March\n              2014, <https://www.rfc-editor.org/info/rfc7159>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 15]\n\f\nRFC 8259                          JSON                     December 2017\n\n\nAppendix A.  Changes from RFC 7159\n\n   This section lists changes between this document and the text in\n   RFC 7159.\n\n   o  Section 1.2 has been updated to reflect the removal of a JSON\n      specification from ECMA-262, to make ECMA-404 a normative\n      reference, and to explain the particular meaning of \"normative\".\n\n   o  Section 1.3 has been updated to reflect errata filed against\n      RFC 7159, not RFC 4627.\n\n   o  Section 8.1 was changed to require the use of UTF-8 when\n      transmitted over a network.\n\n   o  Section 12 has been updated to increase the precision of the\n      description of the security risk that follows from using the\n      ECMAScript \"eval()\" function.\n\n   o  Section 14.1 has been updated to include ECMA-404 as a normative\n      reference.\n\n   o  Section 14.2 has been updated to remove ECMA-404, update the\n      version of ECMA-262, and refresh the errata list.\n\nContributors\n\n   RFC 4627 was written by Douglas Crockford.  This document was\n   constructed by making a relatively small number of changes to that\n   document; thus, the vast majority of the text here is his.\n\nAuthor's Address\n\n   Tim Bray (editor)\n   Textuality\n\n   Email: tbray@textuality.com\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBray                         Standards Track                   [Page 16]\n\f\n\n\n==================== RFC - OAUTH ====================\n\n\n\n\n\n\n\nInternet Engineering Task Force (IETF)                     D. Hardt, Ed.\nRequest for Comments: 6749                                     Microsoft\nObsoletes: 5849                                             October 2012\nCategory: Standards Track\nISSN: 2070-1721\n\n\n                 The OAuth 2.0 Authorization Framework\n\nAbstract"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_121",
        "original_index": 121,
        "content": "The OAuth 2.0 Authorization Framework\n\nAbstract\n\n   The OAuth 2.0 authorization framework enables a third-party\n   application to obtain limited access to an HTTP service, either on\n   behalf of a resource owner by orchestrating an approval interaction\n   between the resource owner and the HTTP service, or by allowing the\n   third-party application to obtain access on its own behalf.  This\n   specification replaces and obsoletes the OAuth 1.0 protocol described\n   in RFC 5849.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 5741.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6749.\n\nCopyright Notice\n\n   Copyright (c) 2012 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\n\n\n\nHardt                        Standards Track                    [Page 1]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nTable of Contents"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_122",
        "original_index": 122,
        "content": "Hardt                        Standards Track                    [Page 1]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nTable of Contents\n\n   1. Introduction ....................................................4\n      1.1. Roles ......................................................6\n      1.2. Protocol Flow ..............................................7\n      1.3. Authorization Grant ........................................8\n           1.3.1. Authorization Code ..................................8\n           1.3.2. Implicit ............................................8\n           1.3.3. Resource Owner Password Credentials .................9\n           1.3.4. Client Credentials ..................................9\n      1.4. Access Token ..............................................10\n      1.5. Refresh Token .............................................10\n      1.6. TLS Version ...............................................12\n      1.7. HTTP Redirections .........................................12\n      1.8. Interoperability ..........................................12\n      1.9. Notational Conventions ....................................13\n   2. Client Registration ............................................13\n      2.1. Client Types ..............................................14\n      2.2. Client Identifier .........................................15\n      2.3. Client Authentication .....................................16\n           2.3.1. Client Password ....................................16\n           2.3.2. Other Authentication Methods .......................17\n      2.4. Unregistered Clients ......................................17\n   3. Protocol Endpoints .............................................18\n      3.1. Authorization Endpoint ....................................18\n           3.1.1. Response Type ......................................19\n           3.1.2. Redirection Endpoint ...............................19\n      3.2. Token Endpoint ............................................21\n           3.2.1. Client Authentication ..............................22\n      3.3. Access Token Scope ........................................23\n   4. Obtaining Authorization ........................................23\n      4.1. Authorization Code Grant ..................................24\n           4.1.1. Authorization Request ..............................25\n           4.1.2. Authorization Response .............................26\n           4.1.3. Access Token Request ...............................29\n           4.1.4. Access Token Response ..............................30\n      4.2. Implicit Grant ............................................31\n           4.2.1. Authorization Request ..............................33\n           4.2.2. Access Token Response ..............................35\n      4.3. Resource Owner Password Credentials Grant .................37\n           4.3.1. Authorization Request and Response .................39\n           4.3.2. Access Token Request ...............................39\n           4.3.3. Access Token Response ..............................40\n      4.4. Client Credentials Grant ..................................40\n           4.4.1. Authorization Request and Response .................41\n           4.4.2. Access Token Request ...............................41\n           4.4.3. Access Token Response ..............................42\n      4.5. Extension Grants ..........................................42\n\n\n\nHardt                        Standards Track                    [Page 2]\n\f\nRFC 6749                        OAuth 2.0                   October 2012"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_123",
        "original_index": 123,
        "content": "Hardt                        Standards Track                    [Page 2]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   5. Issuing an Access Token ........................................43\n      5.1. Successful Response .......................................43\n      5.2. Error Response ............................................45\n   6. Refreshing an Access Token .....................................47\n   7. Accessing Protected Resources ..................................48\n      7.1. Access Token Types ........................................49\n      7.2. Error Response ............................................49\n   8. Extensibility ..................................................50\n      8.1. Defining Access Token Types ...............................50\n      8.2. Defining New Endpoint Parameters ..........................50\n      8.3. Defining New Authorization Grant Types ....................51\n      8.4. Defining New Authorization Endpoint Response Types ........51\n      8.5. Defining Additional Error Codes ...........................51\n   9. Native Applications ............................................52\n   10. Security Considerations .......................................53\n      10.1. Client Authentication ....................................53\n      10.2. Client Impersonation .....................................54\n      10.3. Access Tokens ............................................55\n      10.4. Refresh Tokens ...........................................55\n      10.5. Authorization Codes ......................................56\n      10.6. Authorization Code Redirection URI Manipulation ..........56\n      10.7. Resource Owner Password Credentials ......................57\n      10.8. Request Confidentiality ..................................58\n      10.9. Ensuring Endpoint Authenticity ...........................58\n      10.10. Credentials-Guessing Attacks ............................58\n      10.11. Phishing Attacks ........................................58\n      10.12. Cross-Site Request Forgery ..............................59\n      10.13. Clickjacking ............................................60\n      10.14. Code Injection and Input Validation .....................60\n      10.15. Open Redirectors ........................................60\n      10.16. Misuse of Access Token to Impersonate Resource\n             Owner in Implicit Flow ..................................61\n   11. IANA Considerations ...........................................62\n      11.1. OAuth Access Token Types Registry ........................62\n           11.1.1. Registration Template .............................62\n      11.2. OAuth Parameters Registry ................................63\n           11.2.1. Registration Template .............................63\n           11.2.2. Initial Registry Contents .........................64\n      11.3. OAuth Authorization Endpoint Response Types Registry .....66\n           11.3.1. Registration Template .............................66\n           11.3.2. Initial Registry Contents .........................67\n      11.4. OAuth Extensions Error Registry ..........................67\n           11.4.1. Registration Template .............................68\n   12. References ....................................................68\n      12.1. Normative References .....................................68\n      12.2. Informative References ...................................70\n\n\n\n\n\nHardt                        Standards Track                    [Page 3]\n\f\nRFC 6749                        OAuth 2.0                   October 2012"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_124",
        "original_index": 124,
        "content": "Hardt                        Standards Track                    [Page 3]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Appendix A. Augmented Backus-Naur Form (ABNF) Syntax ..............71\n     A.1.  \"client_id\" Syntax ........................................71\n     A.2.  \"client_secret\" Syntax ....................................71\n     A.3.  \"response_type\" Syntax ....................................71\n     A.4.  \"scope\" Syntax ............................................72\n     A.5.  \"state\" Syntax ............................................72\n     A.6.  \"redirect_uri\" Syntax .....................................72\n     A.7.  \"error\" Syntax ............................................72\n     A.8.  \"error_description\" Syntax ................................72\n     A.9.  \"error_uri\" Syntax ........................................72\n     A.10. \"grant_type\" Syntax .......................................73\n     A.11. \"code\" Syntax .............................................73\n     A.12. \"access_token\" Syntax .....................................73\n     A.13. \"token_type\" Syntax .......................................73\n     A.14. \"expires_in\" Syntax .......................................73\n     A.15. \"username\" Syntax .........................................73\n     A.16. \"password\" Syntax .........................................73\n     A.17. \"refresh_token\" Syntax ....................................74\n     A.18. Endpoint Parameter Syntax .................................74\n   Appendix B. Use of application/x-www-form-urlencoded Media Type ...74\n   Appendix C. Acknowledgements ......................................75\n\n1.  Introduction\n\n   In the traditional client-server authentication model, the client\n   requests an access-restricted resource (protected resource) on the\n   server by authenticating with the server using the resource owner's\n   credentials.  In order to provide third-party applications access to\n   restricted resources, the resource owner shares its credentials with\n   the third party.  This creates several problems and limitations:\n\n   o  Third-party applications are required to store the resource\n      owner's credentials for future use, typically a password in\n      clear-text.\n\n   o  Servers are required to support password authentication, despite\n      the security weaknesses inherent in passwords.\n\n   o  Third-party applications gain overly broad access to the resource\n      owner's protected resources, leaving resource owners without any\n      ability to restrict duration or access to a limited subset of\n      resources.\n\n   o  Resource owners cannot revoke access to an individual third party\n      without revoking access to all third parties, and must do so by\n      changing the third party's password.\n\n\n\n\n\nHardt                        Standards Track                    [Page 4]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   o  Compromise of any third-party application results in compromise of\n      the end-user's password and all of the data protected by that\n      password.\n\n   OAuth addresses these issues by introducing an authorization layer\n   and separating the role of the client from that of the resource\n   owner.  In OAuth, the client requests access to resources controlled\n   by the resource owner and hosted by the resource server, and is\n   issued a different set of credentials than those of the resource\n   owner.\n\n   Instead of using the resource owner's credentials to access protected\n   resources, the client obtains an access token -- a string denoting a\n   specific scope, lifetime, and other access attributes.  Access tokens\n   are issued to third-party clients by an authorization server with the\n   approval of the resource owner.  The client uses the access token to\n   access the protected resources hosted by the resource server."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_125",
        "original_index": 125,
        "content": "For example, an end-user (resource owner) can grant a printing\n   service (client) access to her protected photos stored at a photo-\n   sharing service (resource server), without sharing her username and\n   password with the printing service.  Instead, she authenticates\n   directly with a server trusted by the photo-sharing service\n   (authorization server), which issues the printing service delegation-\n   specific credentials (access token).\n\n   This specification is designed for use with HTTP ([RFC2616]).  The\n   use of OAuth over any protocol other than HTTP is out of scope.\n\n   The OAuth 1.0 protocol ([RFC5849]), published as an informational\n   document, was the result of a small ad hoc community effort.  This\n   Standards Track specification builds on the OAuth 1.0 deployment\n   experience, as well as additional use cases and extensibility\n   requirements gathered from the wider IETF community.  The OAuth 2.0\n   protocol is not backward compatible with OAuth 1.0.  The two versions\n   may co-exist on the network, and implementations may choose to\n   support both.  However, it is the intention of this specification\n   that new implementations support OAuth 2.0 as specified in this\n   document and that OAuth 1.0 is used only to support existing\n   deployments.  The OAuth 2.0 protocol shares very few implementation\n   details with the OAuth 1.0 protocol.  Implementers familiar with\n   OAuth 1.0 should approach this document without any assumptions as to\n   its structure and details.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 5]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.1.  Roles\n\n   OAuth defines four roles:\n\n   resource owner\n      An entity capable of granting access to a protected resource.\n      When the resource owner is a person, it is referred to as an\n      end-user.\n\n   resource server\n      The server hosting the protected resources, capable of accepting\n      and responding to protected resource requests using access tokens.\n\n   client\n      An application making protected resource requests on behalf of the\n      resource owner and with its authorization.  The term \"client\" does\n      not imply any particular implementation characteristics (e.g.,\n      whether the application executes on a server, a desktop, or other\n      devices).\n\n   authorization server\n      The server issuing access tokens to the client after successfully\n      authenticating the resource owner and obtaining authorization.\n\n   The interaction between the authorization server and resource server\n   is beyond the scope of this specification.  The authorization server\n   may be the same server as the resource server or a separate entity.\n   A single authorization server may issue access tokens accepted by\n   multiple resource servers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 6]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.2.  Protocol Flow"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_126",
        "original_index": 126,
        "content": "Hardt                        Standards Track                    [Page 6]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.2.  Protocol Flow\n\n     +--------+                               +---------------+\n     |        |--(A)- Authorization Request ->|   Resource    |\n     |        |                               |     Owner     |\n     |        |<-(B)-- Authorization Grant ---|               |\n     |        |                               +---------------+\n     |        |\n     |        |                               +---------------+\n     |        |--(C)-- Authorization Grant -->| Authorization |\n     | Client |                               |     Server    |\n     |        |<-(D)----- Access Token -------|               |\n     |        |                               +---------------+\n     |        |\n     |        |                               +---------------+\n     |        |--(E)----- Access Token ------>|    Resource   |\n     |        |                               |     Server    |\n     |        |<-(F)--- Protected Resource ---|               |\n     +--------+                               +---------------+\n\n                     Figure 1: Abstract Protocol Flow\n\n   The abstract OAuth 2.0 flow illustrated in Figure 1 describes the\n   interaction between the four roles and includes the following steps:\n\n   (A)  The client requests authorization from the resource owner.  The\n        authorization request can be made directly to the resource owner\n        (as shown), or preferably indirectly via the authorization\n        server as an intermediary.\n\n   (B)  The client receives an authorization grant, which is a\n        credential representing the resource owner's authorization,\n        expressed using one of four grant types defined in this\n        specification or using an extension grant type.  The\n        authorization grant type depends on the method used by the\n        client to request authorization and the types supported by the\n        authorization server.\n\n   (C)  The client requests an access token by authenticating with the\n        authorization server and presenting the authorization grant.\n\n   (D)  The authorization server authenticates the client and validates\n        the authorization grant, and if valid, issues an access token.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                    [Page 7]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (E)  The client requests the protected resource from the resource\n        server and authenticates by presenting the access token.\n\n   (F)  The resource server validates the access token, and if valid,\n        serves the request.\n\n   The preferred method for the client to obtain an authorization grant\n   from the resource owner (depicted in steps (A) and (B)) is to use the\n   authorization server as an intermediary, which is illustrated in\n   Figure 3 in Section 4.1.\n\n1.3.  Authorization Grant\n\n   An authorization grant is a credential representing the resource\n   owner's authorization (to access its protected resources) used by the\n   client to obtain an access token.  This specification defines four\n   grant types -- authorization code, implicit, resource owner password\n   credentials, and client credentials -- as well as an extensibility\n   mechanism for defining additional types.\n\n1.3.1.  Authorization Code\n\n   The authorization code is obtained by using an authorization server\n   as an intermediary between the client and resource owner.  Instead of\n   requesting authorization directly from the resource owner, the client\n   directs the resource owner to an authorization server (via its\n   user-agent as defined in [RFC2616]), which in turn directs the\n   resource owner back to the client with the authorization code."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_127",
        "original_index": 127,
        "content": "Before directing the resource owner back to the client with the\n   authorization code, the authorization server authenticates the\n   resource owner and obtains authorization.  Because the resource owner\n   only authenticates with the authorization server, the resource\n   owner's credentials are never shared with the client.\n\n   The authorization code provides a few important security benefits,\n   such as the ability to authenticate the client, as well as the\n   transmission of the access token directly to the client without\n   passing it through the resource owner's user-agent and potentially\n   exposing it to others, including the resource owner.\n\n1.3.2.  Implicit\n\n   The implicit grant is a simplified authorization code flow optimized\n   for clients implemented in a browser using a scripting language such\n   as JavaScript.  In the implicit flow, instead of issuing the client\n   an authorization code, the client is issued an access token directly\n\n\n\n\nHardt                        Standards Track                    [Page 8]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (as the result of the resource owner authorization).  The grant type\n   is implicit, as no intermediate credentials (such as an authorization\n   code) are issued (and later used to obtain an access token).\n\n   When issuing an access token during the implicit grant flow, the\n   authorization server does not authenticate the client.  In some\n   cases, the client identity can be verified via the redirection URI\n   used to deliver the access token to the client.  The access token may\n   be exposed to the resource owner or other applications with access to\n   the resource owner's user-agent.\n\n   Implicit grants improve the responsiveness and efficiency of some\n   clients (such as a client implemented as an in-browser application),\n   since it reduces the number of round trips required to obtain an\n   access token.  However, this convenience should be weighed against\n   the security implications of using implicit grants, such as those\n   described in Sections 10.3 and 10.16, especially when the\n   authorization code grant type is available.\n\n1.3.3.  Resource Owner Password Credentials\n\n   The resource owner password credentials (i.e., username and password)\n   can be used directly as an authorization grant to obtain an access\n   token.  The credentials should only be used when there is a high\n   degree of trust between the resource owner and the client (e.g., the\n   client is part of the device operating system or a highly privileged\n   application), and when other authorization grant types are not\n   available (such as an authorization code).\n\n   Even though this grant type requires direct client access to the\n   resource owner credentials, the resource owner credentials are used\n   for a single request and are exchanged for an access token.  This\n   grant type can eliminate the need for the client to store the\n   resource owner credentials for future use, by exchanging the\n   credentials with a long-lived access token or refresh token.\n\n1.3.4.  Client Credentials\n\n   The client credentials (or other forms of client authentication) can\n   be used as an authorization grant when the authorization scope is\n   limited to the protected resources under the control of the client,\n   or to protected resources previously arranged with the authorization\n   server.  Client credentials are used as an authorization grant\n   typically when the client is acting on its own behalf (the client is\n   also the resource owner) or is requesting access to protected\n   resources based on an authorization previously arranged with the\n   authorization server.\n\n\n\n\nHardt                        Standards Track                    [Page 9]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.4.  Access Token"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_128",
        "original_index": 128,
        "content": "Hardt                        Standards Track                    [Page 9]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n1.4.  Access Token\n\n   Access tokens are credentials used to access protected resources.  An\n   access token is a string representing an authorization issued to the\n   client.  The string is usually opaque to the client.  Tokens\n   represent specific scopes and durations of access, granted by the\n   resource owner, and enforced by the resource server and authorization\n   server.\n\n   The token may denote an identifier used to retrieve the authorization\n   information or may self-contain the authorization information in a\n   verifiable manner (i.e., a token string consisting of some data and a\n   signature).  Additional authentication credentials, which are beyond\n   the scope of this specification, may be required in order for the\n   client to use a token.\n\n   The access token provides an abstraction layer, replacing different\n   authorization constructs (e.g., username and password) with a single\n   token understood by the resource server.  This abstraction enables\n   issuing access tokens more restrictive than the authorization grant\n   used to obtain them, as well as removing the resource server's need\n   to understand a wide range of authentication methods.\n\n   Access tokens can have different formats, structures, and methods of\n   utilization (e.g., cryptographic properties) based on the resource\n   server security requirements.  Access token attributes and the\n   methods used to access protected resources are beyond the scope of\n   this specification and are defined by companion specifications such\n   as [RFC6750].\n\n1.5.  Refresh Token\n\n   Refresh tokens are credentials used to obtain access tokens.  Refresh\n   tokens are issued to the client by the authorization server and are\n   used to obtain a new access token when the current access token\n   becomes invalid or expires, or to obtain additional access tokens\n   with identical or narrower scope (access tokens may have a shorter\n   lifetime and fewer permissions than authorized by the resource\n   owner).  Issuing a refresh token is optional at the discretion of the\n   authorization server.  If the authorization server issues a refresh\n   token, it is included when issuing an access token (i.e., step (D) in\n   Figure 1).\n\n   A refresh token is a string representing the authorization granted to\n   the client by the resource owner.  The string is usually opaque to\n   the client.  The token denotes an identifier used to retrieve the\n\n\n\n\n\nHardt                        Standards Track                   [Page 10]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   authorization information.  Unlike access tokens, refresh tokens are\n   intended for use only with authorization servers and are never sent\n   to resource servers."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_129",
        "original_index": 129,
        "content": "authorization information.  Unlike access tokens, refresh tokens are\n   intended for use only with authorization servers and are never sent\n   to resource servers.\n\n  +--------+                                           +---------------+\n  |        |--(A)------- Authorization Grant --------->|               |\n  |        |                                           |               |\n  |        |<-(B)----------- Access Token -------------|               |\n  |        |               & Refresh Token             |               |\n  |        |                                           |               |\n  |        |                            +----------+   |               |\n  |        |--(C)---- Access Token ---->|          |   |               |\n  |        |                            |          |   |               |\n  |        |<-(D)- Protected Resource --| Resource |   | Authorization |\n  | Client |                            |  Server  |   |     Server    |\n  |        |--(E)---- Access Token ---->|          |   |               |\n  |        |                            |          |   |               |\n  |        |<-(F)- Invalid Token Error -|          |   |               |\n  |        |                            +----------+   |               |\n  |        |                                           |               |\n  |        |--(G)----------- Refresh Token ----------->|               |\n  |        |                                           |               |\n  |        |<-(H)----------- Access Token -------------|               |\n  +--------+           & Optional Refresh Token        +---------------+\n\n               Figure 2: Refreshing an Expired Access Token\n\n   The flow illustrated in Figure 2 includes the following steps:\n\n   (A)  The client requests an access token by authenticating with the\n        authorization server and presenting an authorization grant.\n\n   (B)  The authorization server authenticates the client and validates\n        the authorization grant, and if valid, issues an access token\n        and a refresh token.\n\n   (C)  The client makes a protected resource request to the resource\n        server by presenting the access token.\n\n   (D)  The resource server validates the access token, and if valid,\n        serves the request.\n\n   (E)  Steps (C) and (D) repeat until the access token expires.  If the\n        client knows the access token expired, it skips to step (G);\n        otherwise, it makes another protected resource request.\n\n   (F)  Since the access token is invalid, the resource server returns\n        an invalid token error.\n\n\n\nHardt                        Standards Track                   [Page 11]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   (G)  The client requests a new access token by authenticating with\n        the authorization server and presenting the refresh token.  The\n        client authentication requirements are based on the client type\n        and on the authorization server policies.\n\n   (H)  The authorization server authenticates the client and validates\n        the refresh token, and if valid, issues a new access token (and,\n        optionally, a new refresh token).\n\n   Steps (C), (D), (E), and (F) are outside the scope of this\n   specification, as described in Section 7.\n\n1.6.  TLS Version\n\n   Whenever Transport Layer Security (TLS) is used by this\n   specification, the appropriate version (or versions) of TLS will vary\n   over time, based on the widespread deployment and known security\n   vulnerabilities.  At the time of this writing, TLS version 1.2\n   [RFC5246] is the most recent version, but has a very limited\n   deployment base and might not be readily available for\n   implementation.  TLS version 1.0 [RFC2246] is the most widely\n   deployed version and will provide the broadest interoperability.\n\n   Implementations MAY also support additional transport-layer security\n   mechanisms that meet their security requirements."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_130",
        "original_index": 130,
        "content": "Implementations MAY also support additional transport-layer security\n   mechanisms that meet their security requirements.\n\n1.7.  HTTP Redirections\n\n   This specification makes extensive use of HTTP redirections, in which\n   the client or the authorization server directs the resource owner's\n   user-agent to another destination.  While the examples in this\n   specification show the use of the HTTP 302 status code, any other\n   method available via the user-agent to accomplish this redirection is\n   allowed and is considered to be an implementation detail.\n\n1.8.  Interoperability\n\n   OAuth 2.0 provides a rich authorization framework with well-defined\n   security properties.  However, as a rich and highly extensible\n   framework with many optional components, on its own, this\n   specification is likely to produce a wide range of non-interoperable\n   implementations.\n\n   In addition, this specification leaves a few required components\n   partially or fully undefined (e.g., client registration,\n   authorization server capabilities, endpoint discovery).  Without\n\n\n\n\n\nHardt                        Standards Track                   [Page 12]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   these components, clients must be manually and specifically\n   configured against a specific authorization server and resource\n   server in order to interoperate.\n\n   This framework was designed with the clear expectation that future\n   work will define prescriptive profiles and extensions necessary to\n   achieve full web-scale interoperability.\n\n1.9.  Notational Conventions\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   specification are to be interpreted as described in [RFC2119].\n\n   This specification uses the Augmented Backus-Naur Form (ABNF)\n   notation of [RFC5234].  Additionally, the rule URI-reference is\n   included from \"Uniform Resource Identifier (URI): Generic Syntax\"\n   [RFC3986].\n\n   Certain security-related terms are to be understood in the sense\n   defined in [RFC4949].  These terms include, but are not limited to,\n   \"attack\", \"authentication\", \"authorization\", \"certificate\",\n   \"confidentiality\", \"credential\", \"encryption\", \"identity\", \"sign\",\n   \"signature\", \"trust\", \"validate\", and \"verify\".\n\n   Unless otherwise noted, all the protocol parameter names and values\n   are case sensitive.\n\n2.  Client Registration\n\n   Before initiating the protocol, the client registers with the\n   authorization server.  The means through which the client registers\n   with the authorization server are beyond the scope of this\n   specification but typically involve end-user interaction with an HTML\n   registration form.\n\n   Client registration does not require a direct interaction between the\n   client and the authorization server.  When supported by the\n   authorization server, registration can rely on other means for\n   establishing trust and obtaining the required client properties\n   (e.g., redirection URI, client type).  For example, registration can\n   be accomplished using a self-issued or third-party-issued assertion,\n   or by the authorization server performing client discovery using a\n   trusted channel.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 13]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   When registering a client, the client developer SHALL:\n\n   o  specify the client type as described in Section 2.1,\n\n   o  provide its client redirection URIs as described in Section 3.1.2,\n      and\n\n   o  include any other information required by the authorization server\n      (e.g., application name, website, description, logo image, the\n      acceptance of legal terms).\n\n2.1.  Client Types"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_131",
        "original_index": 131,
        "content": "o  include any other information required by the authorization server\n      (e.g., application name, website, description, logo image, the\n      acceptance of legal terms).\n\n2.1.  Client Types\n\n   OAuth defines two client types, based on their ability to\n   authenticate securely with the authorization server (i.e., ability to\n   maintain the confidentiality of their client credentials):\n\n   confidential\n      Clients capable of maintaining the confidentiality of their\n      credentials (e.g., client implemented on a secure server with\n      restricted access to the client credentials), or capable of secure\n      client authentication using other means.\n\n   public\n      Clients incapable of maintaining the confidentiality of their\n      credentials (e.g., clients executing on the device used by the\n      resource owner, such as an installed native application or a web\n      browser-based application), and incapable of secure client\n      authentication via any other means.\n\n   The client type designation is based on the authorization server's\n   definition of secure authentication and its acceptable exposure\n   levels of client credentials.  The authorization server SHOULD NOT\n   make assumptions about the client type.\n\n   A client may be implemented as a distributed set of components, each\n   with a different client type and security context (e.g., a\n   distributed client with both a confidential server-based component\n   and a public browser-based component).  If the authorization server\n   does not provide support for such clients or does not provide\n   guidance with regard to their registration, the client SHOULD\n   register each component as a separate client.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 14]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   This specification has been designed around the following client\n   profiles:\n\n   web application\n      A web application is a confidential client running on a web\n      server.  Resource owners access the client via an HTML user\n      interface rendered in a user-agent on the device used by the\n      resource owner.  The client credentials as well as any access\n      token issued to the client are stored on the web server and are\n      not exposed to or accessible by the resource owner.\n\n   user-agent-based application\n      A user-agent-based application is a public client in which the\n      client code is downloaded from a web server and executes within a\n      user-agent (e.g., web browser) on the device used by the resource\n      owner.  Protocol data and credentials are easily accessible (and\n      often visible) to the resource owner.  Since such applications\n      reside within the user-agent, they can make seamless use of the\n      user-agent capabilities when requesting authorization.\n\n   native application\n      A native application is a public client installed and executed on\n      the device used by the resource owner.  Protocol data and\n      credentials are accessible to the resource owner.  It is assumed\n      that any client authentication credentials included in the\n      application can be extracted.  On the other hand, dynamically\n      issued credentials such as access tokens or refresh tokens can\n      receive an acceptable level of protection.  At a minimum, these\n      credentials are protected from hostile servers with which the\n      application may interact.  On some platforms, these credentials\n      might be protected from other applications residing on the same\n      device.\n\n2.2.  Client Identifier\n\n   The authorization server issues the registered client a client\n   identifier -- a unique string representing the registration\n   information provided by the client.  The client identifier is not a\n   secret; it is exposed to the resource owner and MUST NOT be used\n   alone for client authentication.  The client identifier is unique to\n   the authorization server."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_132",
        "original_index": 132,
        "content": "The client identifier string size is left undefined by this\n   specification.  The client should avoid making assumptions about the\n   identifier size.  The authorization server SHOULD document the size\n   of any identifier it issues.\n\n\n\n\n\nHardt                        Standards Track                   [Page 15]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n2.3.  Client Authentication\n\n   If the client type is confidential, the client and authorization\n   server establish a client authentication method suitable for the\n   security requirements of the authorization server.  The authorization\n   server MAY accept any form of client authentication meeting its\n   security requirements.\n\n   Confidential clients are typically issued (or establish) a set of\n   client credentials used for authenticating with the authorization\n   server (e.g., password, public/private key pair).\n\n   The authorization server MAY establish a client authentication method\n   with public clients.  However, the authorization server MUST NOT rely\n   on public client authentication for the purpose of identifying the\n   client.\n\n   The client MUST NOT use more than one authentication method in each\n   request.\n\n2.3.1.  Client Password\n\n   Clients in possession of a client password MAY use the HTTP Basic\n   authentication scheme as defined in [RFC2617] to authenticate with\n   the authorization server.  The client identifier is encoded using the\n   \"application/x-www-form-urlencoded\" encoding algorithm per\n   Appendix B, and the encoded value is used as the username; the client\n   password is encoded using the same algorithm and used as the\n   password.  The authorization server MUST support the HTTP Basic\n   authentication scheme for authenticating clients that were issued a\n   client password.\n\n   For example (with extra line breaks for display purposes only):\n\n     Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n\n   Alternatively, the authorization server MAY support including the\n   client credentials in the request-body using the following\n   parameters:\n\n   client_id\n         REQUIRED.  The client identifier issued to the client during\n         the registration process described by Section 2.2.\n\n   client_secret\n         REQUIRED.  The client secret.  The client MAY omit the\n         parameter if the client secret is an empty string.\n\n\n\n\nHardt                        Standards Track                   [Page 16]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Including the client credentials in the request-body using the two\n   parameters is NOT RECOMMENDED and SHOULD be limited to clients unable\n   to directly utilize the HTTP Basic authentication scheme (or other\n   password-based HTTP authentication schemes).  The parameters can only\n   be transmitted in the request-body and MUST NOT be included in the\n   request URI.\n\n   For example, a request to refresh an access token (Section 6) using\n   the body parameters (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n     &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n\n   The authorization server MUST require the use of TLS as described in\n   Section 1.6 when sending requests using password authentication.\n\n   Since this client authentication method involves a password, the\n   authorization server MUST protect any endpoint utilizing it against\n   brute force attacks.\n\n2.3.2.  Other Authentication Methods\n\n   The authorization server MAY support any suitable HTTP authentication\n   scheme matching its security requirements.  When using other\n   authentication methods, the authorization server MUST define a\n   mapping between the client identifier (registration record) and\n   authentication scheme.\n\n2.4.  Unregistered Clients"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_133",
        "original_index": 133,
        "content": "2.4.  Unregistered Clients\n\n   This specification does not exclude the use of unregistered clients.\n   However, the use of such clients is beyond the scope of this\n   specification and requires additional security analysis and review of\n   its interoperability impact.\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 17]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.  Protocol Endpoints\n\n   The authorization process utilizes two authorization server endpoints\n   (HTTP resources):\n\n   o  Authorization endpoint - used by the client to obtain\n      authorization from the resource owner via user-agent redirection.\n\n   o  Token endpoint - used by the client to exchange an authorization\n      grant for an access token, typically with client authentication.\n\n   As well as one client endpoint:\n\n   o  Redirection endpoint - used by the authorization server to return\n      responses containing authorization credentials to the client via\n      the resource owner user-agent.\n\n   Not every authorization grant type utilizes both endpoints.\n   Extension grant types MAY define additional endpoints as needed.\n\n3.1.  Authorization Endpoint\n\n   The authorization endpoint is used to interact with the resource\n   owner and obtain an authorization grant.  The authorization server\n   MUST first verify the identity of the resource owner.  The way in\n   which the authorization server authenticates the resource owner\n   (e.g., username and password login, session cookies) is beyond the\n   scope of this specification.\n\n   The means through which the client obtains the location of the\n   authorization endpoint are beyond the scope of this specification,\n   but the location is typically provided in the service documentation.\n\n   The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n   formatted (per Appendix B) query component ([RFC3986] Section 3.4),\n   which MUST be retained when adding additional query parameters.  The\n   endpoint URI MUST NOT include a fragment component.\n\n   Since requests to the authorization endpoint result in user\n   authentication and the transmission of clear-text credentials (in the\n   HTTP response), the authorization server MUST require the use of TLS\n   as described in Section 1.6 when sending requests to the\n   authorization endpoint.\n\n   The authorization server MUST support the use of the HTTP \"GET\"\n   method [RFC2616] for the authorization endpoint and MAY support the\n   use of the \"POST\" method as well.\n\n\n\n\nHardt                        Standards Track                   [Page 18]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Parameters sent without a value MUST be treated as if they were\n   omitted from the request.  The authorization server MUST ignore\n   unrecognized request parameters.  Request and response parameters\n   MUST NOT be included more than once.\n\n3.1.1.  Response Type\n\n   The authorization endpoint is used by the authorization code grant\n   type and implicit grant type flows.  The client informs the\n   authorization server of the desired grant type using the following\n   parameter:\n\n   response_type\n         REQUIRED.  The value MUST be one of \"code\" for requesting an\n         authorization code as described by Section 4.1.1, \"token\" for\n         requesting an access token (implicit grant) as described by\n         Section 4.2.1, or a registered extension value as described by\n         Section 8.4.\n\n   Extension response types MAY contain a space-delimited (%x20) list of\n   values, where the order of values does not matter (e.g., response\n   type \"a b\" is the same as \"b a\").  The meaning of such composite\n   response types is defined by their respective specifications.\n\n   If an authorization request is missing the \"response_type\" parameter,\n   or if the response type is not understood, the authorization server\n   MUST return an error response as described in Section 4.1.2.1."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_134",
        "original_index": 134,
        "content": "3.1.2.  Redirection Endpoint\n\n   After completing its interaction with the resource owner, the\n   authorization server directs the resource owner's user-agent back to\n   the client.  The authorization server redirects the user-agent to the\n   client's redirection endpoint previously established with the\n   authorization server during the client registration process or when\n   making the authorization request.\n\n   The redirection endpoint URI MUST be an absolute URI as defined by\n   [RFC3986] Section 4.3.  The endpoint URI MAY include an\n   \"application/x-www-form-urlencoded\" formatted (per Appendix B) query\n   component ([RFC3986] Section 3.4), which MUST be retained when adding\n   additional query parameters.  The endpoint URI MUST NOT include a\n   fragment component.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 19]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.1.2.1.  Endpoint Request Confidentiality\n\n   The redirection endpoint SHOULD require the use of TLS as described\n   in Section 1.6 when the requested response type is \"code\" or \"token\",\n   or when the redirection request will result in the transmission of\n   sensitive credentials over an open network.  This specification does\n   not mandate the use of TLS because at the time of this writing,\n   requiring clients to deploy TLS is a significant hurdle for many\n   client developers.  If TLS is not available, the authorization server\n   SHOULD warn the resource owner about the insecure endpoint prior to\n   redirection (e.g., display a message during the authorization\n   request).\n\n   Lack of transport-layer security can have a severe impact on the\n   security of the client and the protected resources it is authorized\n   to access.  The use of transport-layer security is particularly\n   critical when the authorization process is used as a form of\n   delegated end-user authentication by the client (e.g., third-party\n   sign-in service).\n\n3.1.2.2.  Registration Requirements\n\n   The authorization server MUST require the following clients to\n   register their redirection endpoint:\n\n   o  Public clients.\n\n   o  Confidential clients utilizing the implicit grant type.\n\n   The authorization server SHOULD require all clients to register their\n   redirection endpoint prior to utilizing the authorization endpoint.\n\n   The authorization server SHOULD require the client to provide the\n   complete redirection URI (the client MAY use the \"state\" request\n   parameter to achieve per-request customization).  If requiring the\n   registration of the complete redirection URI is not possible, the\n   authorization server SHOULD require the registration of the URI\n   scheme, authority, and path (allowing the client to dynamically vary\n   only the query component of the redirection URI when requesting\n   authorization).\n\n   The authorization server MAY allow the client to register multiple\n   redirection endpoints.\n\n   Lack of a redirection URI registration requirement can enable an\n   attacker to use the authorization endpoint as an open redirector as\n   described in Section 10.15.\n\n\n\n\nHardt                        Standards Track                   [Page 20]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n3.1.2.3.  Dynamic Configuration\n\n   If multiple redirection URIs have been registered, if only part of\n   the redirection URI has been registered, or if no redirection URI has\n   been registered, the client MUST include a redirection URI with the\n   authorization request using the \"redirect_uri\" request parameter."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_135",
        "original_index": 135,
        "content": "When a redirection URI is included in an authorization request, the\n   authorization server MUST compare and match the value received\n   against at least one of the registered redirection URIs (or URI\n   components) as defined in [RFC3986] Section 6, if any redirection\n   URIs were registered.  If the client registration included the full\n   redirection URI, the authorization server MUST compare the two URIs\n   using simple string comparison as defined in [RFC3986] Section 6.2.1.\n\n3.1.2.4.  Invalid Endpoint\n\n   If an authorization request fails validation due to a missing,\n   invalid, or mismatching redirection URI, the authorization server\n   SHOULD inform the resource owner of the error and MUST NOT\n   automatically redirect the user-agent to the invalid redirection URI.\n\n3.1.2.5.  Endpoint Content\n\n   The redirection request to the client's endpoint typically results in\n   an HTML document response, processed by the user-agent.  If the HTML\n   response is served directly as the result of the redirection request,\n   any script included in the HTML document will execute with full\n   access to the redirection URI and the credentials it contains.\n\n   The client SHOULD NOT include any third-party scripts (e.g., third-\n   party analytics, social plug-ins, ad networks) in the redirection\n   endpoint response.  Instead, it SHOULD extract the credentials from\n   the URI and redirect the user-agent again to another endpoint without\n   exposing the credentials (in the URI or elsewhere).  If third-party\n   scripts are included, the client MUST ensure that its own scripts\n   (used to extract and remove the credentials from the URI) will\n   execute first.\n\n3.2.  Token Endpoint\n\n   The token endpoint is used by the client to obtain an access token by\n   presenting its authorization grant or refresh token.  The token\n   endpoint is used with every authorization grant except for the\n   implicit grant type (since an access token is issued directly).\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 21]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The means through which the client obtains the location of the token\n   endpoint are beyond the scope of this specification, but the location\n   is typically provided in the service documentation.\n\n   The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n   formatted (per Appendix B) query component ([RFC3986] Section 3.4),\n   which MUST be retained when adding additional query parameters.  The\n   endpoint URI MUST NOT include a fragment component.\n\n   Since requests to the token endpoint result in the transmission of\n   clear-text credentials (in the HTTP request and response), the\n   authorization server MUST require the use of TLS as described in\n   Section 1.6 when sending requests to the token endpoint.\n\n   The client MUST use the HTTP \"POST\" method when making access token\n   requests.\n\n   Parameters sent without a value MUST be treated as if they were\n   omitted from the request.  The authorization server MUST ignore\n   unrecognized request parameters.  Request and response parameters\n   MUST NOT be included more than once.\n\n3.2.1.  Client Authentication\n\n   Confidential clients or other clients issued client credentials MUST\n   authenticate with the authorization server as described in\n   Section 2.3 when making requests to the token endpoint.  Client\n   authentication is used for:\n\n   o  Enforcing the binding of refresh tokens and authorization codes to\n      the client they were issued to.  Client authentication is critical\n      when an authorization code is transmitted to the redirection\n      endpoint over an insecure channel or when the redirection URI has\n      not been registered in full."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_136",
        "original_index": 136,
        "content": "o  Recovering from a compromised client by disabling the client or\n      changing its credentials, thus preventing an attacker from abusing\n      stolen refresh tokens.  Changing a single set of client\n      credentials is significantly faster than revoking an entire set of\n      refresh tokens.\n\n   o  Implementing authentication management best practices, which\n      require periodic credential rotation.  Rotation of an entire set\n      of refresh tokens can be challenging, while rotation of a single\n      set of client credentials is significantly easier.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 22]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   A client MAY use the \"client_id\" request parameter to identify itself\n   when sending requests to the token endpoint.  In the\n   \"authorization_code\" \"grant_type\" request to the token endpoint, an\n   unauthenticated client MUST send its \"client_id\" to prevent itself\n   from inadvertently accepting a code intended for a client with a\n   different \"client_id\".  This protects the client from substitution of\n   the authentication code.  (It provides no additional security for the\n   protected resource.)\n\n3.3.  Access Token Scope\n\n   The authorization and token endpoints allow the client to specify the\n   scope of the access request using the \"scope\" request parameter.  In\n   turn, the authorization server uses the \"scope\" response parameter to\n   inform the client of the scope of the access token issued.\n\n   The value of the scope parameter is expressed as a list of space-\n   delimited, case-sensitive strings.  The strings are defined by the\n   authorization server.  If the value contains multiple space-delimited\n   strings, their order does not matter, and each string adds an\n   additional access range to the requested scope.\n\n     scope       = scope-token *( SP scope-token )\n     scope-token = 1*( %x21 / %x23-5B / %x5D-7E )\n\n   The authorization server MAY fully or partially ignore the scope\n   requested by the client, based on the authorization server policy or\n   the resource owner's instructions.  If the issued access token scope\n   is different from the one requested by the client, the authorization\n   server MUST include the \"scope\" response parameter to inform the\n   client of the actual scope granted.\n\n   If the client omits the scope parameter when requesting\n   authorization, the authorization server MUST either process the\n   request using a pre-defined default value or fail the request\n   indicating an invalid scope.  The authorization server SHOULD\n   document its scope requirements and default value (if defined).\n\n4.  Obtaining Authorization\n\n   To request an access token, the client obtains authorization from the\n   resource owner.  The authorization is expressed in the form of an\n   authorization grant, which the client uses to request the access\n   token.  OAuth defines four grant types: authorization code, implicit,\n   resource owner password credentials, and client credentials.  It also\n   provides an extension mechanism for defining additional grant types.\n\n\n\n\n\nHardt                        Standards Track                   [Page 23]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.1.  Authorization Code Grant\n\n   The authorization code grant type is used to obtain both access\n   tokens and refresh tokens and is optimized for confidential clients.\n   Since this is a redirection-based flow, the client must be capable of\n   interacting with the resource owner's user-agent (typically a web\n   browser) and capable of receiving incoming requests (via redirection)\n   from the authorization server."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_137",
        "original_index": 137,
        "content": "+----------+\n     | Resource |\n     |   Owner  |\n     |          |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier      +---------------+\n     |         -+----(A)-- & Redirection URI ---->|               |\n     |  User-   |                                 | Authorization |\n     |  Agent  -+----(B)-- User authenticates --->|     Server    |\n     |          |                                 |               |\n     |         -+----(C)-- Authorization Code ---<|               |\n     +-|----|---+                                 +---------------+\n       |    |                                         ^      v\n      (A)  (C)                                        |      |\n       |    |                                         |      |\n       ^    v                                         |      |\n     +---------+                                      |      |\n     |         |>---(D)-- Authorization Code ---------'      |\n     |  Client |          & Redirection URI                  |\n     |         |                                             |\n     |         |<---(E)----- Access Token -------------------'\n     +---------+       (w/ Optional Refresh Token)\n\n   Note: The lines illustrating steps (A), (B), and (C) are broken into\n   two parts as they pass through the user-agent.\n\n                     Figure 3: Authorization Code Flow\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 24]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The flow illustrated in Figure 3 includes the following steps:\n\n   (A)  The client initiates the flow by directing the resource owner's\n        user-agent to the authorization endpoint.  The client includes\n        its client identifier, requested scope, local state, and a\n        redirection URI to which the authorization server will send the\n        user-agent back once access is granted (or denied).\n\n   (B)  The authorization server authenticates the resource owner (via\n        the user-agent) and establishes whether the resource owner\n        grants or denies the client's access request.\n\n   (C)  Assuming the resource owner grants access, the authorization\n        server redirects the user-agent back to the client using the\n        redirection URI provided earlier (in the request or during\n        client registration).  The redirection URI includes an\n        authorization code and any local state provided by the client\n        earlier.\n\n   (D)  The client requests an access token from the authorization\n        server's token endpoint by including the authorization code\n        received in the previous step.  When making the request, the\n        client authenticates with the authorization server.  The client\n        includes the redirection URI used to obtain the authorization\n        code for verification.\n\n   (E)  The authorization server authenticates the client, validates the\n        authorization code, and ensures that the redirection URI\n        received matches the URI used to redirect the client in\n        step (C).  If valid, the authorization server responds back with\n        an access token and, optionally, a refresh token.\n\n4.1.1.  Authorization Request\n\n   The client constructs the request URI by adding the following\n   parameters to the query component of the authorization endpoint URI\n   using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   response_type\n         REQUIRED.  Value MUST be set to \"code\".\n\n   client_id\n         REQUIRED.  The client identifier as described in Section 2.2.\n\n   redirect_uri\n         OPTIONAL.  As described in Section 3.1.2.\n\n\n\n\n\nHardt                        Standards Track                   [Page 25]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_138",
        "original_index": 138,
        "content": "scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   state\n         RECOMMENDED.  An opaque value used by the client to maintain\n         state between the request and callback.  The authorization\n         server includes this value when redirecting the user-agent back\n         to the client.  The parameter SHOULD be used for preventing\n         cross-site request forgery as described in Section 10.12.\n\n   The client directs the resource owner to the constructed URI using an\n   HTTP redirection response, or by other means available to it via the\n   user-agent.\n\n   For example, the client directs the user-agent to make the following\n   HTTP request using TLS (with extra line breaks for display purposes\n   only):\n\n    GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n    Host: server.example.com\n\n   The authorization server validates the request to ensure that all\n   required parameters are present and valid.  If the request is valid,\n   the authorization server authenticates the resource owner and obtains\n   an authorization decision (by asking the resource owner or by\n   establishing approval via other means).\n\n   When a decision is established, the authorization server directs the\n   user-agent to the provided client redirection URI using an HTTP\n   redirection response, or by other means available to it via the\n   user-agent.\n\n4.1.2.  Authorization Response\n\n   If the resource owner grants the access request, the authorization\n   server issues an authorization code and delivers it to the client by\n   adding the following parameters to the query component of the\n   redirection URI using the \"application/x-www-form-urlencoded\" format,\n   per Appendix B:\n\n   code\n         REQUIRED.  The authorization code generated by the\n         authorization server.  The authorization code MUST expire\n         shortly after it is issued to mitigate the risk of leaks.  A\n         maximum authorization code lifetime of 10 minutes is\n         RECOMMENDED.  The client MUST NOT use the authorization code\n\n\n\nHardt                        Standards Track                   [Page 26]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         more than once.  If an authorization code is used more than\n         once, the authorization server MUST deny the request and SHOULD\n         revoke (when possible) all tokens previously issued based on\n         that authorization code.  The authorization code is bound to\n         the client identifier and redirection URI.\n\n   state\n         REQUIRED if the \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n     HTTP/1.1 302 Found\n     Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n               &state=xyz\n\n   The client MUST ignore unrecognized response parameters.  The\n   authorization code string size is left undefined by this\n   specification.  The client should avoid making assumptions about code\n   value sizes.  The authorization server SHOULD document the size of\n   any value it issues.\n\n4.1.2.1.  Error Response\n\n   If the request fails due to a missing, invalid, or mismatching\n   redirection URI, or if the client identifier is missing or invalid,\n   the authorization server SHOULD inform the resource owner of the\n   error and MUST NOT automatically redirect the user-agent to the\n   invalid redirection URI."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_139",
        "original_index": 139,
        "content": "If the resource owner denies the access request or if the request\n   fails for reasons other than a missing or invalid redirection URI,\n   the authorization server informs the client by adding the following\n   parameters to the query component of the redirection URI using the\n   \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               invalid parameter value, includes a parameter more than\n               once, or is otherwise malformed.\n\n\n\n\n\nHardt                        Standards Track                   [Page 27]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         unauthorized_client\n               The client is not authorized to request an authorization\n               code using this method.\n\n         access_denied\n               The resource owner or authorization server denied the\n               request.\n\n         unsupported_response_type\n               The authorization server does not support obtaining an\n               authorization code using this method.\n\n         invalid_scope\n               The requested scope is invalid, unknown, or malformed.\n\n         server_error\n               The authorization server encountered an unexpected\n               condition that prevented it from fulfilling the request.\n               (This error code is needed because a 500 Internal Server\n               Error HTTP status code cannot be returned to the client\n               via an HTTP redirect.)\n\n         temporarily_unavailable\n               The authorization server is currently unable to handle\n               the request due to a temporary overloading or maintenance\n               of the server.  (This error code is needed because a 503\n               Service Unavailable HTTP status code cannot be returned\n               to the client via an HTTP redirect.)\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n\n\n\n\nHardt                        Standards Track                   [Page 28]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   state\n         REQUIRED if a \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n   HTTP/1.1 302 Found\n   Location: https://client.example.com/cb?error=access_denied&state=xyz\n\n4.1.3.  Access Token Request\n\n   The client makes a request to the token endpoint by sending the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"authorization_code\".\n\n   code\n         REQUIRED.  The authorization code received from the\n         authorization server."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_140",
        "original_index": 140,
        "content": "grant_type\n         REQUIRED.  Value MUST be set to \"authorization_code\".\n\n   code\n         REQUIRED.  The authorization code received from the\n         authorization server.\n\n   redirect_uri\n         REQUIRED, if the \"redirect_uri\" parameter was included in the\n         authorization request as described in Section 4.1.1, and their\n         values MUST be identical.\n\n   client_id\n         REQUIRED, if the client is not authenticating with the\n         authorization server as described in Section 3.2.1.\n\n   If the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 29]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, the client makes the following HTTP request using TLS\n   (with extra line breaks for display purposes only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n     &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included,\n\n   o  ensure that the authorization code was issued to the authenticated\n      confidential client, or if the client is public, ensure that the\n      code was issued to \"client_id\" in the request,\n\n   o  verify that the authorization code is valid, and\n\n   o  ensure that the \"redirect_uri\" parameter is present if the\n      \"redirect_uri\" parameter was included in the initial authorization\n      request as described in Section 4.1.1, and if included ensure that\n      their values are identical.\n\n4.1.4.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request client\n   authentication failed or is invalid, the authorization server returns\n   an error response as described in Section 5.2.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 30]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n4.2.  Implicit Grant\n\n   The implicit grant type is used to obtain access tokens (it does not\n   support the issuance of refresh tokens) and is optimized for public\n   clients known to operate a particular redirection URI.  These clients\n   are typically implemented in a browser using a scripting language\n   such as JavaScript.\n\n   Since this is a redirection-based flow, the client must be capable of\n   interacting with the resource owner's user-agent (typically a web\n   browser) and capable of receiving incoming requests (via redirection)\n   from the authorization server.\n\n   Unlike the authorization code grant type, in which the client makes\n   separate requests for authorization and for an access token, the\n   client receives the access token as the result of the authorization\n   request."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_141",
        "original_index": 141,
        "content": "The implicit grant type does not include client authentication, and\n   relies on the presence of the resource owner and the registration of\n   the redirection URI.  Because the access token is encoded into the\n   redirection URI, it may be exposed to the resource owner and other\n   applications residing on the same device.\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 31]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n     +----------+\n     | Resource |\n     |  Owner   |\n     |          |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier     +---------------+\n     |         -+----(A)-- & Redirection URI --->|               |\n     |  User-   |                                | Authorization |\n     |  Agent  -|----(B)-- User authenticates -->|     Server    |\n     |          |                                |               |\n     |          |<---(C)--- Redirection URI ----<|               |\n     |          |          with Access Token     +---------------+\n     |          |            in Fragment\n     |          |                                +---------------+\n     |          |----(D)--- Redirection URI ---->|   Web-Hosted  |\n     |          |          without Fragment      |     Client    |\n     |          |                                |    Resource   |\n     |     (F)  |<---(E)------- Script ---------<|               |\n     |          |                                +---------------+\n     +-|--------+\n       |    |\n      (A)  (G) Access Token\n       |    |\n       ^    v\n     +---------+\n     |         |\n     |  Client |\n     |         |\n     +---------+\n\n   Note: The lines illustrating steps (A) and (B) are broken into two\n   parts as they pass through the user-agent.\n\n                       Figure 4: Implicit Grant Flow\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 32]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The flow illustrated in Figure 4 includes the following steps:\n\n   (A)  The client initiates the flow by directing the resource owner's\n        user-agent to the authorization endpoint.  The client includes\n        its client identifier, requested scope, local state, and a\n        redirection URI to which the authorization server will send the\n        user-agent back once access is granted (or denied).\n\n   (B)  The authorization server authenticates the resource owner (via\n        the user-agent) and establishes whether the resource owner\n        grants or denies the client's access request.\n\n   (C)  Assuming the resource owner grants access, the authorization\n        server redirects the user-agent back to the client using the\n        redirection URI provided earlier.  The redirection URI includes\n        the access token in the URI fragment.\n\n   (D)  The user-agent follows the redirection instructions by making a\n        request to the web-hosted client resource (which does not\n        include the fragment per [RFC2616]).  The user-agent retains the\n        fragment information locally.\n\n   (E)  The web-hosted client resource returns a web page (typically an\n        HTML document with an embedded script) capable of accessing the\n        full redirection URI including the fragment retained by the\n        user-agent, and extracting the access token (and other\n        parameters) contained in the fragment.\n\n   (F)  The user-agent executes the script provided by the web-hosted\n        client resource locally, which extracts the access token.\n\n   (G)  The user-agent passes the access token to the client.\n\n   See Sections 1.3.2 and 9 for background on using the implicit grant.\n   See Sections 10.3 and 10.16 for important security considerations\n   when using the implicit grant.\n\n4.2.1.  Authorization Request"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_142",
        "original_index": 142,
        "content": "4.2.1.  Authorization Request\n\n   The client constructs the request URI by adding the following\n   parameters to the query component of the authorization endpoint URI\n   using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   response_type\n         REQUIRED.  Value MUST be set to \"token\".\n\n   client_id\n         REQUIRED.  The client identifier as described in Section 2.2.\n\n\n\nHardt                        Standards Track                   [Page 33]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   redirect_uri\n         OPTIONAL.  As described in Section 3.1.2.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   state\n         RECOMMENDED.  An opaque value used by the client to maintain\n         state between the request and callback.  The authorization\n         server includes this value when redirecting the user-agent back\n         to the client.  The parameter SHOULD be used for preventing\n         cross-site request forgery as described in Section 10.12.\n\n   The client directs the resource owner to the constructed URI using an\n   HTTP redirection response, or by other means available to it via the\n   user-agent.\n\n   For example, the client directs the user-agent to make the following\n   HTTP request using TLS (with extra line breaks for display purposes\n   only):\n\n    GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz\n        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n    Host: server.example.com\n\n   The authorization server validates the request to ensure that all\n   required parameters are present and valid.  The authorization server\n   MUST verify that the redirection URI to which it will redirect the\n   access token matches a redirection URI registered by the client as\n   described in Section 3.1.2.\n\n   If the request is valid, the authorization server authenticates the\n   resource owner and obtains an authorization decision (by asking the\n   resource owner or by establishing approval via other means).\n\n   When a decision is established, the authorization server directs the\n   user-agent to the provided client redirection URI using an HTTP\n   redirection response, or by other means available to it via the\n   user-agent.\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 34]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.2.2.  Access Token Response\n\n   If the resource owner grants the access request, the authorization\n   server issues an access token and delivers it to the client by adding\n   the following parameters to the fragment component of the redirection\n   URI using the \"application/x-www-form-urlencoded\" format, per\n   Appendix B:\n\n   access_token\n         REQUIRED.  The access token issued by the authorization server.\n\n   token_type\n         REQUIRED.  The type of the token issued as described in\n         Section 7.1.  Value is case insensitive.\n\n   expires_in\n         RECOMMENDED.  The lifetime in seconds of the access token.  For\n         example, the value \"3600\" denotes that the access token will\n         expire in one hour from the time the response was generated.\n         If omitted, the authorization server SHOULD provide the\n         expiration time via other means or document the default value.\n\n   scope\n         OPTIONAL, if identical to the scope requested by the client;\n         otherwise, REQUIRED.  The scope of the access token as\n         described by Section 3.3.\n\n   state\n         REQUIRED if the \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   The authorization server MUST NOT issue a refresh token.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response (with extra line breaks for\n   display purposes only):"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_143",
        "original_index": 143,
        "content": "For example, the authorization server redirects the user-agent by\n   sending the following HTTP response (with extra line breaks for\n   display purposes only):\n\n     HTTP/1.1 302 Found\n     Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\n               &state=xyz&token_type=example&expires_in=3600\n\n   Developers should note that some user-agents do not support the\n   inclusion of a fragment component in the HTTP \"Location\" response\n   header field.  Such clients will require using other methods for\n   redirecting the client than a 3xx redirection response -- for\n   example, returning an HTML page that includes a 'continue' button\n   with an action linked to the redirection URI.\n\n\n\nHardt                        Standards Track                   [Page 35]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The client MUST ignore unrecognized response parameters.  The access\n   token string size is left undefined by this specification.  The\n   client should avoid making assumptions about value sizes.  The\n   authorization server SHOULD document the size of any value it issues.\n\n4.2.2.1.  Error Response\n\n   If the request fails due to a missing, invalid, or mismatching\n   redirection URI, or if the client identifier is missing or invalid,\n   the authorization server SHOULD inform the resource owner of the\n   error and MUST NOT automatically redirect the user-agent to the\n   invalid redirection URI.\n\n   If the resource owner denies the access request or if the request\n   fails for reasons other than a missing or invalid redirection URI,\n   the authorization server informs the client by adding the following\n   parameters to the fragment component of the redirection URI using the\n   \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               invalid parameter value, includes a parameter more than\n               once, or is otherwise malformed.\n\n         unauthorized_client\n               The client is not authorized to request an access token\n               using this method.\n\n         access_denied\n               The resource owner or authorization server denied the\n               request.\n\n         unsupported_response_type\n               The authorization server does not support obtaining an\n               access token using this method.\n\n         invalid_scope\n               The requested scope is invalid, unknown, or malformed.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 36]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         server_error\n               The authorization server encountered an unexpected\n               condition that prevented it from fulfilling the request.\n               (This error code is needed because a 500 Internal Server\n               Error HTTP status code cannot be returned to the client\n               via an HTTP redirect.)\n\n         temporarily_unavailable\n               The authorization server is currently unable to handle\n               the request due to a temporary overloading or maintenance\n               of the server.  (This error code is needed because a 503\n               Service Unavailable HTTP status code cannot be returned\n               to the client via an HTTP redirect.)\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_144",
        "original_index": 144,
        "content": "error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n   state\n         REQUIRED if a \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.\n\n   For example, the authorization server redirects the user-agent by\n   sending the following HTTP response:\n\n   HTTP/1.1 302 Found\n   Location: https://client.example.com/cb#error=access_denied&state=xyz\n\n4.3.  Resource Owner Password Credentials Grant\n\n   The resource owner password credentials grant type is suitable in\n   cases where the resource owner has a trust relationship with the\n   client, such as the device operating system or a highly privileged\n\n\n\nHardt                        Standards Track                   [Page 37]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   application.  The authorization server should take special care when\n   enabling this grant type and only allow it when other flows are not\n   viable.\n\n   This grant type is suitable for clients capable of obtaining the\n   resource owner's credentials (username and password, typically using\n   an interactive form).  It is also used to migrate existing clients\n   using direct authentication schemes such as HTTP Basic or Digest\n   authentication to OAuth by converting the stored credentials to an\n   access token.\n\n     +----------+\n     | Resource |\n     |  Owner   |\n     |          |\n     +----------+\n          v\n          |    Resource Owner\n         (A) Password Credentials\n          |\n          v\n     +---------+                                  +---------------+\n     |         |>--(B)---- Resource Owner ------->|               |\n     |         |         Password Credentials     | Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(C)---- Access Token ---------<|               |\n     |         |    (w/ Optional Refresh Token)   |               |\n     +---------+                                  +---------------+\n\n            Figure 5: Resource Owner Password Credentials Flow\n\n   The flow illustrated in Figure 5 includes the following steps:\n\n   (A)  The resource owner provides the client with its username and\n        password.\n\n   (B)  The client requests an access token from the authorization\n        server's token endpoint by including the credentials received\n        from the resource owner.  When making the request, the client\n        authenticates with the authorization server.\n\n   (C)  The authorization server authenticates the client and validates\n        the resource owner credentials, and if valid, issues an access\n        token.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 38]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n4.3.1.  Authorization Request and Response\n\n   The method through which the client obtains the resource owner\n   credentials is beyond the scope of this specification.  The client\n   MUST discard the credentials once an access token has been obtained.\n\n4.3.2.  Access Token Request\n\n   The client makes a request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"password\".\n\n   username\n         REQUIRED.  The resource owner username.\n\n   password\n         REQUIRED.  The resource owner password.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_145",
        "original_index": 145,
        "content": "password\n         REQUIRED.  The resource owner password.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   If the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=password&username=johndoe&password=A3ddj3w\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 39]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included, and\n\n   o  validate the resource owner password credentials using its\n      existing password validation algorithm.\n\n   Since this access token request utilizes the resource owner's\n   password, the authorization server MUST protect the endpoint against\n   brute force attacks (e.g., using rate-limitation or generating\n   alerts).\n\n4.3.3.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n4.4.  Client Credentials Grant\n\n   The client can request an access token using only its client\n   credentials (or other supported means of authentication) when the\n   client is requesting access to the protected resources under its\n   control, or those of another resource owner that have been previously\n   arranged with the authorization server (the method of which is beyond\n   the scope of this specification).\n\n\n\n\nHardt                        Standards Track                   [Page 40]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The client credentials grant type MUST only be used by confidential\n   clients.\n\n     +---------+                                  +---------------+\n     |         |                                  |               |\n     |         |>--(A)- Client Authentication --->| Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(B)---- Access Token ---------<|               |\n     |         |                                  |               |\n     +---------+                                  +---------------+\n\n                     Figure 6: Client Credentials Flow\n\n   The flow illustrated in Figure 6 includes the following steps:\n\n   (A)  The client authenticates with the authorization server and\n        requests an access token from the token endpoint.\n\n   (B)  The authorization server authenticates the client, and if valid,\n        issues an access token.\n\n4.4.1.  Authorization Request and Response\n\n   Since the client authentication is used as the authorization grant,\n   no additional authorization request is needed.\n\n4.4.2.  Access Token Request"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_146",
        "original_index": 146,
        "content": "4.4.1.  Authorization Request and Response\n\n   Since the client authentication is used as the authorization grant,\n   no additional authorization request is needed.\n\n4.4.2.  Access Token Request\n\n   The client makes a request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"client_credentials\".\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.\n\n   The client MUST authenticate with the authorization server as\n   described in Section 3.2.1.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 41]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=client_credentials\n\n   The authorization server MUST authenticate the client.\n\n4.4.3.  Access Token Response\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token as described in\n   Section 5.1.  A refresh token SHOULD NOT be included.  If the request\n   failed client authentication or is invalid, the authorization server\n   returns an error response as described in Section 5.2.\n\n   An example successful response:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"example_parameter\":\"example_value\"\n     }\n\n4.5.  Extension Grants\n\n   The client uses an extension grant type by specifying the grant type\n   using an absolute URI (defined by the authorization server) as the\n   value of the \"grant_type\" parameter of the token endpoint, and by\n   adding any additional parameters necessary.\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 42]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   For example, to request an access token using a Security Assertion\n   Markup Language (SAML) 2.0 assertion grant type as defined by\n   [OAuth-SAML2], the client could make the following HTTP request using\n   TLS (with extra line breaks for display purposes only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-\n     bearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU\n     [...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n5.  Issuing an Access Token\n\n   If the access token request is valid and authorized, the\n   authorization server issues an access token and optional refresh\n   token as described in Section 5.1.  If the request failed client\n   authentication or is invalid, the authorization server returns an\n   error response as described in Section 5.2.\n\n5.1.  Successful Response\n\n   The authorization server issues an access token and optional refresh\n   token, and constructs the response by adding the following parameters\n   to the entity-body of the HTTP response with a 200 (OK) status code:\n\n   access_token\n         REQUIRED.  The access token issued by the authorization server."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_147",
        "original_index": 147,
        "content": "access_token\n         REQUIRED.  The access token issued by the authorization server.\n\n   token_type\n         REQUIRED.  The type of the token issued as described in\n         Section 7.1.  Value is case insensitive.\n\n   expires_in\n         RECOMMENDED.  The lifetime in seconds of the access token.  For\n         example, the value \"3600\" denotes that the access token will\n         expire in one hour from the time the response was generated.\n         If omitted, the authorization server SHOULD provide the\n         expiration time via other means or document the default value.\n\n\n\n\n\nHardt                        Standards Track                   [Page 43]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   refresh_token\n         OPTIONAL.  The refresh token, which can be used to obtain new\n         access tokens using the same authorization grant as described\n         in Section 6.\n\n   scope\n         OPTIONAL, if identical to the scope requested by the client;\n         otherwise, REQUIRED.  The scope of the access token as\n         described by Section 3.3.\n\n   The parameters are included in the entity-body of the HTTP response\n   using the \"application/json\" media type as defined by [RFC4627].  The\n   parameters are serialized into a JavaScript Object Notation (JSON)\n   structure by adding each parameter at the highest structure level.\n   Parameter names and string values are included as JSON strings.\n   Numerical values are included as JSON numbers.  The order of\n   parameters does not matter and can vary.\n\n   The authorization server MUST include the HTTP \"Cache-Control\"\n   response header field [RFC2616] with a value of \"no-store\" in any\n   response containing tokens, credentials, or other sensitive\n   information, as well as the \"Pragma\" response header field [RFC2616]\n   with a value of \"no-cache\".\n\n   For example:\n\n     HTTP/1.1 200 OK\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n       \"token_type\":\"example\",\n       \"expires_in\":3600,\n       \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n       \"example_parameter\":\"example_value\"\n     }\n\n   The client MUST ignore unrecognized value names in the response.  The\n   sizes of tokens and other values received from the authorization\n   server are left undefined.  The client should avoid making\n   assumptions about value sizes.  The authorization server SHOULD\n   document the size of any value it issues.\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 44]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n5.2.  Error Response\n\n   The authorization server responds with an HTTP 400 (Bad Request)\n   status code (unless specified otherwise) and includes the following\n   parameters with the response:\n\n   error\n         REQUIRED.  A single ASCII [USASCII] error code from the\n         following:\n\n         invalid_request\n               The request is missing a required parameter, includes an\n               unsupported parameter value (other than grant type),\n               repeats a parameter, includes multiple credentials,\n               utilizes more than one mechanism for authenticating the\n               client, or is otherwise malformed."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_148",
        "original_index": 148,
        "content": "invalid_client\n               Client authentication failed (e.g., unknown client, no\n               client authentication included, or unsupported\n               authentication method).  The authorization server MAY\n               return an HTTP 401 (Unauthorized) status code to indicate\n               which HTTP authentication schemes are supported.  If the\n               client attempted to authenticate via the \"Authorization\"\n               request header field, the authorization server MUST\n               respond with an HTTP 401 (Unauthorized) status code and\n               include the \"WWW-Authenticate\" response header field\n               matching the authentication scheme used by the client.\n\n         invalid_grant\n               The provided authorization grant (e.g., authorization\n               code, resource owner credentials) or refresh token is\n               invalid, expired, revoked, does not match the redirection\n               URI used in the authorization request, or was issued to\n               another client.\n\n         unauthorized_client\n               The authenticated client is not authorized to use this\n               authorization grant type.\n\n         unsupported_grant_type\n               The authorization grant type is not supported by the\n               authorization server.\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 45]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n         invalid_scope\n               The requested scope is invalid, unknown, malformed, or\n               exceeds the scope granted by the resource owner.\n\n         Values for the \"error\" parameter MUST NOT include characters\n         outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_description\n         OPTIONAL.  Human-readable ASCII [USASCII] text providing\n         additional information, used to assist the client developer in\n         understanding the error that occurred.\n         Values for the \"error_description\" parameter MUST NOT include\n         characters outside the set %x20-21 / %x23-5B / %x5D-7E.\n\n   error_uri\n         OPTIONAL.  A URI identifying a human-readable web page with\n         information about the error, used to provide the client\n         developer with additional information about the error.\n         Values for the \"error_uri\" parameter MUST conform to the\n         URI-reference syntax and thus MUST NOT include characters\n         outside the set %x21 / %x23-5B / %x5D-7E.\n\n   The parameters are included in the entity-body of the HTTP response\n   using the \"application/json\" media type as defined by [RFC4627].  The\n   parameters are serialized into a JSON structure by adding each\n   parameter at the highest structure level.  Parameter names and string\n   values are included as JSON strings.  Numerical values are included\n   as JSON numbers.  The order of parameters does not matter and can\n   vary.\n\n   For example:\n\n     HTTP/1.1 400 Bad Request\n     Content-Type: application/json;charset=UTF-8\n     Cache-Control: no-store\n     Pragma: no-cache\n\n     {\n       \"error\":\"invalid_request\"\n     }\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 46]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n6.  Refreshing an Access Token\n\n   If the authorization server issued a refresh token to the client, the\n   client makes a refresh request to the token endpoint by adding the\n   following parameters using the \"application/x-www-form-urlencoded\"\n   format per Appendix B with a character encoding of UTF-8 in the HTTP\n   request entity-body:\n\n   grant_type\n         REQUIRED.  Value MUST be set to \"refresh_token\".\n\n   refresh_token\n         REQUIRED.  The refresh token issued to the client."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_149",
        "original_index": 149,
        "content": "grant_type\n         REQUIRED.  Value MUST be set to \"refresh_token\".\n\n   refresh_token\n         REQUIRED.  The refresh token issued to the client.\n\n   scope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.  The requested scope MUST NOT include any scope\n         not originally granted by the resource owner, and if omitted is\n         treated as equal to the scope originally granted by the\n         resource owner.\n\n   Because refresh tokens are typically long-lasting credentials used to\n   request additional access tokens, the refresh token is bound to the\n   client to which it was issued.  If the client type is confidential or\n   the client was issued client credentials (or assigned other\n   authentication requirements), the client MUST authenticate with the\n   authorization server as described in Section 3.2.1.\n\n   For example, the client makes the following HTTP request using\n   transport-layer security (with extra line breaks for display purposes\n   only):\n\n     POST /token HTTP/1.1\n     Host: server.example.com\n     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n     Content-Type: application/x-www-form-urlencoded\n\n     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 47]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST:\n\n   o  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\n   o  authenticate the client if client authentication is included and\n      ensure that the refresh token was issued to the authenticated\n      client, and\n\n   o  validate the refresh token.\n\n   If valid and authorized, the authorization server issues an access\n   token as described in Section 5.1.  If the request failed\n   verification or is invalid, the authorization server returns an error\n   response as described in Section 5.2.\n\n   The authorization server MAY issue a new refresh token, in which case\n   the client MUST discard the old refresh token and replace it with the\n   new refresh token.  The authorization server MAY revoke the old\n   refresh token after issuing a new refresh token to the client.  If a\n   new refresh token is issued, the refresh token scope MUST be\n   identical to that of the refresh token included by the client in the\n   request.\n\n7.  Accessing Protected Resources\n\n   The client accesses protected resources by presenting the access\n   token to the resource server.  The resource server MUST validate the\n   access token and ensure that it has not expired and that its scope\n   covers the requested resource.  The methods used by the resource\n   server to validate the access token (as well as any error responses)\n   are beyond the scope of this specification but generally involve an\n   interaction or coordination between the resource server and the\n   authorization server.\n\n   The method in which the client utilizes the access token to\n   authenticate with the resource server depends on the type of access\n   token issued by the authorization server.  Typically, it involves\n   using the HTTP \"Authorization\" request header field [RFC2617] with an\n   authentication scheme defined by the specification of the access\n   token type used, such as [RFC6750].\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 48]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n7.1.  Access Token Types\n\n   The access token type provides the client with the information\n   required to successfully utilize the access token to make a protected\n   resource request (along with type-specific attributes).  The client\n   MUST NOT use an access token if it does not understand the token\n   type."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_150",
        "original_index": 150,
        "content": "For example, the \"bearer\" token type defined in [RFC6750] is utilized\n   by simply including the access token string in the request:\n\n     GET /resource/1 HTTP/1.1\n     Host: example.com\n     Authorization: Bearer mF_9.B5f-4.1JqM\n\n   while the \"mac\" token type defined in [OAuth-HTTP-MAC] is utilized by\n   issuing a Message Authentication Code (MAC) key together with the\n   access token that is used to sign certain components of the HTTP\n   requests:\n\n     GET /resource/1 HTTP/1.1\n     Host: example.com\n     Authorization: MAC id=\"h480djs93hd8\",\n                        nonce=\"274312:dj83hs9s\",\n                        mac=\"kDZvddkndxvhGRXZhvuDjEWhGeE=\"\n\n   The above examples are provided for illustration purposes only.\n   Developers are advised to consult the [RFC6750] and [OAuth-HTTP-MAC]\n   specifications before use.\n\n   Each access token type definition specifies the additional attributes\n   (if any) sent to the client together with the \"access_token\" response\n   parameter.  It also defines the HTTP authentication method used to\n   include the access token when making a protected resource request.\n\n7.2.  Error Response\n\n   If a resource access request fails, the resource server SHOULD inform\n   the client of the error.  While the specifics of such error responses\n   are beyond the scope of this specification, this document establishes\n   a common registry in Section 11.4 for error values to be shared among\n   OAuth token authentication schemes.\n\n   New authentication schemes designed primarily for OAuth token\n   authentication SHOULD define a mechanism for providing an error\n   status code to the client, in which the error values allowed are\n   registered in the error registry established by this specification.\n\n\n\n\nHardt                        Standards Track                   [Page 49]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Such schemes MAY limit the set of valid error codes to a subset of\n   the registered values.  If the error code is returned using a named\n   parameter, the parameter name SHOULD be \"error\".\n\n   Other schemes capable of being used for OAuth token authentication,\n   but not primarily designed for that purpose, MAY bind their error\n   values to the registry in the same manner.\n\n   New authentication schemes MAY choose to also specify the use of the\n   \"error_description\" and \"error_uri\" parameters to return error\n   information in a manner parallel to their usage in this\n   specification.\n\n8.  Extensibility\n\n8.1.  Defining Access Token Types\n\n   Access token types can be defined in one of two ways: registered in\n   the Access Token Types registry (following the procedures in\n   Section 11.1), or by using a unique absolute URI as its name.\n\n   Types utilizing a URI name SHOULD be limited to vendor-specific\n   implementations that are not commonly applicable, and are specific to\n   the implementation details of the resource server where they are\n   used.\n\n   All other types MUST be registered.  Type names MUST conform to the\n   type-name ABNF.  If the type definition includes a new HTTP\n   authentication scheme, the type name SHOULD be identical to the HTTP\n   authentication scheme name (as defined by [RFC2617]).  The token type\n   \"example\" is reserved for use in examples.\n\n     type-name  = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\n8.2.  Defining New Endpoint Parameters\n\n   New request or response parameters for use with the authorization\n   endpoint or the token endpoint are defined and registered in the\n   OAuth Parameters registry following the procedure in Section 11.2.\n\n   Parameter names MUST conform to the param-name ABNF, and parameter\n   values syntax MUST be well-defined (e.g., using ABNF, or a reference\n   to the syntax of an existing parameter).\n\n     param-name  = 1*name-char\n     name-char   = \"-\" / \".\" / \"_\" / DIGIT / ALPHA"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_151",
        "original_index": 151,
        "content": "param-name  = 1*name-char\n     name-char   = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\n\n\n\nHardt                        Standards Track                   [Page 50]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Unregistered vendor-specific parameter extensions that are not\n   commonly applicable and that are specific to the implementation\n   details of the authorization server where they are used SHOULD\n   utilize a vendor-specific prefix that is not likely to conflict with\n   other registered values (e.g., begin with 'companyname_').\n\n8.3.  Defining New Authorization Grant Types\n\n   New authorization grant types can be defined by assigning them a\n   unique absolute URI for use with the \"grant_type\" parameter.  If the\n   extension grant type requires additional token endpoint parameters,\n   they MUST be registered in the OAuth Parameters registry as described\n   by Section 11.2.\n\n8.4.  Defining New Authorization Endpoint Response Types\n\n   New response types for use with the authorization endpoint are\n   defined and registered in the Authorization Endpoint Response Types\n   registry following the procedure in Section 11.3.  Response type\n   names MUST conform to the response-type ABNF.\n\n     response-type  = response-name *( SP response-name )\n     response-name  = 1*response-char\n     response-char  = \"_\" / DIGIT / ALPHA\n\n   If a response type contains one or more space characters (%x20), it\n   is compared as a space-delimited list of values in which the order of\n   values does not matter.  Only one order of values can be registered,\n   which covers all other arrangements of the same set of values.\n\n   For example, the response type \"token code\" is left undefined by this\n   specification.  However, an extension can define and register the\n   \"token code\" response type.  Once registered, the same combination\n   cannot be registered as \"code token\", but both values can be used to\n   denote the same response type.\n\n8.5.  Defining Additional Error Codes\n\n   In cases where protocol extensions (i.e., access token types,\n   extension parameters, or extension grant types) require additional\n   error codes to be used with the authorization code grant error\n   response (Section 4.1.2.1), the implicit grant error response\n   (Section 4.2.2.1), the token error response (Section 5.2), or the\n   resource access error response (Section 7.2), such error codes MAY be\n   defined.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 51]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Extension error codes MUST be registered (following the procedures in\n   Section 11.4) if the extension they are used in conjunction with is a\n   registered access token type, a registered endpoint parameter, or an\n   extension grant type.  Error codes used with unregistered extensions\n   MAY be registered.\n\n   Error codes MUST conform to the error ABNF and SHOULD be prefixed by\n   an identifying name when possible.  For example, an error identifying\n   an invalid value set to the extension parameter \"example\" SHOULD be\n   named \"example_invalid\".\n\n     error      = 1*error-char\n     error-char = %x20-21 / %x23-5B / %x5D-7E\n\n9.  Native Applications\n\n   Native applications are clients installed and executed on the device\n   used by the resource owner (i.e., desktop application, native mobile\n   application).  Native applications require special consideration\n   related to security, platform capabilities, and overall end-user\n   experience.\n\n   The authorization endpoint requires interaction between the client\n   and the resource owner's user-agent.  Native applications can invoke\n   an external user-agent or embed a user-agent within the application.\n   For example:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_152",
        "original_index": 152,
        "content": "o  External user-agent - the native application can capture the\n      response from the authorization server using a redirection URI\n      with a scheme registered with the operating system to invoke the\n      client as the handler, manual copy-and-paste of the credentials,\n      running a local web server, installing a user-agent extension, or\n      by providing a redirection URI identifying a server-hosted\n      resource under the client's control, which in turn makes the\n      response available to the native application.\n\n   o  Embedded user-agent - the native application obtains the response\n      by directly communicating with the embedded user-agent by\n      monitoring state changes emitted during the resource load, or\n      accessing the user-agent's cookies storage.\n\n   When choosing between an external or embedded user-agent, developers\n   should consider the following:\n\n   o  An external user-agent may improve completion rate, as the\n      resource owner may already have an active session with the\n      authorization server, removing the need to re-authenticate.  It\n      provides a familiar end-user experience and functionality.  The\n\n\n\nHardt                        Standards Track                   [Page 52]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n      resource owner may also rely on user-agent features or extensions\n      to assist with authentication (e.g., password manager, 2-factor\n      device reader).\n\n   o  An embedded user-agent may offer improved usability, as it removes\n      the need to switch context and open new windows.\n\n   o  An embedded user-agent poses a security challenge because resource\n      owners are authenticating in an unidentified window without access\n      to the visual protections found in most external user-agents.  An\n      embedded user-agent educates end-users to trust unidentified\n      requests for authentication (making phishing attacks easier to\n      execute).\n\n   When choosing between the implicit grant type and the authorization\n   code grant type, the following should be considered:\n\n   o  Native applications that use the authorization code grant type\n      SHOULD do so without using client credentials, due to the native\n      application's inability to keep client credentials confidential.\n\n   o  When using the implicit grant type flow, a refresh token is not\n      returned, which requires repeating the authorization process once\n      the access token expires.\n\n10.  Security Considerations\n\n   As a flexible and extensible framework, OAuth's security\n   considerations depend on many factors.  The following sections\n   provide implementers with security guidelines focused on the three\n   client profiles described in Section 2.1: web application,\n   user-agent-based application, and native application.\n\n   A comprehensive OAuth security model and analysis, as well as\n   background for the protocol design, is provided by\n   [OAuth-THREATMODEL].\n\n10.1.  Client Authentication\n\n   The authorization server establishes client credentials with web\n   application clients for the purpose of client authentication.  The\n   authorization server is encouraged to consider stronger client\n   authentication means than a client password.  Web application clients\n   MUST ensure confidentiality of client passwords and other client\n   credentials.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 53]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   The authorization server MUST NOT issue client passwords or other\n   client credentials to native application or user-agent-based\n   application clients for the purpose of client authentication.  The\n   authorization server MAY issue a client password or other credentials\n   for a specific installation of a native application client on a\n   specific device."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_153",
        "original_index": 153,
        "content": "When client authentication is not possible, the authorization server\n   SHOULD employ other means to validate the client's identity -- for\n   example, by requiring the registration of the client redirection URI\n   or enlisting the resource owner to confirm identity.  A valid\n   redirection URI is not sufficient to verify the client's identity\n   when asking for resource owner authorization but can be used to\n   prevent delivering credentials to a counterfeit client after\n   obtaining resource owner authorization.\n\n   The authorization server must consider the security implications of\n   interacting with unauthenticated clients and take measures to limit\n   the potential exposure of other credentials (e.g., refresh tokens)\n   issued to such clients.\n\n10.2.  Client Impersonation\n\n   A malicious client can impersonate another client and obtain access\n   to protected resources if the impersonated client fails to, or is\n   unable to, keep its client credentials confidential.\n\n   The authorization server MUST authenticate the client whenever\n   possible.  If the authorization server cannot authenticate the client\n   due to the client's nature, the authorization server MUST require the\n   registration of any redirection URI used for receiving authorization\n   responses and SHOULD utilize other means to protect resource owners\n   from such potentially malicious clients.  For example, the\n   authorization server can engage the resource owner to assist in\n   identifying the client and its origin.\n\n   The authorization server SHOULD enforce explicit resource owner\n   authentication and provide the resource owner with information about\n   the client and the requested authorization scope and lifetime.  It is\n   up to the resource owner to review the information in the context of\n   the current client and to authorize or deny the request.\n\n   The authorization server SHOULD NOT process repeated authorization\n   requests automatically (without active resource owner interaction)\n   without authenticating the client or relying on other measures to\n   ensure that the repeated request comes from the original client and\n   not an impersonator.\n\n\n\n\nHardt                        Standards Track                   [Page 54]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.3.  Access Tokens\n\n   Access token credentials (as well as any confidential access token\n   attributes) MUST be kept confidential in transit and storage, and\n   only shared among the authorization server, the resource servers the\n   access token is valid for, and the client to whom the access token is\n   issued.  Access token credentials MUST only be transmitted using TLS\n   as described in Section 1.6 with server authentication as defined by\n   [RFC2818].\n\n   When using the implicit grant type, the access token is transmitted\n   in the URI fragment, which can expose it to unauthorized parties.\n\n   The authorization server MUST ensure that access tokens cannot be\n   generated, modified, or guessed to produce valid access tokens by\n   unauthorized parties.\n\n   The client SHOULD request access tokens with the minimal scope\n   necessary.  The authorization server SHOULD take the client identity\n   into account when choosing how to honor the requested scope and MAY\n   issue an access token with less rights than requested.\n\n   This specification does not provide any methods for the resource\n   server to ensure that an access token presented to it by a given\n   client was issued to that client by the authorization server.\n\n10.4.  Refresh Tokens\n\n   Authorization servers MAY issue refresh tokens to web application\n   clients and native application clients."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_154",
        "original_index": 154,
        "content": "10.4.  Refresh Tokens\n\n   Authorization servers MAY issue refresh tokens to web application\n   clients and native application clients.\n\n   Refresh tokens MUST be kept confidential in transit and storage, and\n   shared only among the authorization server and the client to whom the\n   refresh tokens were issued.  The authorization server MUST maintain\n   the binding between a refresh token and the client to whom it was\n   issued.  Refresh tokens MUST only be transmitted using TLS as\n   described in Section 1.6 with server authentication as defined by\n   [RFC2818].\n\n   The authorization server MUST verify the binding between the refresh\n   token and client identity whenever the client identity can be\n   authenticated.  When client authentication is not possible, the\n   authorization server SHOULD deploy other means to detect refresh\n   token abuse.\n\n   For example, the authorization server could employ refresh token\n   rotation in which a new refresh token is issued with every access\n   token refresh response.  The previous refresh token is invalidated\n\n\n\nHardt                        Standards Track                   [Page 55]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   but retained by the authorization server.  If a refresh token is\n   compromised and subsequently used by both the attacker and the\n   legitimate client, one of them will present an invalidated refresh\n   token, which will inform the authorization server of the breach.\n\n   The authorization server MUST ensure that refresh tokens cannot be\n   generated, modified, or guessed to produce valid refresh tokens by\n   unauthorized parties.\n\n10.5.  Authorization Codes\n\n   The transmission of authorization codes SHOULD be made over a secure\n   channel, and the client SHOULD require the use of TLS with its\n   redirection URI if the URI identifies a network resource.  Since\n   authorization codes are transmitted via user-agent redirections, they\n   could potentially be disclosed through user-agent history and HTTP\n   referrer headers.\n\n   Authorization codes operate as plaintext bearer credentials, used to\n   verify that the resource owner who granted authorization at the\n   authorization server is the same resource owner returning to the\n   client to complete the process.  Therefore, if the client relies on\n   the authorization code for its own resource owner authentication, the\n   client redirection endpoint MUST require the use of TLS.\n\n   Authorization codes MUST be short lived and single-use.  If the\n   authorization server observes multiple attempts to exchange an\n   authorization code for an access token, the authorization server\n   SHOULD attempt to revoke all access tokens already granted based on\n   the compromised authorization code.\n\n   If the client can be authenticated, the authorization servers MUST\n   authenticate the client and ensure that the authorization code was\n   issued to the same client.\n\n10.6.  Authorization Code Redirection URI Manipulation\n\n   When requesting authorization using the authorization code grant\n   type, the client can specify a redirection URI via the \"redirect_uri\"\n   parameter.  If an attacker can manipulate the value of the\n   redirection URI, it can cause the authorization server to redirect\n   the resource owner user-agent to a URI under the control of the\n   attacker with the authorization code.\n\n   An attacker can create an account at a legitimate client and initiate\n   the authorization flow.  When the attacker's user-agent is sent to\n   the authorization server to grant access, the attacker grabs the\n   authorization URI provided by the legitimate client and replaces the\n\n\n\nHardt                        Standards Track                   [Page 56]\n\f\nRFC 6749                        OAuth 2.0                   October 2012"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_155",
        "original_index": 155,
        "content": "Hardt                        Standards Track                   [Page 56]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   client's redirection URI with a URI under the control of the\n   attacker.  The attacker then tricks the victim into following the\n   manipulated link to authorize access to the legitimate client.\n\n   Once at the authorization server, the victim is prompted with a\n   normal, valid request on behalf of a legitimate and trusted client,\n   and authorizes the request.  The victim is then redirected to an\n   endpoint under the control of the attacker with the authorization\n   code.  The attacker completes the authorization flow by sending the\n   authorization code to the client using the original redirection URI\n   provided by the client.  The client exchanges the authorization code\n   with an access token and links it to the attacker's client account,\n   which can now gain access to the protected resources authorized by\n   the victim (via the client).\n\n   In order to prevent such an attack, the authorization server MUST\n   ensure that the redirection URI used to obtain the authorization code\n   is identical to the redirection URI provided when exchanging the\n   authorization code for an access token.  The authorization server\n   MUST require public clients and SHOULD require confidential clients\n   to register their redirection URIs.  If a redirection URI is provided\n   in the request, the authorization server MUST validate it against the\n   registered value.\n\n10.7.  Resource Owner Password Credentials\n\n   The resource owner password credentials grant type is often used for\n   legacy or migration reasons.  It reduces the overall risk of storing\n   usernames and passwords by the client but does not eliminate the need\n   to expose highly privileged credentials to the client.\n\n   This grant type carries a higher risk than other grant types because\n   it maintains the password anti-pattern this protocol seeks to avoid.\n   The client could abuse the password, or the password could\n   unintentionally be disclosed to an attacker (e.g., via log files or\n   other records kept by the client).\n\n   Additionally, because the resource owner does not have control over\n   the authorization process (the resource owner's involvement ends when\n   it hands over its credentials to the client), the client can obtain\n   access tokens with a broader scope than desired by the resource\n   owner.  The authorization server should consider the scope and\n   lifetime of access tokens issued via this grant type.\n\n   The authorization server and client SHOULD minimize use of this grant\n   type and utilize other grant types whenever possible.\n\n\n\n\n\nHardt                        Standards Track                   [Page 57]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.8.  Request Confidentiality\n\n   Access tokens, refresh tokens, resource owner passwords, and client\n   credentials MUST NOT be transmitted in the clear.  Authorization\n   codes SHOULD NOT be transmitted in the clear.\n\n   The \"state\" and \"scope\" parameters SHOULD NOT include sensitive\n   client or resource owner information in plain text, as they can be\n   transmitted over insecure channels or stored insecurely.\n\n10.9.  Ensuring Endpoint Authenticity\n\n   In order to prevent man-in-the-middle attacks, the authorization\n   server MUST require the use of TLS with server authentication as\n   defined by [RFC2818] for any request sent to the authorization and\n   token endpoints.  The client MUST validate the authorization server's\n   TLS certificate as defined by [RFC6125] and in accordance with its\n   requirements for server identity authentication.\n\n10.10.  Credentials-Guessing Attacks\n\n   The authorization server MUST prevent attackers from guessing access\n   tokens, authorization codes, refresh tokens, resource owner\n   passwords, and client credentials."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_156",
        "original_index": 156,
        "content": "The authorization server MUST prevent attackers from guessing access\n   tokens, authorization codes, refresh tokens, resource owner\n   passwords, and client credentials.\n\n   The probability of an attacker guessing generated tokens (and other\n   credentials not intended for handling by end-users) MUST be less than\n   or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).\n\n   The authorization server MUST utilize other means to protect\n   credentials intended for end-user usage.\n\n10.11.  Phishing Attacks\n\n   Wide deployment of this and similar protocols may cause end-users to\n   become inured to the practice of being redirected to websites where\n   they are asked to enter their passwords.  If end-users are not\n   careful to verify the authenticity of these websites before entering\n   their credentials, it will be possible for attackers to exploit this\n   practice to steal resource owners' passwords.\n\n   Service providers should attempt to educate end-users about the risks\n   phishing attacks pose and should provide mechanisms that make it easy\n   for end-users to confirm the authenticity of their sites.  Client\n   developers should consider the security implications of how they\n   interact with the user-agent (e.g., external, embedded), and the\n   ability of the end-user to verify the authenticity of the\n   authorization server.\n\n\n\nHardt                        Standards Track                   [Page 58]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   To reduce the risk of phishing attacks, the authorization servers\n   MUST require the use of TLS on every endpoint used for end-user\n   interaction.\n\n10.12.  Cross-Site Request Forgery\n\n   Cross-site request forgery (CSRF) is an exploit in which an attacker\n   causes the user-agent of a victim end-user to follow a malicious URI\n   (e.g., provided to the user-agent as a misleading link, image, or\n   redirection) to a trusting server (usually established via the\n   presence of a valid session cookie).\n\n   A CSRF attack against the client's redirection URI allows an attacker\n   to inject its own authorization code or access token, which can\n   result in the client using an access token associated with the\n   attacker's protected resources rather than the victim's (e.g., save\n   the victim's bank account information to a protected resource\n   controlled by the attacker).\n\n   The client MUST implement CSRF protection for its redirection URI.\n   This is typically accomplished by requiring any request sent to the\n   redirection URI endpoint to include a value that binds the request to\n   the user-agent's authenticated state (e.g., a hash of the session\n   cookie used to authenticate the user-agent).  The client SHOULD\n   utilize the \"state\" request parameter to deliver this value to the\n   authorization server when making an authorization request.\n\n   Once authorization has been obtained from the end-user, the\n   authorization server redirects the end-user's user-agent back to the\n   client with the required binding value contained in the \"state\"\n   parameter.  The binding value enables the client to verify the\n   validity of the request by matching the binding value to the\n   user-agent's authenticated state.  The binding value used for CSRF\n   protection MUST contain a non-guessable value (as described in\n   Section 10.10), and the user-agent's authenticated state (e.g.,\n   session cookie, HTML5 local storage) MUST be kept in a location\n   accessible only to the client and the user-agent (i.e., protected by\n   same-origin policy).\n\n   A CSRF attack against the authorization server's authorization\n   endpoint can result in an attacker obtaining end-user authorization\n   for a malicious client without involving or alerting the end-user."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_157",
        "original_index": 157,
        "content": "The authorization server MUST implement CSRF protection for its\n   authorization endpoint and ensure that a malicious client cannot\n   obtain authorization without the awareness and explicit consent of\n   the resource owner.\n\n\n\n\nHardt                        Standards Track                   [Page 59]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n10.13.  Clickjacking\n\n   In a clickjacking attack, an attacker registers a legitimate client\n   and then constructs a malicious site in which it loads the\n   authorization server's authorization endpoint web page in a\n   transparent iframe overlaid on top of a set of dummy buttons, which\n   are carefully constructed to be placed directly under important\n   buttons on the authorization page.  When an end-user clicks a\n   misleading visible button, the end-user is actually clicking an\n   invisible button on the authorization page (such as an \"Authorize\"\n   button).  This allows an attacker to trick a resource owner into\n   granting its client access without the end-user's knowledge.\n\n   To prevent this form of attack, native applications SHOULD use\n   external browsers instead of embedding browsers within the\n   application when requesting end-user authorization.  For most newer\n   browsers, avoidance of iframes can be enforced by the authorization\n   server using the (non-standard) \"x-frame-options\" header.  This\n   header can have two values, \"deny\" and \"sameorigin\", which will block\n   any framing, or framing by sites with a different origin,\n   respectively.  For older browsers, JavaScript frame-busting\n   techniques can be used but may not be effective in all browsers.\n\n10.14.  Code Injection and Input Validation\n\n   A code injection attack occurs when an input or otherwise external\n   variable is used by an application unsanitized and causes\n   modification to the application logic.  This may allow an attacker to\n   gain access to the application device or its data, cause denial of\n   service, or introduce a wide range of malicious side-effects.\n\n   The authorization server and client MUST sanitize (and validate when\n   possible) any value received -- in particular, the value of the\n   \"state\" and \"redirect_uri\" parameters.\n\n10.15.  Open Redirectors\n\n   The authorization server, authorization endpoint, and client\n   redirection endpoint can be improperly configured and operate as open\n   redirectors.  An open redirector is an endpoint using a parameter to\n   automatically redirect a user-agent to the location specified by the\n   parameter value without any validation.\n\n   Open redirectors can be used in phishing attacks, or by an attacker\n   to get end-users to visit malicious sites by using the URI authority\n   component of a familiar and trusted destination.  In addition, if the\n   authorization server allows the client to register only part of the\n   redirection URI, an attacker can use an open redirector operated by\n\n\n\nHardt                        Standards Track                   [Page 60]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   the client to construct a redirection URI that will pass the\n   authorization server validation but will send the authorization code\n   or access token to an endpoint under the control of the attacker.\n\n10.16.  Misuse of Access Token to Impersonate Resource Owner in Implicit\n        Flow\n\n   For public clients using implicit flows, this specification does not\n   provide any method for the client to determine what client an access\n   token was issued to.\n\n   A resource owner may willingly delegate access to a resource by\n   granting an access token to an attacker's malicious client.  This may\n   be due to phishing or some other pretext.  An attacker may also steal\n   a token via some other mechanism.  An attacker may then attempt to\n   impersonate the resource owner by providing the access token to a\n   legitimate public client."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_158",
        "original_index": 158,
        "content": "In the implicit flow (response_type=token), the attacker can easily\n   switch the token in the response from the authorization server,\n   replacing the real access token with the one previously issued to the\n   attacker.\n\n   Servers communicating with native applications that rely on being\n   passed an access token in the back channel to identify the user of\n   the client may be similarly compromised by an attacker creating a\n   compromised application that can inject arbitrary stolen access\n   tokens.\n\n   Any public client that makes the assumption that only the resource\n   owner can present it with a valid access token for the resource is\n   vulnerable to this type of attack.\n\n   This type of attack may expose information about the resource owner\n   at the legitimate client to the attacker (malicious client).  This\n   will also allow the attacker to perform operations at the legitimate\n   client with the same permissions as the resource owner who originally\n   granted the access token or authorization code.\n\n   Authenticating resource owners to clients is out of scope for this\n   specification.  Any specification that uses the authorization process\n   as a form of delegated end-user authentication to the client (e.g.,\n   third-party sign-in service) MUST NOT use the implicit flow without\n   additional security mechanisms that would enable the client to\n   determine if the access token was issued for its use (e.g., audience-\n   restricting the access token).\n\n\n\n\n\nHardt                        Standards Track                   [Page 61]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.  IANA Considerations\n\n11.1.  OAuth Access Token Types Registry\n\n   This specification establishes the OAuth Access Token Types registry.\n\n   Access token types are registered with a Specification Required\n   ([RFC5226]) after a two-week review period on the\n   oauth-ext-review@ietf.org mailing list, on the advice of one or more\n   Designated Experts.  However, to allow for the allocation of values\n   prior to publication, the Designated Expert(s) may approve\n   registration once they are satisfied that such a specification will\n   be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for access token type: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.1.1.  Registration Template\n\n   Type name:\n      The name requested (e.g., \"example\").\n\n   Additional Token Endpoint Response Parameters:\n      Additional response parameters returned together with the\n      \"access_token\" parameter.  New parameters MUST be separately\n      registered in the OAuth Parameters registry as described by\n      Section 11.2.\n\n   HTTP Authentication Scheme(s):\n      The HTTP authentication scheme name(s), if any, used to\n      authenticate protected resource requests using access tokens of\n      this type.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n\n\nHardt                        Standards Track                   [Page 62]\n\f\nRFC 6749                        OAuth 2.0                   October 2012"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_159",
        "original_index": 159,
        "content": "Hardt                        Standards Track                   [Page 62]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Specification document(s):\n      Reference to the document(s) that specify the parameter,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n11.2.  OAuth Parameters Registry\n\n   This specification establishes the OAuth Parameters registry.\n\n   Additional parameters for inclusion in the authorization endpoint\n   request, the authorization endpoint response, the token endpoint\n   request, or the token endpoint response are registered with a\n   Specification Required ([RFC5226]) after a two-week review period on\n   the oauth-ext-review@ietf.org mailing list, on the advice of one or\n   more Designated Experts.  However, to allow for the allocation of\n   values prior to publication, the Designated Expert(s) may approve\n   registration once they are satisfied that such a specification will\n   be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for parameter: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.2.1.  Registration Template\n\n   Parameter name:\n      The name requested (e.g., \"example\").\n\n   Parameter usage location:\n      The location(s) where parameter can be used.  The possible\n      locations are authorization request, authorization response, token\n      request, or token response.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n\n\nHardt                        Standards Track                   [Page 63]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   Specification document(s):\n      Reference to the document(s) that specify the parameter,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n11.2.2.  Initial Registry Contents\n\n   The OAuth Parameters registry's initial contents are:\n\n   o  Parameter name: client_id\n   o  Parameter usage location: authorization request, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: client_secret\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: response_type\n   o  Parameter usage location: authorization request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: redirect_uri\n   o  Parameter usage location: authorization request, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: scope\n   o  Parameter usage location: authorization request, authorization\n      response, token request, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: state\n   o  Parameter usage location: authorization request, authorization\n      response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_160",
        "original_index": 160,
        "content": "o  Parameter name: state\n   o  Parameter usage location: authorization request, authorization\n      response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: code\n   o  Parameter usage location: authorization response, token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n\n\n\n\nHardt                        Standards Track                   [Page 64]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   o  Parameter name: error_description\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: error_uri\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: grant_type\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: access_token\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: token_type\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: expires_in\n   o  Parameter usage location: authorization response, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: username\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: password\n   o  Parameter usage location: token request\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Parameter name: refresh_token\n   o  Parameter usage location: token request, token response\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 65]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.3.  OAuth Authorization Endpoint Response Types Registry\n\n   This specification establishes the OAuth Authorization Endpoint\n   Response Types registry.\n\n   Additional response types for use with the authorization endpoint are\n   registered with a Specification Required ([RFC5226]) after a two-week\n   review period on the oauth-ext-review@ietf.org mailing list, on the\n   advice of one or more Designated Experts.  However, to allow for the\n   allocation of values prior to publication, the Designated Expert(s)\n   may approve registration once they are satisfied that such a\n   specification will be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for response type: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n11.3.1.  Registration Template\n\n   Response type name:\n      The name requested (e.g., \"example\").\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_161",
        "original_index": 161,
        "content": "Specification document(s):\n      Reference to the document(s) that specify the type, preferably\n      including a URI that can be used to retrieve a copy of the\n      document(s).  An indication of the relevant sections may also be\n      included but is not required.\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 66]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.3.2.  Initial Registry Contents\n\n   The OAuth Authorization Endpoint Response Types registry's initial\n   contents are:\n\n   o  Response type name: code\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n   o  Response type name: token\n   o  Change controller: IETF\n   o  Specification document(s): RFC 6749\n\n11.4.  OAuth Extensions Error Registry\n\n   This specification establishes the OAuth Extensions Error registry.\n\n   Additional error codes used together with other protocol extensions\n   (i.e., extension grant types, access token types, or extension\n   parameters) are registered with a Specification Required ([RFC5226])\n   after a two-week review period on the oauth-ext-review@ietf.org\n   mailing list, on the advice of one or more Designated Experts.\n   However, to allow for the allocation of values prior to publication,\n   the Designated Expert(s) may approve registration once they are\n   satisfied that such a specification will be published.\n\n   Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing list for review and comment, with an appropriate subject\n   (e.g., \"Request for error code: example\").\n\n   Within the review period, the Designated Expert(s) will either\n   approve or deny the registration request, communicating this decision\n   to the review list and IANA.  Denials should include an explanation\n   and, if applicable, suggestions as to how to make the request\n   successful.\n\n   IANA must only accept registry updates from the Designated Expert(s)\n   and should direct all requests for registration to the review mailing\n   list.\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 67]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n11.4.1.  Registration Template\n\n   Error name:\n      The name requested (e.g., \"example\").  Values for the error name\n      MUST NOT include characters outside the set %x20-21 / %x23-5B /\n      %x5D-7E.\n\n   Error usage location:\n      The location(s) where the error can be used.  The possible\n      locations are authorization code grant error response\n      (Section 4.1.2.1), implicit grant error response\n      (Section 4.2.2.1), token error response (Section 5.2), or resource\n      access error response (Section 7.2).\n\n   Related protocol extension:\n      The name of the extension grant type, access token type, or\n      extension parameter that the error code is used in conjunction\n      with.\n\n   Change controller:\n      For Standards Track RFCs, state \"IETF\".  For others, give the name\n      of the responsible party.  Other details (e.g., postal address,\n      email address, home page URI) may also be included.\n\n   Specification document(s):\n      Reference to the document(s) that specify the error code,\n      preferably including a URI that can be used to retrieve a copy of\n      the document(s).  An indication of the relevant sections may also\n      be included but is not required.\n\n12.  References\n\n12.1.  Normative References\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\n   [RFC2246]  Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\",\n              RFC 2246, January 1999.\n\n   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999."
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_162",
        "original_index": 162,
        "content": "[RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n              Leach, P., Luotonen, A., and L. Stewart, \"HTTP\n              Authentication: Basic and Digest Access Authentication\",\n              RFC 2617, June 1999.\n\n\n\nHardt                        Standards Track                   [Page 68]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.\n\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of\n              ISO 10646\", STD 63, RFC 3629, November 2003.\n\n   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, January 2005.\n\n   [RFC4627]  Crockford, D., \"The application/json Media Type for\n              JavaScript Object Notation (JSON)\", RFC 4627, July 2006.\n\n   [RFC4949]  Shirey, R., \"Internet Security Glossary, Version 2\",\n              RFC 4949, August 2007.\n\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n\n   [RFC5234]  Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n\n   [RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification of Domain-Based Application Service Identity\n              within Internet Public Key Infrastructure Using X.509\n              (PKIX) Certificates in the Context of Transport Layer\n              Security (TLS)\", RFC 6125, March 2011.\n\n   [USASCII]  American National Standards Institute, \"Coded Character\n              Set -- 7-bit American Standard Code for Information\n              Interchange\", ANSI X3.4, 1986.\n\n   [W3C.REC-html401-19991224]\n              Raggett, D., Le Hors, A., and I. Jacobs, \"HTML 4.01\n              Specification\", World Wide Web Consortium\n              Recommendation REC-html401-19991224, December 1999,\n              <http://www.w3.org/TR/1999/REC-html401-19991224>.\n\n   [W3C.REC-xml-20081126]\n              Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,\n              and F. Yergeau, \"Extensible Markup Language (XML) 1.0\n              (Fifth Edition)\", World Wide Web Consortium\n               Recommendation REC-xml-20081126, November 2008,\n              <http://www.w3.org/TR/2008/REC-xml-20081126>.\n\n\n\n\nHardt                        Standards Track                   [Page 69]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n12.2.  Informative References\n\n   [OAuth-HTTP-MAC]\n              Hammer-Lahav, E., Ed., \"HTTP Authentication: MAC Access\n              Authentication\", Work in Progress, February 2012.\n\n   [OAuth-SAML2]\n              Campbell, B. and C. Mortimore, \"SAML 2.0 Bearer Assertion\n              Profiles for OAuth 2.0\", Work in Progress, September 2012.\n\n   [OAuth-THREATMODEL]\n              Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \"OAuth 2.0\n              Threat Model and Security Considerations\", Work\n              in Progress, October 2012.\n\n   [OAuth-WRAP]\n              Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, \"OAuth\n              Web Resource Authorization Profiles\", Work in Progress,\n              January 2010.\n\n   [RFC5849]  Hammer-Lahav, E., \"The OAuth 1.0 Protocol\", RFC 5849,\n              April 2010.\n\n   [RFC6750]  Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization\n              Framework: Bearer Token Usage\", RFC 6750, October 2012.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 70]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nAppendix A.  Augmented Backus-Naur Form (ABNF) Syntax"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_163",
        "original_index": 163,
        "content": "Appendix A.  Augmented Backus-Naur Form (ABNF) Syntax\n\n   This section provides Augmented Backus-Naur Form (ABNF) syntax\n   descriptions for the elements defined in this specification using the\n   notation of [RFC5234].  The ABNF below is defined in terms of Unicode\n   code points [W3C.REC-xml-20081126]; these characters are typically\n   encoded in UTF-8.  Elements are presented in the order first defined.\n\n   Some of the definitions that follow use the \"URI-reference\"\n   definition from [RFC3986].\n\n   Some of the definitions that follow use these common definitions:\n\n     VSCHAR     = %x20-7E\n     NQCHAR     = %x21 / %x23-5B / %x5D-7E\n     NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E\n     UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /\n                         %xE000-FFFD / %x10000-10FFFF\n\n   (The UNICODECHARNOCRLF definition is based upon the Char definition\n   in Section 2.2 of [W3C.REC-xml-20081126], but omitting the Carriage\n   Return and Linefeed characters.)\n\nA.1.  \"client_id\" Syntax\n\n   The \"client_id\" element is defined in Section 2.3.1:\n\n     client-id     = *VSCHAR\n\nA.2.  \"client_secret\" Syntax\n\n   The \"client_secret\" element is defined in Section 2.3.1:\n\n     client-secret = *VSCHAR\n\nA.3.  \"response_type\" Syntax\n\n   The \"response_type\" element is defined in Sections 3.1.1 and 8.4:\n\n     response-type = response-name *( SP response-name )\n     response-name = 1*response-char\n     response-char = \"_\" / DIGIT / ALPHA\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 71]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.4.  \"scope\" Syntax\n\n   The \"scope\" element is defined in Section 3.3:\n\n     scope       = scope-token *( SP scope-token )\n     scope-token = 1*NQCHAR\n\nA.5.  \"state\" Syntax\n\n   The \"state\" element is defined in Sections 4.1.1, 4.1.2, 4.1.2.1,\n   4.2.1, 4.2.2, and 4.2.2.1:\n\n     state      = 1*VSCHAR\n\nA.6.  \"redirect_uri\" Syntax\n\n   The \"redirect_uri\" element is defined in Sections 4.1.1, 4.1.3,\n   and 4.2.1:\n\n     redirect-uri      = URI-reference\n\nA.7.  \"error\" Syntax\n\n   The \"error\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\n   7.2, and 8.5:\n\n     error             = 1*NQSCHAR\n\nA.8.  \"error_description\" Syntax\n\n   The \"error_description\" element is defined in Sections 4.1.2.1,\n   4.2.2.1, 5.2, and 7.2:\n\n     error-description = 1*NQSCHAR\n\nA.9.  \"error_uri\" Syntax\n\n   The \"error_uri\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\n   and 7.2:\n\n     error-uri         = URI-reference\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 72]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.10.  \"grant_type\" Syntax\n\n   The \"grant_type\" element is defined in Sections 4.1.3, 4.3.2, 4.4.2,\n   4.5, and 6:\n\n     grant-type = grant-name / URI-reference\n     grant-name = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nA.11.  \"code\" Syntax\n\n   The \"code\" element is defined in Section 4.1.3:\n\n     code       = 1*VSCHAR\n\nA.12.  \"access_token\" Syntax\n\n   The \"access_token\" element is defined in Sections 4.2.2 and 5.1:\n\n     access-token = 1*VSCHAR\n\nA.13.  \"token_type\" Syntax\n\n   The \"token_type\" element is defined in Sections 4.2.2, 5.1, and 8.1:\n\n     token-type = type-name / URI-reference\n     type-name  = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nA.14.  \"expires_in\" Syntax\n\n   The \"expires_in\" element is defined in Sections 4.2.2 and 5.1:\n\n     expires-in = 1*DIGIT\n\nA.15.  \"username\" Syntax\n\n   The \"username\" element is defined in Section 4.3.2:\n\n     username = *UNICODECHARNOCRLF\n\nA.16.  \"password\" Syntax\n\n   The \"password\" element is defined in Section 4.3.2:\n\n     password = *UNICODECHARNOCRLF\n\n\n\n\n\nHardt                        Standards Track                   [Page 73]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nA.17.  \"refresh_token\" Syntax\n\n   The \"refresh_token\" element is defined in Sections 5.1 and 6:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_164",
        "original_index": 164,
        "content": "A.17.  \"refresh_token\" Syntax\n\n   The \"refresh_token\" element is defined in Sections 5.1 and 6:\n\n     refresh-token = 1*VSCHAR\n\nA.18.  Endpoint Parameter Syntax\n\n   The syntax for new endpoint parameters is defined in Section 8.2:\n\n     param-name = 1*name-char\n     name-char  = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n\nAppendix B.  Use of application/x-www-form-urlencoded Media Type\n\n   At the time of publication of this specification, the\n   \"application/x-www-form-urlencoded\" media type was defined in\n   Section 17.13.4 of [W3C.REC-html401-19991224] but not registered in\n   the IANA MIME Media Types registry\n   (<http://www.iana.org/assignments/media-types>).  Furthermore, that\n   definition is incomplete, as it does not consider non-US-ASCII\n   characters.\n\n   To address this shortcoming when generating payloads using this media\n   type, names and values MUST be encoded using the UTF-8 character\n   encoding scheme [RFC3629] first; the resulting octet sequence then\n   needs to be further encoded using the escaping rules defined in\n   [W3C.REC-html401-19991224].\n\n   When parsing data from a payload using this media type, the names and\n   values resulting from reversing the name/value encoding consequently\n   need to be treated as octet sequences, to be decoded using the UTF-8\n   character encoding scheme.\n\n   For example, the value consisting of the six Unicode code points\n   (1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN),\n   (3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN),\n   (5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN) would be encoded\n   into the octet sequence below (using hexadecimal notation):\n\n     20 25 26 2B C2 A3 E2 82 AC\n\n   and then represented in the payload as:\n\n     +%25%26%2B%C2%A3%E2%82%AC\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 74]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\nAppendix C.  Acknowledgements\n\n   The initial OAuth 2.0 protocol specification was edited by David\n   Recordon, based on two previous publications: the OAuth 1.0 community\n   specification [RFC5849], and OAuth WRAP (OAuth Web Resource\n   Authorization Profiles) [OAuth-WRAP].  Eran Hammer then edited many\n   of the intermediate drafts that evolved into this RFC.  The Security\n   Considerations section was drafted by Torsten Lodderstedt, Mark\n   McGloin, Phil Hunt, Anthony Nadalin, and John Bradley.  The section\n   on use of the \"application/x-www-form-urlencoded\" media type was\n   drafted by Julian Reschke.  The ABNF section was drafted by Michael\n   B. Jones.\n\n   The OAuth 1.0 community specification was edited by Eran Hammer and\n   authored by Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M.\n   Conlan, Blaine Cook, Leah Culver, Breno de Medeiros, Brian Eaton,\n   Kellan Elliott-McCrea, Larry Halff, Eran Hammer, Ben Laurie, Chris\n   Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,\n   Jonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.\n\n   The OAuth WRAP specification was edited by Dick Hardt and authored by\n   Brian Eaton, Yaron Y. Goland, Dick Hardt, and Allen Tom.\n\n   This specification is the work of the OAuth Working Group, which\n   includes dozens of active and dedicated participants.  In particular,\n   the following individuals contributed ideas, feedback, and wording\n   that shaped and formed the final specification:"
      },
      {
        "chunk_id": "rfc_standards_complete_chunk_165",
        "original_index": 165,
        "content": "Michael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden\n   Bell, John Bradley, Marcos Caceres, Brian Campbell, Scott Cantor,\n   Blaine Cook, Roger Crew, Leah Culver, Bill de hOra, Andre DeMarre,\n   Brian Eaton, Wesley Eddy, Wolter Eldering, Brian Ellin, Igor\n   Faynberg, George Fletcher, Tim Freeman, Luca Frosini, Evan Gilbert,\n   Yaron Y. Goland, Brent Goldman, Kristoffer Gronowski, Eran Hammer,\n   Dick Hardt, Justin Hart, Craig Heath, Phil Hunt, Michael B. Jones,\n   Terry Jones, John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara,\n   Rasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Casey Lucas, Paul\n   Madsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin,\n   Laurence Miao, William Mills, Chuck Mortimore, Anthony Nadalin,\n   Julian Reschke, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob\n   Sayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov,\n   Justin Smith, Haibin Song, Niv Steingarten, Christian Stuebner,\n   Jeremy Suriel, Paul Tarjan, Christopher Thomas, Henry S. Thompson,\n   Allen Tom, Franklin Tse, Nick Walker, Shane Weeden, and Skylar\n   Woodward.\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 75]\n\f\nRFC 6749                        OAuth 2.0                   October 2012\n\n\n   This document was produced under the chairmanship of Blaine Cook,\n   Peter Saint-Andre, Hannes Tschofenig, Barry Leiba, and Derek Atkins.\n   The area directors included Lisa Dusseault, Peter Saint-Andre, and\n   Stephen Farrell.\n\nAuthor's Address\n\n   Dick Hardt (editor)\n   Microsoft\n\n   EMail: dick.hardt@gmail.com\n   URI:   http://dickhardt.org/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardt                        Standards Track                   [Page 76]"
      }
    ]
  }
]